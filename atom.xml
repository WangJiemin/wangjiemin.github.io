<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jamin Blog</title>
  <icon>https://www.gravatar.com/avatar/fca0f49342f608d216999d4b41d5ba65</icon>
  <subtitle>一个不聊技术的 DBA 不是一个好厨子...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiemin.wang/"/>
  <updated>2019-05-20T11:30:26.055Z</updated>
  <id>https://jiemin.wang/</id>
  
  <author>
    <name>Wang Jiemin</name>
    <email>278667010@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mongodb aggregate 基于UNIX时间戳的聚合</title>
    <link href="https://jiemin.wang/2019/05/20/mongodb-aggregate/"/>
    <id>https://jiemin.wang/2019/05/20/mongodb-aggregate/</id>
    <published>2019-05-20T10:31:54.000Z</published>
    <updated>2019-05-20T11:30:26.055Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="iiiiii.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>对今天解决不了的事情，也不要着急。因为明天也可能还是解决不了。</strong></p></blockquote><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>开发找我问<code>MongoDB</code> 的 <code>aggregate 聚合</code>用过不<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f630.png?v8">😰</span> 。</p><p>我说查查资料吧，发现是<code>aggregate</code>聚合管道 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f628.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f628.png?v8">😨</span> 。</p><p>把SQL 与 Aggergation 对比下<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></p><table><thead><tr><th style="text-align:center">SQL Terms, Functions, and Concepts</th><th style="text-align:center">MongoDB Aggregation Operators</th></tr></thead><tbody><tr><td style="text-align:center">WHERE</td><td style="text-align:center">$match</td></tr><tr><td style="text-align:center">HAVING</td><td style="text-align:center">$match</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">$project</td></tr><tr><td style="text-align:center">ORDER BY</td><td style="text-align:center">$sort</td></tr><tr><td style="text-align:center">LIMIT</td><td style="text-align:center">$limit</td></tr><tr><td style="text-align:center">SUM()</td><td style="text-align:center">$sum</td></tr><tr><td style="text-align:center">COUNT()</td><td style="text-align:center">$sum</td></tr><tr><td style="text-align:center">COUNT()</td><td style="text-align:center">$sortByCount</td></tr><tr><td style="text-align:center">join</td><td style="text-align:center">$lookup</td></tr></tbody></table><p>开发的需求是:</p><ul><li>按照天分组，统计一下数量</li></ul><p>经过查看<code>MongoDB官网</code>的<a href="https://docs.mongodb.com/manual/aggregation/" target="_blank" rel="noopener">aggregate资料</a>实现开发的需求</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>查询数据的状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_image.find({<span class="string">"moduleId"</span>:5,createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}).pretty().<span class="built_in">limit</span>(1);</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">        <span class="string">"_id"</span> : ObjectId(<span class="string">"5c125657372eecd7a0a54e5e"</span>),</span><br><span class="line">        <span class="string">"adRate"</span> : 0,</span><br><span class="line">        <span class="string">"assoId"</span> : <span class="string">"223794113"</span>,</span><br><span class="line">        <span class="string">"assoType"</span> : 201,</span><br><span class="line">        <span class="string">"clientIp"</span> : <span class="string">"183.131.7.23"</span>,</span><br><span class="line">        <span class="string">"clientType"</span> : <span class="string">""</span>,</span><br><span class="line">        <span class="string">"confidence"</span> : 12.655,</span><br><span class="line">        <span class="string">"content"</span> : <span class="string">"****http://videoplayer.babytreeimg.com/lamavideo:2018/1213/Flb_T4qsxRcK7suNqaHo2JbD6zWJ_000001.jpg?id=-1\**"</span>,</span><br><span class="line">        <span class="string">"createTs"</span> : NumberLong(1544705623),</span><br><span class="line">        <span class="string">"emailStatus"</span> : <span class="string">"verified"</span>,</span><br><span class="line">        <span class="string">"handleTs"</span> : NumberLong(1545036013),</span><br><span class="line">        <span class="string">"hotScore"</span> : 14.285,</span><br><span class="line">        <span class="string">"inspectStatus"</span> : 2,</span><br><span class="line">        <span class="string">"message"</span> : <span class="string">""</span>,</span><br><span class="line">        <span class="string">"moduleId"</span> : NumberLong(5),</span><br><span class="line">        <span class="string">"normalScore"</span> : 73.25,</span><br><span class="line">        <span class="string">"ocrKeyword"</span> : [ ],</span><br><span class="line">        <span class="string">"ocrText"</span> : [ ],</span><br><span class="line">        <span class="string">"opUser"</span> : <span class="string">"fanyanning"</span>,</span><br><span class="line">        <span class="string">"opUserId"</span> : NumberLong(31648494),</span><br><span class="line">        <span class="string">"pornScore"</span> : 12.464,</span><br><span class="line">        <span class="string">"qcode"</span> : 0,</span><br><span class="line">        <span class="string">"receiveTs"</span> : NumberLong(1545035885),</span><br><span class="line">        <span class="string">"regTs"</span> : NumberLong(1475385061),</span><br><span class="line">        <span class="string">"requestId"</span> : <span class="string">"6f078c58-1235-4816-96a5-e876ea0cbcf2"</span>,</span><br><span class="line">        <span class="string">"rotOcrKeyword"</span> : [ ],</span><br><span class="line">        <span class="string">"rotOcrText"</span> : [ ],</span><br><span class="line">        <span class="string">"ruleId"</span> : NumberLong(10019),</span><br><span class="line">        <span class="string">"sim"</span> : 0,</span><br><span class="line">        <span class="string">"status"</span> : 1000,</span><br><span class="line">        <span class="string">"trashType"</span> : 0,</span><br><span class="line">        <span class="string">"ts"</span> : NumberLong(1544705623),</span><br><span class="line">        <span class="string">"url"</span> : <span class="string">"http://videoplayer.babytreeimg.com/lamavideo:2018/1213/Flb_T4qsxRcK7suNqaHo2JbD6zWJ_000001.jpg?id=-1"</span>,</span><br><span class="line">        <span class="string">"userId"</span> : NumberLong(56349617),</span><br><span class="line">        <span class="string">"userLevel"</span> : 3,</span><br><span class="line">        <span class="string">"version"</span> : <span class="string">"1.0.0"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>开发给的聚合的查询<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_image.aggregate([</span><br><span class="line">{ <span class="variable">$match</span>: {<span class="string">"moduleId"</span>:5,createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}},</span><br><span class="line">{ <span class="variable">$group</span>: {_id :{<span class="variable">$dateToString</span>: {format: <span class="string">"%Y-%m-%d"</span>, date: <span class="string">"<span class="variable">$createTs</span>"</span> }},count: { <span class="variable">$sum</span>: 1 }}}</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mgset-11469021:SECONDARY> db.antispam_image.aggregate([{<span class="variable">$match</span>: {<span class="string">"moduleId"</span>:5, createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}}, {<span class="variable">$group</span>: {_id: {<span class="variable">$dateToString</span>: {format: <span class="string">"%Y-%m-%d"</span>, date: <span class="string">"<span class="variable">$createTs</span>"</span>}}, count: {<span class="variable">$sum</span>: 1}}}]);</span><br><span class="line">assert: <span class="built_in">command</span> failed: {</span><br><span class="line">        <span class="string">"operationTime"</span> : Timestamp(1558347069, 2),</span><br><span class="line">        <span class="string">"ok"</span> : 0,</span><br><span class="line">        <span class="string">"errmsg"</span> : <span class="string">"can't convert from BSON type long to Date"</span>,</span><br><span class="line">        <span class="string">"code"</span> : 16006,</span><br><span class="line">        <span class="string">"codeName"</span> : <span class="string">"Location16006"</span></span><br><span class="line">} : aggregate failed</span><br><span class="line">_getErrorWithCode@src/mongo/shell/utils.js:25:13</span><br><span class="line">doassert@src/mongo/shell/assert.js:16:14</span><br><span class="line">assert.commandWorked@src/mongo/shell/assert.js:370:5</span><br><span class="line">DBCollection.prototype.aggregate@src/mongo/shell/collection.js:1319:5</span><br><span class="line">@(shell):1:1</span><br><span class="line"></span><br><span class="line">2019-05-20T18:11:10.818+0800 E QUERY    [thread1] Error: <span class="built_in">command</span> failed: {</span><br><span class="line">        <span class="string">"operationTime"</span> : Timestamp(1558347069, 2),</span><br><span class="line">        <span class="string">"ok"</span> : 0,</span><br><span class="line">        <span class="string">"errmsg"</span> : <span class="string">"can't convert from BSON type long to Date"</span>,</span><br><span class="line">        <span class="string">"code"</span> : 16006,</span><br><span class="line">        <span class="string">"codeName"</span> : <span class="string">"Location16006"</span></span><br><span class="line">} : aggregate failed :</span><br><span class="line">_getErrorWithCode@src/mongo/shell/utils.js:25:13</span><br><span class="line">doassert@src/mongo/shell/assert.js:16:14</span><br><span class="line">assert.commandWorked@src/mongo/shell/assert.js:370:5</span><br><span class="line">DBCollection.prototype.aggregate@src/mongo/shell/collection.js:1319:5</span><br><span class="line">@(shell):1:1</span><br></pre></td></tr></tbody></table></figure><p>报错了，问开发。开发又给了一个查询语句<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_image.aggregate([</span><br><span class="line">{ <span class="variable">$match</span>: {<span class="string">"moduleId"</span>:5,createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}},</span><br><span class="line">{ <span class="variable">$group</span>: {</span><br><span class="line">_id :{ <span class="variable">$dateToString</span>: {format: <span class="string">"%Y-%m-%d"</span>, date:{<span class="string">"<span class="variable">$add</span>"</span>:[new Date(0),<span class="string">"<span class="variable">$createTs</span>"</span>]}} },</span><br><span class="line">count: { <span class="variable">$sum</span>: 1 }</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="string">"_id"</span> : <span class="string">"1970-01-19"</span>, <span class="string">"count"</span> : 15131 }</span><br><span class="line">{ <span class="string">"_id"</span> : <span class="string">"1970-01-18"</span>, <span class="string">"count"</span> : 180400 }</span><br></pre></td></tr></tbody></table></figure><p>发现时间戳转化不对</p><p>于是查看官网资料，继续改写先把UNIX时间戳转化为日期。可是MongoDB又没有<code>MySQL</code>那种<code>FROM_UNIXTIME()</code>与<code>UNIX_TIMESTAMP()</code>函数。只能自己造</p><p>通过将值乘以1000将createTs字段转换为毫秒时间戳<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>]}</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>$multiply    将数字相乘以返回产品。接受任意数量的参数表达式。</p></blockquote><p>然后转换为日期<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>]} ]</span><br></pre></td></tr></tbody></table></figure><p></p><p>继续组装查询<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="string">"<span class="variable">$group</span>"</span>: { <span class="string">"_id"</span>: { <span class="string">"year"</span>: { <span class="string">"<span class="variable">$year</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}, <span class="string">"mmonth"</span>: { <span class="string">"<span class="variable">$month</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}, <span class="string">"day"</span>: { <span class="string">"<span class="variable">$dayOfMonth</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}}, <span class="string">"count"</span> : { <span class="string">"<span class="variable">$sum</span>"</span> : 1 }}}</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>在<code>$project</code>管道中完成,方法是将<code>毫秒时间</code>添加到<code>零毫秒Date(0)</code>对象,然后从转换后的<code>日期</code>中提取<code>$year</code>,<code>$month</code>,<code>$dayOfMonth</code>个零件,可以在<code>$group</code>管道中使用这些零件对文档进行分组</p></blockquote><p>完整的查询语句拼接出来<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_image.aggregate([{ <span class="variable">$match</span>: {<span class="string">"moduleId"</span>:5,createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}}, {<span class="string">"<span class="variable">$group</span>"</span>: { <span class="string">"_id"</span>: { <span class="string">"year"</span>: { <span class="string">"<span class="variable">$year</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}, <span class="string">"mmonth"</span>: { <span class="string">"<span class="variable">$month</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}, <span class="string">"day"</span>: { <span class="string">"<span class="variable">$dayOfMonth</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ] }}}, <span class="string">"count"</span> : { <span class="string">"<span class="variable">$sum</span>"</span> : 1 }}}]);</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 30 }, <span class="string">"count"</span> : 624 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 28 }, <span class="string">"count"</span> : 695 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 27 }, <span class="string">"count"</span> : 683 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 26 }, <span class="string">"count"</span> : 765 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 1, <span class="string">"day"</span> : 12 }, <span class="string">"count"</span> : 610 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 1, <span class="string">"day"</span> : 4 }, <span class="string">"count"</span> : 429 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 1, <span class="string">"day"</span> : 3 }, <span class="string">"count"</span> : 475 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 29 }, <span class="string">"count"</span> : 732 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 12, <span class="string">"day"</span> : 31 }, <span class="string">"count"</span> : 592 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 12, <span class="string">"day"</span> : 30 }, <span class="string">"count"</span> : 542 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 3, <span class="string">"day"</span> : 14 }, <span class="string">"count"</span> : 1155 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 3, <span class="string">"day"</span> : 13 }, <span class="string">"count"</span> : 1169 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 20 }, <span class="string">"count"</span> : 945 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 3, <span class="string">"day"</span> : 15 }, <span class="string">"count"</span> : 1062 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 24 }, <span class="string">"count"</span> : 751 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 10, <span class="string">"day"</span> : 15 }, <span class="string">"count"</span> : 721 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 18 }, <span class="string">"count"</span> : 895 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 10, <span class="string">"day"</span> : 16 }, <span class="string">"count"</span> : 713 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 14 }, <span class="string">"count"</span> : 1278 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 10, <span class="string">"day"</span> : 17 }, <span class="string">"count"</span> : 583 }</span><br><span class="line">Type <span class="string">"it"</span> <span class="keyword">for</span> more</span><br><span class="line">mgset-11469021:SECONDARY></span><br></pre></td></tr></tbody></table></figure><p>拿这样查询出来的数据问开发是否是这样、开发确认这样可以。需求解决。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>针对DBA这个岗位来说。大多数都是从事MongoDB 运维工作 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>。</p><p>很少贴近开发需求，这次开发问了我这个问题。我当然无法立马给出答案。只能不断的查询。拼接，才能马马虎虎的满足了开发的需求 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/2705.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/2705.png?v8">✅</span>。</p><p>刚才问一个架构师，架构师说有一个更简单的方式：</p><ol><li>查出总结出一天的数据，放到管道中临时保存起来</li><li>在用前一次查询的结束时间作为第二天的开始时间，在加上一天的时间(86400s)得出结尾时间。</li><li>查询完成在统一显示打印出来</li></ol><p>这种方式就需要使用<code>MongoDB forEach</code>方式实现了。</p><p>开发又说不能按时间排序<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f631.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f631.png?v8">😱</span> , 妹的<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>哪里来的这么多要求<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f631.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f631.png?v8">😱</span></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>MongoDB 官方资料: <a href="https://docs.mongodb.com/manual/aggregation/" target="_blank" rel="noopener">aggregate资料</a></li><li><a href="https://blog.gaoqixhb.com/p/5938ca473b447c14248d41ad" target="_blank" rel="noopener">MongoDB 聚合查询 - 按时间分组统计</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;iiiiii.jpg&quot; class=&quot;full-image&quot; alt=
      
    
    </summary>
    
      <category term="MongoDB" scheme="https://jiemin.wang/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://jiemin.wang/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>mongodb数据导出CSV文件</title>
    <link href="https://jiemin.wang/2019/05/17/mongodb-to-csv/"/>
    <id>https://jiemin.wang/2019/05/17/mongodb-to-csv/</id>
    <published>2019-05-17T05:45:15.000Z</published>
    <updated>2019-05-17T06:20:44.896Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="qiong.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>要不是因为我，你能有今天？</strong><br><strong>要不是我伤害你，你能成长？</strong></p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>产品需要分析达人文章的标签，需要把2019年1月1号到现在的标签，从mongo导出来，导出格式为csv，查询条件如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.content_medium_hismatch.find({<span class="string">"content_type_id"</span>:<span class="string">"28"</span>,<span class="string">"update_time"</span>:{<span class="string">"<span class="variable">$gte</span>"</span>:1546272000000},<span class="string">"is_delete"</span>:0}, {<span class="string">"content_id"</span>:1,<span class="string">"content_tags"</span>:1});</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>使用<code>MongoDB</code>中的<code>mongoexport</code>命令<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mongoexport --<span class="built_in">help</span></span><br><span class="line">Usage:</span><br><span class="line">  mongoexport <options></span><br><span class="line"></span><br><span class="line">Export data from MongoDB <span class="keyword">in</span> CSV or JSON format.</span><br><span class="line"></span><br><span class="line">See http://docs.mongodb.org/manual/reference/program/mongoexport/ <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">general options:</span><br><span class="line">      --<span class="built_in">help</span>                                      <span class="built_in">print</span> usage</span><br><span class="line">      --version                                   <span class="built_in">print</span> the tool version and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">verbosity options:</span><br><span class="line">  -v, --verbose=<level>                           more detailed <span class="built_in">log</span> output (include multiple <span class="built_in">times</span> <span class="keyword">for</span> more verbosity, e.g. -vvvvv, or specify a numeric value, e.g. --verbose=N)</span><br><span class="line">      --quiet                                     hide all <span class="built_in">log</span> output</span><br><span class="line"></span><br><span class="line">connection options:</span><br><span class="line">  -h, --host=<hostname>                           mongodb host to connect to (setname/host1,host2 <span class="keyword">for</span> replica sets)</span><br><span class="line">      --port=<port>                               server port (can also use --host hostname:port)</span><br><span class="line"></span><br><span class="line">ssl options:</span><br><span class="line">      --ssl                                       connect to a mongod or mongos that has ssl enabled</span><br><span class="line">      --sslCAFile=<filename>                      the .pem file containing the root certificate chain from the certificate authority</span><br><span class="line">      --sslPEMKeyFile=<filename>                  the .pem file containing the certificate and key</span><br><span class="line">      --sslPEMKeyPassword=<password>              the password to decrypt the sslPEMKeyFile, <span class="keyword">if</span> necessary</span><br><span class="line">      --sslCRLFile=<filename>                     the .pem file containing the certificate revocation list</span><br><span class="line">      --sslAllowInvalidCertificates               bypass the validation <span class="keyword">for</span> server certificates</span><br><span class="line">      --sslAllowInvalidHostnames                  bypass the validation <span class="keyword">for</span> server name</span><br><span class="line">      --sslFIPSMode                               use FIPS mode of the installed openssl library</span><br><span class="line"></span><br><span class="line">authentication options:</span><br><span class="line">  -u, --username=<username>                       username <span class="keyword">for</span> authentication</span><br><span class="line">  -p, --password=<password>                       password <span class="keyword">for</span> authentication</span><br><span class="line">      --authenticationDatabase=<database-name>    database that holds the user<span class="string">'s credentials</span></span><br><span class="line"><span class="string">      --authenticationMechanism=<mechanism>       authentication mechanism to use</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">namespace options:</span></span><br><span class="line"><span class="string">  -d, --db=<database-name>                        database to use</span></span><br><span class="line"><span class="string">  -c, --collection=<collection-name>              collection to use</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">output options:</span></span><br><span class="line"><span class="string">  -f, --fields=<field>[,<field>]*                 comma separated list of field names (required for exporting CSV) e.g. -f "name,age"</span></span><br><span class="line"><span class="string">      --fieldFile=<filename>                      file with field names - 1 per line</span></span><br><span class="line"><span class="string">      --type=<type>                               the output format, either json or csv (defaults to '</span>json<span class="string">') (default: json)</span></span><br><span class="line"><span class="string">  -o, --out=<filename>                            output file; if not specified, stdout is used</span></span><br><span class="line"><span class="string">      --jsonArray                                 output to a JSON array rather than one object per line</span></span><br><span class="line"><span class="string">      --pretty                                    output JSON formatted to be human-readable</span></span><br><span class="line"><span class="string">      --noHeaderLine                              export CSV data without a list of field names at the first line</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">querying options:</span></span><br><span class="line"><span class="string">  -q, --query=<json>                              query filter, as a JSON string, e.g., '</span>{x:{<span class="variable">$gt</span>:1}}<span class="string">'</span></span><br><span class="line"><span class="string">      --queryFile=<filename>                      path to a file containing a query filter (JSON)</span></span><br><span class="line"><span class="string">  -k, --slaveOk                                   allow secondary reads if available (default true) (default: false)</span></span><br><span class="line"><span class="string">      --readPreference=<string>|<json>            specify either a preference name or a preference json object</span></span><br><span class="line"><span class="string">      --forceTableScan                            force a table scan (do not use $snapshot)</span></span><br><span class="line"><span class="string">      --skip=<count>                              number of documents to skip</span></span><br><span class="line"><span class="string">      --limit=<count>                             limit the number of documents to export</span></span><br><span class="line"><span class="string">      --sort=<json>                               sort order, as a JSON string, e.g. '</span>{x:1}<span class="string">'</span></span><br><span class="line"><span class="string">      --assertExists                              if specified, export fails if the collection does not exist (default: false)</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>操作命令如下:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongoexport --port 29001 --host=localhost -user=*** --password=***** --authenticationDatabase=**** --db=db --collection=collection --query=<span class="string">'{"content_type_id":"28","update_time":{"$gte":1546272000000},"is_delete":0}, {"content_id":1,"content_tags":1}'</span> --<span class="built_in">type</span>=csv --out=***.csv</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-05-17T13:18:52.325+0800    error validating settings: query <span class="string">'[123 34 99 111 110 116 101 110 116 95 116 121 112 101 95 105 100 34 58 34 50 56 34 44 34 117 112 100 97 116 101 95 116 105 109 101 34 58 123 34 36 103 116 101 34 58 49 53 52 54 50 55 50 48 48 48 48 48 48 125 44 34 105 115 95 100 101 108 101 116 101 34 58 48 125 44 32 123 34 99 111 110 116 101 110 116 95 105 100 34 58 49 44 34 99 111 110 116 101 110 116 95 116 97 103 115 34 58 49 125]'</span> is not valid JSON: invalid character <span class="string">','</span> after top-level value</span><br><span class="line">2019-05-17T13:18:52.325+0800    try <span class="string">'mongoexport --help'</span> <span class="keyword">for</span> more information</span><br></pre></td></tr></tbody></table></figure><p>初步判断是导出<code>CSV文件</code>中需要的<code>逗号(,)</code>分割。字段发生错误。语句添加–fields _id,content_id,content_tags<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongoexport --port 29001 --host=localhost -user=*** --password=***** --authenticationDatabase=**** --db=db --collection=collection --query=<span class="string">'{"content_type_id":"28","update_time":{"$gte":1546272000000},"is_delete":0}, {"content_id":1,"content_tags":1}'</span> --<span class="built_in">type</span>=csv --fields _id,content_id,content_tags --out=***.csv</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`2019-05-17T13:18:54.325+0800    error validating settings: query <span class="string">'[123 34 99 111 110 116 101 110 116 95 116 121 112 101 95 105 100 34 58 34 50 56 34 44 34 117 112 100 97 116 101 95 116 105 109 101 34 58 123 34 36 103 116 101 34 58 49 53 52 54 50 55 50 48 48 48 48 48 48 125 44 34 105 115 95 100 101 108 101 116 101 34 58 48 125 44 32 123 34 99 111 110 116 101 110 116 95 105 100 34 58 49 44 34 99 111 110 116 101 110 116 95 116 97 103 115 34 58 49 125]'</span> is not valid JSON: invalid character <span class="string">','</span> after top-level value</span><br><span class="line"> 2019-05-17T13:18:54.325+0800    try <span class="string">'mongoexport --help'</span> <span class="keyword">for</span> more information``bash</span><br></pre></td></tr></tbody></table></figure><p>开始排查为什么还继续报错。使用 <code>mongo shell</code> 连接到mongodb中查询发现是能获取到数据的。去掉–query 条件之后再执行一次发现是没问题<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongoexport --port 29001 --host=localhost -user=*** --password=***** --authenticationDatabase=**** --db=db --collection=collection --<span class="built_in">type</span>=csv --fields _id,content_id,content_tags --out=***.csv</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">2019-05-17T13:24:18.176+0800    connected to: localhost:29001</span><br><span class="line">2019-05-17T13:24:19.167+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:20.167+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:21.168+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:22.167+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:23.168+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:24.168+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:25.167+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:26.168+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">^C2019-05-17T13:24:26.900+0800  signal <span class="string">'interrupt'</span> received; forcefully terminating</span><br><span class="line">public-ops-mongodb2 seclogin <span class="comment"># ls</span></span><br><span class="line">content_medium_hismatch.csv</span><br><span class="line">public-ops-mongodb2 seclogin <span class="comment"># cat content_medium_hismatch.csv |more</span></span><br><span class="line">_id,content_id,content_tags</span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db599),1229,<span class="string">"["</span><span class="string">"奶瓶"</span><span class="string">","</span><span class="string">"吃奶"</span><span class="string">","</span><span class="string">"吸吮"</span><span class="string">","</span><span class="string">"乳头混淆"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db5c8),1290,<span class="string">"["</span><span class="string">"衣服"</span><span class="string">","</span><span class="string">"二手衣服"</span><span class="string">","</span><span class="string">"清洗"</span><span class="string">","</span><span class="string">"皮肤"</span><span class="string">","</span><span class="string">"细菌"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db5cd),1297,<span class="string">"["</span><span class="string">"身材"</span><span class="string">","</span><span class="string">"产后妈妈"</span><span class="string">","</span><span class="string">"新妈妈"</span><span class="string">","</span><span class="string">"裙子"</span><span class="string">","</span><span class="string">"衣服"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db5e1),1325,<span class="string">"["</span><span class="string">"护肤品"</span><span class="string">","</span><span class="string">"哺乳期"</span><span class="string">","</span><span class="string">"皮肤"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"护肤"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db5e8),1343,<span class="string">"["</span><span class="string">"收纳"</span><span class="string">","</span><span class="string">"家具"</span><span class="string">","</span><span class="string">"奶粉"</span><span class="string">","</span><span class="string">"分享"</span><span class="string">","</span><span class="string">"三角形"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db618),1393,<span class="string">"["</span><span class="string">"背带"</span><span class="string">","</span><span class="string">"婴儿"</span><span class="string">","</span><span class="string">"带宝宝"</span><span class="string">","</span><span class="string">"出门"</span><span class="string">","</span><span class="string">"肌肉发育"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db65e),1465,<span class="string">"["</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"骨骼"</span><span class="string">","</span><span class="string">"眼睛"</span><span class="string">","</span><span class="string">"帮助"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db660),1467,<span class="string">"["</span><span class="string">"晒太阳"</span><span class="string">","</span><span class="string">"紫外线"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"黄疸"</span><span class="string">","</span><span class="string">"眼睛"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db666),1472,<span class="string">"["</span><span class="string">"伞车"</span><span class="string">","</span><span class="string">"推车"</span><span class="string">","</span><span class="string">"婴儿伞车"</span><span class="string">","</span><span class="string">"婴儿推车"</span><span class="string">","</span><span class="string">"优点"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db669),1474,<span class="string">"["</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"味觉发育"</span><span class="string">","</span><span class="string">"口味"</span><span class="string">","</span><span class="string">"食盐"</span><span class="string">","</span><span class="string">"饮食"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db674),1490,<span class="string">"["</span><span class="string">"患病"</span><span class="string">","</span><span class="string">"父母"</span><span class="string">","</span><span class="string">"指甲"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"打呼噜"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db67a),1500,<span class="string">"["</span><span class="string">"睡眠"</span><span class="string">","</span><span class="string">"疾病"</span><span class="string">","</span><span class="string">"父母"</span><span class="string">","</span><span class="string">"症状"</span><span class="string">","</span><span class="string">"医院"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db68c),1513,<span class="string">"["</span><span class="string">"声音"</span><span class="string">","</span><span class="string">"奶睡"</span><span class="string">","</span><span class="string">"美国"</span><span class="string">","</span><span class="string">"摇晃"</span><span class="string">","</span><span class="string">"宝宝睡觉"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db6a0),1535,<span class="string">"["</span><span class="string">"安全"</span><span class="string">","</span><span class="string">"清洗"</span><span class="string">","</span><span class="string">"坐便器"</span><span class="string">","</span><span class="string">"马桶"</span><span class="string">","</span><span class="string">"优点"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db746),2732,<span class="string">"["</span><span class="string">"荔枝"</span><span class="string">","</span><span class="string">"进食"</span><span class="string">","</span><span class="string">"葡萄糖"</span><span class="string">","</span><span class="string">"上火"</span><span class="string">","</span><span class="string">"症状"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db749),2733,<span class="string">"["</span><span class="string">"宝宝喂养"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">","</span><span class="string">"饮食"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db752),2742,<span class="string">"["</span><span class="string">"乳头"</span><span class="string">","</span><span class="string">"喂奶"</span><span class="string">","</span><span class="string">"乳头皲裂"</span><span class="string">","</span><span class="string">"哺乳"</span><span class="string">","</span><span class="string">"乳房"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db758),2745,<span class="string">"["</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"挑食"</span><span class="string">","</span><span class="string">"偏食"</span><span class="string">","</span><span class="string">"爸爸"</span><span class="string">","</span><span class="string">"菠菜"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db75b),2746,<span class="string">"["</span><span class="string">"吃饭"</span><span class="string">","</span><span class="string">"爸爸"</span><span class="string">","</span><span class="string">"咀嚼"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"时间"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db75f),2747,<span class="string">"["</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"小宝"</span><span class="string">","</span><span class="string">"核桃油"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"亚麻酸"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db761),2748,<span class="string">"["</span><span class="string">"油炸"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"食品"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"油脂"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db768),2751,<span class="string">"["</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"膳食纤维"</span><span class="string">","</span><span class="string">"消化不良"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"肠道"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db76d),2753,<span class="string">"["</span><span class="string">"吃饭"</span><span class="string">","</span><span class="string">"饮食习惯"</span><span class="string">","</span><span class="string">"帮助"</span><span class="string">","</span><span class="string">"习惯"</span><span class="string">","</span><span class="string">"爸爸"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db770),2754,<span class="string">"["</span><span class="string">"微波炉"</span><span class="string">","</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db773),2755,<span class="string">"["</span><span class="string">"葡萄糖"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"习惯"</span><span class="string">","</span><span class="string">"家长"</span><span class="string">","</span><span class="string">"宝宝生病"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db775),2756,<span class="string">"["</span><span class="string">"祛湿"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"帮助"</span><span class="string">","</span><span class="string">"食谱"</span><span class="string">","</span><span class="string">"红豆"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db778),2757,<span class="string">"["</span><span class="string">"水果"</span><span class="string">","</span><span class="string">"蔬菜"</span><span class="string">","</span><span class="string">"果汁"</span><span class="string">","</span><span class="string">"配方奶"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db77e),2759,<span class="string">"["</span><span class="string">"挑食"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"宝宝挑食"</span><span class="string">","</span><span class="string">"缺锌"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db781),2760,<span class="string">"["</span><span class="string">"吃肉"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"水果"</span><span class="string">","</span><span class="string">"饱和脂肪酸"</span><span class="string">","</span><span class="string">"便秘"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db784),2761,<span class="string">"["</span><span class="string">"水果"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"胡萝卜素"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db787),2762,<span class="string">"["</span><span class="string">"体重"</span><span class="string">","</span><span class="string">"宝宝瘦"</span><span class="string">","</span><span class="string">"营养不良"</span><span class="string">","</span><span class="string">"原因"</span><span class="string">","</span><span class="string">"父母"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db789),2763,<span class="string">"["</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"宝宝喂养"</span><span class="string">","</span><span class="string">"进食"</span><span class="string">","</span><span class="string">"时间"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db790),2765,<span class="string">"["</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"宝宝断奶"</span><span class="string">","</span><span class="string">"断奶"</span><span class="string">","</span><span class="string">"保存"</span><span class="string">","</span><span class="string">"冰箱"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db792),2766,<span class="string">"["</span><span class="string">"断奶"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">","</span><span class="string">"环境"</span><span class="string">","</span><span class="string">"夏季"</span><span class="string">","</span><span class="string">"宝宝生病"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db795),2767,<span class="string">"["</span><span class="string">"益生菌"</span><span class="string">","</span><span class="string">"药物"</span><span class="string">","</span><span class="string">"食品"</span><span class="string">","</span><span class="string">"平衡"</span><span class="string">","</span><span class="string">"抗生素"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db798),2768,<span class="string">"["</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"咳嗽"</span><span class="string">","</span><span class="string">"宝宝咳嗽"</span><span class="string">","</span><span class="string">"饮食"</span><span class="string">","</span><span class="string">"辛辣"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db79b),2769,<span class="string">"["</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"饮食"</span><span class="string">","</span><span class="string">"断奶"</span><span class="string">","</span><span class="string">"宝宝断奶"</span><span class="string">","</span><span class="string">"保存"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db7a1),2773,<span class="string">"["</span><span class="string">"补钙"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"宝宝缺钙"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">","</span><span class="string">"配方奶"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7a6),2775,<span class="string">"["</span><span class="string">"果泥"</span><span class="string">","</span><span class="string">"水果"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"哈密瓜"</span><span class="string">","</span><span class="string">"香蕉"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7a9),2776,<span class="string">"["</span><span class="string">"饮食"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"进食"</span><span class="string">","</span><span class="string">"水果"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7ac),2777,<span class="string">"["</span><span class="string">"有机蔬菜"</span><span class="string">","</span><span class="string">"蔬菜"</span><span class="string">","</span><span class="string">"农药"</span><span class="string">","</span><span class="string">"有机"</span><span class="string">","</span><span class="string">"农药残留"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7b4),2780,<span class="string">"["</span><span class="string">"断奶"</span><span class="string">","</span><span class="string">"乳头"</span><span class="string">","</span><span class="string">"乳房"</span><span class="string">","</span><span class="string">"乳腺炎"</span><span class="string">","</span><span class="string">"回奶"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7b8),2783,<span class="string">"["</span><span class="string">"叶黄素"</span><span class="string">","</span><span class="string">"太阳镜"</span><span class="string">","</span><span class="string">"胡萝卜"</span><span class="string">","</span><span class="string">"南瓜"</span><span class="string">","</span><span class="string">"芒果"</span><span class="string">"]"</span></span><br></pre></td></tr></tbody></table></figure><p>就能确定这么执行是没有问题。重点排查<code>--query条件</code>。根据之前报错<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-05-17T13:25:56.341+0800    error validating settings: query <span class="string">'[123 99 111 110 116 101 110 116 95 116 121 112 101 95 105 100 58 50 56 44 117 112 100 97 116 101 95 116 105 109 101 58 123 36 103 116 101 58 49 53 52 54 50 55 50 48 48 48 48 48 48 125 44 105 115 95 100 101 108 101 116 101 58 48 125 44 123 99 111 110 116 101 110 116 95 105 100 58 49 44 99 111 110 116 101 110 116 95 116 97 103 115 58 49 125]'</span> is not valid JSON: invalid character <span class="string">','</span> after top-level value</span><br><span class="line">2019-05-17T13:25:56.341+0800    try <span class="string">'mongoexport --help'</span> <span class="keyword">for</span> more information</span><br></pre></td></tr></tbody></table></figure><p></p><p>发现一个点<code>invalid character ',' after top-level value</code>中提示有<code>逗号,</code>的问题，排查一下<code>--query条件</code>发现有<code>'{"content_type_id":"28","update_time":{"$gte":1546272000000},"is_delete":0}, {"content_id":1,"content_tags":1}'</code>有一个<code>逗号,</code></p><p>去掉<code>逗号,</code>和后面的<code>逗号之后的条件</code>发现执行成功<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongoexport --port 29001 --host=localhost -user=*** --password=***** --authenticationDatabase=**** --db=db --collection=collection --query=<span class="string">'{"content_type_id":"28","update_time":{"$gte":1546272000000},"is_delete":0}'</span> --<span class="built_in">type</span>=csv --fields _id,content_id,content_tags --out=***.csv</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2019-05-17T13:41:33.068+0800    connected to: localhost:29001</span><br><span class="line">2019-05-17T13:41:34.067+0800    feeds.content_medium_hismatch  0</span><br><span class="line">2019-05-17T13:41:35.067+0800    feeds.content_medium_hismatch  0</span><br><span class="line">2019-05-17T13:41:36.067+0800    feeds.content_medium_hismatch  0</span><br><span class="line">2019-05-17T13:41:36.656+0800    feeds.content_medium_hismatch  18870</span><br><span class="line">2019-05-17T13:41:36.656+0800    exported 18870 records</span><br><span class="line">public-ops-mongodb2 seclogin <span class="comment"># cat content_medium_hismatch.csv |wc -l</span></span><br><span class="line">18871</span><br><span class="line">public-ops-mongodb2 seclogin <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>和开发确认一下这个条件能否却掉，开发确认可以去掉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>mongoexport</code>在执行有条件的导出文件，<code>--query</code> 条件要写在一个<code>花括号{}</code>里面，如果要有两个<code>花括号{}</code>的条件，中间用<code>逗号,</code>分割，这样是不行的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;qiong.gif&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MongoDB" scheme="https://jiemin.wang/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://jiemin.wang/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>详细的MySQL高性能优化实战总结</title>
    <link href="https://jiemin.wang/2019/05/16/mysql-innodb/"/>
    <id>https://jiemin.wang/2019/05/16/mysql-innodb/</id>
    <published>2019-05-16T09:53:50.000Z</published>
    <updated>2019-05-16T11:59:42.490Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="iiiii.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>努力不一定成功，但是不努力会很舒服的哦!</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL 对于很多 Linux 从业者而言，是一个非常棘手的问题，多数情况都是因为对数据库出现问题的情况和处理思路不清晰。</p><p>在进行 MySQL 的优化之前必须要了解的就是 MySQL 的查询过程，很多的查询优化工作实际上就是遵循一些原则让 MySQL 的优化器能够按照预想的合理方式运行而已。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><img src="http://www.plantuml.com/plantuml/svg/bLDTIm9157sVNx5i3tt0Rk_Bij3NWv15I0-HFKGj4SKgMeH4q4EKbPfbXPPeQub2k4e41Hh-6MTs_HVDxgop7ndHFDsvSywvToxdHjStTjQtP8OD9a9BymmgLurcnUYUwVLBzX0m-8pDx6xBojwuTLbb2KBlv60ZpwxPIQFsZ4fPMAZxCkZfccRwbHFuSg9dJzqmTD_wYIGbUfqyJDrxmESrGqqPcWgJDpwmhn-I97ZOkKEv37qAA4faTffUWub0Q2f8hxnr79sx5afhzBeo5wBnmY8EZm1OZiinHkHNHsBovXelEUCQ128l-RiK6AXLKF93VsrEec8QNgWu2YlzuuTULuNfAqFJm2ZbSzw9O7f2ZeSL_V4TPQf6znO-blHsWIe2VpLkFyf9TlEuylLNxxE1wTOhS5SXY7-AIsGK0eFUL5GyjsL9qdnqMKCWCVOPyEIvpSY1uc0jAmZwRHabis65ve3VGcRBRWPv8kfUNvb8BzTkvNSAxUc76V5FBL_PB8ydHNFMGpaO7LPiiBLTv7zWk5T5KjulBtWg3-5DqBQfpVy2qWNu2qXNmn5tXZJOazz4Y0LzMq02RBPs3fMABYjYzCHm9O5OSi3v1W00"><h3 id="优化的哲学"><a href="#优化的哲学" class="headerlink" title="优化的哲学"></a>优化的哲学</h3><blockquote><p>注：优化有风险，修改需谨慎。</p></blockquote><ul><li>优化可能带来的问题：</li><li>优化不总是对一个单纯的环境进行，还很可能是一个复杂的已投产的系统。</li><li>优化手段本来就有很大的风险，只不过你没能力意识到和预见到。</li><li>任何的技术可以解决一个问题，但必然存在带来一个问题的风险。</li><li>对于优化来说解决问题而带来的问题，控制在可接受的范围内才是有成果。</li><li>保持现状或出现更差的情况都是失败。</li></ul><p>优化的需求：</p><ul><li>稳定性和业务可持续性，通常比性能更重要。</li><li>优化不可避免涉及到变更，变更就有风险。</li><li>优化使性能变好，维持和变差是等概率事件。</li><li>切记优化，应该是各部门协同，共同参与的工作，任何单一部门都不能对数据库进行优化。</li></ul><p>所以优化工作，是由业务需求驱使的!</p><p>优化由谁参与?在进行数据库优化时，应由数据库管理员、业务部门代表、应用程序架构师、应用程序设计人员、应用程序开发人员、硬件及系统管理员、存储管理员等，业务相关人员共同参与。</p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><h4 id="优化什么"><a href="#优化什么" class="headerlink" title="优化什么"></a>优化什么</h4><p>在数据库优化上有两个主要方面：</p><ul><li>安全：数据可持续性。</li><li>性能：数据的高性能访问。</li></ul><h4 id="优化的范围有哪些"><a href="#优化的范围有哪些" class="headerlink" title="优化的范围有哪些"></a>优化的范围有哪些</h4><p>存储、主机和操作系统方面：</p><ul><li>主机架构稳定性</li><li>I/O 规划及配置</li><li>Swap 交换分区</li><li>OS 内核参数和网络问题</li></ul><p>应用程序方面：</p><ul><li>应用程序稳定性</li><li>SQL 语句性能</li><li>串行访问资源</li><li>性能欠佳会话管理</li><li>这个应用适不适合用 MySQL</li></ul><p>数据库优化方面：</p><ul><li>内存</li><li>数据库结构(物理&逻辑)</li><li>实例配置</li></ul><blockquote><p>说明：不管是设计系统、定位问题还是优化，都可以按照这个顺序执行。</p></blockquote><h4 id="优化维度"><a href="#优化维度" class="headerlink" title="优化维度"></a>优化维度</h4><img src="/2019/05/16/mysql-innodb/weidu.jpeg" title="weidu"><p>数据库优化维度有如下四个:</p><ul><li>硬件</li><li>系统配置</li><li>数据库表结构</li><li>SQL 及索引</li></ul><p>优化选择:</p><ul><li>优化成本：硬件>系统配置>数据库表结构>SQL 及索引。</li><li>优化效果：硬件<系统配置<数据库表结构</li></ul><h4 id="优化工具有啥"><a href="#优化工具有啥" class="headerlink" title="优化工具有啥"></a>优化工具有啥</h4><h2 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h2><p>检查问题常用的 12 个工具:</p><ul><li>MySQL</li><li>mysqladmin：MySQL 客户端，可进行管理操作</li><li>mysqlshow：功能强大的查看 shell 命令</li><li>SHOW [SESSION | GLOBAL] variables：查看数据库参数信息</li><li>SHOW [SESSION | GLOBAL] STATUS：查看数据库的状态信息</li><li>information_schema：获取元数据的方法</li><li>SHOW ENGINE INNODB STATUS：Innodb 引擎的所有状态</li><li>SHOW PROCESSLIST：查看当前所有连接的 session 状态</li><li>explain：获取查询语句的执行计划</li><li>show index：查看表的索引信息</li><li>slow-log：记录慢查询语句</li><li>mysqldumpslow：分析 slowlog 文件的工具</li></ul><p>不常用但好用的 7 个工具:</p><ul><li>Zabbix：监控主机、系统、数据库(部署 Zabbix 监控平台)</li><li>pt-query-digest：分析慢日志</li><li>MySQL slap：分析慢日志</li><li>sysbench：压力测试工具</li><li>MySQL profiling：统计数据库整体状态工具</li><li>Performance Schema：MySQL 性能状态统计的数据</li><li>workbench：管理、备份、监控、分析、优化工具(比较费资源)</li></ul><h4 id="数据库层面问题解决思路"><a href="#数据库层面问题解决思路" class="headerlink" title="数据库层面问题解决思路"></a>数据库层面问题解决思路</h4><p>一般应急调优的思路：针对突然的业务办理卡顿，无法进行正常的业务处理，需要马上解决的场景。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show processlist </span><br><span class="line">explain select id ,name from stu <span class="built_in">where</span> name=<span class="string">'clsn'</span>; <span class="comment"># ALL id name age sex </span></span><br><span class="line"> select id,name from stu <span class="built_in">where</span> id=2-1 函数 结果集>30; </span><br><span class="line">　 show index from table; </span><br><span class="line">通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题 </span><br><span class="line">show status like <span class="string">'%lock%'</span>; <span class="comment"># 查询锁状态 </span></span><br><span class="line"><span class="built_in">kill</span> SESSION_ID; <span class="comment"># 杀掉有问题的session</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>常规调优思路：针对业务周期性的卡顿，例如在每天 10-11 点业务特别慢，但是还能够使用，过了这段时间就好了。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看slowlog，分析slowlog，分析出查询慢的语句； </span><br><span class="line">按照一定优先级，一个一个排查所有慢语句； </span><br><span class="line">分析top SQL，进行explain调试，查看语句执行时间； </span><br><span class="line">调整索引或语句本身。</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a>系统层面</h4><p>CPU方面：vmstat、sar top、htop、nmon、mpstat。</p><p>内存：free、ps-aux。</p><p>IO 设备(磁盘、网络)：iostat、ss、netstat、iptraf、iftop、lsof。</p><p>vmstat 命令说明：</p><ul><li>Procs：r 显示有多少进程正在等待 CPU 时间。b 显示处于不可中断的休眠的进程数量。在等待 I/O。</li><li>Memory：swpd 显示被交换到磁盘的数据块的数量。未被使用的数据块，用户缓冲数据块，用于操作系统的数据块的数量。</li><li>Swap：操作系统每秒从磁盘上交换到内存和从内存交换到磁盘的数据块的数量。s1 和 s0 最好是 0。</li><li>IO：每秒从设备中读入 b1 的写入到设备 b0 的数据块的数量。反映了磁盘 I/O。</li><li>System：显示了每秒发生中断的数量(in)和上下文交换(cs)的数量。</li><li>CPU：显示用于运行用户代码，系统代码，空闲，等待 I/O 的 CPU 时间。</li></ul><p>iostat 命令说明：</p><ul><li>实例命令：iostat -dk 1 5;iostat -d -k -x 5 (查看设备使用率(%util)和响应时间(await))。</li><li>TPS：该设备每秒的传输次数。“一次传输”意思是“一次 I/O 请求”。多个逻辑请求可能会被合并为“一次 I/O 请求”。</li><li>iops ：硬件出厂的时候，厂家定义的一个每秒最大的 IO 次数。</li><li>“一次传输”请求的大小是未知的。</li><li>KB_read/s：每秒从设备(drive expressed)读取的数据量。</li><li>KB_wrtn/s：每秒向设备(drive expressed)写入的数据量。</li><li>KB_read：读取的总数据量。</li><li>KB_wrtn：写入的总数量数据量;这些单位都为 Kilobytes。</li></ul><h4 id="系统层面问题解决办法"><a href="#系统层面问题解决办法" class="headerlink" title="系统层面问题解决办法"></a>系统层面问题解决办法</h4><p>你认为到底负载高好，还是低好呢?在实际的生产中，一般认为 CPU 只要不超过 90% 都没什么问题。当然不排除下面这些特殊情况。</p><p>CPU 负载高，IO 负载低：</p><ul><li>内存不够</li><li>磁盘性能差</li><li>SQL 问题：去数据库层，进一步排查 SQL 问题</li><li>IO 出问题了(磁盘到临界了、raid 设计不好、raid 降级、锁、在单位时间内 TPS 过高)</li><li>TPS 过高：大量的小数据 IO、大量的全表扫描</li></ul><p>IO 负载高，CPU 负载低：</p><ul><li>大量小的 IO 写操作</li><li>autocommit，产生大量小 IO;IO/PS，磁盘的一个定值，硬件出厂的时候，厂家定义的一个每秒最大的 IO 次数。</li><li>大量大的 IO 写操作：SQL 问题的几率比较大</li></ul><p>IO和 CPU 负载都很高：</p><ul><li>硬件不够了或 SQL 存在问题</li></ul><h2 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h2><h4 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h4><p>定位问题点吮吸：硬件>系统>应用>数据库>架构(高可用、读写分离、分库分表)。</p><p>处理方向：明确优化目标、性能和安全的折中、防患未然。</p><h4 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h4><h5 id="主机方面"><a href="#主机方面" class="headerlink" title="主机方面"></a>主机方面</h5><p>根据数据库类型，主机 CPU 选择、内存容量选择、磁盘选择：</p><ul><li>平衡内存和磁盘资源</li><li>随机的 I/O 和顺序的 I/O</li><li>主机 RAID 卡的 BBU(Battery Backup Unit)关闭</li></ul><h5 id="CPU-的选择"><a href="#CPU-的选择" class="headerlink" title="CPU 的选择"></a>CPU 的选择</h5><p>CPU 的两个关键因素：核数、主频。根据不同的业务类型进行选择：</p><ul><li>CPU 密集型：计算比较多，OLTP 主频很高的 CPU、核数还要多。</li><li>IO 密集型：查询比较，OLAP 核数要多，主频不一定高的。</li></ul><h5 id="内存的选择"><a href="#内存的选择" class="headerlink" title="内存的选择"></a>内存的选择</h5><p>OLAP 类型数据库，需要更多内存，和数据获取量级有关。OLTP 类型数据一般内存是 CPU 核心数量的 2 倍到 4 倍，没有最佳实践。</p><h5 id="存储方面"><a href="#存储方面" class="headerlink" title="存储方面"></a>存储方面</h5><p>根据存储数据种类的不同，选择不同的存储设备，配置合理的 RAID 级别(raid5、raid10、热备盘)。</p><p>对于操作系统来讲，不需要太特殊的选择，最好做好冗余(raid1)(ssd、sas、sata)。</p><p>主机 raid 卡选择：</p><ul><li>实现操作系统磁盘的冗余(raid1)</li><li>平衡内存和磁盘资源</li><li>随机的 I/O 和顺序的 I/O</li><li>主机 raid 卡的 BBU(Battery Backup Unit)要关闭</li></ul><h5 id="网络设备方面"><a href="#网络设备方面" class="headerlink" title="网络设备方面"></a>网络设备方面</h5><p>使用流量支持更高的网络设备(交换机、路由器、网线、网卡、HBA 卡)。注意：以上这些规划应该在初始设计系统时就应该考虑好。</p><h4 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h4><p>服务器硬件优化关键点：</p><ul><li>物理状态灯</li><li>自带管理设备：远程控制卡(FENCE设备：ipmi ilo idarc)、开关机、硬件监控。</li><li>第三方的监控软件、设备(snmp、agent)对物理设施进行监控。</li><li>存储设备：自带的监控平台。EMC2(HP 收购了)、 日立(HDS)、IBM 低端 OEM HDS、高端存储是自己技术，华为存储。</li></ul><h4 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h4><p>CPU：基本不需要调整，在硬件选择方面下功夫即可。</p><p>内存：基本不需要调整，在硬件选择方面下功夫即可。</p><p>SWAP：MySQL 尽量避免使用 Swap。阿里云的服务器中默认 swap 为 0。</p><p>IO ：raid、no lvm、ext4 或 xfs、ssd、IO 调度策略。</p><p>Swap 调整(不使用 swap 分区)：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/vm/swappiness的内容改成0(临时)，/etc/sysctl. conf上添加vm.swappiness=0(永久)</span><br></pre></td></tr></tbody></table></figure><p></p><p>这个参数决定了 Linux 是倾向于使用 Swap，还是倾向于释放文件系统 Cache。在内存紧张的情况下，数值越低越倾向于释放文件系统 Cache。</p><p>当然，这个参数只能减少使用 Swap 的概率，并不能避免 Linux 使用 Swap。</p><p>修改 MySQL 的配置参数 innodb_flush_ method，开启 O_DIRECT 模式。</p><p>这种情况下，InnoDB 的 buffer pool 会直接绕过文件系统 Cache 来访问磁盘，但是 redo log 依旧会使用文件系统 Cache。</p><p>值得注意的是，Redo log 是覆写模式的，即使使用了文件系统的 Cache，也不会占用太多。</p><p>IO 调度策略：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#echo deadline>/sys/block/sda/queue/scheduler 临时修改为deadline</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>永久修改<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /boot/grub/grub.conf </span><br><span class="line">更改到如下内容: </span><br><span class="line">kernel /boot/vmlinuz-2.6.18-8.el5 ro root=LABEL=/ elevator=deadline rhgb quiet</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="系统参数调整"><a href="#系统参数调整" class="headerlink" title="系统参数调整"></a>系统参数调整</h4><p>Linux 系统内核参数优化<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/sysctl.conf </span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65535：<span class="comment"># 用户端口范围 </span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096 </span><br><span class="line">net.ipv4.tcp_fin_timeout = 30 </span><br><span class="line">fs.file-max=65535：<span class="comment"># 系统最大文件句柄，控制的是能打开文件最大数量</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>用户限制参数(MySQL 可以不设置以下配置)：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/security/limits.conf </span><br><span class="line">* soft nproc 65535 </span><br><span class="line">* hard nproc 65535 </span><br><span class="line">* soft nofile 65535 </span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><p>业务应用和数据库应用独立。</p><p>防火墙：iptables、selinux 等其他无用服务(关闭)：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 23456 acpid off </span><br><span class="line">chkconfig --level 23456 anacron off </span><br><span class="line">chkconfig --level 23456 autofs off </span><br><span class="line">chkconfig --level 23456 avahi-daemon off </span><br><span class="line">chkconfig --level 23456 bluetooth off </span><br><span class="line">chkconfig --level 23456 cups off </span><br><span class="line">chkconfig --level 23456 firstboot off </span><br><span class="line">chkconfig --level 23456 haldaemon off </span><br><span class="line">chkconfig --level 23456 hplip off </span><br><span class="line">chkconfig --level 23456 ip6tables off </span><br><span class="line">chkconfig --level 23456 iptables off </span><br><span class="line">chkconfig --level 23456 isdn off </span><br><span class="line">chkconfig --level 23456 pcscd off </span><br><span class="line">chkconfig --level 23456 sendmail off </span><br><span class="line">chkconfig --level 23456 yum-updatesd off</span><br></pre></td></tr></tbody></table></figure><p></p><p>安装图形界面的服务器不要启动图形界面 runlevel 3。</p><p>另外，思考将来我们的业务是否真的需要 MySQL，还是使用其他种类的数据库。用数据库的最高境界就是不用数据库。</p><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><p>SQL 优化方向：</p><ul><li>执行计划</li><li>索引</li><li>SQL 改写</li></ul><p>架构优化方向：</p><ul><li>高可用架构</li><li>高性能架构</li><li>分库分表</li></ul><h4 id="数据库参数优化"><a href="#数据库参数优化" class="headerlink" title="数据库参数优化"></a>数据库参数优化</h4><h5 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h5><p>实例整体(高级优化，扩展)：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread_concurrency：<span class="comment"># 并发线程数量个数 </span></span><br><span class="line">sort_buffer_size：<span class="comment"># 排序缓存 </span></span><br><span class="line">read_buffer_size：<span class="comment"># 顺序读取缓存 </span></span><br><span class="line">read_rnd_buffer_size：<span class="comment"># 随机读取缓存 </span></span><br><span class="line">key_buffer_size：<span class="comment"># 索引缓存 </span></span><br><span class="line">thread_cache_size：<span class="comment"># (1G—>8, 2G—>16, 3G—>32, >3G—>64)</span></span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="连接层-基础优化"><a href="#连接层-基础优化" class="headerlink" title="连接层(基础优化)"></a>连接层(基础优化)</h5><p>设置合理的连接客户和连接方式：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">max_connections <span class="comment"># 最大连接数，看交易笔数设置 </span></span><br><span class="line">max_connect_errors <span class="comment"># 最大错误连接数，能大则大 </span></span><br><span class="line">connect_timeout <span class="comment"># 连接超时 </span></span><br><span class="line">max_user_connections <span class="comment"># 最大用户连接数 </span></span><br><span class="line">skip-name-resolve <span class="comment"># 跳过域名解析 </span></span><br><span class="line">wait_timeout <span class="comment"># 等待超时 </span></span><br><span class="line">back_log <span class="comment"># 可以在堆栈中的连接数量 </span></span><br><span class="line">```      </span><br><span class="line"><span class="comment">##### SQL 层(基础优化)</span></span><br><span class="line">query_cache_size： 查询缓存 >>> OLAP 类型数据库，需要重点加大此内存缓存，但是一般不会超过 GB。</span><br><span class="line"></span><br><span class="line">对于经常被修改的数据，缓存会马上失效。我们可以使用内存数据库(redis、memecache)，替代它的功能。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 存储引擎层优化</span></span><br><span class="line">innodb 基础优化参数：</span><br><span class="line">```bash</span><br><span class="line">default-storage-engine </span><br><span class="line">innodb_buffer_pool_size <span class="comment"># 没有固定大小，50%测试值，看看情况再微调。但是尽量设置不要超过物理内存70% </span></span><br><span class="line">innodb_file_per_table=(1,0) </span><br><span class="line">innodb_flush_log_at_trx_commit=(0,1,2) <span class="comment"># 1是最安全的，0是性能最高，2折中 </span></span><br><span class="line">binlog_sync </span><br><span class="line">Innodb_flush_method=(O_DIRECT, fdatasync) </span><br><span class="line">innodb_log_buffer_size <span class="comment"># 100M以下 </span></span><br><span class="line">innodb_log_file_size <span class="comment"># 100M 以下 </span></span><br><span class="line">innodb_log_files_in_group <span class="comment"># 5个成员以下,一般2-3个够用（iblogfile0-N） </span></span><br><span class="line">innodb_max_dirty_pages_pct <span class="comment"># 达到百分之75的时候刷写 内存脏页到磁盘。 </span></span><br><span class="line">log_bin </span><br><span class="line">max_binlog_cache_size <span class="comment"># 可以不设置 </span></span><br><span class="line">max_binlog_size <span class="comment"># 可以不设置 </span></span><br><span class="line">innodb_additional_mem_pool_size <span class="comment">#小于2G内存的机器，推荐值是20M。32G内存以上100M</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>51CTO传媒: <a href="https://www.toutiao.com/i6647024189007987208/?tt_from=weixin&utm_campaign=client_share&wxshare_count=2&from=singlemessage&timestamp=1555614491&app=news_article&utm_source=weixin&isappinstalled=0&utm_medium=toutiao_ios&req_id=201904190308110100230720231370496&group_id=6647024189007987208&pbid=6691541599112283651" target="_blank" rel="noopener">一份超详细的MySQL高性能优化实战总结</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;iiiii.jpg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>pt-table-checksum fails on older MySQL without utf8mb4-support</title>
    <link href="https://jiemin.wang/2019/05/14/PT-0/"/>
    <id>https://jiemin.wang/2019/05/14/PT-0/</id>
    <published>2019-05-14T02:45:11.000Z</published>
    <updated>2019-05-14T03:30:30.797Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="bs.png" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>“别再抱怨你此生找不到一个对的人，当初的数学选择题就四个，你也找不到对的答案啊”</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天帮同事解决主从同步的问题。</p><p>原因是同事使用<code>Django</code>开发了一套运维平台。但是里面的表使用了<code>FOREIGN KEY</code>，在插入的是报错。造成了<code>主从同步错误</code>，数据量不大，使用<code>pt-table-checksum</code>来校验主从数据</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>一、先跳过主从错误，主从同步关系恢复正常。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STOP SLAVE sql_thread;</span><br><span class="line">SET GLOBAL sql_slave_skip_counter = 1;</span><br><span class="line">START SLAVE sql_thread;</span><br><span class="line">SHOW SLAVE STATUS\G</span><br></pre></td></tr></tbody></table></figure><p></p><p>二、使用 pt-table-checksum<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-table-checksum --<span class="built_in">set</span>-vars innodb_lock_wait_timeout=200 --nocheck-replication-filters --no-check-binlog-format --replicate=test.checksums --create-replicate-table --databases=***** --host=*** --port=*** --user=*** --password=<span class="string">'*****'</span> --recursion-method=<span class="string">'processlist'</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Error setting innodb_lock_wait_timeout: DBD::mysql::db <span class="keyword">do</span> failed: Variable <span class="string">'innodb_lock_wait_timeout'</span> is a <span class="built_in">read</span> only variable [<span class="keyword">for</span> Statement <span class="string">"SET SESSION innodb_lock_wait_timeout=1"</span>].  The current value <span class="keyword">for</span> innodb_lock_wait_timeout is 50.  If the variable is <span class="built_in">read</span> only (not dynamic), specify --<span class="built_in">set</span>-vars innodb_lock_wait_timeout=50 to avoid this warning, <span class="keyword">else</span> manually <span class="built_in">set</span> the variable and restart MySQL.</span><br><span class="line"></span><br><span class="line">Checking <span class="keyword">if</span> all tables can be checksummed ...</span><br><span class="line">Starting checksum ...</span><br><span class="line">Error setting innodb_lock_wait_timeout: DBD::mysql::db <span class="keyword">do</span> failed: Variable <span class="string">'innodb_lock_wait_timeout'</span> is a <span class="built_in">read</span> only variable [<span class="keyword">for</span> Statement <span class="string">"SET SESSION innodb_lock_wait_timeout=1"</span>].  The current value <span class="keyword">for</span> innodb_lock_wait_timeout is 50.  If the variable is <span class="built_in">read</span> only (not dynamic), specify --<span class="built_in">set</span>-vars innodb_lock_wait_timeout=50 to avoid this warning, <span class="keyword">else</span> manually <span class="built_in">set</span> the variable and restart MySQL.</span><br><span class="line"></span><br><span class="line">05-13T18:42:19 Error executing EXPLAIN SELECT COUNT(*) AS cnt, COALESCE(LOWER(CONV(BIT_XOR(CAST(CRC32(CONCAT_WS(<span class="string">'#'</span>, `id`, convert(`uuid` using utf8mb4), convert(`city` using utf8mb4), convert(`bassert` using utf8mb4), convert(`hostname` using utf8mb4), `idc_id`, `dp_id`, convert(`vlanip` using utf8mb4), convert(`wlanip` using utf8mb4), convert(`remote_ip` using utf8mb4), convert(`network_card` using utf8mb4), convert(`mac` using utf8mb4), convert(`serverown` using utf8mb4), convert(`status` using utf8mb4), convert(`rack` using utf8mb4), convert(`unit` using utf8mb4), convert(`sysversion` using utf8mb4), `order_time`, convert(`comment` using utf8mb4), `update_time`, `onlinetime`, `offlinetime`, convert(`roles` using utf8mb4), convert(`services` using utf8mb4), convert(`install_status` using utf8mb4), convert(`service_env` using utf8mb4), convert(`host_type` using utf8mb4), convert(`kvm_local` using utf8mb4), CONCAT(ISNULL(`order_time`), ISNULL(`onlinetime`), ISNULL(`offlinetime`), ISNULL(`roles`), ISNULL(`services`)))) AS UNSIGNED)), 10, 16)), 0) AS crc FROM `bportal`.`server_basic_info` /*explain checksum table*/: DBD::mysql::st execute failed: Unknown character <span class="built_in">set</span>: <span class="string">'utf8mb4'</span> [<span class="keyword">for</span> Statement <span class="string">"EXPLAIN SELECT COUNT(*) AS cnt, COALESCE(LOWER(CONV(BIT_XOR(CAST(CRC32(CONCAT_WS('#', `id`, convert(`uuid` using utf8mb4), convert(`city` using utf8mb4), convert(`bassert` using utf8mb4), convert(`hostname` using utf8mb4), `idc_id`, `dp_id`, convert(`vlanip` using utf8mb4), convert(`wlanip` using utf8mb4), convert(`remote_ip` using utf8mb4), convert(`network_card` using utf8mb4), convert(`mac` using utf8mb4), convert(`serverown` using utf8mb4), convert(`status` using utf8mb4), convert(`rack` using utf8mb4), convert(`unit` using utf8mb4), convert(`sysversion` using utf8mb4), `order_time`, convert(`comment` using utf8mb4), `update_time`, `onlinetime`, `offlinetime`, convert(`roles` using utf8mb4), convert(`services` using utf8mb4), convert(`install_status` using utf8mb4), convert(`service_env` using utf8mb4), convert(`host_type` using utf8mb4), convert(`kvm_local` using utf8mb4), CONCAT(ISNULL(`order_time`), ISNULL(`onlinetime`), ISNULL(`offlinetime`), ISNULL(`roles`), ISNULL(`services`)))) AS UNSIGNED)), 10, 16)), 0) AS crc FROM `bportal`.`server_basic_info` /*explain checksum table*/"</span>] at /usr/bin/pt-table-checksum line 12302.</span><br><span class="line"></span><br><span class="line">05-13T18:42:19 Error checksumming table bportal.server_basic_info: Error executing checksum query: DBD::mysql::st execute failed: Unknown character <span class="built_in">set</span>: <span class="string">'utf8mb4'</span> [<span class="keyword">for</span> Statement <span class="string">"REPLACE INTO `test`.`checksums` (db, tbl, chunk, chunk_index, lower_boundary, upper_boundary, this_cnt, this_crc) SELECT ?, ?, ?, ?, ?, ?, COUNT(*) AS cnt, COALESCE(LOWER(CONV(BIT_XOR(CAST(CRC32(CONCAT_WS('#', `id`, convert(`uuid` using utf8mb4), convert(`city` using utf8mb4), convert(`bassert` using utf8mb4), convert(`hostname` using utf8mb4), `idc_id`, `dp_id`, convert(`vlanip` using utf8mb4), convert(`wlanip` using utf8mb4), convert(`remote_ip` using utf8mb4), convert(`network_card` using utf8mb4), convert(`mac` using utf8mb4), convert(`serverown` using utf8mb4), convert(`status` using utf8mb4), convert(`rack` using utf8mb4), convert(`unit` using utf8mb4), convert(`sysversion` using utf8mb4), `order_time`, convert(`comment` using utf8mb4), `update_time`, `onlinetime`, `offlinetime`, convert(`roles` using utf8mb4), convert(`services` using utf8mb4), convert(`install_status` using utf8mb4), convert(`service_env` using utf8mb4), convert(`host_type` using utf8mb4), convert(`kvm_local` using utf8mb4), CONCAT(ISNULL(`order_time`), ISNULL(`onlinetime`), ISNULL(`offlinetime`), ISNULL(`roles`), ISNULL(`services`)))) AS UNSIGNED)), 10, 16)), 0) AS crc FROM `bportal`.`server_basic_info` /*checksum table*/"</span> with ParamValues: 0=<span class="string">'bportal'</span>, 1=<span class="string">'server_basic_info'</span>, 2=1, 3=undef, 4=undef, 5=undef] at /usr/bin/pt-table-checksum line 11691.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            TS ERRORS  DIFFS     ROWS  DIFF_ROWS  CHUNKS SKIPPED    TIME TABLE</span><br><span class="line">05-13T18:42:19      2      0        0          0       1       0   0.008 bportal.server_basic_info</span><br></pre></td></tr></tbody></table></figure><h4 id="于是排除问题："><a href="#于是排除问题：" class="headerlink" title="于是排除问题："></a>于是排除问题：</h4><ol><li>查看MySQL 版本</li><li>查看MySQL 字符集</li><li>查看数据库和表的字符集<h4 id="google查找问题原因"><a href="#google查找问题原因" class="headerlink" title="google查找问题原因"></a>google查找问题原因</h4>发现篇文章和该错误几乎一致。说到pt-table-checksum已经不支持MySQL 5.1版本。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thank you <span class="keyword">for</span> the report.</span><br><span class="line"></span><br><span class="line">The error is expected since  character <span class="built_in">set</span> utf8mb4 Unknown to the MySQL 5.1</span><br><span class="line"></span><br><span class="line">MySQL 5.1 is not a supported version: https://www.percona.com/services/support/mysql-support/percona-toolkit-supported-platforms-and-versions</span><br></pre></td></tr></tbody></table></figure></li></ol><p>写了一个<a href="./pt-table-checksum.utf8mb4.patch">patch</a></p><h4 id="pt-table-checksum打补丁"><a href="#pt-table-checksum打补丁" class="headerlink" title="pt-table-checksum打补丁"></a>pt-table-checksum打补丁</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch pt-table-checksum < pt-table-checksum.utf8mb4.patch</span><br></pre></td></tr></tbody></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-table-checksum --<span class="built_in">set</span>-vars innodb_lock_wait_timeout=200 --nocheck-replication-filters --no-check-binlog-format --replicate=test.checksums --create-replicate-table --databases=***** --host=*** --port=*** --user=*** --password=<span class="string">'*****'</span> --recursion-method=<span class="string">'processlist'</span></span><br></pre></td></tr></tbody></table></figure><p>发现没有上面的问题，一切都正常。在执行<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-table-sync --replicate=test.checksums --databases=***** --charset=utf8 h=****,P=****,u=****,p=<span class="string">'****'</span> --execute</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用MySQL 5.1版本的数据库赶快升级吧。太折腾人了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Percona: <a href="https://jira.percona.com/browse/PT-1552" target="_blank" rel="noopener">jira</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;bs.png&quot; class=&quot;full-image&quot; alt=&quot;alt
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://jiemin.wang/categories/Toolkit/"/>
    
    
      <category term="Toolkit" scheme="https://jiemin.wang/tags/Toolkit/"/>
    
  </entry>
  
  <entry>
    <title>图解Go的channel底层原理</title>
    <link href="https://jiemin.wang/2019/05/05/go-channal-graphic/"/>
    <id>https://jiemin.wang/2019/05/05/go-channal-graphic/</id>
    <published>2019-05-05T05:33:49.000Z</published>
    <updated>2019-05-05T06:13:58.039Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="iiii.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>努力不一定成功，但是不努力会很舒服的哦!</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>channel的整体结构图<br><img src="/2019/05/05/go-channal-graphic/hchan.png" title="hchan"></p><p>简单说明：</p><ul><li><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表</li><li><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的~发送或者接收的~index</li><li><code>lock</code>是个互斥锁。</li><li><code>recvq</code>和<code>sendq</code>分别是接收(<-channel)或者发送(channel <- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><p>源码位于<code>/runtime/chan.go</code>中(目前版本：1.11)。结构体为<code>hchan</code>。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>下面我们来详细介绍<code>hchan</code>中各部分是如何使用的。</p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><p>先从创建开始</p><p>我们首先创建一个channel。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/05/05/go-channal-graphic/hchan1.png" title="hchan1"><p>创建channel实际上就是在内存中实例化了一个<code>hchan</code>的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接用channel就行了，因为channel本身就是一个指针。</p><h4 id="channel中发送send-ch-lt-xxx-和recv-lt-ch-接收"><a href="#channel中发送send-ch-lt-xxx-和recv-lt-ch-接收" class="headerlink" title="channel中发送send(ch <- xxx)和recv(<- ch)接收"></a>channel中发送send(ch <- xxx)和recv(<- ch)接收</h4><p>先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？<br>加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁<code>mutex</code></p><h4 id="channel中队列是如何实现的"><a href="#channel中队列是如何实现的" class="headerlink" title="channel中队列是如何实现的"></a>channel中队列是如何实现的</h4><p>channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。<br>还是刚才创建的那个channel<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/05/05/go-channal-graphic/hchan_gif1.png" title="hchan_gif1"><p>当使用<code>send (ch <- xx)</code>或者<code>recv ( <-ch)</code>的时候，首先要锁住<code>hchan</code>这个结构体。</p><img src="/2019/05/05/go-channal-graphic/hchan_gif2.png" title="hchan_gif2"><p>然后开始<code>send (ch <- xx)</code>数据。</p><p>一<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch <- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>二<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch <- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>三<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch <- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>这时候满了，队列塞不进去了</p><p>动态图表示为：<br><img src="/2019/05/05/go-channal-graphic/send.gif" title="send"><br>然后是取<code>recv ( <-ch)</code>的过程，是个逆向的操作，也是需要加锁。<br><img src="/2019/05/05/go-channal-graphic/hchan_gif6.png" title="hchan_gif6"></p><p>然后开始<code>recv (<-ch)</code>数据。<br>一<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><-ch</span><br></pre></td></tr></tbody></table></figure><p></p><p>二<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><-ch</span><br></pre></td></tr></tbody></table></figure><p></p><p>三<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><-ch</span><br></pre></td></tr></tbody></table></figure><p></p><p>图为：<br><img src="/2019/05/05/go-channal-graphic/recv.gif" title="recv"><br>注意以上两幅图中<code>buf</code>和<code>recvx</code>以及<code>sendx</code>的变化，<code>recvx</code>和<code>sendx</code>是根据循环链表<code>buf</code>的变动而改变的。</p><p>至于为什么<code>channel</code>会使用<code>循环链表</code>作为缓存结构，我个人认为是在缓存列表在动态的<code>send</code>和<code>recv</code>过程中，定位当前<code>send</code>或者<code>recvx</code>的位置、选择<code>send</code>的和<code>recvx</code>的位置比较方便吧，只要顺着链表顺序一直旋转操作就好。</p><p>缓存中按链表顺序存放，取数据的时候按链表顺序读取，符合FIFO的原则。</p><h4 id="send-recv的细化操作"><a href="#send-recv的细化操作" class="headerlink" title="send/recv的细化操作"></a>send/recv的细化操作</h4><p>注意：缓存链表中以上每一步的操作，都是需要加锁操作的！</p><p>每一步的操作的细节可以细化为：</p><ul><li>第一，加锁</li><li>第二，把数据从goroutine中copy到“队列”中(或者从队列中copy到goroutine中）。</li><li>第三，释放锁</li></ul><p>每一步的操作总结为动态图为：(发送过程)<br><img src="/2019/05/05/go-channal-graphic/send_single.gif" title="send_single"></p><p>或者为：(接收过程)<br><img src="/2019/05/05/go-channal-graphic/recv_single.gif" title="recv_single"></p><p>所以不难看出，Go中那句经典的话：<code>Do not communicate by sharing memory; instead, share memory by communicating.</code>的具体实现就是利用channel把数据从一端copy到了另一端！</p><p>还真是符合<code>channel</code>的英文含义：<br><img src="/2019/05/05/go-channal-graphic/hchan_channl.gif" title="hchan_channl"></p><h4 id="当channel缓存满了之后会发生什么？这其中的原理是怎样的？"><a href="#当channel缓存满了之后会发生什么？这其中的原理是怎样的？" class="headerlink" title="当channel缓存满了之后会发生什么？这其中的原理是怎样的？"></a>当channel缓存满了之后会发生什么？这其中的原理是怎样的？</h4><p>使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch <- xxx)或者recv(<- ch)会阻塞当前goroutine，但是，是如何实现的呢？</p><p>我们知道，Go的goroutine是用户态的线程(<code>user-space threads</code>)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。关于Go的调度模型GMP模型我在此不做赘述，如果不了解，可以看我另一篇文章(<a href="https://i6448038.github.io/2017/12/04/golang-concurrency-principle/" target="_blank" rel="noopener">Go并发原理</a>)</p><p>goroutine的阻塞操作，实际上是调用<code>send (ch <- xx)</code>或者<code>recv ( <-ch)</code>的时候主动触发的，具体请看以下内容：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goroutine1 中，记做G1</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ch <- <span class="number">1</span></span><br><span class="line">ch <- <span class="number">1</span></span><br><span class="line">ch <- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><img src="/2019/05/05/go-channal-graphic/hchan_block.png" title="hchan_block"><img src="/2019/05/05/go-channal-graphic/hchan_block1.png" title="hchan_block1"><p>这个时候G1正在正常运行,当再次进行send操作(ch<-1)的时候，会主动调用Go的调度器,让G1等待，并从让出M，让其他G去使用<br><img src="/2019/05/05/go-channal-graphic/hchan_block2.png" title="hchan_block2"></p><p>同时G1也会被抽象成含有G1指针和send元素的<code>sudog</code>结构体保存到hchan的<code>sendq</code>中等待被唤醒。<br><img src="/2019/05/05/go-channal-graphic/hchan_blok3.gif" title="hchan_blok3"></p><p>那么，G1什么时候被唤醒呢？这个时候G2隆重登场。<br><img src="/2019/05/05/go-channal-graphic/hchan_block4.png" title="hchan_block4"></p><p>G2执行了recv操作<code>p := <-ch</code>，于是会发生以下的操作：<br><img src="/2019/05/05/go-channal-graphic/hchan_block5.gif" title="hchan_block5"></p><p>G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。<br><img src="/2019/05/05/go-channal-graphic/hchan_block6.gif" title="hchan_block6"></p><h4 id="假如是先进行执行recv操作的G2会怎么样？"><a href="#假如是先进行执行recv操作的G2会怎么样？" class="headerlink" title="假如是先进行执行recv操作的G2会怎么样？"></a>假如是先进行执行recv操作的G2会怎么样？</h4><p>你可能会顺着以上的思路反推。首先：<br><img src="/2019/05/05/go-channal-graphic/hchan_block7_1.png" title="hchan_block7_1"></p><p>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。</p><p>G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒<br><img src="/2019/05/05/go-channal-graphic/hchan_block7.gif" title="hchan_block7"></p><p>此时恰好有个goroutine G1开始向channel中推送数据 <code>ch <- 1</code>。</p><p>此时，非常有意思的事情发生了：<br><img src="/2019/05/05/go-channal-graphic/hchan_block8.gif" title="hchan_block8"></p><p>G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。</p><p>这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。</p><p>之后的事情显而易见：<br><img src="/2019/05/05/go-channal-graphic/hchan_block9.gif" title="hchan_block9"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.youtube.com/watch?v=KBZlN0izeiY" target="_blank" rel="noopener">youtube</a></li><li><a href="https://zhuanlan.zhihu.com/p/27917262" target="_blank" rel="noopener">深入理解Golang Channel</a></li></ul><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><ul><li><a href="https://i6448038.github.io/2019/04/11/go-channel/" target="_blank" rel="noopener">图解Go的channel底层实现(RyuGou)</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;iiii.jpg&quot; class=&quot;full-image&quot; alt=&quot;a
      
    
    </summary>
    
      <category term="Golang" scheme="https://jiemin.wang/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://jiemin.wang/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>最全Oracle DBA日常维护SQL脚本命令</title>
    <link href="https://jiemin.wang/2019/04/26/oracle-ops-sql/"/>
    <id>https://jiemin.wang/2019/04/26/oracle-ops-sql/</id>
    <published>2019-04-26T01:23:59.000Z</published>
    <updated>2019-04-26T02:54:17.653Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="aaa.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>“原谅他们是上帝的事，我们的任务是负责送他们见上帝。”</strong></p></blockquote><h2 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h2><h4 id="查询碎片程度高（实际使用率小于30-）的表"><a href="#查询碎片程度高（实际使用率小于30-）的表" class="headerlink" title="查询碎片程度高（实际使用率小于30%）的表"></a>查询碎片程度高（实际使用率小于30%）的表</h4><p>可以收缩的表条件为什么<code>block>100</code>，因为一些很小的表，只有几行数据实际大小很小，但是block一次性分配就是5个（11g开始默认一次性分配1M的block大小了，见create table storged的NEXT参数），5个block相对于几行小表数据来说就相差太大了。</p><p>算法中<code>/0.9</code>是因为块的<code>pfree</code>一般为<code>10%</code>，所以一个块最多只用了<code>90%</code>，而且一行数据大于<code>8KB</code>时容易产生行链接，把一行分片存储，一样的一个块连<code>90%</code>都用不满 ，<code>AVG_ROW_LEN</code>还是比较准的，比如个人实验情况一表6个字段，一个<code>numbe</code>r，其他5个都是<code>char(100)</code>但是实际数据都是’1111111’7位，AVG_ROW_LEN显示依然为513 。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT TABLE_NAME,</span><br><span class="line">        (BLOCKS * 8192/1024/1024) <span class="string">"理论大小M"</span>,</span><br><span class="line">         (NUM_ROWS * AVG_ROW_LEN/1024/1024/0.9) <span class="string">"实际大小M"</span>,</span><br><span class="line">         ROUND((NUM_ROWS * AVG_ROW_LEN/1024/1024/0.9)/(BLOCKS * 8192/1024/1024),</span><br><span class="line">         3) * 100|| <span class="string">'%'</span> <span class="string">"实际使用率%"</span></span><br><span class="line">FROM USER_TABLES</span><br><span class="line">WHERE blocks > 100</span><br><span class="line">        AND (NUM_ROWS * AVG_ROW_LEN/1024/1024/0.9)/(BLOCKS * 8192/1024/1024) < 0.3</span><br><span class="line">ORDER BY  (NUM_ROWS * AVG_ROW_LEN/1024/1024/0.9)/(BLOCKS * 8192/1024/1024) DESC</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查询索引碎片的比例"><a href="#查询索引碎片的比例" class="headerlink" title="查询索引碎片的比例"></a>查询索引碎片的比例</h4><p>索引删除行数除以索引总行数的百分比>30%即认为索引碎片大，也就是需要重建的索引<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line">         del_lf_rows,</span><br><span class="line">         lf_rows,</span><br><span class="line">         ROUND(del_lf_rows/decode(lf_rows,</span><br><span class="line">         0,</span><br><span class="line">         1,</span><br><span class="line">         lf_rows) * 100,</span><br><span class="line">        0)||<span class="string">'%'</span> frag_pct</span><br><span class="line">FROM index_stats</span><br><span class="line">WHERE ROUND(del_lf_rows/decode(lf_rows, 0, 1, lf_rows) * 100,0) > 30;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="集群因子clustering-factor高的表"><a href="#集群因子clustering-factor高的表" class="headerlink" title="集群因子clustering_factor高的表"></a>集群因子clustering_factor高的表</h4><p>集群因子越接近块数越好，接近行数则说明索引列的列值相等的行分布极度散列，可能不走索引扫描而走全表扫描 ：</p><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT tab.table_name,</span><br><span class="line">         tab.blocks,</span><br><span class="line">         tab.num_rows,</span><br><span class="line">         ind.index_name,</span><br><span class="line">         ind.clustering_factor,</span><br><span class="line">         ROUND(nvl(ind.clustering_factor,</span><br><span class="line">         1)/decode(tab.num_rows,</span><br><span class="line">         0,</span><br><span class="line">         1,</span><br><span class="line">         tab.num_rows),</span><br><span class="line">         3) * 100||<span class="string">'%'</span> <span class="string">"集群因子接近行数"</span></span><br><span class="line">FROM user_tables tab, user_indexes ind</span><br><span class="line">WHERE tab.table_name = ind.table_name</span><br><span class="line">        AND tab.blocks>100</span><br><span class="line">        AND nvl(ind.clustering_factor, 1)/decode(tab.num_rows, 0, 1, tab.num_rows)</span><br><span class="line">    BETWEEN 0.35</span><br><span class="line">        AND 3</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT tab.owner,</span><br><span class="line">         tab.table_name,</span><br><span class="line">         tab.blocks,</span><br><span class="line">         tab.num_rows,</span><br><span class="line">         ind.index_name,</span><br><span class="line">         ind.clustering_factor,</span><br><span class="line">         round(nvl(ind.clustering_factor,</span><br><span class="line">        1)/decode(tab.num_rows,</span><br><span class="line">        0,</span><br><span class="line">        1,</span><br><span class="line">        tab.num_rows),</span><br><span class="line">        3)*100||<span class="string">'%'</span> <span class="string">"集群因子接近行数"</span></span><br><span class="line">FROM dba_tables tab, dba_indexes ind</span><br><span class="line">WHERE tab.table_name=ind.table_name</span><br><span class="line">        AND tab.owner NOT IN (<span class="string">'SYS'</span>, <span class="string">'SYSTEM'</span>, <span class="string">'WMSYS'</span>, <span class="string">'DBSNMP'</span>, <span class="string">'CTXSYS'</span>, <span class="string">'XDB'</span>, <span class="string">'ORDDATA'</span>, <span class="string">'SYSMAN'</span>, <span class="string">'CATALOG'</span>, <span class="string">'APEX_030200'</span>, <span class="string">'MDSYS'</span>, <span class="string">'OLAPSYS'</span>, <span class="string">'EXFSYS'</span>)</span><br><span class="line">        AND tab.blocks > 100</span><br><span class="line">        AND nvl(ind.clustering_factor, 1)/decode(tab.num_rows, 0, 1, tab.num_rows)</span><br><span class="line">    BETWEEN 0.35</span><br><span class="line">        AND 3</span><br></pre></td></tr></tbody></table></figure><h4 id="根据sid查spid或根据spid查sid"><a href="#根据sid查spid或根据spid查sid" class="headerlink" title="根据sid查spid或根据spid查sid"></a>根据sid查spid或根据spid查sid</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">         s.serial<span class="comment">#,</span></span><br><span class="line">         p.spid,</span><br><span class="line">         s.terminal,</span><br><span class="line">         s.LOGON_TIME,</span><br><span class="line">         s.status,</span><br><span class="line">         s.PROGRAM,</span><br><span class="line">         s.CLIENT_IDENTIFIER,</span><br><span class="line">         s.machine,</span><br><span class="line">         s.action,</span><br><span class="line">         s.MODULE,</span><br><span class="line">         s.PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         s.osuser</span><br><span class="line">FROM v<span class="variable">$session</span> s, v<span class="variable">$process</span> p</span><br><span class="line">WHERE s.paddr=p.addr</span><br><span class="line">        AND s.sid=XX</span><br><span class="line">        OR p.spid=YY</span><br></pre></td></tr></tbody></table></figure><h4 id="根据sid查看具体的sql语句，不要加条件v-session-status-39-ACTIVE-39-，比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select-from-v-session时会发现另一个窗口在v-session-status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql-id对应的语句就是select-from-v-session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。"><a href="#根据sid查看具体的sql语句，不要加条件v-session-status-39-ACTIVE-39-，比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select-from-v-session时会发现另一个窗口在v-session-status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql-id对应的语句就是select-from-v-session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。" class="headerlink" title="根据sid查看具体的sql语句，不要加条件v$session.status='ACTIVE'，比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select * from v$session时会发现另一个窗口在v$session.status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql_id对应的语句就是select * from v$session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。"></a>根据<code>sid</code>查看具体的<code>sql语句</code>，不要加条件<code>v$session.status='ACTIVE'</code>，比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询<code>select * from v$session</code>时会发现另一个窗口在<code>v$session.status</code>是<code>INACTIVE</code>，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql_id对应的语句就是<code>select * from v$session</code>而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。</h4><p>一个sid可能执行过很多个sql，所以有时需要的sql通过如下查不到是正常的，比如查询到某死锁源sid，通过如下查询可能只是个<code>select语句</code>，而真正引起死锁的sql却查不到，是因为可能这个sid持续了很长时间，这个sid之前执行的一些sql在<code>v$sql</code>可能已经被清除了。</p><h5 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,</span><br><span class="line">         sid,</span><br><span class="line">        SERIAL<span class="comment">#,</span></span><br><span class="line">         LOGON_TIME,</span><br><span class="line">         status,</span><br><span class="line">         PROGRAM,</span><br><span class="line">         CLIENT_IDENTIFIER,</span><br><span class="line">         machine,</span><br><span class="line">        action,</span><br><span class="line">         PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         osuser,</span><br><span class="line">         sql_text</span><br><span class="line">FROM v<span class="variable">$session</span> a, v<span class="variable">$sqltext_with_newlines</span> b</span><br><span class="line">WHERE DECODE(a.sql_hash_value, 0, prev_hash_value, sql_hash_value) = b.hash_value</span><br><span class="line">        AND a.sid=&sid</span><br><span class="line">ORDER BY  piece; </span><br><span class="line">``` </span><br><span class="line"><span class="comment">##### 方法二:</span></span><br><span class="line">```bash</span><br><span class="line">SELECT username,</span><br><span class="line">         sid,</span><br><span class="line">        SERIAL<span class="comment">#,</span></span><br><span class="line">         LOGON_TIME,</span><br><span class="line">         status,</span><br><span class="line">         sql_fulltext,</span><br><span class="line">         PROGRAM,</span><br><span class="line">         CLIENT_IDENTIFIER,</span><br><span class="line">         machine,</span><br><span class="line">         a.action,</span><br><span class="line">         PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         osuser</span><br><span class="line">FROM v<span class="variable">$session</span> a, v<span class="variable">$sql</span> b</span><br><span class="line">WHERE DECODE(a.sql_hash_value, 0, prev_hash_value, sql_hash_value) = b.hash_value</span><br><span class="line">        AND a.sid=&sid</span><br></pre></td></tr></tbody></table></figure><h5 id="如果上面语句执行太慢，则按如下两步"><a href="#如果上面语句执行太慢，则按如下两步" class="headerlink" title="如果上面语句执行太慢，则按如下两步"></a>如果上面语句执行太慢，则按如下两步</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT sql_hash_value,</span><br><span class="line">         prev_hash_value,</span><br><span class="line">         username,</span><br><span class="line">         sid.SERIAL<span class="comment">#,</span></span><br><span class="line">         LOGON_TIME,</span><br><span class="line">         status,</span><br><span class="line">         PROGRAM,</span><br><span class="line">         CLIENT_IDENTIFIER,</span><br><span class="line">         machine,</span><br><span class="line">         action,</span><br><span class="line">         PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         osuser</span><br><span class="line">FROM v<span class="variable">$session</span></span><br><span class="line">WHERE sid=&sidSELECT sql_fulltext</span><br><span class="line">FROM v<span class="variable">$sql</span></span><br><span class="line">WHERE hash_value=XX</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li>XX为上面 <code>sql_hash_value</code>，如果 <code>sql_hash_value为0</code>，则XX为上面 <code>prev_hash_value</code></li></ul></blockquote><h4 id="根据spid查询具体的sql语句-不要加条件v-session-status-’-ACTIVE’-比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select-from-v-session时会发现另一个窗口在v-session-status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql-id对应的语句就是select-from-v-session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。"><a href="#根据spid查询具体的sql语句-不要加条件v-session-status-’-ACTIVE’-比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select-from-v-session时会发现另一个窗口在v-session-status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql-id对应的语句就是select-from-v-session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。" class="headerlink" title="根据spid查询具体的sql语句(不要加条件v$session.status=’ ACTIVE’,比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select  from v$session时会发现另一个窗口在v$session.status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql_id对应的语句就是select  from v$session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。)"></a>根据spid查询具体的sql语句(不要加条件v$session.status=’ ACTIVE’,比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select <em> from v$session时会发现另一个窗口在v$session.status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql_id对应的语句就是select </em> from v$session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。)</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT ss.SID,</span><br><span class="line">         ss.SERIAL<span class="comment">#,</span></span><br><span class="line">         ss.LOGON_TIME,</span><br><span class="line">         pr.SPID,</span><br><span class="line">         sa.SQL_FULLTEXT,</span><br><span class="line">         ss.machine,</span><br><span class="line">         ss.TERMINAL,</span><br><span class="line">         ss.PROGRAM,</span><br><span class="line">         ss.USERNAME,</span><br><span class="line">         ss.CLIENT_IDENTIFIER,</span><br><span class="line">         ss.action,</span><br><span class="line">         ss.PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         ss.STATUS,</span><br><span class="line">         ss.OSUSER,</span><br><span class="line">         ss.status,</span><br><span class="line">         ss.last_call_et,</span><br><span class="line">         sa.sql_text</span><br><span class="line">FROM v<span class="variable">$process</span> pr, v<span class="variable">$session</span> ss, v<span class="variable">$sql</span> sa</span><br><span class="line">WHERE pr.ADDR = ss.PADDR</span><br><span class="line">        AND DECODE(ss.sql_hash_value, 0, prev_hash_value, sql_hash_value)=sa.hash_value</span><br><span class="line">        AND pr.spid=&spid</span><br></pre></td></tr></tbody></table></figure><h4 id="查看历史session-id的SQL来自哪个IP"><a href="#查看历史session-id的SQL来自哪个IP" class="headerlink" title="查看历史session_id的SQL来自哪个IP"></a>查看历史session_id的SQL来自哪个IP</h4><p>查看trace文件名就可以知道spid,trace文件里面有sid和具体sql，如果trace存在incident，那trace就看不到具体sql，但是可以在incident文件中看到具体的sql，如DW_ora_17751.trc中17751就是spid，里面有这样的内容Incident 115 created, dump file: /XX/incident/incdir_115/DW_ora_17751_i115.trc，那么在DW_ora_17751_i115.trc就可以看到具体的sql语句)</p><p>DB_ora_29349.trc中出现<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** SESSION ID:(5057.12807) 2016-10-26 14:45:52.726</span><br></pre></td></tr></tbody></table></figure><p></p><p>通过表<code>V$ACTIVE_SESSION_HISTORY</code>来查<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.sql_id,</span><br><span class="line">         a.machine,</span><br><span class="line">         a.*</span><br><span class="line">FROM V<span class="variable">$ACTIVE_SESSION_HISTORY</span> a</span><br><span class="line">WHERE a.session_id=5057</span><br><span class="line">        AND a.SESSION_SERIAL<span class="comment">#=12807</span></span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查询上面的machine的IP"><a href="#查询上面的machine的IP" class="headerlink" title="查询上面的machine的IP"></a>查询上面的machine的IP</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">         s.serial<span class="comment">#,</span></span><br><span class="line">         s.LOGON_TIME,</span><br><span class="line">         s.machine,</span><br><span class="line">         p.spid,</span><br><span class="line">         p.terminal</span><br><span class="line">FROM v<span class="variable">$session</span> s, v<span class="variable">$process</span> p</span><br><span class="line">WHERE s.paddr=p.addr</span><br><span class="line">        AND s.machine=<span class="string">'localhost'</span></span><br></pre></td></tr></tbody></table></figure><p>通过上面的<code>spid</code>在oracle服务器上执行<code>netstat -anp |grep spid</code>即可<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[oracle@dwdb trace]$ netstat -anp |grep 17630 </span><br><span class="line">tcp      210      0 192.168.64.228:11095        192.168.21.16:1521          ESTABLISHED 17630/oracleDB </span><br><span class="line">tcp        0      0 ::ffff:192.168.64.228:1521  ::ffff:192.168.64.220:59848 ESTABLISHED 17630/oracleDB</span><br></pre></td></tr></tbody></table></figure><p></p><p>出现两个，说明来自220，连接了228数据库服务器，但是又通过228服务器的dblink去连接了16服务器 </p><h4 id="查询死锁堵塞的会话sid"><a href="#查询死锁堵塞的会话sid" class="headerlink" title="查询死锁堵塞的会话sid"></a>查询死锁堵塞的会话sid</h4><p>最简单的一个SQL<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from V<span class="variable">$SESSION_BLOCKERS</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from dba_waiters</span><br></pre></td></tr></tbody></table></figure><p></p><p>最常用的一个SQL<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT sid,</span><br><span class="line">         status,</span><br><span class="line">         LOGON_TIME,</span><br><span class="line">         sql_id,</span><br><span class="line">         blocking_session <span class="string">"死锁直接源"</span>,</span><br><span class="line">         FINAL_BLOCKING_SESSION <span class="string">"死锁最终源"</span>,</span><br><span class="line">         event,</span><br><span class="line">        seconds_in_wait <span class="string">"会话锁住时间_S"</span>,</span><br><span class="line">         LAST_CALL_ET <span class="string">"会话STATUS持续时间_S"</span></span><br><span class="line">FROM v<span class="variable">$session</span></span><br><span class="line">WHERE state=<span class="string">'WAITING'</span></span><br><span class="line">        AND BLOCKING_SESSION_STATUS=<span class="string">'VALID'</span></span><br><span class="line">        AND FINAL_BLOCKING_SESSION_STATUS=<span class="string">'VALID'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>可以把两者<code>SID</code>放入<code>v$session</code>，发现<code>LOGON_TIME</code>字段<code>FINAL_BLOCKING_SESSION</code>比<code>SID</code>要早 </p><blockquote><p>BLOCKING_SESSION:Session identifier of the blocking session. This column is valid only if BLOCKING_SESSION_STATUS has the value VALID. </p></blockquote><blockquote><p>FINAL_BLOCKING_SESSION:Session identifier of the blocking session. This column is valid only if FINAL_BLOCKING_SESSION_STATUS has the value VALID. </p></blockquote><p>如果遇到<code>RAC环境</code>，一定要用<code>gv$</code>来查，并且执行<code>alter system kill session 'sid,serial#'</code>要到<code>RAC</code>对应的实例上去执行   </p><p>把上面被堵塞会话的<code>sid</code>代入如下语句，可以发现锁住的对象和对象的哪一行(如果<code>sid</code>是堵塞源的会话，则 <code>row_wait_obj#=-1</code>，表示锁持有者，就是死锁源了 )<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">         s.username,</span><br><span class="line">         d.owner,</span><br><span class="line">         d.object_name,</span><br><span class="line">         s.row_wait_obj<span class="comment">#,</span></span><br><span class="line">         s.row_wait_row<span class="comment">#,</span></span><br><span class="line">         s.row_wait_file<span class="comment">#,</span></span><br><span class="line">         s.row_wait_block<span class="comment">#</span></span><br><span class="line">FROM v<span class="variable">$session</span> s, dba_objects d</span><br><span class="line">WHERE s.row_wait_obj<span class="comment"># = d.object_id</span></span><br><span class="line">        AND s.sid <span class="keyword">in</span>(XX,XX)</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查询锁住的DDL对象"><a href="#查询锁住的DDL对象" class="headerlink" title="查询锁住的DDL对象"></a>查询锁住的DDL对象</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT d.session_id,</span><br><span class="line">         s.SERIAL<span class="comment">#,</span></span><br><span class="line">         d.name</span><br><span class="line">FROM dba_ddl_locks d, v<span class="variable">$session</span> s</span><br><span class="line">WHERE d.owner = <span class="string">'MKLMIGEM'</span></span><br><span class="line">        AND d.SESSION_ID=s.sid</span><br></pre></td></tr></tbody></table></figure><h4 id="查询超过两个小时的不活动会话"><a href="#查询超过两个小时的不活动会话" class="headerlink" title="查询超过两个小时的不活动会话"></a>查询超过两个小时的不活动会话</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">         s.serial<span class="comment">#,</span></span><br><span class="line">         p.spid,</span><br><span class="line">         s.LOGON_TIME,</span><br><span class="line">         s.LAST_CALL_ET,</span><br><span class="line">         s.status,</span><br><span class="line">         s.PROGRAM,</span><br><span class="line">         s.CLIENT_IDENTIFIER,</span><br><span class="line">         s.machine,</span><br><span class="line">         s.terminal,</span><br><span class="line">         s.action,</span><br><span class="line">         s.PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         s.osuser</span><br><span class="line">FROM v<span class="variable">$session</span> s, v<span class="variable">$process</span> p</span><br><span class="line">WHERE s.paddr=p.addr</span><br><span class="line">        AND s.sid IN </span><br><span class="line">    (SELECT sid</span><br><span class="line">    FROM v<span class="variable">$session</span></span><br><span class="line">    WHERE machine <> &DB服务器名称</span><br><span class="line">            AND status=<span class="string">'INACTIVE'</span></span><br><span class="line">            AND sql_id is null</span><br><span class="line">            AND LAST_CALL_ET > 7200 )</span><br></pre></td></tr></tbody></table></figure><h4 id="查询堵塞别的会话超过30分钟且自身是不活动的会话"><a href="#查询堵塞别的会话超过30分钟且自身是不活动的会话" class="headerlink" title="查询堵塞别的会话超过30分钟且自身是不活动的会话"></a>查询堵塞别的会话超过30分钟且自身是不活动的会话</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,</span><br><span class="line">        sid,</span><br><span class="line">        serial<span class="comment">#,</span></span><br><span class="line">        status,</span><br><span class="line">        seconds_in_wait,</span><br><span class="line">        LAST_CALL_ET</span><br><span class="line">FROM v<span class="variable">$session</span></span><br><span class="line">WHERE sid IN </span><br><span class="line">    (SELECT FINAL_BLOCKING_SESSION</span><br><span class="line">    FROM v<span class="variable">$session</span></span><br><span class="line">    WHERE state=<span class="string">'WAITING'</span></span><br><span class="line">            AND BLOCKING_SESSION_STATUS=<span class="string">'VALID'</span></span><br><span class="line">            AND FINAL_BLOCKING_SESSION_STATUS=<span class="string">'VALID'</span>)</span><br><span class="line">        AND status=<span class="string">'INACTIVE'</span></span><br><span class="line">        AND sql_id is null</span><br><span class="line">        AND seconds_in_wait>1800</span><br></pre></td></tr></tbody></table></figure><h4 id="查询可能存在连接池空闲初始配置过大的连接（来自同一台机器的同一个程序的状态为INACTIVE的连接非常多）"><a href="#查询可能存在连接池空闲初始配置过大的连接（来自同一台机器的同一个程序的状态为INACTIVE的连接非常多）" class="headerlink" title="查询可能存在连接池空闲初始配置过大的连接（来自同一台机器的同一个程序的状态为INACTIVE的连接非常多）"></a>查询可能存在连接池空闲初始配置过大的连接（来自同一台机器的同一个程序的状态为INACTIVE的连接非常多）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(ss.SID),</span><br><span class="line">        ss.machine,</span><br><span class="line">        ss.status,</span><br><span class="line">        ss.TERMINAL,</span><br><span class="line">        ss.PROGRAM,</span><br><span class="line">        ss.USERNAME,</span><br><span class="line">        ss.CLIENT_IDENTIFIER</span><br><span class="line">FROM v<span class="variable">$session</span> ss</span><br><span class="line">GROUP BY  ss.machine,ss.status,ss.TERMINAL,ss.PROGRAM,ss.USERNAME,ss.CLIENT_IDENTIFIER</span><br><span class="line">HAVING count(ss.SID)>10</span><br></pre></td></tr></tbody></table></figure><h4 id="查询当前正在执行的sql"><a href="#查询当前正在执行的sql" class="headerlink" title="查询当前正在执行的sql"></a>查询当前正在执行的sql</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">        s.serial<span class="comment">#,</span></span><br><span class="line">        s.username,</span><br><span class="line">        spid,</span><br><span class="line">        v<span class="variable">$sql</span>.sql_id,</span><br><span class="line">        machine,</span><br><span class="line">        s.terminal,</span><br><span class="line">        s.program,</span><br><span class="line">        sql_text</span><br><span class="line">FROM v<span class="variable">$process</span>,v<span class="variable">$session</span> s,v<span class="variable">$sql</span></span><br><span class="line">WHERE addr=paddr</span><br><span class="line">        AND s.sql_id=v<span class="variable">$sql</span>.sql_id</span><br><span class="line">        AND sql_hash_value=hash_value</span><br><span class="line">        AND s.STATUS=<span class="string">'ACTIVE'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查询正在执行的SCHEDULER-JOB"><a href="#查询正在执行的SCHEDULER-JOB" class="headerlink" title="查询正在执行的SCHEDULER_JOB"></a>查询正在执行的SCHEDULER_JOB</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT owner,</span><br><span class="line">        job_name,</span><br><span class="line">        sid,</span><br><span class="line">        b.SERIAL<span class="comment">#,</span></span><br><span class="line">        b.username,</span><br><span class="line">        spid</span><br><span class="line">FROM ALL_SCHEDULER_RUNNING_JOBS,v<span class="variable">$session</span> b,v<span class="variable">$process</span></span><br><span class="line">WHERE session_id=sid</span><br><span class="line">        AND paddr=addr</span><br></pre></td></tr></tbody></table></figure><h4 id="查询正在执行的dbms-job"><a href="#查询正在执行的dbms-job" class="headerlink" title="查询正在执行的dbms_job"></a>查询正在执行的dbms_job</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT job,</span><br><span class="line">        b.sid,</span><br><span class="line">        b.SERIAL<span class="comment">#,</span></span><br><span class="line">        b.username,</span><br><span class="line">        spid</span><br><span class="line">FROM DBA_JOBS_RUNNING a ,v<span class="variable">$session</span> b,v<span class="variable">$process</span></span><br><span class="line">WHERE a.sid=b.sid</span><br><span class="line">        AND paddr=addr</span><br></pre></td></tr></tbody></table></figure><h4 id="查询一个会话session、process平均消耗多少PGA内存，查看下面avg-used-M值"><a href="#查询一个会话session、process平均消耗多少PGA内存，查看下面avg-used-M值" class="headerlink" title="查询一个会话session、process平均消耗多少PGA内存，查看下面avg_used_M值"></a>查询一个会话session、process平均消耗多少PGA内存，查看下面avg_used_M值</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT round(sum(pga_used_mem)/1024/1024,</span><br><span class="line">        0) total_used_M,</span><br><span class="line">         round(sum(pga_used_mem)/count(1)/1024/1024,</span><br><span class="line">        0) avg_used_M,</span><br><span class="line">         round(sum(pga_alloc_mem)/1024/1024,</span><br><span class="line">        0) total_alloc_M,</span><br><span class="line">         round(sum(pga_alloc_mem)/count(1)/1024/1024,</span><br><span class="line">        0) avg_alloc_M</span><br><span class="line">FROM v<span class="variable">$process</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="TOP-10-执行次数排序"><a href="#TOP-10-执行次数排序" class="headerlink" title="TOP 10 执行次数排序"></a>TOP 10 执行次数排序</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT executions,</span><br><span class="line">        username,</span><br><span class="line">        PARSING_USER_ID,</span><br><span class="line">        sql_id,</span><br><span class="line">        sql_text</span><br><span class="line">    FROM v<span class="variable">$sql</span>,dba_users</span><br><span class="line">    WHERE user_id=PARSING_USER_ID</span><br><span class="line">    ORDER BY  executions desc)</span><br><span class="line">WHERE rownum <=5;</span><br></pre></td></tr></tbody></table></figure><h4 id="TOP-10-物理读排序（消耗IO排序，即最差性能SQL、低效SQL排序）"><a href="#TOP-10-物理读排序（消耗IO排序，即最差性能SQL、低效SQL排序）" class="headerlink" title="TOP 10 物理读排序（消耗IO排序，即最差性能SQL、低效SQL排序）"></a>TOP 10 物理读排序（消耗IO排序，即最差性能SQL、低效SQL排序）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT DISK_READS,</span><br><span class="line">        username,</span><br><span class="line">        PARSING_USER_ID,</span><br><span class="line">        sql_id,</span><br><span class="line">        ELAPSED_TIME/1000000,</span><br><span class="line">        sql_text</span><br><span class="line">    FROM v<span class="variable">$sql</span>,dba_users</span><br><span class="line">    WHERE user_id=PARSING_USER_ID</span><br><span class="line">    ORDER BY  DISK_READS desc)</span><br><span class="line">WHERE rownum <=5;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：不要使用DISK_READS/ EXECUTIONS来排序，因为任何一条语句不管执行几次都会耗逻辑读和cpu，可能不会耗物理读（遇到LRU还会耗物理读，LRU规则是执行最不频繁的且最后一次执行时间距离现在最久远的就会被交互出buffer cache），是因为buffer cache存放的是数据块，去数据块里找行一定会消耗cpu和逻辑读的。Shared pool执行存放sql的解析结果，sql执行的时候只是去share pool中找hash value，如果有匹配的就是软解析。所以物理读逻辑读是在buffer cache中，软解析硬解析是在shared pool</p></blockquote><h4 id="TOP-10-逻辑读排序（消耗内存排序）"><a href="#TOP-10-逻辑读排序（消耗内存排序）" class="headerlink" title="TOP 10 逻辑读排序（消耗内存排序）"></a>TOP 10 逻辑读排序（消耗内存排序）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT BUFFER_GETS,</span><br><span class="line">        username,</span><br><span class="line">        PARSING_USER_ID,</span><br><span class="line">        sql_id,</span><br><span class="line">        ELAPSED_TIME/1000000,</span><br><span class="line">        sql_text</span><br><span class="line">    FROM v<span class="variable">$sql</span>,dba_users</span><br><span class="line">    WHERE user_id=PARSING_USER_ID</span><br><span class="line">    ORDER BY  BUFFER_GETS desc)</span><br><span class="line">WHERE rownum <=5;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：不要使用BUFFER_GETS/ EXECUTIONS来排序，因为任何一条语句不管执行几次都会耗逻辑读和cpu，可能不会耗物理读（遇到LRU还会耗物理读，LRU规则是执行最不频繁的且最后一次执行时间距离现在最久远的就会被交互出buffer cache），是因为buffer cache存放的是数据块，去数据块里找行一定会消耗cpu和逻辑读的。Shared pool执行存放sql的解析结果，sql执行的时候只是去share pool中找hash value，如果有匹配的就是软解析。所以物理读逻辑读是在buffer cache中，软解析硬解析是在shared pool）</p></blockquote><h4 id="TOP-10-CPU排序-单位秒-cpu-time-1000000"><a href="#TOP-10-CPU排序-单位秒-cpu-time-1000000" class="headerlink" title="TOP 10 CPU排序(单位秒=cpu_time/1000000)"></a>TOP 10 CPU排序(单位秒=cpu_time/1000000)</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT CPU_TIME/1000000,</span><br><span class="line">        username,</span><br><span class="line">        PARSING_USER_ID,</span><br><span class="line">        sql_id,</span><br><span class="line">        ELAPSED_TIME/1000000,</span><br><span class="line">        sql_text</span><br><span class="line">    FROM v<span class="variable">$sql</span>,dba_users</span><br><span class="line">    WHERE user_id=PARSING_USER_ID</span><br><span class="line">    ORDER BY  CPU_TIME/1000000 desc)</span><br><span class="line">WHERE rownum <=5;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：不要使用CPU_TIME/ EXECUTIONS来排序，因为任何一条语句不管执行几次都会耗逻辑读和cpu，可能不会耗物理读（遇到LRU还会耗物理读，LRU规则是执行最不频繁的且最后一次执行时间距离现在最久远的就会被交互出buffer cache），是因为buffer cache存放的是数据块，去数据块里找行一定会消耗cpu和逻辑读的。Shared pool执行存放sql的解析结果，sql执行的时候只是去share pool中找hash value，如果有匹配的就是软解析。所以物理读逻辑读是在buffer cache中，软解析硬解析是在shared pool。</p></blockquote><h4 id="查询等待事件"><a href="#查询等待事件" class="headerlink" title="查询等待事件"></a>查询等待事件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT event,</span><br><span class="line">        sum(decode(wait_time,</span><br><span class="line">        0,</span><br><span class="line">        0,</span><br><span class="line">        1)) <span class="string">"之前等待次数"</span>,</span><br><span class="line">         sum(decode(wait_time,</span><br><span class="line">        0,</span><br><span class="line">        1,</span><br><span class="line">        0)) <span class="string">"正在等待次数"</span>,</span><br><span class="line">        count(*)</span><br><span class="line">FROM v<span class="variable">$session_wait</span></span><br><span class="line">GROUP BY  event</span><br><span class="line">ORDER BY  4 DESC </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 查询当前等待事件对应的对象</span></span><br><span class="line">```bash</span><br><span class="line">SELECT DISTINCT wait_class<span class="comment">#,</span></span><br><span class="line">        wait_class</span><br><span class="line">FROM v<span class="variable">$session_wait_class</span></span><br><span class="line">ORDER BY  1</span><br></pre></td></tr></tbody></table></figure><h4 id="以上sql发现wait-class-6的是空闲等待"><a href="#以上sql发现wait-class-6的是空闲等待" class="headerlink" title="以上sql发现wait_class#=6的是空闲等待"></a>以上sql发现wait_class#=6的是空闲等待</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT sid,</span><br><span class="line">        event,</span><br><span class="line">        p1text,</span><br><span class="line">        p1,</span><br><span class="line">        p2text,</span><br><span class="line">        p2,</span><br><span class="line">        p3text,</span><br><span class="line">        p3,</span><br><span class="line">        WAIT_TIME,</span><br><span class="line">        SECONDS_IN_WAIT,</span><br><span class="line">        wait_class<span class="comment">#</span></span><br><span class="line">    FROM v<span class="variable">$session_wait</span></span><br><span class="line">    WHERE wait_class<span class="comment"># <> 6</span></span><br><span class="line">    ORDER BY  wait_time desc)</span><br><span class="line">WHERE rownum <=10;</span><br></pre></td></tr></tbody></table></figure><h4 id="能查出等待的对象是否来自数据文件（如果以上查到p1text是file-或file-number）"><a href="#能查出等待的对象是否来自数据文件（如果以上查到p1text是file-或file-number）" class="headerlink" title="能查出等待的对象是否来自数据文件（如果以上查到p1text是file#或file number）"></a>能查出等待的对象是否来自数据文件（如果以上查到p1text是file#或file number）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT owner,</span><br><span class="line">        segment_name,</span><br><span class="line">        segment_type,</span><br><span class="line">        block_id,</span><br><span class="line">        bytes</span><br><span class="line">    FROM dba_extents</span><br><span class="line">    WHERE file_id=p1</span><br><span class="line">            AND block_id<p2 order=<span class="string">""</span> by=<span class="string">""</span> block_id=<span class="string">""</span> desc)</span><br><span class="line">WHERE rownum<2</span><br></pre></td></tr></tbody></table></figure><p>把上面第二个sql结果的p1、p2值代入上述sql的file_id、block_id</p><p>通过<code>AWR</code>的<code>top sql</code>或<code>v$sql.sql_text</code>查看是否有该对象的语句，检查该语句的执行计划就可以查出问题所在。</p><h4 id="查询当前正在消耗临时空间的sql语句"><a href="#查询当前正在消耗临时空间的sql语句" class="headerlink" title="查询当前正在消耗临时空间的sql语句"></a>查询当前正在消耗临时空间的sql语句</h4><h5 id="方法一：-2"><a href="#方法一：-2" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT se.username,</span><br><span class="line">         se.sid,</span><br><span class="line">         su.blocks * to_number(rtrim(p.value))/1024/1024 AS space_G,</span><br><span class="line">         su.tablespace,</span><br><span class="line">         sql_text</span><br><span class="line">FROM V<span class="variable">$TEMPSEG_USAGE</span> su, v<span class="variable">$parameter</span> p, v<span class="variable">$session</span> se, v<span class="variable">$sql</span> s</span><br><span class="line">WHERE p.name = <span class="string">'db_block_size'</span></span><br><span class="line">        AND su.session_addr=se.saddr</span><br><span class="line">        AND su.sqlhash=s.hash_value</span><br><span class="line">        AND su.sqladdr=s.address</span><br><span class="line">        AND se.STATUS=<span class="string">'ACTIVE'</span></span><br><span class="line">``` </span><br><span class="line"><span class="comment">##### 方法二：</span></span><br><span class="line">```bash</span><br><span class="line">SELECT v<span class="variable">$sql</span>.sql_id,</span><br><span class="line">        v<span class="variable">$sql</span>.sql_fulltext,</span><br><span class="line">        swa.TEMPSEG_SIZE/1024/1024 TEMPSEG_M,</span><br><span class="line">         swa.*</span><br><span class="line">FROM v<span class="variable">$sql_workarea_active</span> swa,v<span class="variable">$sql</span></span><br><span class="line">WHERE swa.sql_id=v<span class="variable">$sql</span>.sql_id</span><br><span class="line">        AND swa.NUMBER_PASSES>0</span><br></pre></td></tr></tbody></table></figure><h4 id="查询因PGA不足而使用临时表空间的最频繁的10条SQL语句"><a href="#查询因PGA不足而使用临时表空间的最频繁的10条SQL语句" class="headerlink" title="查询因PGA不足而使用临时表空间的最频繁的10条SQL语句"></a>查询因PGA不足而使用临时表空间的最频繁的10条SQL语句</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT OPERATION_TYPE,</span><br><span class="line">        ESTIMATED_OPTIMAL_SIZE,</span><br><span class="line">        ESTIMATED_ONEPASS_SIZE,</span><br><span class="line">         sum(OPTIMAL_EXECUTIONS) optimal_cnt,</span><br><span class="line">        sum(ONEPASS_EXECUTIONS) AS onepass_cnt,</span><br><span class="line">         sum(MULTIPASSES_EXECUTIONS) AS mpass_cnt,</span><br><span class="line">        s.sql_text</span><br><span class="line">    FROM V<span class="variable">$SQL_WORKAREA</span> swa, v<span class="variable">$sql</span> s</span><br><span class="line">    WHERE swa.sql_id=s.sql_id</span><br><span class="line">    GROUP BY  OPERATION_TYPE,ESTIMATED_OPTIMAL_SIZE,ESTIMATED_ONEPASS_SIZE,sql_text</span><br><span class="line">    HAVING sum(ONEPASS_EXECUTIONS+MULTIPASSES_EXECUTIONS)>0</span><br><span class="line">    ORDER BY  sum(ONEPASS_EXECUTIONS) DESC )</span><br><span class="line">WHERE rownum<10</span><br></pre></td></tr></tbody></table></figure><h4 id="查询正在消耗PGA的SQL"><a href="#查询正在消耗PGA的SQL" class="headerlink" title="查询正在消耗PGA的SQL"></a>查询正在消耗PGA的SQL</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sql_text,</span><br><span class="line">         sw.EXPECTED_SIZE,</span><br><span class="line">         sw.ACTUAL_MEM_USED,</span><br><span class="line">        sw.NUMBER_PASSES,</span><br><span class="line">         sw.TEMPSEG_SIZE</span><br><span class="line">FROM v<span class="variable">$sql_workarea_active</span> sw, v<span class="variable">$sql</span> s</span><br><span class="line">WHERE sw.sql_id=s.sql_id;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询需要使用绑定变量的sql，10G以后推荐第二种"><a href="#查询需要使用绑定变量的sql，10G以后推荐第二种" class="headerlink" title="查询需要使用绑定变量的sql，10G以后推荐第二种"></a>查询需要使用绑定变量的sql，10G以后推荐第二种</h4><blockquote><p>注意：任何一条执行过的语句不管执行了几次在V$SQL中都只有一条记录，V$SQL中会记录执行了几次。两条一模一样的语句但是在不同的schema下执行的两种结果，如select <em> from t1.test在sye、system下执行则V$SQL只有一条记录(谁先执行则PARSING_SCHEMA_NAME显示谁)。如在sys和system都执行select </em> from test则V$SQL中有两条记录，两条记录的CHILD_NUMBER和PARSING_SCHEMA_NAME不一样。</p></blockquote><p>同一个用户下执行一样的语句如果大小写不一样或加了hint的话则会出现多个V$SQL记录，说明V$SQL对应的sql语句必须一模一样，如果alter system flush shared_pool（主站慎用）后再执行一样的语句，发现语句在V$SQL中的SQL_ID和HASH_VALUE与之前的一样，说明SQL_ID和HASH_VALUE应该是oracle自己的一套算法来的，只是根据sql语句内容来进行转换，sql语句不变则SQL_ID和HASH_VALUE也不变。</p><h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT count(*),</span><br><span class="line">        sql_id,</span><br><span class="line">         substr(sql_text,</span><br><span class="line">        1,</span><br><span class="line">        40)</span><br><span class="line">    FROM v<span class="variable">$sql</span></span><br><span class="line">    GROUP BY  sql_id, substr(sql_text,1,40)</span><br><span class="line">    HAVING count(*) > 10</span><br><span class="line">    ORDER BY  count(*) desc)</span><br><span class="line">WHERE rownum<10</span><br></pre></td></tr></tbody></table></figure><h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">count(1)>10表示类语句运行了10次以上SELECT sql_id,</span><br><span class="line">         FORCE_MATCHING_SIGNATURE,</span><br><span class="line">         sql_text</span><br><span class="line">FROM v<span class="variable">$SQL</span></span><br><span class="line">WHERE FORCE_MATCHING_SIGNATURE IN </span><br><span class="line">    (SELECT /*+ unnest */ FORCE_MATCHING_SIGNATURE</span><br><span class="line">    FROM v<span class="variable">$sql</span></span><br><span class="line">    WHERE FORCE_MATCHING_SIGNATURE > 0</span><br><span class="line">            AND FORCE_MATCHING_SIGNATURE != EXACT_MATCHING_SIGNATURE</span><br><span class="line">    GROUP BY  FORCE_MATCHING_SIGNATURE</span><br><span class="line">    HAVING count(1) > 10)</span><br></pre></td></tr></tbody></table></figure><h4 id="查看数据文件可用百分比"><a href="#查看数据文件可用百分比" class="headerlink" title="查看数据文件可用百分比"></a>查看数据文件可用百分比</h4><p><code>dba_free_space</code>并不会包含所有<code>file_id</code>，如果该数据文件满了，则 <code>dba_free_space.file_id</code>没有该数据文件，所以以下sql中 <code>a.file_id=b.file_id</code>的条件过滤后是不会有所有file_id的<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.file_id,</span><br><span class="line">        b.tablespace_name,</span><br><span class="line">        b.file_name,</span><br><span class="line">        b.AUTOEXTENSIBLE,</span><br><span class="line">         ROUND(b.MAXBYTES/1024/1024/1024,</span><br><span class="line">        2) ||<span class="string">'G'</span> <span class="string">"文件最大可用总容量"</span>, ROUND(b.bytes/1024/1024/1024,2) ||<span class="string">'G'</span> <span class="string">"文件总容量"</span>, ROUND((b.bytes-sum(nvl(a.bytes,0)))/1024/1024/1024,2)||<span class="string">'G'</span> <span class="string">"文件已用容量"</span>, ROUND(sum(nvl(a.bytes,0))/1024/1024/1024,2)||<span class="string">'G'</span> <span class="string">"文件可用容量"</span>, ROUND(sum(nvl(a.bytes,0))/(b.bytes),2)*100||<span class="string">'%'</span> <span class="string">"文件可用百分比"</span></span><br><span class="line">FROM dba_free_space a,dba_data_files b</span><br><span class="line">WHERE a.file_id=b.file_id</span><br><span class="line">GROUP BY  b.tablespace_name,b.file_name,b.file_id,b.bytes,b.AUTOEXTENSIBLE,b.MAXBYTES</span><br><span class="line">ORDER BY  b.tablespace_name;</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>如下为标准版<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.file_id,</span><br><span class="line">        b.tablespace_name,</span><br><span class="line">        b.file_name,</span><br><span class="line">        b.AUTOEXTENSIBLE,</span><br><span class="line">         ROUND(b.MAXBYTES/1024/1024/1024,</span><br><span class="line">        2) ||<span class="string">'G'</span> <span class="string">"文件最大可用总容量"</span>, ROUND(b.bytes/1024/1024/1024,2) ||<span class="string">'G'</span> <span class="string">"文件当前总容量"</span>, ROUND((b.bytes-sum(nvl(a.bytes,0)))/1024/1024/1024,2)||<span class="string">'G'</span> <span class="string">"文件当前已用容量"</span>, ROUND((decode(AUTOEXTENSIBLE,<span class="string">'NO'</span>,b.BYTES,b.MAXBYTES)+sum(nvl(a.bytes,0))-b.bytes)/1024/1024/1024,2)||<span class="string">'G'</span> <span class="string">"文件可用容量"</span>, ROUND((decode(AUTOEXTENSIBLE,<span class="string">'NO'</span>,b.BYTES,b.MAXBYTES)+sum(nvl(a.bytes,0))-b.bytes)/(decode(AUTOEXTENSIBLE,<span class="string">'NO'</span>,b.BYTES,b.MAXBYTES)),2)*100||<span class="string">'%'</span> <span class="string">"文件可用百分比"</span></span><br><span class="line">FROM dba_free_space a,dba_data_files b</span><br><span class="line">WHERE a.file_id=b.file_id</span><br><span class="line">GROUP BY  b.tablespace_name,b.file_name,b.file_id,b.bytes,b.AUTOEXTENSIBLE,b.MAXBYTES</span><br><span class="line">ORDER BY  decode(AUTOEXTENSIBLE,<span class="string">'NO'</span>,b.BYTES,b.MAXBYTES)+sum(nvl(a.bytes,0))-b.bytes;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="查看数据库文件的实际总量，单位G"><a href="#查看数据库文件的实际总量，单位G" class="headerlink" title="查看数据库文件的实际总量，单位G"></a>查看数据库文件的实际总量，单位G</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.datafile_size+b.tempfile_size-c.free_size</span><br><span class="line">FROM </span><br><span class="line">    (SELECT sum(bytes/1024/1024/1024) datafile_size</span><br><span class="line">    FROM dba_data_files ) a, </span><br><span class="line">    (SELECT sum(bytes/1024/1024/1024) tempfile_size</span><br><span class="line">    FROM dba_temp_files ) b, </span><br><span class="line">    (SELECT sum(bytes/1024/1024/1024) free_size</span><br><span class="line">    FROM dba_free_space ) c</span><br></pre></td></tr></tbody></table></figure><h4 id="查看表空间可用百分比（-dba-free-space不会包含所有tablespace，如果一个表空间的数据文件都满了，则这个表空间不会出现在dba-free-space中-）"><a href="#查看表空间可用百分比（-dba-free-space不会包含所有tablespace，如果一个表空间的数据文件都满了，则这个表空间不会出现在dba-free-space中-）" class="headerlink" title="查看表空间可用百分比（ dba_free_space不会包含所有tablespace，如果一个表空间的数据文件都满了，则这个表空间不会出现在dba_free_space中 ）"></a>查看表空间可用百分比（ dba_free_space不会包含所有tablespace，如果一个表空间的数据文件都满了，则这个表空间不会出现在dba_free_space中 ）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.tablespace_name,</span><br><span class="line">        a.maxsize max_M,</span><br><span class="line">        a.total total_M,</span><br><span class="line">        b.free free_M,</span><br><span class="line">        round((b.free/a.total)*100) <span class="string">"% Free"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         sum(bytes/(1024*1024)) total ,</span><br><span class="line">        sum(MAXBYTES/(1024*1024)) maxsize</span><br><span class="line">    FROM dba_data_files</span><br><span class="line">    GROUP BY  tablespace_name) a, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         round(sum(bytes/(1024*1024))) free</span><br><span class="line">    FROM dba_free_space</span><br><span class="line">    GROUP BY  tablespace_name) b</span><br><span class="line">WHERE a.tablespace_name = b.tablespace_name</span><br><span class="line">ORDER BY  <span class="string">"% Free"</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如下为标准版 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.tablespace_name,</span><br><span class="line">        a.maxsize max_M,</span><br><span class="line">        a.total total_M,</span><br><span class="line">        b.free free_M,</span><br><span class="line">        round(((a.maxsize+b.free-a.total)/a.maxsize)*100) <span class="string">"% Free"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         sum(bytes/(1024*1024)) total ,</span><br><span class="line">        sum((decode(AUTOEXTENSIBLE,</span><br><span class="line">        <span class="string">'NO'</span>,BYTES,MAXBYTES))/(1024*1024)) maxsize</span><br><span class="line">    FROM dba_data_files</span><br><span class="line">    GROUP BY  tablespace_name) a, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         round(sum(bytes/(1024*1024))) free</span><br><span class="line">    FROM dba_free_space</span><br><span class="line">    GROUP BY  tablespace_name) b</span><br><span class="line">WHERE a.tablespace_name = b.tablespace_name</span><br><span class="line">ORDER BY  <span class="string">"% Free"</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="查看临时表空间使用率"><a href="#查看临时表空间使用率" class="headerlink" title="查看临时表空间使用率"></a>查看临时表空间使用率</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT temp_used.tablespace_name,</span><br><span class="line">        round(total),</span><br><span class="line">        used,</span><br><span class="line">         round(total - used) AS <span class="string">"Free"</span>,</span><br><span class="line">         round(nvl(total-used,</span><br><span class="line">         0) * 100/total,</span><br><span class="line">        1) <span class="string">"Free percent"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         SUM(bytes_used)/1024/1024 used</span><br><span class="line">    FROM GV<span class="variable">$TEMP_SPACE_HEADER</span></span><br><span class="line">    GROUP BY  tablespace_name) temp_used, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         SUM(decode(autoextensible,</span><br><span class="line">        <span class="string">'YES'</span>,MAXBYTES,bytes))/1024/1024 total</span><br><span class="line">    FROM dba_temp_files</span><br><span class="line">    GROUP BY  tablespace_name) temp_total</span><br><span class="line">WHERE temp_used.tablespace_name = temp_total.tablespace_name</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.tablespace_name,</span><br><span class="line">         round(a.BYTES/1024/1024) total_M,</span><br><span class="line">         round(a.bytes/1024/1024 - nvl(b.bytes/1024/1024,</span><br><span class="line">         0)) free_M,</span><br><span class="line">         round(b.bytes/1024/1024) used,</span><br><span class="line">        round(b.using/1024/1024) using</span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         SUM (decode(autoextensible,</span><br><span class="line">        <span class="string">'YES'</span>,MAXBYTES,bytes)) bytes</span><br><span class="line">    FROM dba_temp_files</span><br><span class="line">    GROUP BY  tablespace_name) a, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         SUM (bytes_cached) bytes,</span><br><span class="line">        sum(bytes_used) using</span><br><span class="line">    FROM v<span class="variable">$temp_extent_pool</span></span><br><span class="line">    GROUP BY  tablespace_name) b</span><br><span class="line">WHERE a.tablespace_name = b.tablespace_name(+)</span><br></pre></td></tr></tbody></table></figure><h4 id="查询undo表空间使用情况"><a href="#查询undo表空间使用情况" class="headerlink" title="查询undo表空间使用情况"></a>查询undo表空间使用情况</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT tablespace_name,</span><br><span class="line">        status,</span><br><span class="line">        sum(bytes)/1024/1024 M</span><br><span class="line">FROM dba_undo_extents</span><br><span class="line">GROUP BY  tablespace_name,status</span><br></pre></td></tr></tbody></table></figure><h4 id="查询使用undo比较多的SQL"><a href="#查询使用undo比较多的SQL" class="headerlink" title="查询使用undo比较多的SQL"></a>查询使用undo比较多的SQL</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT *from </span><br><span class="line">    (SELECT maxqueryid,</span><br><span class="line">         round(sum(undoblks )*8/1024) consumed_size_MB</span><br><span class="line">    FROM v<span class="variable">$undostat</span></span><br><span class="line">    GROUP BY  maxqueryid</span><br><span class="line">    ORDER BY  consumed_size_MB DESC )</span><br><span class="line">WHERE rownum<10;</span><br></pre></td></tr></tbody></table></figure><h4 id="估计undo需要多大"><a href="#估计undo需要多大" class="headerlink" title="估计undo需要多大"></a>估计undo需要多大</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT (UR * (UPS * DBS)) AS <span class="string">"Bytes"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT max(tuned_undoretention) AS UR</span><br><span class="line">    FROM v<span class="variable">$undostat</span>), </span><br><span class="line">    (SELECT undoblks/((end_time-begin_time)*86400) AS UPS</span><br><span class="line">    FROM v<span class="variable">$undostat</span></span><br><span class="line">    WHERE undoblks = </span><br><span class="line">        (SELECT MAX(undoblks)</span><br><span class="line">        FROM v<span class="variable">$undostat</span>)), </span><br><span class="line">        (SELECT block_size AS DBS</span><br><span class="line">        FROM dba_tablespaces</span><br><span class="line">        WHERE tablespace_name = </span><br><span class="line">            (SELECT UPPER(value)</span><br><span class="line">            FROM v<span class="variable">$parameter</span></span><br><span class="line">            WHERE name = <span class="string">'undo_tablespace'</span>));</span><br></pre></td></tr></tbody></table></figure><h4 id="产生undo的当前活动会话是哪些"><a href="#产生undo的当前活动会话是哪些" class="headerlink" title="产生undo的当前活动会话是哪些"></a>产生undo的当前活动会话是哪些</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.inst_id,</span><br><span class="line">         a.sid,</span><br><span class="line">         c.username,</span><br><span class="line">         c.osuser,</span><br><span class="line">         c.program,</span><br><span class="line">         b.name,</span><br><span class="line">         a.value,</span><br><span class="line">         d.used_urec,</span><br><span class="line">         d.used_ublk</span><br><span class="line">FROM gv<span class="variable">$sesstat</span> a, v<span class="variable">$statname</span> b, gv<span class="variable">$session</span> c, gv<span class="variable">$transaction</span> d</span><br><span class="line">WHERE a.statistic<span class="comment"># = b.statistic#</span></span><br><span class="line">        AND a.inst_id = c.inst_id</span><br><span class="line">        AND a.sid = c.sid</span><br><span class="line">        AND c.inst_id = d.inst_id</span><br><span class="line">        AND c.saddr = d.ses_addr</span><br><span class="line">        AND b.name = <span class="string">'undo change vector size'</span></span><br><span class="line">        AND a.value>0</span><br><span class="line">ORDER BY  a.value DESC</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">        s.serial<span class="comment">#,</span></span><br><span class="line">        s.sql_id,</span><br><span class="line">        v.usn,</span><br><span class="line">        r.status,</span><br><span class="line">         v.rssize/1024/1024 mb</span><br><span class="line">FROM dba_rollback_segs r, v<span class="variable">$rollstat</span> v,v<span class="variable">$transaction</span> t,v<span class="variable">$session</span> s</span><br><span class="line">WHERE r.segment_id = v.usn</span><br><span class="line">        AND v.usn=t.xidusn</span><br><span class="line">        AND t.addr=s.taddr</span><br><span class="line">ORDER BY  6 desc;</span><br></pre></td></tr></tbody></table></figure><h4 id="查看ASM磁盘组使用率"><a href="#查看ASM磁盘组使用率" class="headerlink" title="查看ASM磁盘组使用率"></a>查看ASM磁盘组使用率</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line">        round(total_mb/1024) <span class="string">"总容量"</span>,</span><br><span class="line">        round(free_mb/1024) <span class="string">"空闲空间"</span>,</span><br><span class="line">        round((free_mb/total_mb)*100) <span class="string">"可用空间比例"</span></span><br><span class="line">FROM gv<span class="variable">$asm_diskgroup</span></span><br></pre></td></tr></tbody></table></figure><h4 id="统计每个用户使用表空间率"><a href="#统计每个用户使用表空间率" class="headerlink" title="统计每个用户使用表空间率"></a>统计每个用户使用表空间率</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.owner <span class="string">"用户"</span>,</span><br><span class="line">         a.tablespace_name <span class="string">"表空间名"</span>,</span><br><span class="line">         total/1024/1024 <span class="string">"表空间大小M"</span>,</span><br><span class="line">         free/1024/1024 <span class="string">"表空间剩余大小M"</span>,</span><br><span class="line">         ( total - free )/1024/1024 <span class="string">"表空间使用大小M"</span>,</span><br><span class="line">         Round(( total - free ) / total,</span><br><span class="line">         4) * 100 <span class="string">"表空间总计使用率 %"</span>,</span><br><span class="line">         c.schemas_use/1024/1024 <span class="string">"用户使用表空间大小M"</span>,</span><br><span class="line">         round((schemas_use)/total,</span><br><span class="line">        4)*100 <span class="string">"用户使用表空间率 %"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         Sum(bytes) free</span><br><span class="line">    FROM DBA_FREE_SPACE</span><br><span class="line">    GROUP BY  tablespace_name) a, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         Sum(bytes) total</span><br><span class="line">    FROM DBA_DATA_FILES</span><br><span class="line">    GROUP BY  tablespace_name) b, </span><br><span class="line">    (SELECT owner ,</span><br><span class="line">        Tablespace_Name,</span><br><span class="line">         Sum(bytes) schemas_use</span><br><span class="line">    FROM Dba_Segments</span><br><span class="line">    GROUP BY  owner,Tablespace_Name) c</span><br><span class="line">WHERE a.tablespace_name = b.tablespace_name</span><br><span class="line">        AND a.tablespace_name =c.Tablespace_Name</span><br><span class="line">ORDER BY  <span class="string">"用户"</span>,<span class="string">"表空间名"</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查看闪回区-快速恢复区空间使用率"><a href="#查看闪回区-快速恢复区空间使用率" class="headerlink" title="查看闪回区\快速恢复区空间使用率"></a>查看闪回区\快速恢复区空间使用率</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT sum(percent_space_used)||<span class="string">'%'</span> <span class="string">"已使用空间比例"</span></span><br><span class="line">FROM V<span class="variable">$RECOVERY_AREA_USAGE</span> </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">SELECT round(100*(a.space_used/space_limit),</span><br><span class="line">        2)||<span class="string">'%'</span> <span class="string">"已使用空间比例"</span>,a.*</span><br><span class="line">FROM v<span class="variable">$recovery_file_dest</span> a;</span><br></pre></td></tr></tbody></table></figure><h4 id="查看僵死进程，分两种（一种是会话不在的，另一种是会话标记为killed的但是会话还在的）"><a href="#查看僵死进程，分两种（一种是会话不在的，另一种是会话标记为killed的但是会话还在的）" class="headerlink" title="查看僵死进程，分两种（一种是会话不在的，另一种是会话标记为killed的但是会话还在的）"></a>查看僵死进程，分两种（一种是会话不在的，另一种是会话标记为killed的但是会话还在的）</h4><p><code>alter system kill session</code>一执行则<code>session</code>即标记为<code>KILLED</code>，但是如果会话产生的数据量大则这个kill可能会比较久，在这个过程中session标记为KILLED但是这个会话还在<code>V$session</code>中，则<code>V$session.paddr</code>还在，所以可以匹配到<code>V$process.addr</code>，所以process进程还在；当kill过程执行完毕，则这个会话即不在<code>V$session</code>中</p><h5 id="会话不在的"><a href="#会话不在的" class="headerlink" title="会话不在的"></a>会话不在的</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM v<span class="variable">$process</span></span><br><span class="line">WHERE addr NOT IN </span><br><span class="line">    (SELECT paddr</span><br><span class="line">    FROM v<span class="variable">$session</span>)</span><br><span class="line">        AND pid NOT IN (1,17,18)</span><br></pre></td></tr></tbody></table></figure><h5 id="会话还在的，但是会话标记为killed"><a href="#会话还在的，但是会话标记为killed" class="headerlink" title="会话还在的，但是会话标记为killed"></a>会话还在的，但是会话标记为killed</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM v<span class="variable">$process</span></span><br><span class="line">WHERE addr IN </span><br><span class="line">    (SELECT paddr</span><br><span class="line">    FROM v<span class="variable">$session</span></span><br><span class="line">    WHERE status=<span class="string">'KILLED'</span>)</span><br></pre></td></tr></tbody></table></figure><p>再根据上述结果中的SPID通过如下命令可以查看到process的启动时间<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|head -1;ps auxw|grep SPID</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查看行迁移或行链接的表"><a href="#查看行迁移或行链接的表" class="headerlink" title="查看行迁移或行链接的表"></a>查看行迁移或行链接的表</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_tables</span><br><span class="line">WHERE nvl(chain_cnt,0)<>0 chain_cnt ：Number of rows IN the table that are chained</span><br><span class="line">FROM one data block to another</span><br><span class="line">        OR that have migrated to a new block, requiring a link to preserve the old rowid. This column is updated only after you analyze the table.</span><br></pre></td></tr></tbody></table></figure><h4 id="数据缓冲区命中率（百分比小于90就要加大db-cache-size）"><a href="#数据缓冲区命中率（百分比小于90就要加大db-cache-size）" class="headerlink" title="数据缓冲区命中率（百分比小于90就要加大db_cache_size）"></a>数据缓冲区命中率（百分比小于90就要加大db_cache_size）</h4><h5 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.VALUE+b.VALUE logical_reads,</span><br><span class="line">         c.VALUE phys_reads,</span><br><span class="line">         round(100*(1-c.value/(a.value+b.value)),</span><br><span class="line">        2)||<span class="string">'%'</span> hit_ratio</span><br><span class="line">FROM v<span class="variable">$sysstat</span> a,v<span class="variable">$sysstat</span> b,v<span class="variable">$sysstat</span> c</span><br><span class="line">WHERE a.NAME=<span class="string">'db block gets'</span></span><br><span class="line">        AND b.NAME=<span class="string">'consistent gets'</span></span><br><span class="line">        AND c.NAME=<span class="string">'physical reads'</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DB_BLOCK_GETS+CONSISTENT_GETS Logical_reads,</span><br><span class="line">        PHYSICAL_READS phys_reads,</span><br><span class="line">         round(100*(1-(PHYSICAL_READS/(DB_BLOCK_GETS+CONSISTENT_GETS))),</span><br><span class="line">        2)||<span class="string">'%'</span> <span class="string">"Hit Ratio"</span></span><br><span class="line">FROM V<span class="variable">$BUFFER_POOL_STATISTICS</span></span><br><span class="line">WHERE NAME=<span class="string">'DEFAULT'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="共享池命中率（百分比小于90就要加大shared-pool-size）"><a href="#共享池命中率（百分比小于90就要加大shared-pool-size）" class="headerlink" title="共享池命中率（百分比小于90就要加大shared_pool_size）"></a>共享池命中率（百分比小于90就要加大shared_pool_size）</h4><p>以下两者可以根据个人理解运用<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT sum(pinhits)/sum(pins)*100</span><br><span class="line">FROM v<span class="variable">$librarycache</span>;</span><br><span class="line"></span><br><span class="line">SELECT sum(pinhits-reloads)/sum(pins)*100</span><br><span class="line">FROM v<span class="variable">$librarycache</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查询归档日志切换频率"><a href="#查询归档日志切换频率" class="headerlink" title="查询归档日志切换频率"></a>查询归档日志切换频率</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SELECT sequence<span class="comment">#,</span></span><br><span class="line">        to_char(first_time,</span><br><span class="line">        <span class="string">'yyyymmdd_hh24:mi:ss'</span>) firsttime,round((first_time-lag(first_time) over(order by first_time))*24*60,2) minutes</span><br><span class="line">FROM v<span class="variable">$log_history</span></span><br><span class="line">WHERE first_time > sysdate - 3</span><br><span class="line">ORDER BY  first_time,</span><br><span class="line">        minutes; </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">SELECT sequence<span class="comment">#,</span></span><br><span class="line">        to_char(first_time,</span><br><span class="line">        <span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) First_time,First_change<span class="comment">#,switch_change#</span></span><br><span class="line">FROM v<span class="variable">$loghist</span></span><br><span class="line">WHERE first_time>sysdate-3</span><br><span class="line">ORDER BY  1;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">SELECT TO_CHAR(first_time,</span><br><span class="line">         <span class="string">'MM/DD'</span>) DAY, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'00'</span>, 1, 0)) H00, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'01'</span>, 1, 0)) H01, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'02'</span>, 1, 0)) H02, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'03'</span>, 1, 0)) H03, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'04'</span>, 1, 0)) H04, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'05'</span>, 1, 0)) H05, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'06'</span>, 1, 0)) H06, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'07'</span>, 1, 0)) H07, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'08'</span>, 1, 0)) H08, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'09'</span>, 1, 0)) H09, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'10'</span>, 1, 0)) H10, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'11'</span>, 1, 0)) H11, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'12'</span>, 1, 0)) H12, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'13'</span>, 1, 0)) H13, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'14'</span>, 1, 0)) H14, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'15'</span>, 1, 0)) H15, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'16'</span>, 1, 0)) H16, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'17'</span>, 1, 0)) H17, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'18'</span>, 1, 0)) H18, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'19'</span>, 1, 0)) H19, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'20'</span>, 1, 0)) H20, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'21'</span>, 1, 0)) H21, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'22'</span>, 1, 0)) H22, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'23'</span>, 1, 0)) H23, COUNT(*) TOTAL</span><br><span class="line">FROM </span><br><span class="line">    (SELECT ROWNUM RN,</span><br><span class="line">         FIRST_TIME</span><br><span class="line">    FROM V<span class="variable">$LOG_HISTORY</span></span><br><span class="line">    WHERE first_time>sysdate-18</span><br><span class="line">            AND FIRST_TIME>ADD_MONTHS(SYSDATE,-1)</span><br><span class="line">    ORDER BY  FIRST_TIME)</span><br><span class="line">GROUP BY  TO_CHAR(first_time, <span class="string">'MM/DD'</span>)</span><br><span class="line">ORDER BY  MIN(RN);</span><br></pre></td></tr></tbody></table></figure><h4 id="查询lgwr进程写日志时每执行一次lgwr需要多少秒，在state是waiting的情况下，某个等待编号seq-下，seconds-in-wait达多少秒，就是lgwr进程写一次IO需要多少秒"><a href="#查询lgwr进程写日志时每执行一次lgwr需要多少秒，在state是waiting的情况下，某个等待编号seq-下，seconds-in-wait达多少秒，就是lgwr进程写一次IO需要多少秒" class="headerlink" title="查询lgwr进程写日志时每执行一次lgwr需要多少秒，在state是waiting的情况下，某个等待编号seq#下，seconds_in_wait达多少秒，就是lgwr进程写一次IO需要多少秒"></a>查询lgwr进程写日志时每执行一次lgwr需要多少秒，在state是waiting的情况下，某个等待编号seq#下，seconds_in_wait达多少秒，就是lgwr进程写一次IO需要多少秒</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT event,</span><br><span class="line">        state,</span><br><span class="line">        seq<span class="comment">#,</span></span><br><span class="line">        seconds_in_wait,</span><br><span class="line">        program</span><br><span class="line">FROM v<span class="variable">$session</span></span><br><span class="line">WHERE program LIKE <span class="string">'%LGWR%'</span></span><br><span class="line">        AND state=<span class="string">'WAITING'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查询没有索引的表"><a href="#查询没有索引的表" class="headerlink" title="查询没有索引的表"></a>查询没有索引的表</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT table_name</span><br><span class="line">FROM user_tables</span><br><span class="line">WHERE table_name NOT IN </span><br><span class="line">    (SELECT table_name</span><br><span class="line">    FROM user_indexes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT table_name</span><br><span class="line">FROM user_tables</span><br><span class="line">WHERE table_name NOT IN </span><br><span class="line">    (SELECT table_name</span><br><span class="line">    FROM user_ind_columns)</span><br></pre></td></tr></tbody></table></figure><h4 id="查询一个AWR周期内的平均session数、OS平均负载、平均db-time、平均每秒多少事务"><a href="#查询一个AWR周期内的平均session数、OS平均负载、平均db-time、平均每秒多少事务" class="headerlink" title="查询一个AWR周期内的平均session数、OS平均负载、平均db time、平均每秒多少事务"></a>查询一个AWR周期内的平均session数、OS平均负载、平均db time、平均每秒多少事务</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT to_char(max(BEGIN_TIME),</span><br><span class="line">        <span class="string">'yyyy-mm-dd hh24:mi'</span>)||to_char(max(end_time),<span class="string">'* hh24:mi'</span>) time, snap_id, trunc(sum(<span class="keyword">case</span> metric_name</span><br><span class="line">    WHEN <span class="string">'Session Count'</span> THEN</span><br><span class="line">    average end),2) sessions, trunc(sum(<span class="keyword">case</span> metric_name</span><br><span class="line">    WHEN <span class="string">'Current OS Load'</span> THEN</span><br><span class="line">    average end),2) OS_LOAD, (trunc(sum(<span class="keyword">case</span> metric_name</span><br><span class="line">    WHEN <span class="string">'Database Time Per Sec'</span> THEN</span><br><span class="line">    average end),2)/100)*(ceil((max(end_time)-max(BEGIN_TIME))*24*60*60)) Database_Time_second, trunc(sum(<span class="keyword">case</span> metric_name</span><br><span class="line">    WHEN <span class="string">'User Transaction Per Sec'</span> THEN</span><br><span class="line">    average end),2) User_Transaction_Per_Sec</span><br><span class="line">FROM dba_hist_sysmetric_summary</span><br><span class="line">GROUP BY  snap_id</span><br><span class="line">ORDER BY  snap_id;</span><br></pre></td></tr></tbody></table></figure><ul><li>Database Time Per Sec对应值的单位是百分一秒/每秒 </li><li>(/100)<em>(ceil((max(end_time)-max(BEGIN_TIME))</em>24<em>60</em>60))是代表每个snap周期内的总秒数，oracle 两个时间相减默认的是天数,<em>24</em>60*60 为相差的秒数 </li><li>这个SQL查到的DB TIME比较准确，和awr上面的db time比较一致 </li></ul><h4 id="查询产生热块较多的对象"><a href="#查询产生热块较多的对象" class="headerlink" title="查询产生热块较多的对象"></a>查询产生热块较多的对象</h4><p>x$bh .tch(Touch)表示访问次数越高，热点快竞争问题就存在<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.owner,</span><br><span class="line">         e.segment_name,</span><br><span class="line">         e.segment_type</span><br><span class="line">FROM dba_extents e, </span><br><span class="line">    (SELECT *</span><br><span class="line">    FROM </span><br><span class="line">        (SELECT addr,</span><br><span class="line">        ts<span class="comment">#,</span></span><br><span class="line">        file<span class="comment">#,</span></span><br><span class="line">        dbarfil,</span><br><span class="line">        dbablk,</span><br><span class="line">        tch</span><br><span class="line">        FROM x<span class="variable">$bh</span></span><br><span class="line">        ORDER BY  tch DESC)</span><br><span class="line">        WHERE ROWNUM < 11) b</span><br><span class="line">    WHERE e.relative_fno = b.dbarfil</span><br><span class="line">        AND e.block_id <= b.dbablk</span><br><span class="line">        AND e.block_id + e.blocks > b.dbablk;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="手工创建快照的语句"><a href="#手工创建快照的语句" class="headerlink" title="手工创建快照的语句"></a>手工创建快照的语句</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> dbms_workload_repository.create_snapshot;</span><br></pre></td></tr></tbody></table></figure><h4 id="AWR设置每隔30分钟收集一次报告，保留14天的报告"><a href="#AWR设置每隔30分钟收集一次报告，保留14天的报告" class="headerlink" title="AWR设置每隔30分钟收集一次报告，保留14天的报告"></a>AWR设置每隔30分钟收集一次报告，保留14天的报告</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> DBMS_WORKLOAD_REPOSITORY.MODIFY_SNAPSHOT_SETTINGS(retention=>14*24*60, interval=>30); </span><br><span class="line"></span><br><span class="line">select * from dba_hist_wr_control;</span><br></pre></td></tr></tbody></table></figure><h4 id="AWR基线查看和创建"><a href="#AWR基线查看和创建" class="headerlink" title="AWR基线查看和创建"></a>AWR基线查看和创建</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from dba_hist_baseline; </span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> DBMS_WORKLOAD_REPOSITORY.CREATE_BASELINE(start_snap_id=>7550,end_snap_id=>7660,baseline_name=><span class="string">'am_baseline'</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="导出AWR报告的SQL语句"><a href="#导出AWR报告的SQL语句" class="headerlink" title="导出AWR报告的SQL语句"></a>导出AWR报告的SQL语句</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_hist_snapshot</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM table(dbms_workload_repository.awr_report_html(DBID, INSTANCE_NUMBER, startsnapid,endsnapid))</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM TABLE(DBMS_WORKLOAD_REPOSITORY.awr_diff_report_html(DBID, INSTANCE_NUMBER, startsnapid,endsnapid, DBID, INSTANCE_NUMBER, startsnapid,endsnapid));</span><br></pre></td></tr></tbody></table></figure><h4 id="导出最新ADDM的报告（需要sys用户）"><a href="#导出最新ADDM的报告（需要sys用户）" class="headerlink" title="导出最新ADDM的报告（需要sys用户）"></a>导出最新ADDM的报告（需要sys用户）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT dbms_advisor.get_task_report(task_name)</span><br><span class="line">FROM dba_advisor_tasks</span><br><span class="line">WHERE task_id =</span><br><span class="line">    (SELECT max(t.task_id)</span><br><span class="line">    FROM dba_advisor_tasks t, dba_advisor_log l</span><br><span class="line">    WHERE t.task_id=l.task_id</span><br><span class="line">            AND t.advisor_name=<span class="string">'ADDM'</span></span><br><span class="line">            AND l.status=<span class="string">'COMPLETED'</span> );SELECT task_id,</span><br><span class="line">        task_name,</span><br><span class="line">        description</span><br><span class="line">FROM dba_advisor_tasks</span><br><span class="line">ORDER BY  1 DESCSELECT dbms_advisor.get_task_report(task_name)</span><br><span class="line">FROM dba_advisor_tasks</span><br><span class="line">WHERE task_id =XX</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某个SQL的执行计划"><a href="#查询某个SQL的执行计划" class="headerlink" title="查询某个SQL的执行计划"></a>查询某个SQL的执行计划</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table(dbms_xplan.display_cursor(<span class="string">'sql_id'</span>,0,<span class="string">' advanced '</span>));</span><br></pre></td></tr></tbody></table></figure><p>上面的0表示<code>v$sql.child_number</code>为0，如果一个sql_id在v$sql中有多行说明有多个child_number，要看哪儿child_number的执行计划，就写哪个的值，比如要看child_number为2的执行计划，就把上面sql的0改为2 。</p><h4 id="官方文档对display-cursor这个函数的说明里面没有advanced这个参数值，只有BASIC、TYPICAL、ALL这几个，不过实践中发现advanced这个参数值显示的内容比这几个参数值显示的都多。"><a href="#官方文档对display-cursor这个函数的说明里面没有advanced这个参数值，只有BASIC、TYPICAL、ALL这几个，不过实践中发现advanced这个参数值显示的内容比这几个参数值显示的都多。" class="headerlink" title="官方文档对display_cursor这个函数的说明里面没有advanced这个参数值，只有BASIC、TYPICAL、ALL这几个，不过实践中发现advanced这个参数值显示的内容比这几个参数值显示的都多。"></a>官方文档对display_cursor这个函数的说明里面没有advanced这个参数值，只有BASIC、TYPICAL、ALL这几个，不过实践中发现advanced这个参数值显示的内容比这几个参数值显示的都多。</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table(xplan.display_cursor(<span class="string">'v$sql.sql_id'</span>,0,<span class="string">'advanced'</span>));</span><br></pre></td></tr></tbody></table></figure><h4 id="创建xplan包，再执行"><a href="#创建xplan包，再执行" class="headerlink" title="创建xplan包，再执行"></a>创建xplan包，再执行</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL> CREATE PUBLIC SYNONYM XPLAN FOR SYS.XPLAN; </span><br><span class="line">SQL> grant execute on sys.xplan to public;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询Rman的配置信息"><a href="#查询Rman的配置信息" class="headerlink" title="查询Rman的配置信息"></a>查询Rman的配置信息</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT NAME,</span><br><span class="line">        VALUE</span><br><span class="line">FROM V<span class="variable">$RMAN_CONFIGURATION</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询Rman备份集详细信息（未过期的，过期并已删除的查不到）"><a href="#查询Rman备份集详细信息（未过期的，过期并已删除的查不到）" class="headerlink" title="查询Rman备份集详细信息（未过期的，过期并已删除的查不到）"></a>查询Rman备份集详细信息（未过期的，过期并已删除的查不到）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT B.RECID BackupSet_ID,</span><br><span class="line">        </span><br><span class="line">         A.SET_STAMP,</span><br><span class="line">        </span><br><span class="line">         DECODE (B.INCREMENTAL_LEVEL,</span><br><span class="line">        </span><br><span class="line">         <span class="string">''</span>, DECODE (BACKUP_TYPE, <span class="string">'L'</span>, <span class="string">'Archivelog'</span>, <span class="string">'Full'</span>), 1, <span class="string">'Incr-1级'</span>, 0, <span class="string">'Incr-0级'</span>, B.INCREMENTAL_LEVEL) <span class="string">"Type LV"</span>, B.CONTROLFILE_INCLUDED <span class="string">"包含CTL"</span>, DECODE (A.STATUS, <span class="string">'A'</span>, <span class="string">'AVAILABLE'</span>, <span class="string">'D'</span>, <span class="string">'DELETED'</span>, <span class="string">'X'</span>, <span class="string">'EXPIRED'</span>, <span class="string">'ERROR'</span>) <span class="string">"STATUS"</span>, A.DEVICE_TYPE <span class="string">"Device Type"</span>, A.START_TIME <span class="string">"Start Time"</span>, A.COMPLETION_TIME <span class="string">"Completion Time"</span>, A.ELAPSED_SECONDS <span class="string">"Elapsed Seconds"</span>, A.BYTES/1024/1024/1024 <span class="string">"Size(G)"</span>, A.COMPRESSED, A.TAG <span class="string">"Tag"</span>, A.HANDLE <span class="string">"Path"</span></span><br><span class="line">FROM GV<span class="variable">$BACKUP_PIECE</span> A,</span><br><span class="line">         GV<span class="variable">$BACKUP_SET</span> B</span><br><span class="line">WHERE A.SET_STAMP = B.SET_STAMP</span><br><span class="line">        AND A.DELETED = <span class="string">'NO'</span></span><br><span class="line">ORDER BY  A.COMPLETION_TIME DESC;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询Rman备份进度"><a href="#查询Rman备份进度" class="headerlink" title="查询Rman备份进度"></a>查询Rman备份进度</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT SID,</span><br><span class="line">         SERIAL<span class="comment">#,</span></span><br><span class="line">         opname,</span><br><span class="line">        ROUND(SOFAR/TOTALWORK*100)||<span class="string">'%'</span> <span class="string">"%_COMPLETE"</span>, TRUNC(elapsed_seconds/60) || <span class="string">':'</span> || MOD(elapsed_seconds,60) elapsed, TRUNC(time_remaining/60) || <span class="string">':'</span> || MOD(time_remaining,60) remaining, CONTEXT,target,SOFAR, TOTALWORK</span><br><span class="line">FROM V<span class="variable">$SESSION_LONGOPS</span></span><br><span class="line">WHERE OPNAME LIKE <span class="string">'RMAN%'</span></span><br><span class="line">        AND OPNAME NOT LIKE <span class="string">'%aggregate%'</span></span><br><span class="line">        AND TOTALWORK != 0</span><br><span class="line">        AND SOFAR <> TOTALWORK;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询执行过全表扫描的sql语句的SQL-ID和sql-fulltext"><a href="#查询执行过全表扫描的sql语句的SQL-ID和sql-fulltext" class="headerlink" title="查询执行过全表扫描的sql语句的SQL_ID和sql_fulltext"></a>查询执行过全表扫描的sql语句的SQL_ID和sql_fulltext</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">        s.serial<span class="comment">#,</span></span><br><span class="line">        s.inst_id,</span><br><span class="line">        s.sql_id,</span><br><span class="line">        s.username,</span><br><span class="line">        s.target,</span><br><span class="line">        s.ELAPSED_SECONDS,</span><br><span class="line">        s.START_TIME,</span><br><span class="line">        s.LAST_UPDATE_TIME,</span><br><span class="line">        v.sql_fulltext</span><br><span class="line">FROM gv<span class="variable">$session_longops</span> s,gv<span class="variable">$sql</span> v</span><br><span class="line">WHERE s.OPNAME = <span class="string">'Table Scan'</span></span><br><span class="line">        AND s.SQL_PLAN_OPERATION = <span class="string">'TABLE ACCESS'</span></span><br><span class="line">        AND s.SQL_PLAN_OPTIONS = <span class="string">'FULL'</span></span><br><span class="line">        AND s.sql_id=v.sql_id</span><br><span class="line">ORDER BY  s.LAST_UPDATE_TIME DESC</span><br></pre></td></tr></tbody></table></figure><h4 id="查询死事务需要多长的回滚时间"><a href="#查询死事务需要多长的回滚时间" class="headerlink" title="查询死事务需要多长的回滚时间"></a>查询死事务需要多长的回滚时间</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="variable">$KTUXE</span>：[K]ernel [T]ransaction [U]ndo Transa[x]tion [E]ntry (table)`</span><br></pre></td></tr></tbody></table></figure><p><code>X$KTUXE</code>表的一个重要功能是，可以获得无法通过<code>v$transaction</code>来观察的死事务信息，当一个数据库发生异常中断，或者进行延迟事务恢复时，数据库启动后，无法通过V$TRANSACTION来观察事务信息，但是<code>X$KTUXE</code>可以帮助我们获得这些信息。该表中的KTUXECFL代表了事务的Flag标记，通过这个标记可以找到那些Dead事务：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL> select distinct KTUXECFL,count(*) from x<span class="variable">$ktuxe</span> group by KTUXECFL; </span><br><span class="line">    KTUXECFL                  COUNT(*) </span><br><span class="line">    ------------------------ ---------- </span><br><span class="line">    DEAD                              1 </span><br><span class="line">NONE                          2393</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="KTUXESIZ用来记录事务使用的回滚段块数，可以通过观察这个字段来评估恢复进度-例如如下事务回滚经过测算需要大约3小时"><a href="#KTUXESIZ用来记录事务使用的回滚段块数，可以通过观察这个字段来评估恢复进度-例如如下事务回滚经过测算需要大约3小时" class="headerlink" title="KTUXESIZ用来记录事务使用的回滚段块数，可以通过观察这个字段来评估恢复进度,例如如下事务回滚经过测算需要大约3小时"></a>KTUXESIZ用来记录事务使用的回滚段块数，可以通过观察这个字段来评估恢复进度,例如如下事务回滚经过测算需要大约3小时</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SQL> select ADDR,KTUXEUSN,KTUXESLT,KTUXESQN,KTUXESIZ from x<span class="variable">$ktuxe</span> <span class="built_in">where</span>  KTUXECFL =<span class="string">'DEAD'</span>; </span><br><span class="line">    ADDR              KTUXEUSN  KTUXESLT  KTUXESQN  KTUXESIZ </span><br><span class="line">    ---------------- ---------- ---------- ---------- ---------- </span><br><span class="line">FFFFFFFF7D07B91C        10        39    2567412    1086075 </span><br><span class="line"></span><br><span class="line">SQL> select ADDR,KTUXEUSN,KTUXESLT,KTUXESQN,KTUXESIZ from x<span class="variable">$ktuxe</span> <span class="built_in">where</span>  KTUXECFL =<span class="string">'DEAD'</span>; </span><br><span class="line">    ADDR              KTUXEUSN  KTUXESLT  KTUXESQN  KTUXESIZ </span><br><span class="line">    ---------------- ---------- ---------- ---------- ---------- </span><br><span class="line">    FFFFFFFF7D07B91C        10        39    2567412    1086067 </span><br><span class="line"></span><br><span class="line">SQL> <span class="built_in">declare</span> </span><br><span class="line">   l_start number; </span><br><span class="line">   l_end    number; </span><br><span class="line">   begin </span><br><span class="line">    select ktuxesiz into l_start from x<span class="variable">$ktuxe</span> <span class="built_in">where</span>  KTUXEUSN=10 and KTUXESLT=39; </span><br><span class="line">    dbms_lock.sleep(60); </span><br><span class="line">    select ktuxesiz into l_end from x<span class="variable">$ktuxe</span> <span class="built_in">where</span>  KTUXEUSN=10 and KTUXESLT=39; </span><br><span class="line">    dbms_output.put_line(<span class="string">'time_H:'</span>|| round(l_end/(l_start -l_end)/60,2)); </span><br><span class="line">  end; </span><br><span class="line">  / </span><br><span class="line"></span><br><span class="line">time_H:3</span><br></pre></td></tr></tbody></table></figure><h4 id="把XXX用户下面的某些YYY表赋权给user-XXX-YYY要大写"><a href="#把XXX用户下面的某些YYY表赋权给user-XXX-YYY要大写" class="headerlink" title="把XXX用户下面的某些YYY表赋权给user,XXX\YYY要大写"></a>把XXX用户下面的某些YYY表赋权给user,XXX\YYY要大写</h4><ul><li>XXX要大写<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> tablename varchar2(200);     </span><br><span class="line">    begin </span><br><span class="line">    <span class="keyword">for</span> x IN (SELECT * FROM dba_tables <span class="built_in">where</span> owner=<span class="string">'XXX'</span> and table_name like <span class="string">'%YYY%'</span>) loop   </span><br><span class="line">    tablename:=x.table_name; </span><br><span class="line">    dbms_output.put_line(<span class="string">'GRANT SELECT ON XXX.'</span>||tablename||<span class="string">' to user'</span>); </span><br><span class="line">    EXECUTE IMMEDIATE <span class="string">'GRANT SELECT ON XXX.'</span>||tablename||<span class="string">' TO user'</span>;  </span><br><span class="line">    end loop; </span><br><span class="line">end;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Oracle查出一个用户具有的所有系统权限和对象权限"><a href="#Oracle查出一个用户具有的所有系统权限和对象权限" class="headerlink" title="Oracle查出一个用户具有的所有系统权限和对象权限"></a>Oracle查出一个用户具有的所有系统权限和对象权限</h4><p>系统权限（和用户自己查询<code>select * from session_privs</code>的结果一致）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM DBA_SYS_PRIVS</span><br><span class="line">WHERE GRANTEE = <span class="string">'用户名'</span></span><br><span class="line">UNION</span><br><span class="line">ALLSELECT *</span><br><span class="line">FROM DBA_SYS_PRIVS</span><br><span class="line">WHERE GRANTEE IN </span><br><span class="line">    (SELECT GRANTED_ROLE</span><br><span class="line">    FROM DBA_ROLE_PRIVS</span><br><span class="line">    WHERE GRANTEE = <span class="string">'用户名'</span>);</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="对象权限（和用户自己查询select-FROM-TABLE-PRIVILEGES-where-GRANTEE-39-当前用户-39-的结果一致）"><a href="#对象权限（和用户自己查询select-FROM-TABLE-PRIVILEGES-where-GRANTEE-39-当前用户-39-的结果一致）" class="headerlink" title="对象权限（和用户自己查询select * FROM TABLE_PRIVILEGES where GRANTEE='当前用户'的结果一致）"></a>对象权限（和用户自己查询<code>select * FROM TABLE_PRIVILEGES where GRANTEE='当前用户'</code>的结果一致）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM DBA_TAB_PRIVS</span><br><span class="line">WHERE GRANTEE = <span class="string">'用户名'</span></span><br><span class="line">UNION</span><br><span class="line">ALLSELECT *</span><br><span class="line">FROM DBA_TAB_PRIVS</span><br><span class="line">WHERE GRANTEE IN </span><br><span class="line">    (SELECT GRANTED_ROLE</span><br><span class="line">    FROM DBA_ROLE_PRIVS</span><br><span class="line">    WHERE GRANTEE = <span class="string">'用户名'</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某个用户拥有的角色"><a href="#查询某个用户拥有的角色" class="headerlink" title="查询某个用户拥有的角色"></a>查询某个用户拥有的角色</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_role_privs</span><br><span class="line">WHERE GRANTEE=<span class="string">'用户名'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询拥有DBA角色权限的用户"><a href="#查询拥有DBA角色权限的用户" class="headerlink" title="查询拥有DBA角色权限的用户"></a>查询拥有DBA角色权限的用户</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_role_privs</span><br><span class="line">WHERE GRANTED_ROLE=<span class="string">'DBA'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某个角色拥有的系统权限"><a href="#查询某个角色拥有的系统权限" class="headerlink" title="查询某个角色拥有的系统权限"></a>查询某个角色拥有的系统权限</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM ROLE_SYS_PRIVS</span><br><span class="line">WHERE role=<span class="string">'角色名'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="清除某个SQL的执行计划"><a href="#清除某个SQL的执行计划" class="headerlink" title="清除某个SQL的执行计划"></a>清除某个SQL的执行计划</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec DBMS_SHARED_POOL.PURGE(<span class="string">'v$sqlarea.ADDRESS,v$sqlarea.HASH_VALUE'</span>,<span class="string">'c'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="查询密码是否有过期限制，默认是180天，一般修改为unlimited"><a href="#查询密码是否有过期限制，默认是180天，一般修改为unlimited" class="headerlink" title="查询密码是否有过期限制，默认是180天，一般修改为unlimited"></a>查询密码是否有过期限制，默认是180天，一般修改为unlimited</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_profiles</span><br><span class="line">WHERE profile=<span class="string">'DEFAULT'</span></span><br><span class="line">        AND RESOURCE_NAME LIKE <span class="string">'PASSWORD%'</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED</span><br></pre></td></tr></tbody></table></figure><h4 id="查询和修改隐含参数（必须在sysdba权限下操作）"><a href="#查询和修改隐含参数（必须在sysdba权限下操作）" class="headerlink" title="查询和修改隐含参数（必须在sysdba权限下操作）"></a>查询和修改隐含参数（必须在sysdba权限下操作）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.ksppinm name,</span><br><span class="line">         b.ksppstvl value,</span><br><span class="line">         a.ksppdesc description</span><br><span class="line">FROM x<span class="variable">$ksppi</span> a, x<span class="variable">$ksppcv</span> b</span><br><span class="line">WHERE a.indx = b.indx</span><br><span class="line">        AND a.ksppinm LIKE <span class="string">'%_small_table_threshold%'</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">alter system <span class="built_in">set</span> <span class="string">"_small_table_threshold"</span>=value scope=both sid=<span class="string">'*'</span>;</span><br></pre></td></tr></tbody></table></figure><p>不加sid则说明在默认在RAC的所有实例中修改 </p><p>需要注意的是一定要加上双引号, 另外引号内不能有空格, 只能包含参数的名字 </p><h4 id="评估SGA该设置多少"><a href="#评估SGA该设置多少" class="headerlink" title="评估SGA该设置多少"></a>评估SGA该设置多少</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT SGA_SIZE</span><br><span class="line">FROM </span><br><span class="line">    (SELECT *</span><br><span class="line">    FROM V<span class="variable">$SGA_TARGET_ADVICE</span></span><br><span class="line">    WHERE ESTD_DB_TIME_FACTOR=1</span><br><span class="line">    ORDER BY  1)</span><br><span class="line">WHERE rownum=1;</span><br></pre></td></tr></tbody></table></figure><h4 id="查看shared-pool还剩多少"><a href="#查看shared-pool还剩多少" class="headerlink" title="查看shared pool还剩多少"></a>查看shared pool还剩多少</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM v<span class="variable">$sgastat</span></span><br><span class="line">WHERE name=<span class="string">'free memory'</span></span><br><span class="line">        AND pool=<span class="string">'shared pool'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="统计所有表的容量大小-含分区字段、LOB字段"><a href="#统计所有表的容量大小-含分区字段、LOB字段" class="headerlink" title="统计所有表的容量大小(含分区字段、LOB字段)"></a>统计所有表的容量大小(含分区字段、LOB字段)</h4><p>一般先执行<code>select distinct SEGMENT_TYPE from dba_segments where owner<>'SYS' and tablespace_name<>'SYSAUX'</code>查看到所有的<code>segment_type</code><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">SELECT owner,</span><br><span class="line">        table_name,</span><br><span class="line">         TRUNC(sum(bytes)/1024/1024) Meg</span><br><span class="line">FROM </span><br><span class="line">    (SELECT segment_name table_name,</span><br><span class="line">         owner,</span><br><span class="line">         bytes</span><br><span class="line">    FROM dba_segments</span><br><span class="line">    WHERE segment_type = <span class="string">'TABLE'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT s.segment_name table_name,</span><br><span class="line">         pt.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_segments s, dba_part_tables pt</span><br><span class="line">    WHERE s.segment_name = pt.table_name</span><br><span class="line">            AND s.owner = pt.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'TABLE PARTITION'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT i.table_name,</span><br><span class="line">         i.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_indexes i, dba_segments s</span><br><span class="line">    WHERE s.segment_name = i.index_name</span><br><span class="line">            AND s.owner = i.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'INDEX'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT pi.table_name,</span><br><span class="line">         pi.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_part_indexes pi, dba_segments s</span><br><span class="line">    WHERE s.segment_name = pi.index_name</span><br><span class="line">            AND s.owner = pi.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'INDEX PARTITION'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT l.table_name,</span><br><span class="line">         l.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_lobs l, dba_segments s</span><br><span class="line">    WHERE s.segment_name = l.segment_name</span><br><span class="line">            AND s.owner = l.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'LOBSEGMENT'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT l.table_name,</span><br><span class="line">         l.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_lobs l, dba_segments s</span><br><span class="line">    WHERE s.segment_name = l.index_name</span><br><span class="line">            AND s.owner = l.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'LOBINDEX'</span></span><br><span class="line">    UNION</span><br><span class="line">    allSELECT l.table_name,</span><br><span class="line">         l.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_lobs l, dba_segments s</span><br><span class="line">    WHERE s.segment_name = l.segment_name</span><br><span class="line">            AND s.owner = l.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'LOB PARTITION'</span> )</span><br><span class="line">GROUP BY  owner,table_name</span><br><span class="line">HAVING SUM(bytes)/1024/1024 > 10</span><br><span class="line">ORDER BY  SUM(bytes) DESC</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查看当前会话的SID"><a href="#查看当前会话的SID" class="headerlink" title="查看当前会话的SID"></a>查看当前会话的SID</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM V<span class="variable">$MYSTAT</span></span><br><span class="line">WHERE rownum<2</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某个SID的某个统计信息，比如consistent-gets一致性读"><a href="#查询某个SID的某个统计信息，比如consistent-gets一致性读" class="headerlink" title="查询某个SID的某个统计信息，比如consistent gets一致性读"></a>查询某个SID的某个统计信息，比如consistent gets一致性读</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.SID,</span><br><span class="line">        A.STATISTIC<span class="comment">#,</span></span><br><span class="line">        A.VALUE SID_VALUE,</span><br><span class="line">        B.NAME,</span><br><span class="line">        B.VALUE ALL_SID_VALUE</span><br><span class="line">FROM V<span class="variable">$SESSTAT</span> A ,V<span class="variable">$SYSSTAT</span> B</span><br><span class="line">WHERE A.STATISTIC<span class="comment">#=B.STATISTIC#</span></span><br><span class="line">        AND A.SID=1187</span><br><span class="line">        AND B.NAME=<span class="string">'consistent gets'</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>V$SYSSTAT</code>统计整个DB的统计信息，<code>V$SYSSTAT</code>已经取代了<code>V$STATNAME</code>，并且多了VALUE这一列 <code>V$SESSTAT</code>统计每个用户的统计信息 </li></ul><h4 id="查询某个SID的某个等待事件的信息，比如log-file-sync"><a href="#查询某个SID的某个等待事件的信息，比如log-file-sync" class="headerlink" title="查询某个SID的某个等待事件的信息，比如log file sync"></a>查询某个SID的某个等待事件的信息，比如log file sync</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.SID,</span><br><span class="line">        A.EVENT,</span><br><span class="line">        C.NAME,</span><br><span class="line">        C.PARAMETER1,</span><br><span class="line">        C.PARAMETER2,</span><br><span class="line">        C.PARAMETER3,</span><br><span class="line">         A.TIME_WAITED SID_TIMEWAITED,</span><br><span class="line">        B.TIME_WAITED ALL_SID_TIMEWAITED,</span><br><span class="line">        A.TOTAL_WAITS SID_TOTALWAITS,</span><br><span class="line">        B.TOTAL_WAITS ALL_SID_TOTALWAITS</span><br><span class="line">FROM V<span class="variable">$SESSION_EVENT</span> A ,V<span class="variable">$SYSTEM_EVENT</span> B,V<span class="variable">$EVENT_NAME</span> C</span><br><span class="line">WHERE A.EVENT=B.EVENT</span><br><span class="line">        AND A.EVENT=C.NAME</span><br><span class="line">        AND A.SID=1</span><br><span class="line">        AND C.NAME=<span class="string">'log file sync'</span> V<span class="variable">$SESSION_EVENT</span>描述每个用户的等待事件信息 V<span class="variable">$SYSTEM_EVENT</span>描述整个DB等待事件信息 V<span class="variable">$EVENT_NAME</span>描述等待事件信本身的信息(比如V<span class="variable">$ACTIVE_SESSION_HISTORY</span>的P1TEXT、P2TEXT、P2TEXT匹配V<span class="variable">$EVENT_NAME</span>的PARAMETER1、PARAMETER2、PARAMETER3)</span><br></pre></td></tr></tbody></table></figure><h4 id="RAC跨节点杀会话"><a href="#RAC跨节点杀会话" class="headerlink" title="RAC跨节点杀会话"></a>RAC跨节点杀会话</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter system <span class="built_in">kill</span> session <span class="string">'SID,serial#,@1'</span>  --杀掉1节点的进程 </span><br><span class="line">alter system <span class="built_in">kill</span> session <span class="string">'SID,serial#,@2'</span>  --杀掉2节点的进程</span><br></pre></td></tr></tbody></table></figure><h4 id="Truncate-分区的SQL"><a href="#Truncate-分区的SQL" class="headerlink" title="Truncate 分区的SQL"></a>Truncate 分区的SQL</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name TRUNCATE PARTITION p1 DROP STORAGE UPDATE GLOBAL INDEXES;</span><br></pre></td></tr></tbody></table></figure><h4 id="Drop分区的SQL"><a href="#Drop分区的SQL" class="headerlink" title="Drop分区的SQL"></a>Drop分区的SQL</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP PARTITION p1 UPDATE GLOBAL INDEXES;</span><br></pre></td></tr></tbody></table></figure><h4 id="DATAGUARD主备延迟多少时间的查询方法"><a href="#DATAGUARD主备延迟多少时间的查询方法" class="headerlink" title="DATAGUARD主备延迟多少时间的查询方法"></a>DATAGUARD主备延迟多少时间的查询方法</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">备 库sqlplus></span><br><span class="line">SELECT value</span><br><span class="line">FROM v<span class="variable">$dataguard_stats</span></span><br><span class="line">WHERE name=<span class="string">'apply lag'</span> </span><br><span class="line">或 </span><br><span class="line">备库sqlplus></span><br><span class="line">SELECT ceil((sysdate-next_time)*24*60) <span class="string">"M"</span></span><br><span class="line">FROM v<span class="variable">$archived_log</span></span><br><span class="line">WHERE applied=<span class="string">'YES'</span></span><br><span class="line">        AND SEQUENCE<span class="comment">#=</span></span><br><span class="line">    (SELECT MAX(SEQUENCE<span class="comment">#)</span></span><br><span class="line">    FROM V<span class="variable">$ARCHIVED_LOG</span></span><br><span class="line">    WHERE applied=<span class="string">'YES'</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="查看某个包或存储过程是否正在被调用-如果如下有结果，则此时不能编译，否则会锁住"><a href="#查看某个包或存储过程是否正在被调用-如果如下有结果，则此时不能编译，否则会锁住" class="headerlink" title="查看某个包或存储过程是否正在被调用,如果如下有结果，则此时不能编译，否则会锁住"></a>查看某个包或存储过程是否正在被调用,如果如下有结果，则此时不能编译，否则会锁住</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM V<span class="variable">$DB_OBJECT_CACHE</span></span><br><span class="line">WHERE pin>0</span><br><span class="line">        AND name=upper(<span class="string">'XX'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="查询数据库打补丁的记录"><a href="#查询数据库打补丁的记录" class="headerlink" title="查询数据库打补丁的记录"></a>查询数据库打补丁的记录</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_registry_history;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某表的索引字段的distinct行数和CLUSTERING-FACTOR信息"><a href="#查询某表的索引字段的distinct行数和CLUSTERING-FACTOR信息" class="headerlink" title="查询某表的索引字段的distinct行数和CLUSTERING_FACTOR信息"></a>查询某表的索引字段的distinct行数和CLUSTERING_FACTOR信息</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.table_name,</span><br><span class="line">        a.index_name,</span><br><span class="line">        b.COLUMN_NAME,</span><br><span class="line">        a.blevel,</span><br><span class="line">        a.distinct_keys,</span><br><span class="line">        A.CLUSTERING_FACTOR,</span><br><span class="line">        A.NUM_ROWS,</span><br><span class="line">        trunc((a.distinct_keys/A.NUM_ROWS),</span><br><span class="line">        2)*100||<span class="string">'%'</span> <span class="string">"distinct%"</span>,trunc((a.CLUSTERING_FACTOR/A.NUM_ROWS),2)*100||<span class="string">'%'</span> <span class="string">"CLUSTERING_FACTOR%"</span></span><br><span class="line">FROM DBA_IND_STATISTICS a,DBA_IND_COLUMNS b</span><br><span class="line">WHERE a.table_name=<span class="string">'XX'</span></span><br><span class="line">        AND a.INDEX_NAME=b.index_name</span><br><span class="line">ORDER BY  5 desc</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某表的所有字段的distinct行数"><a href="#查询某表的所有字段的distinct行数" class="headerlink" title="查询某表的所有字段的distinct行数"></a>查询某表的所有字段的distinct行数</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.table_name,</span><br><span class="line">        b.num_rows,</span><br><span class="line">        a.column_name,</span><br><span class="line">        a.data_type,</span><br><span class="line">        a.data_length,</span><br><span class="line">        a.num_distinct,</span><br><span class="line">        trunc((a.num_distinct/b.num_rows),</span><br><span class="line">        2)*100||<span class="string">'%'</span></span><br><span class="line">FROM dba_TAB_COLS a,dba_tables b</span><br><span class="line">WHERE a.table_name=<span class="string">'XX'</span></span><br><span class="line">        AND a.table_name=b.table_name</span><br><span class="line">ORDER BY  6 DESC</span><br></pre></td></tr></tbody></table></figure><h4 id="查询5G以上空闲空间可以进行收缩的数据文件"><a href="#查询5G以上空闲空间可以进行收缩的数据文件" class="headerlink" title="查询5G以上空闲空间可以进行收缩的数据文件"></a>查询5G以上空闲空间可以进行收缩的数据文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="string">'alter database datafile '</span><span class="string">''</span> || a.file_name || <span class="string">''</span><span class="string">' resize '</span> || round(a.filesize -(a.filesize - c.hwmsize) * 0.8) || <span class="string">'M;'</span>, a.filesize || <span class="string">'M'</span> AS <span class="string">"数据文件的总大小"</span>, c.hwmsize || <span class="string">'M'</span> AS <span class="string">"数据文件的实用大小"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT file_id,</span><br><span class="line">         file_name,</span><br><span class="line">         round(bytes / 1024 / 1024) AS filesize</span><br><span class="line">    FROM dba_data_files) a, </span><br><span class="line">    (SELECT file_id,</span><br><span class="line">         round(max(block_id) * 8 / 1024) AS HWMsize</span><br><span class="line">    FROM dba_extents</span><br><span class="line">    GROUP BY  file_id) c</span><br><span class="line">WHERE a.file_id = c.file_id</span><br><span class="line">        AND a.filesize - c.hwmsize > 5000;</span><br></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>廖学强,<a href="http://blog.itpub.net/30126024/viewspace-2057474/" target="_blank" rel="noopener">DBA日常维护SQL脚本</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;aaa.jpeg&quot; class=&quot;full-image&quot; alt=&quot;a
      
    
    </summary>
    
      <category term="Oracle" scheme="https://jiemin.wang/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="https://jiemin.wang/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>数据库拆分</title>
    <link href="https://jiemin.wang/2019/04/24/databaseSplitting/"/>
    <id>https://jiemin.wang/2019/04/24/databaseSplitting/</id>
    <published>2019-04-24T10:19:28.000Z</published>
    <updated>2019-04-24T10:28:11.792Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="aaaa.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>童话里灰姑娘都很穷，但都很漂亮，你漂亮吗？</strong></p></blockquote><h2 id="数据库水平垂直拆分"><a href="#数据库水平垂直拆分" class="headerlink" title="数据库水平垂直拆分"></a>数据库水平垂直拆分</h2><p>当数据库量非常大的时候，DB 已经成为系统瓶颈时就可以考虑进行水平垂直拆分了。</p><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>一般水平拆分是根据表中的某一字段(通常是主键 ID )取模处理，将一张表的数据拆分到多个表中。这样每张表的表结构是相同的但是数据不同。</p><p>不但可以通过 ID 取模分表还可以通过时间分表，比如每月生成一张表。<br>按照范围分表也是可行的:一张表只存储 <code>0~1000W</code>的数据，超过只就进行分表，这样分表的优点是扩展灵活，但是存在热点数据。</p><p>按照取模分表拆分之后我们的查询、修改、删除也都是取模。比如新增一条数据的时候往往需要一张临时表来生成 ID,然后根据生成的 ID 取模计算出需要写入的是哪张表(也可以使用<a href="https://jiemin.wang/2019/04/24/Distributed-ID-Generation/">分布式 ID 生成器</a>来生成 ID)。</p><p>分表之后不能避免的就是查询要比以前复杂，通常不建议 <code>join</code> ，一般的做法是做两次查询。</p><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p>当一张表的字段过多时则可以考虑垂直拆分。<br>通常是将一张表的字段才分为主表以及扩展表，使用频次较高的字段在一张表，其余的在一张表。</p><p>这里的多表查询也不建议使用 <code>join</code> ，依然建议使用两次查询。</p><h2 id="拆分之后带来的问题"><a href="#拆分之后带来的问题" class="headerlink" title="拆分之后带来的问题"></a>拆分之后带来的问题</h2><p>拆分之后由一张表变为了多张表，一个库变为了多个库。最突出的一个问题就是事务如何保证。</p><h3 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h3><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>如果业务对强一致性要求不是那么高那么最终一致性则是一种比较好的方案。</p><p>通常的做法就是补偿，比如 一个业务是 A 调用 B，两个执行成功才算最终成功，当 A 成功之后，B 执行失败如何来通知 A 呢。</p><p>比较常见的做法是 失败时 B 通过 MQ 将消息告诉 A，A 再来进行回滚。这种的前提是 A 的回滚操作得是幂等的，不然 B 重复发消息就会出现问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;aaaa.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>分布式 ID 生成策略</title>
    <link href="https://jiemin.wang/2019/04/24/Distributed-ID-Generation/"/>
    <id>https://jiemin.wang/2019/04/24/Distributed-ID-Generation/</id>
    <published>2019-04-24T09:49:09.000Z</published>
    <updated>2019-04-24T10:28:38.062Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="images.png" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>胸小的姑娘一般脾气都特大，胸大的姑娘一般脾气都特好，因为古语有云：穷凶极恶有容乃大！</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于系统中的一组数据而言，必不可少地对应有唯一标识。简单的单体应用可以使用数据库的自增 ID 作为唯一标识。而在复杂的分布式系统中，就需要一些特定的策略去生成对应的分布式 ID。</p><p>常见的项目中 ID 会有以下两个特点：</p><ol><li>全局唯一性。</li><li>趋势递增（对于使用 MySQL 的项目而言）。</li><li><blockquote><p>因为一般 ID 会作为数据库的主键存储，而在 MySQL InnoDB 中使用的是聚簇索引，使用有序的 ID 可以保证写入性能。</p></blockquote></li></ol><p>一般在分布式系统中，会有一个单独的服务来生成 ID。而这个服务则需要保证高可用性、高QPS 与安全性。另外生成的 ID 是不应该对外暴露的，如果非要对外展示，最好是无规则、不规律的编码。</p><h2 id="生成策略"><a href="#生成策略" class="headerlink" title="生成策略"></a>生成策略</h2><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>UUID (Universally Unique Identifier) 生成的是一个长度为 32 的 16 进制格式的字符串。UUID 有多个版本，各版本算法不同。但核心思想是一致的，基本上都是结合机器的网卡、当前时间、一个随机数来生成特定长度的字符串。</p><p>优点：性能好、高可扩展性：本地生成，无网络消耗，不需要考虑性能瓶颈。</p><p>缺点：</p><ul><li>无法保证趋势递增。</li><li>UUID 过长，如果需要在数据库存储，作为主键建立索引效率低。</li></ul><p>适用场景：不需要考虑空间占用，不需要生成有递增趋势，且不在 MySQL 中存储。</p><h4 id="Snowflake"><a href="#Snowflake" class="headerlink" title="Snowflake"></a>Snowflake</h4><p>snowflake 是 Twitter 开源的一个 ID 生成算法。<br><img src="/2019/04/24/Distributed-ID-Generation/640.webp" width="640"></p><ul><li>首位符号位：因为 ID 一般为正数，该值为 0。</li><li>41 位时间戳（毫秒级）：</li><li><blockquote><p>时间戳不是当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 起始时间戳（起始时间戳需要程序指定））理论上可以最多使用 <code>(1 << 41) / (1000x60x60x24x365) = 69年</code>。</p></blockquote></li><li><p>10 位数据机器位：包括 5 位数据标识位和 5 位机器标识位，也就是说最多可以部署节点数为：<code>1 << 10 = 1024</code>。</p></li><li>12 位毫秒内的序列：同一节点、同一时刻最多生成 ID 数 <code>1 << 12 = 4096</code>。</li></ul><p>最后生成结果为 64 位 Long 型数值。</p><p>优点</p><ul><li>趋势递增，且按照时间有序。</li><li>性能高、稳定性高、不依赖数据库等第三方系统。</li><li>可以按照自身业务特性灵活分配 bit 位。</li></ul><p>缺点</p><ul><li>依赖于机器时钟，时钟回拨会造成暂不可用或重复发号。<blockquote><p>在分布式系统中，每台机器上的时钟不可能完全同步。在同步各个服务器的时间时，有一定几率发生时钟回拨。</p></blockquote></li></ul><p>适用场景：要求高性能，可以不连续，数据类型为 long 型。</p><h4 id="Flicker"><a href="#Flicker" class="headerlink" title="Flicker"></a>Flicker</h4><p>Flicker 方案主要思路是设计单独的库表，利用数据库的自增 ID 来生成全局 ID。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ticket_center (  </span><br><span class="line">    id bigint(20) unsigned NOT NULL auto_increment,  </span><br><span class="line">    stub char(1) NOT NULL default <span class="string">''</span>,  </span><br><span class="line">    PRIMARY KEY (id),  </span><br><span class="line">    UNIQUE KEY unq_stub (stub)  </span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li><blockquote><p>stub: 票根，对应需要生成 Id 的业务方编码，可以是项目名、表名甚至是服务器 IP 地址。</p></blockquote></li><li><blockquote><p>MyISAM：默认表类型，基于传统的 ISAM 类型。ISAM是 Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键。如果执行大量的 select，MySql 存储引擎选用 MyISAM 比较适合。</p></blockquote></li></ul><p>可以使用下面的SQL 获取 ID:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO ticket_center (stub) VALUES (<span class="string">'test'</span>);  </span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p><code>Replace into</code> 先尝试插入数据到表中，如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据， 否则直接插入新数据</p></blockquote><p>为了解决单点故障问题：Flicker 方案启用了两台数据库服务器来生成 ID，通过区分 auto_increment 的起始值和步长来生成奇偶数的 ID。（也可以根据情况部署多台服务器）</p><p>优点</p><p>充分利用了数据库自增 ID 机制，生成的 ID 有序递增。</p><p>缺点</p><p>依赖于数据库，可用性低</p><p>水平扩展困难：定义好了起始值、步长和机器台数之后，如果要添加机器就比较麻烦了。</p><p>适用场景：数据量不多，并发量不大。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>因为 Redis 中的所有命令都是单线程的，可以利用 Incrby命令来模拟 ID 的递增。并且可以通过使用集群来提升吞吐量。我们可以为不同的 Redis 节点设置不同的初始值并统一步长，这样就能利用 Redis 生成唯一且趋势递增的 ID 了。例如有 3 个 Redis 节点，分别设置初始值为 1、2、3 ，这时步长就应该定为 3 。这样每个节点不会生成重复的 ID。</p><blockquote><p>Incrby ：将 key 中储存的数字加上指定的增量值。这是一个 “INCR AND GET” 的原子操作, 业务方可以定义一个自己的 key 值，通过 INCR 命令来获取对应的 ID。</p></blockquote><p>优点：<br>不依赖数据库，且性能优于依赖数据库的 Flicker 方案。</p><p>缺点：</p><ul><li>扩展性低，Redis 集群需要设置好初始值与步长。</li><li>Reids 宕机可能会生成重复的Id。</li></ul><p>适用场景：Redis 集群高可用，并发量高。</p><h4 id="Leaf"><a href="#Leaf" class="headerlink" title="Leaf"></a>Leaf</h4><p>上面提到的这些常见的 ID 生成策略，有时并不能完全满足实际生产中的需求，在实际项目中会对其做一些改造和优化。</p><p>美团的 Leaf 分布式 ID 生成系统 ，在 Flicker 策略 与 Snowflake 算法的基础上做了两套优化的方案。下文会简单介绍一下 Leaf 方案做的一些优化，并不会深入分析。详细方案大家可以查看这里：《Leaf 分布式 ID 生成系统 》</p><p>Leaf-segment 数据库方案</p><p>相比于 Flicker 方案每次都需要读取数据库，Leaf-segment 改为了利用 proxy server 批量获取，且做了双 buffer 的优化。设计图如下：<br><img src="/2019/04/24/Distributed-ID-Generation/640_1.webp" title="640_1"></p><blockquote><p>双 buffer：ID 分号段加载，且当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。</p></blockquote><p>Leaf-snowflake 方案</p><p>主要是针对时钟回拨问题做了特殊处理。 若发生时钟回拨则拒绝发号，并进行告警。<br><img src="/2019/04/24/Distributed-ID-Generation/640_2.webp" title="640_2"></p><p>适用场景：服务规模较大，调用频繁。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于分布式 ID 的生成策略暂且介绍到这里。其实还有一些优秀的解决方案，比如百度的 uid-generator，微信的 SEQSVR。基本上都是都上面一些方案的优化，这里就不做详细介绍了。在实际使用中，需要根据自身业务场景来选取合适的方案，也并非大而全的方案就是好的方案。</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p>牛在舒，<a href="https://mp.weixin.qq.com/s/h8dphDS4D36nWyhPCLC7ag" target="_blank" rel="noopener">分布式 ID 生成策略</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;images.png&quot; class=&quot;full-image&quot; alt=
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 水平拆分表的一次踩坑</title>
    <link href="https://jiemin.wang/2019/04/24/mysql-sharding/"/>
    <id>https://jiemin.wang/2019/04/24/mysql-sharding/</id>
    <published>2019-04-24T09:43:37.000Z</published>
    <updated>2019-04-24T09:56:53.810Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="cbC80KVt.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>胸小的姑娘一般脾气都特大，胸大的姑娘一般脾气都特好，因为古语有云：穷凶极恶有容乃大！</strong></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前不少人问我”能否分享一些分库分表相关的实践”，其实不是我不分享，而是真的经验不多🤣；和大部分人一样都是停留在理论阶段。</p><p>不过这次多少有些可以说道了。</p><p>先谈谈背景，我们生产数据库随着业务发展量也逐渐起来；好几张单表已经突破<strong>亿级</strong>数据，并且保持每天 200+W 的数据量增加。</p><p>而我们有些业务需要进行关联查询、或者是报表统计；在这样的背景下大表的问题更加突出（比如一个查询功能需要跑好几分钟）。</p><a id="more"></a><blockquote><p>可能很多人会说：为啥单表都过亿了才想方案解决？其实不是不想，而是由于历史原因加上错误预估了数据增长才导致这个局面。总之原因比较复杂，也不是本次讨论的重点。</p></blockquote><h1 id="临时方案"><a href="#临时方案" class="headerlink" title="临时方案"></a>临时方案</h1><p>由于需求紧、人手缺的情况下，整个处理的过程分为几个阶段。</p><p>第一阶段应该是去年底，当时运维反应 <code>MySQL</code> 所在的主机内存占用很高，整体负载也居高不下，导致整个 MySQL 的吞吐量明显降低（写入、查询数据都明显减慢）。</p><p>为此我们找出了数据量最大的几张表，发现大部分数据量在7/8000W 左右，少数的已经突破一亿。</p><p>通过业务层面进行分析发现，这些数据多数都是用户产生的一些<strong>日志型数据</strong>，而且这些数据在业务上并不是强相关的，甚至两三个月前的数据其实已经不需要实时查询了。</p><p>因为接近年底，尽可能的不想去动应用，考虑是否可以在运维层面缓解压力；主要的目的就是把单表的数据量降低。</p><p>原本是想把两个月之前的数据直接迁移出来放到备份表中，但在准备实施的过程中发现一个大坑。</p><blockquote><p>表中没有一个可以排序的索引，导致我们无法快速的筛选出一部分数据！这真是一个深坑，为后面的一些优化埋了个地雷；即便是加索引也需要花几个小时（具体多久没敢在生产测试）。</p></blockquote><p>如果我们强行按照时间进行筛选，可能查询出 4000W 的数据就得花上好几个小时；这显然是行不通的。</p><p>于是我们便想到了一个大胆的想法：这部分数据是否可以直接不要了？</p><p>这可能是最有效及最快的方式了，和产品沟通后得知这部分数据真的只是日志型的数据，即便是报表出不来今后补上也是可以的。</p><p>于是我们就简单粗暴的做了以下事情：</p><ul><li>修改原有表的表名，比如加上(<code>_190416bak</code>)。</li><li>再新建一张和原有表名称相同的表。</li></ul><p>这样新的数据就写到了新表，同时业务上也是使用的这个数据量较小的新表。</p><p>虽说过程不太优雅，但至少是解决了问题同时也给我们做技术改造预留了时间。</p><h1 id="分表方案"><a href="#分表方案" class="headerlink" title="分表方案"></a>分表方案</h1><p>之前的方案虽说可以缓解压力，但不能根本解决问题。</p><p>有些业务必须得查询之前的数据，导致之前那招行不通了，所以正好我们就借助这个机会把表分了。</p><p>我相信大部分人虽说没有做过实际做过分表，但也见过猪跑；网上一搜各种方案层出不穷。</p><p>我认为最重要的一点是要结合实际业务找出需要 sharding 的字段，同时还有上线阶段的数据迁移也非常重要。</p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>可能大家都会说用 hash 的方式分配得最均匀，但我认为这还是需要使用历史数据的场景才用哈希分表。</p><p>而对于不需要历史数据的场景，比如业务上只查询近三个月的数据。</p><p>这类需求完成可以采取时间分表，按照月份进行划分，这样改动简单，同时对历史数据也比较好迁移。</p><p>于是我们首先将这类需求的表筛选出来，按照月份进行拆分，只是在查询的时候拼接好表名即可；也比较好理解。</p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>刚才也提到了：需要根据业务需求进行分表策略。</p><p>而一旦所有的数据都有可能查询时，按照时间分表也就行不通了。（也能做，只是如果不是按照时间进行查询时需要遍历所有的表）</p><p>因此我们计划采用 <code>hash</code> 的方式分表，这算是业界比较主流的方式就不再赘述。</p><p>采用哈希时需要将 <code>sharding</code> 字段选好，由于我们的业务比较单纯；是一个物联网应用，所有的数据都包含有物联网设备的唯一标识（IMEI），并且这个字段天然的就保持了唯一性；大多数的业务也都是根据这个字段来的，所以它非常适合来做这个 <code>sharding</code> 字段。</p><p>在做分表之前也调研过 <code>MyCAT</code> 及 <code>sharding-jdbc</code>(现已升级为 <code>shardingsphere</code>)，最终考虑到对开发的友好性及不增加运维复杂度还是决定在 jdbc 层 sharding 的方式。</p><p>但由于历史原因我们并不太好集成 <code>sharding-jdbc</code>，但基于 <code>sharding</code> 的特点自己实现了一个分表策略。</p><p>这个简单也好理解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = hash(sharding字段) % 分表数量 ;</span><br><span class="line"></span><br><span class="line">select xx from <span class="string">'busy_'</span>+index where sharding字段 = xxx;</span><br></pre></td></tr></tbody></table></figure><p>其实就是算出了表名，然后路由过去查询即可。</p><p>只是我们实现的非常简单：修改了所有的底层查询方法，每个方法都里都做了这样的一个判断。</p><p>并没有像 <code>sharding-jdbc</code> 一样，代理了数据库的查询方法；其中还要做 <code>SQL解析-->SQL路由-->执行SQL-->合并结果</code> 这一系列的流程。</p><p>如果自己再做一遍无异于重新造了一个轮子，并且并不专业，只是在现有的技术条件下选择了一个快速实现达成效果的方法。</p><p>不过这个过程中我们节省了将 sharding 字段哈希的过程，因为每一个 IMEI 号其实都是一个唯一的整型，直接用它做 mod 运算即可。</p><p>还有一个是需要一个统一的组件生成规则，分表后不能再依赖于单表的字段自增了；方法还是挺多的：</p><ul><li>比如时间戳+随机数可满足大部分业务。</li><li>UUID，生成简单，但没法做排序。</li><li>雪花算法统一生成主键ID。</li></ul><p>大家可以根据自己的实际情况做选择。</p><h1 id="业务调整"><a href="#业务调整" class="headerlink" title="业务调整"></a>业务调整</h1><p>因为我们并没有使用第三方的 sharding-jdbc 组件，所有没有办法做到对代码的低侵入性；每个涉及到分表的业务代码都需要做底层方法的改造（也就是路由到正确的表）。</p><p>考虑到后续业务的发展，我们决定将拆分的表分为 64 张；加上后续引入大数据平台足以应对几年的数据增长。</p><blockquote><p>这里还有个小细节需要注意：分表的数量需要为 2∧N 次方，因为在取模的这种分表方式下，即便是今后再需要分表影响的数据也会尽量的小。</p></blockquote><p>再修改时只能将表名称进行全局搜索，然后加以修改，同时根据修改的方法倒推到表现的业务并记录下来，方便后续回归测试。</p><hr><p>当然无法避免查询时利用非 sharding 字段导致的全表扫描，这是所有分片后都会遇到的问题。</p><p>因此我们在修改分表方法的底层查询时同时也会查看是否有走分片字段，如果不是，那是否可以调整业务。</p><p>比如对于一个上亿的数据是否还有必要存在按照分页查询、日期查询？这样的业务是否真的具有意义？</p><p>我们尽可能的引导产品按照这样的方式来设计产品或者做出调整。</p><p>但对于报表这类的需求确实也没办法，比如统计表中某种类型的数据；这种我们也可以利用多线程的方式去并行查询然后汇总统计来提高查询效率。</p><p>有时也有一些另类场景：</p><blockquote><p>比如一个千万表中有某一特殊类型的数据只占了很小一部分，比如说几千上万条。</p></blockquote><p>这时页面上需要对它进行分页查询是比较正常的（比如某种投诉消息，客户需要一条一条的单独处理），但如果我们按照 IMEI 号或者是主键进行分片后再分页查询那就比较蛋疼了。</p><p>所以这类型的数据建议单独新建一张表来维护，不要和其他数据混合在一起，这样不管是做分页还是 like 都比较简单和独立。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>代码改完，开发也单测完成后怎么来验证分表的业务是否正常也比较麻烦。</p><p>一个是测试麻烦，再一个是万一哪里改漏了还是查询的原表，但这样在测试环境并不会有异常，一旦上线产生了生产数据到新的 64 张表后想要再修复就比较麻烦了。</p><p>所以我们取了个巧，直接将原表的表名修改，比如加一个后缀；这样在测试过程中观察前后台有无报错就比较容易提前发现这个问题。</p><h1 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h1><p>测试验收通过后只是分表这个需求的80%，剩下如何上线也是比较头疼。</p><p>一旦应用上线后所有的查询、写入、删除都会先走路由然后到达新表；而老数据在原表里是不会发生改变的。</p><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>所以我们上线前的第一步自然是需要将原有的数据进行迁移，迁移的目的是要分片到新的 64 张表中，这样才会对原有的业务无影响。</p><p>因此我们需要额外准备一个程序，它需要将老表里的数据按照分片规则复制到新表中；</p><p>在我们这个场景下，生产数据有些已经上亿了，这个迁移过程我们在测试环境模拟发现耗时是非常久的。而且我们老表中对于 <code>create_time</code> 这样用于筛选数据的字段没有索引（以前的技术债），所以查询起来就更加慢了。</p><p>最后没办法，我们只能和产品协商告知用户对于之前产生的数据短期可能会查询不到，这个时间最坏可能会持续几天（我们只能在凌晨迁移，白天会影响到数据库负载）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这便是我们这次的分表实践，虽说不少过程都不优雅，但受限于条件也只能折中处理。</p><p>但我们后续的计划是，修改我们底层的数据连接（目前是自己封装的一个 jar 包，导致集成 sharding-jdbc 比较麻烦）最终逐渐迁移到 <code>sharding-jdbc</code> .</p><p>最后得出了几个结论：</p><ul><li>一个好的产品规划非常有必要，可以在合理的时间对数据处理（不管是分表还是切入归档）。</li><li>每张表都需要一个可以用于排序查询的字段（自增ID、创建时间），整个过程由于没有这个字段导致耽搁了很长时间。</li><li>分表字段需要谨慎，要全盘的考虑业务情况，尽量避免出现查询扫表的情况。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;cbC80KVt.gif&quot; class=&quot;full-image&quot; alt=&quot;alt&quot; title=&quot;title&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;strong&gt;胸小的姑娘一般脾气都特大，胸大的姑娘一般脾气都特好，因为古语有云：穷凶极恶有容乃大！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前不少人问我”能否分享一些分库分表相关的实践”，其实不是我不分享，而是真的经验不多🤣；和大部分人一样都是停留在理论阶段。&lt;/p&gt;
&lt;p&gt;不过这次多少有些可以说道了。&lt;/p&gt;
&lt;p&gt;先谈谈背景，我们生产数据库随着业务发展量也逐渐起来；好几张单表已经突破&lt;strong&gt;亿级&lt;/strong&gt;数据，并且保持每天 200+W 的数据量增加。&lt;/p&gt;
&lt;p&gt;而我们有些业务需要进行关联查询、或者是报表统计；在这样的背景下大表的问题更加突出（比如一个查询功能需要跑好几分钟）。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL5.7 GTID原理与实战</title>
    <link href="https://jiemin.wang/2019/04/22/mysql-GTID/"/>
    <id>https://jiemin.wang/2019/04/22/mysql-GTID/</id>
    <published>2019-04-22T06:14:52.000Z</published>
    <updated>2019-04-22T07:33:26.786Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="aaa.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>工作多年，当人家问你是不是初入社会，不是因为你看起来年轻，而是因为觉得你怎么这么笨。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="GTID是什么？"><a href="#GTID是什么？" class="headerlink" title="GTID是什么？"></a>GTID是什么？</h4><p>GTID 是<a href="https://dev.mysql.com/doc/refman/5.7/en/replication-gtids.html" target="_blank" rel="noopener">Global Transaction Identifiers</a>的缩写，简称GTID</p><h4 id="GTID组成和架构"><a href="#GTID组成和架构" class="headerlink" title="GTID组成和架构"></a>GTID组成和架构</h4><p>1) <code>GTID = source_id:transaction_id</code><br>2) server_uuid 来源于 auto.cnf<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3E11FA47-71CA-11E1-9E33-C80AA9429562</span><br></pre></td></tr></tbody></table></figure><p></p><p>3) GTID: 在一组复制中，全局唯一</p><p>The syntax for a GTID set is as follows:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gtid_set:</span><br><span class="line">    uuid_set [, uuid_set] ...</span><br><span class="line">    | <span class="string">''</span></span><br><span class="line"></span><br><span class="line">uuid_set:</span><br><span class="line">    uuid:interval[:interval]...</span><br><span class="line"></span><br><span class="line">uuid:</span><br><span class="line">    hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh</span><br><span class="line"></span><br><span class="line">h:</span><br><span class="line">    [0-9|A-F]</span><br><span class="line"></span><br><span class="line">interval:</span><br><span class="line">    n[-n]</span><br><span class="line"></span><br><span class="line">    (n >= 1)</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>mysql.gtid_executed表</code>的压缩由名为<code>thread</code>/<code>sql</code>/<code>compress_gtid_table</code>的专用前台线程执行。 此线程未在<code>SHOW PROCESSLIST</code>的输出中列出，但可以将其视为线程表中的一行，如下所示：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql> SELECT * FROM performance_schema.threads WHERE NAME LIKE <span class="string">'%gtid%'</span>\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          THREAD_ID: 26</span><br><span class="line">               NAME: thread/sql/compress_gtid_table</span><br><span class="line">               TYPE: FOREGROUND</span><br><span class="line">     PROCESSLIST_ID: 1</span><br><span class="line">   PROCESSLIST_USER: NULL</span><br><span class="line">   PROCESSLIST_HOST: NULL</span><br><span class="line">     PROCESSLIST_DB: NULL</span><br><span class="line">PROCESSLIST_COMMAND: Daemon</span><br><span class="line">   PROCESSLIST_TIME: 1509</span><br><span class="line">  PROCESSLIST_STATE: Suspending</span><br><span class="line">   PROCESSLIST_INFO: NULL</span><br><span class="line">   PARENT_THREAD_ID: 1</span><br><span class="line">               ROLE: NULL</span><br><span class="line">       INSTRUMENTED: YES</span><br><span class="line">            HISTORY: YES</span><br><span class="line">    CONNECTION_TYPE: NULL</span><br><span class="line">       THREAD_OS_ID: 18677</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="GTID和Binlog的关系"><a href="#GTID和Binlog的关系" class="headerlink" title="GTID和Binlog的关系"></a>GTID和Binlog的关系</h5><ul><li><p>GTID在binlog中的结构</p><img src="/2019/04/22/mysql-GTID/binlog_gtid.jpg" title="binlog_gtid"></li><li><p>GTID event 结构</p></li><li><p>Previous_gtid_log_event</p></li></ul><ol><li><code>Previous_gtid_log_event</code> 在每个binlog 头部都会有</li><li>每次<code>binlog rotate</code>的时候存储在binlog头部</li><li><code>Previous-GTIDs</code>在binlog中只会存储在这台机器上执行过的所有binlog，不包括手动设置<code>gtid_purged</code>值。</li><li>换句话说，如果你手动<code>set global gtid_purged=xx;</code> 那么xx是不会记录在<code>Previous_gtid_log_event</code>中的。</li></ol><ul><li>GTID和Binlog之间的关系是怎么对应的呢<br>  如何才能找到GTID=?对应的binlog文件呢？<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 假设有4个binlog: bin.001,bin.002,bin.003,bin.004</span><br><span class="line">* bin.001 : Previous-GTIDs=empty; binlog_event有：1-40  </span><br><span class="line">* bin.002 : Previous-GTIDs=1-40;  binlog_event有：41-80 </span><br><span class="line">* bin.003 : Previous-GTIDs=1-80;  binlog_event有：81-120  </span><br><span class="line">* bin.004 : Previous-GTIDs=1-120;  binlog_event有：121-160  </span><br><span class="line">    1. 假设现在我们要找GTID=<span class="variable">$A</span>，那么MySQL的扫描顺序为： 从最后一个binlog开始扫描（即：bin.004）      </span><br><span class="line">    2. bin.004的Previous-GTIDs=1-120，如果<span class="variable">$A</span>=140 > Previous-GTIDs,那么肯定在bin.004中  </span><br><span class="line">    3. bin.004的Previous-GTIDs=1-120，如果<span class="variable">$A</span>=88 包含在Previous-GTIDs中,那么继续对比上一个binlog文件 bin.003,然后再循环前面2个步骤，直到找到为止</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="重要参数的持久化"><a href="#重要参数的持久化" class="headerlink" title="重要参数的持久化"></a>重要参数的持久化</h5><ul><li>GTID相关参数</li></ul><table><thead><tr><th style="text-align:center">variables</th><th style="text-align:center">comment</th></tr></thead><tbody><tr><td style="text-align:center">gtid_executed</td><td style="text-align:center">执行过的所有GTID</td></tr><tr><td style="text-align:center">gtid_purged</td><td style="text-align:center">丢弃掉的GTID</td></tr><tr><td style="text-align:center">gtid_mode</td><td style="text-align:center">gtid模式</td></tr><tr><td style="text-align:center">gtid_next</td><td style="text-align:center">session级别的变量，下一个gtid</td></tr><tr><td style="text-align:center">gtid_owned</td><td style="text-align:center">正在运行的gtid</td></tr><tr><td style="text-align:center">enforce_gtid_consistency</td><td style="text-align:center">保证GTID安全的参数</td></tr></tbody></table><ul><li>重要参数如何持久化</li></ul><ol><li>如何持久化<code>gtid_executed</code> <code>[ log-bin=on,log_slave_update=on ]</code><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gtid_executed = mysql.gtid_executed <span class="comment">#[normal]</span></span><br><span class="line">or</span><br><span class="line">gtid_executed = mysql.gtid_executed + last_binlog 中最后没写到mysql.gtid_executed中的gtid_event  <span class="comment">#[recover]</span></span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li>如何持久化重置的gtid_purged值?<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reset master;</span><br><span class="line"><span class="built_in">set</span> global gtid_purged=<span class="string">'$A:a-b'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 由于有可能手动设置过gtid_purged=<span class="variable">$A</span>:a-b, binlog.index中，last_binlog的Previous-GTIDs并不会包含<span class="variable">$A</span>:a-b  </span><br><span class="line">2. 由于有可能手动设置过gtid_purged=<span class="variable">$A</span>:a-b, binlog.index中，first_binlog的Previous-GTIDs肯定不会出现<span class="variable">$A</span>:a-b  </span><br><span class="line">3. 重置的gtid_purged = @@global.gtid_executed(mysql.gtid_executed:注意，考虑到这个表的更新触发条件，所以这里用@@global.gtid_executed代替) - last_binlog的Previous-GTIDs  - last_binlog所有的gtid_event  </span><br><span class="line">4. 下面就用 <span class="variable">$reset_gtid_purged</span> 来表示重置的gtid</span><br></pre></td></tr></tbody></table></figure><ul><li>如何持久化<code>gtid_purged</code> <code>[ log-bin=on,log_slave_update=on ]</code><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gtid_purged=binlog.index:first_binlog的Previous-GTIDs  + <span class="variable">$reset_gtid_purged</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="开启GTID的必备条件"><a href="#开启GTID的必备条件" class="headerlink" title="开启GTID的必备条件"></a>开启GTID的必备条件</h5><ul><li><p>MySQL 5.6</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=ON                (必选)    </span><br><span class="line">log_bin=ON                  (必选)    </span><br><span class="line"><span class="built_in">log</span>-slave-updates=ON        (必选)    </span><br><span class="line">enforce-gtid-consistency    (必选)</span><br></pre></td></tr></tbody></table></figure></li><li><p>MySQL 5.7</p><blockquote><p>MySQL5.7.13 or higher</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=ON                (必选)  </span><br><span class="line">enforce-gtid-consistency    （必选）</span><br><span class="line">log_bin=ON                  （可选）--高可用切换，最好设置ON  </span><br><span class="line"><span class="built_in">log</span>-slave-updates=ON        （可选）--高可用切换，最好设置ON</span><br></pre></td></tr></tbody></table></figure></blockquote></li></ul><h5 id="新的复制协议-COM-BINLOG-DUMP-GTID"><a href="#新的复制协议-COM-BINLOG-DUMP-GTID" class="headerlink" title="新的复制协议 COM_BINLOG_DUMP_GTID"></a>新的复制协议 COM_BINLOG_DUMP_GTID</h5><ul><li><p>slave会将已经执行过的gtid，以及以及接受到relay log中的gtid的并集发送给master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* http://dev.mysql.com/doc/refman/5.7/en/change-master-to.html</span><br><span class="line">UNION(@@global.gtid_executed, Retrieved_gtid_set - last_received_GTID)</span><br></pre></td></tr></tbody></table></figure></li><li><p>Master send all other transactions to slave</p></li><li>同样的GTID不能被执行两次，如果有同样的GTID，会自动被skip掉。</li></ul><img src="/2019/04/22/mysql-GTID/com_binlog_dump_gtid.jpg" title="com_binlog_dump_gtid"><pre><code>- slave1 : 将自身的UUID1:1 发送给 master，然后接收到了 UUID1:2,UUID1:3 event- slave2 : 将自身的UUID1:1,UUID1:2 发送给 master，然后接收到了UUID1:3 event</code></pre><h5 id="GTID重要函数和新语法"><a href="#GTID重要函数和新语法" class="headerlink" title="GTID重要函数和新语法"></a>GTID重要函数和新语法</h5><ul><li>重要函数</li></ul><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">GTID_SUBSET(subset, set)</td><td style="text-align:center">returns true (1) if all GTIDs in subset are also in set</td></tr><tr><td style="text-align:center">GTID_SUBTRACT(set,subset)</td><td style="text-align:center">returns only those GTIDs from set that are not in subset</td></tr><tr><td style="text-align:center">WAIT_FOR_EXECUTED_GTID_SET(gtid_set[, timeout])</td><td style="text-align:center">Wait until the given GTIDs have executed on slave.</td></tr><tr><td style="text-align:center">WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(gtid_set[, timeout][,channel])</td><td style="text-align:center">Wait until the given GTIDs have executed on slave.</td></tr></tbody></table><ul><li><p>新语法</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">START SLAVE [thread_types] [until_option] [connection_options]</span><br><span class="line">thread_types:</span><br><span class="line">    [thread_type [, thread_type] ... ]</span><br><span class="line">thread_type: </span><br><span class="line">    IO_THREAD | SQL_THREAD</span><br><span class="line">until_option:</span><br><span class="line">    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = gtid_set</span><br><span class="line">          |   MASTER_LOG_FILE = <span class="string">'log_name'</span>, MASTER_LOG_POS = log_pos</span><br><span class="line">          |   RELAY_LOG_FILE = <span class="string">'log_name'</span>, RELAY_LOG_POS = log_pos</span><br><span class="line">          |   SQL_AFTER_MTS_GAPS  }</span><br></pre></td></tr></tbody></table></figure></li><li><p>举个栗子: </p></li></ul><ol><li><p>START SLAVE SQL_THREAD UNTIL SQL_BEFORE_GTIDS = 3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56   </p><blockquote><p>表示，当SQL_thread 执行到3E11FA47-71CA-11E1-9E33-C80AA9429562:10 的时候停止，下一个事务是11  </p></blockquote></li><li><p>START SLAVE SQL_THREAD UNTIL SQL_AFTER_GTIDS = 3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56  </p><blockquote><p>表示，当SQL_thread 执行到3E11FA47-71CA-11E1-9E33-C80AA9429562:56 的时候停止，56是最后一个提交的事务。</p></blockquote></li></ol><h4 id="GTID有什么好处"><a href="#GTID有什么好处" class="headerlink" title="GTID有什么好处"></a>GTID有什么好处</h4><h5 id="classic-replication-运维之伤"><a href="#classic-replication-运维之伤" class="headerlink" title="classic replication [运维之伤]"></a>classic replication [运维之伤]</h5><img src="/2019/04/22/mysql-GTID/classic_rpl.jpg" title="classic_rpl"><h5 id="GTID-replication-so-easy"><a href="#GTID-replication-so-easy" class="headerlink" title="GTID replication [so easy]"></a>GTID replication [so easy]</h5><img src="/2019/04/22/mysql-GTID/GTID_rpl.jpg" title="GTID_rpl"><h4 id="GTID的Limitation"><a href="#GTID的Limitation" class="headerlink" title="GTID的Limitation"></a>GTID的Limitation</h4><ul><li>不安全的事务<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置enforce-gtid-consistency=ON</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. CREATE TABLE ... SELECT statements  </span><br><span class="line">2. CREATE TEMPORARY TABLE or DROP TEMPORARY TABLE statements inside transactions</span><br><span class="line">3. 同时更新 事务引擎 和 非事务引擎。</span><br></pre></td></tr></tbody></table></figure><h4 id="MySQL5-7-GTID-crash-safe"><a href="#MySQL5-7-GTID-crash-safe" class="headerlink" title="MySQL5.7 GTID crash-safe"></a>MySQL5.7 GTID crash-safe</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-solutions-unexpected-slave-halt.html" target="_blank" rel="noopener">关于 GTID crash safe 可以参考官方文档列出的安全配置</a></p><ul><li>单线程复制<br>Non-GTID 推荐配置:<ul><li>relay_log_recovery=1</li><li>relay_log_info_repository=TABLE</li><li>master_info_repository=TABLE</li></ul></li></ul><p>GTID 推荐配置:</p><pre><code>* MASTER_AUTO_POSITION=on* relay_log_recovery=0</code></pre><img src="/2019/04/22/mysql-GTID/replication_slave_halt.jpg" title="replication_slave_halt"><ul><li>多线程复制<br>Non-GTID 推荐配置:<ul><li>relay_log_recovery=1</li><li>sync_relay_log=1</li><li>relay_log_info_repository=TABLE</li><li>master_info_repository=TABLE<br>GTID 推荐配置:</li><li>MASTER_AUTO_POSITION=on</li><li>relay_log_recovery=0</li></ul></li></ul><img src="/2019/04/22/mysql-GTID/replication_slave_halt_duoble.jpg" title="replication_slave_halt_duoble"><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h4 id="使用GTID搭建Replication"><a href="#使用GTID搭建Replication" class="headerlink" title="使用GTID搭建Replication"></a>使用GTID搭建Replication</h4><h5 id="从0开始搭建"><a href="#从0开始搭建" class="headerlink" title="从0开始搭建"></a>从0开始搭建</h5><ul><li><p>step 1: 让所有server处于同一个点</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> SET @@global.read_only = ON;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 2: 关闭所有MySQL</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell> mysqladmin -uusername -p shutdown</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 3: 重启所有MySQL，并开启GTID</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell> mysqld --gtid-mode=ON --<span class="built_in">log</span>-bin --enforce-gtid-consistency &</span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>当然，在my.cnf中配置好最佳</p></blockquote><ul><li><p>step 4: change master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> CHANGE MASTER TO MASTER_HOST = host, MASTER_PORT = port, MASTER_USER = user, MASTER_PASSWORD = password, MASTER_AUTO_POSITION = 1, MASTER_CONNECT_RETRY=10;</span><br><span class="line"></span><br><span class="line">mysql> START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 5: 让master 可读可写</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> SET @@global.read_only = OFF;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="从备份中恢复-amp-搭建"><a href="#从备份中恢复-amp-搭建" class="headerlink" title="从备份中恢复&搭建"></a>从备份中恢复&搭建</h5><ul><li><p>step 1: 备份</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump xx 获取并且记录gtid_purged值  </span><br><span class="line">or</span><br><span class="line">冷备份 --获取并且记录gtid_executed值，这个就相当于mysqldump中得到的gtid_purged</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 2: 在新服务器上reset master，导入备份</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reset master; --清空gtid信息  </span><br><span class="line">导入备份； --如果是逻辑导入，请设置sql_log_bin=off  </span><br><span class="line"><span class="built_in">set</span> global gtid_purged=<span class="string">'xx'</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 3: change master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> CHANGE MASTER TO MASTER_HOST = host, MASTER_PORT = port, MASTER_USER = user, MASTER_PASSWORD = password, MASTER_AUTO_POSITION = 1, MASTER_CONNECT_RETRY=10;</span><br><span class="line"></span><br><span class="line">mysql> START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="如何从classic-replication-升级成-GTID-replication"><a href="#如何从classic-replication-升级成-GTID-replication" class="headerlink" title="如何从classic replication 升级成 GTID replication"></a>如何从classic replication 升级成 GTID replication</h4><h5 id="offline-方式升级"><a href="#offline-方式升级" class="headerlink" title="offline 方式升级"></a>offline 方式升级</h5><p>offline 的方式升级最简单。全部关机，然后配置好GTID，重启，<code>CHANGE MASTER TO MASTER_AUTO_POSITION=1</code>。</p><h5 id="online-方式升级"><a href="#online-方式升级" class="headerlink" title="online 方式升级"></a>online 方式升级</h5><p>这里先介绍几个重要<code>GTID_MODE</code>的<code>value</code></p><ul><li>GTID_MODE = OFF               不产生Normal_GTID，只接受来自master的ANONYMOUS_GTID</li><li>GTID_MODE = OFF_PERMISSIVE    不产生Normal_GTID，可以接受来自master的ANONYMOUS_GTID & Normal_GTID</li><li>GTID_MODE = ON_PERMISSIVE     产生Normal_GTID，可以接受来自master的ANONYMOUS_GTID & Normal_GTID</li><li>GTID_MODE = ON                产生Normal_GTID，只接受来自master的Normal_GTID</li></ul><p>master和slave的gtid_mode 组合搭配矩阵图</p><blockquote><p>水平的GTID_MODE为：master</p></blockquote><blockquote><p>垂直的GTID_MODE为：slave</p></blockquote><table><thead><tr><th style="text-align:left">gtid_mode</th><th style="text-align:left">OFF(master)</th><th style="text-align:left">OFF_PERMISSIVE(master)</th><th style="text-align:left">ON_PERMISSIVE(master)</th><th style="text-align:left">ON(master)</th></tr></thead><tbody><tr><td style="text-align:left">OFF(slave)</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">N</td><td style="text-align:left">N</td></tr><tr><td style="text-align:left">OFF_PERMISSIVE(slave)</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y(auto_position可以开启)</td></tr><tr><td style="text-align:left">ON_PERMISSIVE(slave)</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y(auto_position可以开启)</td></tr><tr><td style="text-align:left">ON(slave)</td><td style="text-align:left">N</td><td style="text-align:left">N</td><td style="text-align:left">Y</td><td style="text-align:left">Y(auto_position可以开启)</td></tr></tbody></table><p>归纳总结：</p><ol><li>当master产生Normal_GTID的时候（ON_PERMISSIVE，ON），如果slave的gtid_mode（OFF）不能接受Normal_GTID，那么就会报错</li><li>当master产生ANONYMOUS_GTID的时候（OFF_PERMISSIVE，OFF），如果slave的gtid_mode（ON）不能接受ANONYMOUS_GTID，那么就会报错</li><li>设置auto_position的条件： 当master gtid_mode=ON时，slave可以为OFF_PERMISSIVE，ON_PERMISSIVE，ON。除此之外，都不能设置auto_position = on</li></ol><p>下面罗列下，如何online 升级为GTID模式。</p><ul><li><p>step 1: 每台server执行</p><blockquote><p>检查错误日志，直到没有错误出现，才能进行下一步</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = WARN;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>step 2: 每台server执行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = ON;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 3: 每台server执行</p><blockquote><p>不用关心一组复制集群的server的执行顺序，只需要保证每个Server都执行了，才能进行下一步</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>step 4: 每台server执行</p><blockquote><p>不用关心一组复制集群的server的执行顺序，只需要保证每个Server都执行了，才能进行下一步</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.GTID_MODE = ON_PERMISSIVE;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>step 5: 在每台server上执行，如果ONGOING_ANONYMOUS_TRANSACTION_COUNT=0就可以</p><blockquote><p>不需要一直为0，只要出现过0一次，就ok</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE <span class="string">'ONGOING_ANONYMOUS_TRANSACTION_COUNT'</span>;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>step 6： 确保所有anonymous事务传递到slave上了</p></li></ul><ul><li><p>master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></tbody></table></figure></li><li><p>每个slave  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MASTER_POS_WAIT(file, position);</span><br></pre></td></tr></tbody></table></figure></li></ul><p>或者，等一段时间，只要不是大的延迟，一般都没问题</p><ul><li><p>step 7: 每台Server上执行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.GTID_MODE = ON;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 8: 在每台server上将my.cnf中添加好gtid配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=ON                (必选) </span><br><span class="line">enforce-gtid-consistency    (必选)</span><br><span class="line">log_bin=ON                  (可选)--高可用切换，最好设置ON  </span><br><span class="line"><span class="built_in">log</span>-slave-updates=ON        (可选)--高可用切换，最好设置ON</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 9: change master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STOP SLAVE;  </span><br><span class="line">CHANGE MASTER TO MASTER_AUTO_POSITION = 1;  </span><br><span class="line">START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="GTID-failover"><a href="#GTID-failover" class="headerlink" title="GTID failover"></a>GTID failover</h4><h5 id="MySQL-crash"><a href="#MySQL-crash" class="headerlink" title="MySQL crash"></a>MySQL crash</h5><pre><code>> 配置好loss-less semi-sync replication，可以更可靠的保证数据零丢失。  以下说的都是crash 后，起不来的情况</code></pre><ul><li>binlog 在master还有日志没有传递到 slave<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 选取最新的slave, CHANGE MASTER TO maseter_auto_position 同步好  </span><br><span class="line">2. mysqlbinlog 将没传递过来的binlog在新master上replay  </span><br><span class="line">3. 打开新 master 的 SET GLOBAL surper_read_only=off;</span><br><span class="line">``` </span><br><span class="line">* binlog 已经传递到slave</span><br><span class="line">```bash</span><br><span class="line">1. 选取最新的slave, CHANGE MASTER TO maseter_auto_position同步好  </span><br><span class="line">2. 打开新master的 SET GLOBAL surper_read_only=off;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="OS-crash"><a href="#OS-crash" class="headerlink" title="OS crash"></a>OS crash</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 选取最新的slave, CHANGE MASTER TO maseter_auto_position同步好  </span><br><span class="line">2. 打开新master的 SET GLOBAL surper_read_only=off;</span><br></pre></td></tr></tbody></table></figure><blockquote><blockquote><p>以上操作，在传统模式复制下，只能通过MHA来实现，MHA比较复杂。<br>   现在，在GTID模式下，实现起来非常简单，且非常方便。</p></blockquote></blockquote><h4 id="GTID-运维和错误处理"><a href="#GTID-运维和错误处理" class="headerlink" title="GTID 运维和错误处理"></a>GTID 运维和错误处理</h4><ol><li>使用GTID后，对原来传统的运维有不同之处了，需要调整过来。</li><li>使用Row模式且复制配置正确的情况下，基本上很少发现有复制出错的情况。</li><li>slave 设置 super_read_only=on</li></ol><h5 id="错误场景-Errant-transaction"><a href="#错误场景-Errant-transaction" class="headerlink" title="错误场景: Errant transaction"></a>错误场景: Errant transaction</h5><p>出现这种问题基本有两种情况</p><blockquote><ol><li>复制参数没有配置正确，当slave crash后，会出现重复键问题</li><li>DBA操作不正确，不小心在slave上执行了事务</li></ol></blockquote><p>对于第一个重复键问题</p><ul><li><p>对于第一个重复键问题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* skip transation; </span><br><span class="line">SQL> SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1;</span><br><span class="line">SQL> START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li><li><p>GTID模式</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQL> SET GTID_NEXT=<span class="string">'b9b4712a-df64-11e3-b391-60672090eb04:7'</span>;   --设置需要跳过的gtid event</span><br><span class="line">SQL> BEGIN;COMMIT;</span><br><span class="line">SQL> SET GTID_NEXT=<span class="string">'AUTOMATIC'</span>;</span><br><span class="line">SQL> START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li></ul><p>对于第二种不小心多执行了事务</p><blockquote><p>这种情况就比较难了，这样已经导致了数据不一致，大多数情况，建议slave重做<br>  如何避免： slave 设置 super_read_only=on;</p></blockquote><p><strong><em>重点： 当发生inject empty transction后，有可能会丢失事务</em></strong></p><pre><code>这里说下inject empty transction的隐患    当slave上inject empty transction，说明有一个master的事务被忽略了（这里假设是 $uuid:100）    事务丢失一：如果此时此刻master挂了，这个slave被选举为新master，那么其他的slave如果还没有执行到$uuid:100,就会丢失掉$uuid:100这个事务。    事务丢失二：如果从备份中重新搭建一个slave，需要重新执行之前的所有事务，而此时，master挂了， 又回到了事务丢失一的场景。</code></pre><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h4 id="如何重置gtid-executed，gtid-purged。"><a href="#如何重置gtid-executed，gtid-purged。" class="headerlink" title="如何重置gtid_executed，gtid_purged。"></a>如何重置gtid_executed，gtid_purged。</h4><ul><li><p>设置gtid_executed</p><blockquote><p>现在只能执行:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> reset master;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>设置gtid_purged</p></li><li>当gtid_executed 非空的时候，不能设置gtid_purged</li><li>当gtid_executed 为空的时候(即刚刚备份好的镜像，刚搭建的mysql)<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> SET @@GLOBAL.GTID_PURGED=<span class="string">'0ad6eae9-2d66-11e6-864f-ecf4bbf1f42c:1-3'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="如果auto-cnf-被删掉了，对于GTID的复制会有什么影响？"><a href="#如果auto-cnf-被删掉了，对于GTID的复制会有什么影响？" class="headerlink" title="如果auto.cnf 被删掉了，对于GTID的复制会有什么影响？"></a>如果auto.cnf 被删掉了，对于GTID的复制会有什么影响？</h5><pre><code>> 如果被删掉，重启后，server-uuid 会变</code></pre><h5 id="手动设置-set-gtid-purged-xx-yy-mysql会去主动修改binlog的头么"><a href="#手动设置-set-gtid-purged-xx-yy-mysql会去主动修改binlog的头么" class="headerlink" title="手动设置 set @@gtid_purged = xx:yy, mysql会去主动修改binlog的头么"></a>手动设置 set @@gtid_purged = xx:yy, mysql会去主动修改binlog的头么</h5><pre><code>> 不会</code></pre><h5 id="GTID和复制过滤规则之间如何协同工作？MySQL，test还能愉快的过滤掉吗？"><a href="#GTID和复制过滤规则之间如何协同工作？MySQL，test还能愉快的过滤掉吗？" class="headerlink" title="GTID和复制过滤规则之间如何协同工作？MySQL，test还能愉快的过滤掉吗？"></a>GTID和复制过滤规则之间如何协同工作？MySQL，test还能愉快的过滤掉吗？</h5><pre><code>> 可以，改过滤的会自己过滤，不用担心</code></pre><h2 id="Automatic-failover-with-mysqlfailover-GTID"><a href="#Automatic-failover-with-mysqlfailover-GTID" class="headerlink" title="Automatic failover with mysqlfailover+GTID"></a>Automatic failover with mysqlfailover+GTID</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-solutions-switch.html" target="_blank" rel="noopener">mysqlfailover+GTID</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;aaa.jpg&quot; class=&quot;full-image&quot; alt=&quot;al
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询重复记录,删除重复记录方法</title>
    <link href="https://jiemin.wang/2019/04/22/mysql-duplicate/"/>
    <id>https://jiemin.wang/2019/04/22/mysql-duplicate/</id>
    <published>2019-04-22T05:55:23.000Z</published>
    <updated>2019-04-22T06:05:32.273Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>善良没用，因为只有你先漂亮，别人才能看到你的善良。</strong></p></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查找全部重复记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表 WHERE 重复字段 IN (SELECT 重复字段 FROM 表 GROUP BY 重复字段 HAVING COUNT(*)>1);</span><br></pre></td></tr></tbody></table></figure><p></p><p>过滤重复记录(只显示一条)<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表 WHERE ID IN (SELECT MAX(ID) FROM 表 GROUP BY Title);     <span class="comment">#显示ID最大一条记录</span></span><br><span class="line">SELECT * FROM 表 WHERE ID IN (SELECT MIN(ID) FROM 表 GROUP BY Title);     <span class="comment">#显示ID最小一条记录</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>删除全部重复记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE 表 WHERE 重复字段 IN (SELECT 重复字段 FROM 表 GROUP BY 重复字段 HAVING COUNT(*)>1);</span><br></pre></td></tr></tbody></table></figure><p></p><p>删除全部重复记录保留最大ID最大一条记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表 WHERE ID NOT IN (SELECT MAX(ID) FROM 表 GROUP BY Title)    <span class="comment">#保留ID最大一条记录</span></span><br><span class="line">DELETE FROM 表 WHERE ID NOT IN (SELECT MIN(ID) FROM 表 GROUP BY Title)    <span class="comment">#保留ID最小一条记录</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>删除表中多余的重复记录（多个字段），只留有rowid最小的记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM vitae a WHERE (a.peopleId, a.seq) IN (SELECT peopleId, seq FROM vitae GROUP BY peopleId, seq HAVING COUNT(*) > 1) AND rowid NOT IN (SELECT MIN(rowid) FROM vitae GROUP BY peopleId, seq HAVING COUNT(*)>1)</span><br></pre></td></tr></tbody></table></figure><p></p><p>查找表中多余的重复记录（多个字段），不包含rowid最小的记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM vitae a WHERE (a.peopleId, a.seq) IN (SELECT peopleId, seq FROM vitae GROUP BY peopleId, seq HAVING COUNT(*) > 1) AND rowid NOT IN (SELECT MIN(rowid) FROM vitae GROUP BY peopleId, seq HAVING COUNT(*)>1)</span><br></pre></td></tr></tbody></table></figure><p></p><p>查找表中多余的重复记录（多个字段）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM vitae a WHERE (a.peopleId, a.seq) IN (SELECT peopleId, seq FROM vitae GROUP BY peopleId, seq HAVING COUNT(*) > 1)</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说明：</p><ul><li>单表的唯一查询用：distinct</li><li>多表的唯一查询用：group by</li><li>distinct 查询多表时，left join 还有效，全连接无效</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL修改表、字段、库的字符集及字符集</title>
    <link href="https://jiemin.wang/2019/04/22/mysql-character/"/>
    <id>https://jiemin.wang/2019/04/22/mysql-character/</id>
    <published>2019-04-22T05:48:55.000Z</published>
    <updated>2019-04-22T06:06:52.657Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>一直对发型和身材不满意的人，有一个共同点：不肯承认这是脸的问题。</strong></p></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>修改数据库字符集<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE db_name DEFAULT CHARACTER SET character_name [COLLATE ...];</span><br></pre></td></tr></tbody></table></figure><p></p><p>把表默认的字符集和所有字符列（CHAR,VARCHAR,TEXT）改为新的字符集：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name CONVERT TO CHARACTER SET character_name [COLLATE ...]</span><br><span class="line">如：ALTER TABLE logtest CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></tbody></table></figure><p></p><p>只是修改表的默认字符集<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name DEFAULT CHARACTER SET character_name [COLLATE...];</span><br><span class="line">如：ALTER TABLE logtest DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></tbody></table></figure><p></p><p>修改字段的字符集<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name CHANGE c_name c_name CHARACTER SET character_name [COLLATE ...];</span><br><span class="line">如：ALTER TABLE logtest CHANGE title title VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看字段编码<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW FULL COLUMNS FROM tbl_name;</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看系统的编码字符<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE <span class="string">'character\_set\_%'</span> OR Variable_name LIKE <span class="string">'collation%'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="MySQL字符集设置"><a href="#MySQL字符集设置" class="headerlink" title="MySQL字符集设置"></a>MySQL字符集设置</h2><p>系统变量：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">– character_set_server：默认的内部操作字符集</span><br><span class="line">– character_set_client：客户端来源数据使用的字符集</span><br><span class="line">– character_set_connection：连接层字符集</span><br><span class="line">– character_set_results：查询结果字符集</span><br><span class="line">– character_set_database：当前选中数据库的默认字符集</span><br><span class="line">– character_set_system：系统元数据(字段名等)字符集</span><br><span class="line">– 还有以collation_开头的同上面对应的变量，用来描述字符序。</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="用introducer指定文本字符串的字符集"><a href="#用introducer指定文本字符串的字符集" class="headerlink" title="用introducer指定文本字符串的字符集"></a>用introducer指定文本字符串的字符集</h2><p>格式为：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_charset] ‘string’ [COLLATE collation]</span><br></pre></td></tr></tbody></table></figure><p></p><p>例子:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT _latin1 ‘string’;</span><br><span class="line">• SELECT _utf8 ‘你好’ COLLATE utf8_general_ci;</span><br><span class="line">– 由introducer修饰的文本字符串在请求过程中不经过多余的转码，直接转换为内部字符集处理。</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="MySQL中的字符集转换过程"><a href="#MySQL中的字符集转换过程" class="headerlink" title="MySQL中的字符集转换过程"></a>MySQL中的字符集转换过程</h2><ol><li>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</li><li>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：<ul><li>使用每个数据字段的CHARACTER SET设定值；</li><li>若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；</li><li>若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</li><li>若上述值不存在，则使用character_set_server设定值。</li></ul></li><li>将操作结果从内部操作字符集转换为character_set_results</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.gif&quot; class=&quot;full-image&quot; alt=&quot;a
      
    
    </summary>
    
      <category term="MySQL" scheme="https://jiemin.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://jiemin.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux Systemd详解</title>
    <link href="https://jiemin.wang/2019/04/22/linux-systemd/"/>
    <id>https://jiemin.wang/2019/04/22/linux-systemd/</id>
    <published>2019-04-22T05:15:48.000Z</published>
    <updated>2019-04-22T06:08:00.117Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>一场说走就走的旅行，回来等着你的就是一段吃土的日子。</strong></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Systemd是Linux系统工具，用来启动守护进程，已成为大多数发行版的标配，PID为1最先启动；</p><p>历史上，Linux 的启动一直采用init进程。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/apache2 start</span><br><span class="line">或者</span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></tbody></table></figure><p></p><p>这种方法有两个缺点。</p><ul><li>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li></ul><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。<br>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。<br>CentOS/RHEL7 以上版本中Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。<br>查看版本：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/04/22/linux-systemd/systemd.png" title="systemd"><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl 命令"></a>systemctl 命令</h4><p>重启系统<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot</span><br></pre></td></tr></tbody></table></figure><p></p><p>关闭系统，切断电源<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl poweroff</span><br></pre></td></tr></tbody></table></figure><p></p><p>CPU停止工作<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl halt</span><br></pre></td></tr></tbody></table></figure><p></p><p>暂停系统<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>让系统进入冬眠状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl hibernate</span><br></pre></td></tr></tbody></table></figure><p></p><p>让系统进入交互式休眠状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl hybrid-sleep</span><br></pre></td></tr></tbody></table></figure><p></p><p>启动进入救援状态（单用户状态）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl rescue</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>systemd-analyze</code> 是查看启动耗时</p><p>查看启动耗时<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看每个服务的启动耗时<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze blame</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示瀑布状的启动过程流<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze critical-chain</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示指定服务的启动流<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze critical-chain atd.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="hostnamectl命令用于查看当前主机的信息。"><a href="#hostnamectl命令用于查看当前主机的信息。" class="headerlink" title="hostnamectl命令用于查看当前主机的信息。"></a><code>hostnamectl</code>命令用于查看当前主机的信息。</h4><p>显示当前主机的信息<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl</span><br><span class="line">```bash</span><br><span class="line">设置主机名。</span><br><span class="line">```bash</span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname rhel7</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="localectl命令用于查看本地化设置。"><a href="#localectl命令用于查看本地化设置。" class="headerlink" title="localectl命令用于查看本地化设置。"></a><code>localectl</code>命令用于查看本地化设置。</h4><p>查看本地化设置<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localectl</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置本地化参数。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localectl <span class="built_in">set</span>-locale LANG=en_GB.utf8</span><br><span class="line">localectl <span class="built_in">set</span>-keymap en_GB</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="timedatectl命令用于查看当前时区设置。"><a href="#timedatectl命令用于查看当前时区设置。" class="headerlink" title="timedatectl命令用于查看当前时区设置。"></a><code>timedatectl</code>命令用于查看当前时区设置。</h4><p>查看当前时区设置<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示所有可用的时区<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl list-timezones</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置当前时区<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-timezone America/New_York</span><br><span class="line">timedatectl <span class="built_in">set</span>-time YYYY-MM-DD</span><br><span class="line">timedatectl <span class="built_in">set</span>-time HH:MM:SS</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="loginctl命令用于查看当前登录的用户。"><a href="#loginctl命令用于查看当前登录的用户。" class="headerlink" title="loginctl命令用于查看当前登录的用户。"></a><code>loginctl</code>命令用于查看当前登录的用户。</h4><p>列出当前session<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginctl list-sessions</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出当前登录用户<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginctl list-users</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出显示指定用户的信息<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginctl show-user ruanyf</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><code>Systemd</code> 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p><p><code>Unit</code> 一共分成12种。</p><ul><li><code>Service unit</code>：系统服务</li><li><code>Target unit</code>：多个 Unit 构成的一个组</li><li><code>Device Unit</code>：硬件设备</li><li><code>Mount Unit</code>：文件系统的挂载点</li><li><code>Automount Unit</code>：自动挂载点</li><li><code>Path Unit</code>：文件或路径</li><li><code>Scope Unit</code>：不是由 Systemd 启动的外部进程</li><li><code>Slice Unit</code>：进程组</li><li><code>Snapshot Unit</code>：Systemd 快照，可以切回某个快照</li><li><code>Socket Unit</code>：进程间通信的 socket</li><li><code>Swap Unit</code>：swap 文件</li><li><code>Timer Unit</code>：定时器</li></ul><p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p><p>列出正在运行的 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有Unit，包括没有找到配置文件的或者启动失败的<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --all</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有没有运行的 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --all --state=inactive</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有加载失败的 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --failed</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有正在运行的、类型为 service 的 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Unit-的状态"><a href="#Unit-的状态" class="headerlink" title="Unit 的状态"></a><code>Unit</code> 的状态</h4><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p><p>显示系统状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示单个 Unit 的状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysystemctl status bluetooth.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示远程主机的某个 Unit 的状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p><p>显示某个 Unit 是否正在运行<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-active application.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示某个 Unit 是否处于启动失败状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-failed application.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示某个 Unit 服务是否建立了启动链接<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled application.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Unit-管理"><a href="#Unit-管理" class="headerlink" title="Unit 管理"></a><code>Unit</code> 管理</h4><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p><p>立即启动一个服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>立即停止一个服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>重启一个服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>杀死一个服务的所有子进程<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">kill</span> apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>重新加载一个服务的配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>重载所有修改过的配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示某个 Unit 的所有底层参数<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl show httpd.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示某个 Unit 的指定属性的值<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl show -p CPUShares httpd.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置某个 Unit 的指定属性<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">set</span>-property httpd.service CPUShares=500</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p><code>Unit</code> 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p><p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies nginx.service</span><br><span class="line">```bash</span><br><span class="line">上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用--all参数。</span><br><span class="line">```bash</span><br><span class="line">systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Unit-的配置文件"><a href="#Unit-的配置文件" class="headerlink" title="Unit 的配置文件"></a>Unit 的配置文件</h4><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p><p><code>Systemd</code> 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p><p><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> clamd@scan.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>等同于<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/clamd@scan.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/clamd@scan.service'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。</p><p>与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> clamd@scan.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p><p>配置文件的状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files命令用于列出所有配置文件。</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出指定类型的配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=service</span><br><span class="line">这个命令会输出一个列表。</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files</span><br></pre></td></tr></tbody></table></figure><h4 id="UNIT-FILE-STATE"><a href="#UNIT-FILE-STATE" class="headerlink" title="UNIT FILE STATE"></a>UNIT FILE STATE</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chronyd.service enabled</span><br><span class="line">clamd@.service static</span><br><span class="line">clamd@scan.service disabled</span><br></pre></td></tr></tbody></table></figure><p>这个列表显示每个配置文件的状态，一共有四种。</p><ul><li>enabled：已建立启动链接</li><li>disabled：没建立启动链接</li><li>static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖</li><li>masked：该配置文件被禁止建立启动链接<blockquote><p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status bluetooth.service</span><br></pre></td></tr></tbody></table></figure></blockquote></li></ul><p>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart httpd.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="配置文件的格式"><a href="#配置文件的格式" class="headerlink" title="配置文件的格式"></a>配置文件的格式</h4><p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p><p><code>systemctl cat</code>命令可以查看配置文件的内容。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl cat atd.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="unit-配置文件"><a href="#unit-配置文件" class="headerlink" title="unit 配置文件"></a>unit 配置文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=ATD daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/bin/atd</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。</span><br><span class="line">每个区块内部是一些等号连接的键值对。</span><br><span class="line"></span><br><span class="line">[Section]</span><br><span class="line">Directive1=value</span><br><span class="line">Directive2=value</span><br><span class="line"></span><br><span class="line">. . .</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意，键值对的等号两侧不能有空格。</p></blockquote><h4 id="配置文件的区域"><a href="#配置文件的区域" class="headerlink" title="配置文件的区域"></a>配置文件的区域</h4><p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p><ul><li>Description：简短描述</li><li>Documentation：文档地址</li><li>Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li><li>Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li><li>BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li><li>Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li><li>After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li><li>Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行</li><li>Condition…：当前 Unit 运行必须满足的条件，否则不会运行</li><li>Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败</li></ul><p><code>[Install]</code>通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><ul><li>WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</li><li>RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</li><li>Alias：当前 Unit 可用于启动的别名</li><li>Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li></ul><p><code>[Service]</code>区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><ul><li>Type：定义启动时的进程行为。它有以下几种值。</li><li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li><li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li><li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li><li>Type=dbus：当前服务通过D-Bus启动</li><li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li><li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li><li>ExecStart：启动当前服务的命令</li><li>ExecStartPre：启动当前服务之前执行的命令</li><li>ExecStartPost：启动当前服务之后执行的命令</li><li>ExecReload：重启当前服务时执行的命令</li><li>ExecStop：停止当前服务时执行的命令</li><li>ExecStopPost：停止当其服务之后执行的命令</li><li>RestartSec：自动重启当前服务间隔的秒数</li><li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li><li>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</li><li>Environment：指定环境变量</li></ul><blockquote><p>Unit 配置文件的完整字段清单，请参考官方文档。</p></blockquote><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。<br>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。<br>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><p>查看当前系统的所有 Target<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=target</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看一个 Target 包含的所有 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies multi-user.target</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看启动时的默认 Target<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置启动时的默认 Target<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">set</span>-default multi-user.target</span><br></pre></td></tr></tbody></table></figure><p></p><p>切换 Target 时，默认不关闭前一个 Target 启动的进程，<code>systemctl isolate</code> 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl isolate multi-user.target</span><br></pre></td></tr></tbody></table></figure><p></p><p>Target 与 传统 RunLevel 的对应关系如下。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Traditional runlevel New target name Symbolically linked to...</span><br><span class="line"></span><br><span class="line">Runlevel 0 | runlevel0.target -> poweroff.target</span><br><span class="line">Runlevel 1 | runlevel1.target -> rescue.target</span><br><span class="line">Runlevel 2 | runlevel2.target -> multi-user.target</span><br><span class="line">Runlevel 3 | runlevel3.target -> multi-user.target</span><br><span class="line">Runlevel 4 | runlevel4.target -> multi-user.target</span><br><span class="line">Runlevel 5 | runlevel5.target -> graphical.target</span><br><span class="line">Runlevel 6 | runlevel6.target -> reboot.target</span><br></pre></td></tr></tbody></table></figure><p></p><p>它与init进程的主要差别如下:</p><ol><li>默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li><li>启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</li><li>配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</li></ol><h4 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h4><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。</p><p><code>journalctl</code>功能强大，用法非常多。</p><p>查看所有日志（默认情况下 ，只保存本次启动的日志）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看内核日志（不显示应用日志）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -k</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看系统本次启动的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b</span><br><span class="line">journalctl -b -0</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看上一次启动的日志（需更改设置）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b -1</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定时间的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></span><br><span class="line">journalctl --since <span class="string">"20 min ago"</span></span><br><span class="line">journalctl --since yesterday</span><br><span class="line">journalctl --since <span class="string">"2015-01-10"</span> --until <span class="string">"2015-01-11 03:00"</span></span><br><span class="line">journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>显示尾部的最新10行日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -n</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示尾部指定行数的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -n 20</span><br></pre></td></tr></tbody></table></figure><p></p><p>实时滚动显示最新日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -f</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定服务的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl /usr/lib/systemd/systemd</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定进程的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl _PID=1</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看某个路径的脚本的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl /usr/bin/bash</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定用户的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl _UID=33 --since today</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看某个 Unit 的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service</span><br><span class="line">journalctl -u nginx.service --since today</span><br></pre></td></tr></tbody></table></figure><p></p><p>实时滚动显示某个 Unit 的最新日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service -f</span><br></pre></td></tr></tbody></table></figure><p></p><p>合并显示多个 Unit 的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service -u php-fpm.service --since today</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定优先级（及其以上级别）的日志，共有8级</p><ol start="0"><li>0:emerg</li><li>1:alert</li><li>2:crit</li><li>3:err</li><li>4:warning</li><li>5:notice</li><li>6:info</li><li>7:debug<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -p err -b</span><br></pre></td></tr></tbody></table></figure></li></ol><p>日志默认分页输出，–no-pager 改为正常的标准输出<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --no-pager</span><br></pre></td></tr></tbody></table></figure><p></p><p>以 JSON 格式（单行）输出<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b -u nginx.service -o json</span><br></pre></td></tr></tbody></table></figure><p></p><p>以 JSON 格式（多行）输出，可读性更好<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b -u nginx.serviceqq -o json-pretty</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示日志占据的硬盘空间<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --disk-usage</span><br></pre></td></tr></tbody></table></figure><p></p><p>指定日志文件占据的最大空间<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --vacuum-size=1G</span><br></pre></td></tr></tbody></table></figure><p></p><p>指定日志文件保存多久<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --vacuum-time=1years</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看最消耗CPU和内存的进程</title>
    <link href="https://jiemin.wang/2019/04/22/cpu-memory/"/>
    <id>https://jiemin.wang/2019/04/22/cpu-memory/</id>
    <published>2019-04-22T05:11:18.000Z</published>
    <updated>2019-04-22T06:12:12.052Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>真正努力过的人才知道，智商上的差距是不可逾越的。</strong></p></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li><p>CPU占用最多的前10个进程： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|head -1;ps auxw|sort -rn -k3|head -10</span><br></pre></td></tr></tbody></table></figure></li><li><p>内存消耗最多的前10个进程 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|head -1;ps auxw|sort -rn -k4|head -10</span><br></pre></td></tr></tbody></table></figure></li><li><p>虚拟内存使用最多的前10个进程 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|head -1;ps auxw|sort -rn -k5|head -10</span><br></pre></td></tr></tbody></table></figure></li></ol><p>几个参数含义:</p><ul><li>%MEM 进程的内存占用率</li><li>VSZ 进程所使用的虚存的大小</li><li>RSS 进程使用的驻留集大小或者是实际内存的大小(RSS is the “resident set size” meaning physical memory used)</li><li>TTY 与进程关联的终端（tty）</li><li>串行端口终端（/dev/ttySn）</li><li>伪终端（/dev/pty/）</li><li>控制终端（/dev/tty）</li><li>控制台终端（/dev/ttyn, /dev/console）</li><li>虚拟终端(/dev/pts/n)</li><li>STAT 检查的状态：进程状态使用字符表示的，如R（running正在运行或准备运行）、S（sleeping睡眠）、I（idle空闲）、Z (僵死)、D（不可中断的睡眠，通常是I/O）、P（等待交换页）、W（换出,表示当前页面不在内存）、N（低优先级任务）T(terminate终止)、W has no resident pages</li><li>D 不可中断 Uninterruptible sleep (usually IO)</li><li>R 正在运行，或在队列中的进程</li><li>S 处于休眠状态</li><li>T 停止或被追踪</li><li>Z 僵尸进程</li><li>W 进入内存交换（从内核2.6开始无效）</li><li>X 死掉的进程</li><li>< 高优先级</li><li>N 低优先级</li><li>L 有些页被锁进内存</li><li>s 包含子进程</li></ul><p>位于后台的进程组</p><ul><li>l 多线程</li><li>克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx查看截取切割日志</title>
    <link href="https://jiemin.wang/2019/04/22/nginx-log/"/>
    <id>https://jiemin.wang/2019/04/22/nginx-log/</id>
    <published>2019-04-22T05:07:39.000Z</published>
    <updated>2019-04-22T06:11:27.300Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="AAA.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>这个世界没有错，谁让你长得不好看又没钱。</strong></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>nginx日志最好实现每天定时切割下，特别是在访问量比较大的时候，方便查看与处理，如果没切割，可以用sed直接切割</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查找7月17日访问log导出到17.log文件中<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat gelin_web_access.log | egrep <span class="string">"17/Jul/2017"</span> | sed  -n <span class="string">'/00:00:00/,/23:59:59/p'</span> > /tmp/17.log</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看访问量前10的IP<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $1}'</span> 17.log | sort | uniq -c | sort -nr | head -n 10</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看访问前10的URL<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $11}'</span> gelin_web_access.log | sort | uniq -c | sort -nr | head -n 10</span><br></pre></td></tr></tbody></table></figure><p></p><p>查询访问最频繁的URL<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $7}'</span> gelin_web_access.log | sort | uniq -c | sort -n -k 1 -r | more</span><br></pre></td></tr></tbody></table></figure><p></p><p>查询访问最频繁的IP<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $1}'</span> gelin_web_access.log | sort | uniq -c | sort -n -k 1 -r | more</span><br></pre></td></tr></tbody></table></figure><p></p><p>根据访问IP统计UV<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $1}'</span> gelin_web_access.log | sort | uniq -c | wc -l</span><br></pre></td></tr></tbody></table></figure><p></p><p>统计访问URL统计PV<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $7}'</span> gelin_web_access.log | wc -l</span><br></pre></td></tr></tbody></table></figure><p></p><p>根据时间段统计查看日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat gelin_web_access.log | sed -n <span class="string">'/17\/Jul\/2017:12/,/17\/Jul\/2017:13/p'</span> | more</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;AAA.jpg&quot; class=&quot;full-image&quot; alt=&quot;al
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux iptables 整理</title>
    <link href="https://jiemin.wang/2019/04/22/linux-iptables/"/>
    <id>https://jiemin.wang/2019/04/22/linux-iptables/</id>
    <published>2019-04-22T04:51:19.000Z</published>
    <updated>2019-04-22T06:10:30.728Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>你总嫌有些人懒，说得好像你勤快了就真能干出什么大事儿一样。</strong></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>iptables是Linux中重要的访问控制手段，是俗称的 Linux 防火墙系统的重要组成部分。这里记录了iptables 防火墙规则的一些常用的操作指令。</p><p>iptables的基本语法：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t filter/nat] [-A/I] [INPUT/OUTPUT/FORWARD] [-i/o interface] [-p tcp/udp/icmp/all] [-s ip/network] [--sport ports] [-d ip/network] [--dport ports] [-j ACCEPT/DROP]</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">参数说明:</span><br><span class="line">     不加-t时默认是filter</span><br><span class="line">     </span><br><span class="line">     语法参数：</span><br><span class="line">     -I：第一行插入</span><br><span class="line">     -A：最后追加 </span><br><span class="line">     -i/o：指的是数据要进入或出去所要经过的端口，如eth1,eth0,pppoe等</span><br><span class="line">     -p：你所要指定的协议 </span><br><span class="line">     -s：指定来源ip，可以是单个ip如192.168.109.131，也可以是一个网络 192.168.109.0/24，还可以是一个域名如163.com，如果你填写的是域名系统会自动解析出他的ip并在iptables里显示</span><br><span class="line">     --sport：来源端口 </span><br><span class="line">     -d：指定目标ip</span><br><span class="line">     --dport：目标端口 </span><br><span class="line">     -j：执行参数ACCEPT或DROP，REJECT一般不用</span><br><span class="line">     -A 在指定链的末尾添加（append）一条新的规则</span><br><span class="line">     -D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除</span><br><span class="line">     -I 在指定链中插入（insert）一条新的规则，默认在第一行添加</span><br><span class="line">     -R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换</span><br><span class="line">     -L 列出（list）指定链中所有的规则进行查看</span><br><span class="line">     -E 重命名用户定义的链，不改变链本身</span><br><span class="line">     -F 清空（flush）</span><br><span class="line">     -N 新建（new-chain）一条用户自己定义的规则链</span><br><span class="line">     -X 删除指定表中用户自定义的规则链（delete-chain）</span><br><span class="line">     -P 设置指定链的默认策略（policy）</span><br><span class="line">     -Z 将所有表的所有链的字节和数据包计数器清零</span><br><span class="line">     -n 使用数字形式（numeric）显示输出结果</span><br><span class="line">     -v 查看规则表详细信息（verbose）的信息</span><br><span class="line">     -V 查看版本(version)</span><br><span class="line">     -h 获取帮助（<span class="built_in">help</span>）</span><br></pre></td></tr></tbody></table></figure><p>如果配置的是INPUT（进入）,则来源ip是运程ip，目标端口就是本机；OUTPUT相反</p><img src="/2019/04/22/linux-iptables/iptables.jpeg" title="iptables"><img src="/2019/04/22/linux-iptables/iptables1.png" title="iptables1"><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>当数据包到达目标主机时，经过PREROUTING链,经路由之后决定是否转发，不转发则进入INPUT链，到达用户空间。进程对外通信时，经由OUTPUT链出去，路由之后到达POSTROUTING链，经网卡出去。当一数据包经过PREROUTING链发现其不是到达本主机，那么数据包经过FORWARD链，到达 POSTROUTING链转发出去。本机进程对发送数据时，经由OUTPUT链路由之后进入POSTROUTING链出去。<br>iptables匹配规则时，是自上而下匹配的，匹配到第一条规则时既跳出，否则一直往下匹配，没有则使用默认规则。<br>iptables规则建立时，首先需要确定功能（表），确定报文流向，确定要实现的目标，确定匹配条件。<br>尽量遵循以下规则：尽量减少规则条目，彼此间无关联，访问条目大放上面，有关联（同一功能），规则更严格的放上面</p><p>五个hook函数分别是<code>PREROUTING</code>,<code>INPUT</code> ,<code>OUTPUT</code>,<code>POSTROUTING</code>,<code>FORWARD</code>，我们把这五个钩子函数称为链，Netfilter实现了几功能，<code>raw</code> ，<code>mangle</code>，<code>nat</code>，<code>filter</code>。我们一般把这几个功能称为表，表之间有优先级关系，从低到高为<code>filter—-nat—-mangle—-raw</code>,表与链之间有对应关系，具体见图表。<br><img src="/2019/04/22/linux-iptables/iptables-hook.png" title="iptables-hook"></p><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul><li>raw表： 对报文设置一个标志，决定数据包是否被状态跟踪机制处理</li><li>mangle表： 主要用于修改数据包</li><li>nat表： 主要用处是网络地址转换、端口映射</li><li>fileter表： 主要用于过滤包</li></ul><p>一般情况我们对filter表做配置的更多。</p><h4 id="链"><a href="#链" class="headerlink" title="链"></a>链</h4><ul><li>INPUT： 作用于进入本机的包</li><li>OUTPUT： 作用于本机送出的包 </li><li>FORWARD： 匹配穿过本机的数据包（转发） </li><li>PREROUTING： 用于修改目的地址（DNAT） </li><li>POSTROUTING：用于修改源地址 （SNAT）</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">启动指令:service iptables start    </span><br><span class="line">重启指令:service iptables restart    </span><br><span class="line">关闭指令:service iptables stop</span><br><span class="line">保存指令:service iptables save</span><br><span class="line">清除规则：iptables -F   </span><br><span class="line">将链的记数的流量清零: iptables -Z</span><br><span class="line">清除链: iptables -X</span><br><span class="line">清空iptables时一般-F -Z -X一起使用</span><br></pre></td></tr></tbody></table></figure><h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><ul><li>ACCEPT 允许</li><li>DROP 丢弃</li><li>REJECT 拒绝</li></ul><p>ROP和REJECT的区别：DROP是直接不让进入，而REJECT是先让进入然后再拒绝，LOG在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则.</p><p>DROP更安全，所以一般拒绝都用DROP</p><p>-A默认是插入到尾部的，可以-I来插入到指定位置</p><p>iptables的两种配置思路:</p><ol><li>默认允许，拒绝特别</li><li>默认拒绝，允许特别</li></ol><p>二者都有自己的特点，看情况而定。但是注意：如果要选择第二种配置思路，配置前切记先把ssh设置为ACCEPT，因为一般机器不在我们身边，一旦配置默认拒绝，那我们的远程登录就会断开连接，那问题就大了。<br>配置默认拒绝前设置:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT    </span><br><span class="line">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>还有一种方法：做一个计划任务，让iptables定期停止，即执行service iptables stop，这样的话即使配置默认拒绝前没有允许ssh也没关系，等到计划任务生效的时间iptables就会自动清除所有的配置，包括默认规则。</p><p>iptables的执行优先级:</p><ul><li>iptables的执行顺序是自上而下，当有配置产生冲突时，前面执行的生效。</li></ul><p>删除iptables规则<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT 3  //删除input的第3条规则</span><br><span class="line">iptables -t nat -D POSTROUTING 1  //删除nat表中postrouting的第一条规则</span><br><span class="line">iptables -F INPUT   //清空 filter表INPUT所有规则</span><br><span class="line">iptables -F    //清空所有规则</span><br><span class="line">iptables -t nat -F POSTROUTING   //清空nat表POSTROUTING所有规则</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h2><p>第一种方法：修改配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line">删除相应的行，然后</span><br><span class="line">service iptables restart </span><br><span class="line">service iptables save</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>注意:</p></blockquote><blockquote><p>修改完配置文件不能先save，一定要先restart才能save，要不然就白做了。因为save会在iptables服务启动时重新加载，要是在重启之前直接先调用了service iptables save 那么你的/etc/sysconfig/iptables 配置就回滚到上次启动服务的配置了。</p></blockquote><p>第二种方法：直接用命令删除</p><p>如果你记得配置时的写法，那么可以直接<code>iptables -D</code> 后跟上配置时的写法。如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT -s 10.72.11.12 -p tcp --sport 1234 -d 10.10.2.58 --dport 80 -j DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>或者查看每条iptables的序号<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -L INPUT --line-numbers</span><br><span class="line">然后删除</span><br><span class="line">iptables -D INPUT 2  <span class="comment">#删除第2条规则，即时生效</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="防火墙常用的策略"><a href="#防火墙常用的策略" class="headerlink" title="防火墙常用的策略"></a>防火墙常用的策略</h2><p>拒绝进入防火墙的所有ICMP协议数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p icmp -j REJECT</span><br></pre></td></tr></tbody></table></figure><p></p><p>允许防火墙转发除ICMP协议以外的所有数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -p ! icmp -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/24网段的数据<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -s 192.168.1.11 -j REJECT </span><br><span class="line">iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP </span><br><span class="line">iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP </span><br><span class="line">iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>封堵网段（192.168.1.0/24），两小时后解封。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 10.20.30.0/24 -j DROP </span><br><span class="line">iptables -I FORWARD -s 10.20.30.0/24 -j DROP </span><br><span class="line">at now 2 hours at> iptables -D INPUT 1 at> iptables -D FORWARD 1</span><br></pre></td></tr></tbody></table></figure><p></p><p>只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT </span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>允许本机开放从TCP端口20-1024提供的应用服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT </span><br><span class="line">iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT </span><br><span class="line">iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p icmp --icmp-type Echo-Request -j DROP </span><br><span class="line">iptables -I INPUT -p icmp --icmp-type Echo-Reply -j ACCEPT </span><br><span class="line">iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>禁止转发来自MAC地址为00：0C：29：27：55：3F的和主机的数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP</span><br><span class="line">说明：iptables中使用“-m 模块关键字”的形式调用显示匹配。这里用“-m mac –mac-source”来表示数据包的源MAC地址。</span><br></pre></td></tr></tbody></table></figure><p></p><p>允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT</span><br><span class="line">说明：这里用“-m multiport –dport”来指定目的端口及范围</span><br></pre></td></tr></tbody></table></figure><p></p><p>禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP</span><br><span class="line">说明：此处用“-m –iprange –src-range”指定IP范围。</span><br></pre></td></tr></tbody></table></figure><p></p><p>禁止转发与正常TCP连接无关的非—syn请求数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -m state --state NEW -p tcp ! --syn -j DROP</span><br><span class="line">说明：“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关的</span><br></pre></td></tr></tbody></table></figure><p></p><p>拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m state --state NEW -j DROP </span><br><span class="line">iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>说明：“ESTABLISHED”表示已经响应请求或者已经建立连接的数据包，“RELATED”表示与已建立的连接有相关性的，比如FTP数据连接等。</p><p>只开放本机的web服务（80）、FTP(20、21、20450-20480)，放行外部主机发住服务器其它端口的应答数据包，将其他入站数据包均予以丢弃处理。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp -m multiport --dport 20,21,80 -j ACCEPT </span><br><span class="line">iptables -I INPUT -p tcp --dport 20450:20480 -j ACCEPT </span><br><span class="line">iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT </span><br><span class="line">iptables -P INPUT DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>下面两句话可以定义默认全部丢弃数据包：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>-P参数的意思是policy，翻译成策略～那么这两句话就好理解了。</p><p>第一句的意思是：</p><p>输入(INPUT)的数据包默认的策略(-P)是丢弃(DROP)的</p><p>第二句的意思是：</p><p>输出(OUTPUT)的数据包默认的策略(-P)是丢弃(DROP)的</p><p>其实到这里已经是一个有用的防火墙了，只不过，没有什么意义，和拔掉网线的概念没有什么不同</p><p>首先写下这6句话<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type any -j ACCEPT</span><br><span class="line">允许icmp包进入</span><br><span class="line">iptables -A INPUT -s localhost -d localhost -j ACCEPT</span><br><span class="line">允许本地的数据包</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">允许已经建立和相关的数据包进入</span><br><span class="line">iptables -A OUTPUT -p icmp --icmp any -j ACCEPT</span><br><span class="line">允许icmp包出去</span><br><span class="line">iptables -A OUTPUT -s localhost -d localhost -j ACCEPT</span><br><span class="line">允许本地数据包</span><br><span class="line">iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">允许已经建立和相关的数据包出去</span><br></pre></td></tr></tbody></table></figure><p></p><p>说明一下，这6句基本上都是要的</p><p>查看nat表<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -vnL POSTROUTING --line-number  </span><br><span class="line">Chain POSTROUTING (policy ACCEPT 38 packets, 2297 bytes)  </span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination  </span><br><span class="line">1        0     0 MASQUERADE  all  --  *      *       192.168.10.0/24      0.0.0.0/0</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看filter表<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n --line-number |grep 21 //--line-number可以显示规则序号，在删除的时候比较方便  </span><br><span class="line">5    ACCEPT     tcp  --  192.168.1.0/24       0.0.0.0/0           tcp dpt:21</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="附最经典的iptables脚本"><a href="#附最经典的iptables脚本" class="headerlink" title="附最经典的iptables脚本"></a>附最经典的iptables脚本</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">modprobe ipt_MASQUERADE</span><br><span class="line">modprobe ip_conntrack_ftp</span><br><span class="line">modprobe ip_nat_ftp</span><br><span class="line">iptables -F</span><br><span class="line">iptables -t nat -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -t nat -X</span><br><span class="line"><span class="comment">###########################INPUT键###################################</span></span><br><span class="line"></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -m multiport --dports 110,80,25 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -s 192.168.0.0/24 --dport 139 -j ACCEPT</span><br><span class="line"><span class="comment">#允许内网samba,smtp,pop3,连接</span></span><br><span class="line">iptables -A INPUT -i eth1 -p udp -m multiport --dports 53 -j ACCEPT</span><br><span class="line"><span class="comment">#允许dns连接</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 1723 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p gre -j ACCEPT</span><br><span class="line"><span class="comment">#允许外网vpn连接</span></span><br><span class="line">iptables -A INPUT -s 192.186.0.0/24 -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -A INPUT -i ppp0 -p tcp --syn -m connlimit --connlimit-above 15 -j DROP</span><br><span class="line"><span class="comment">#为了防止DOS太多连接进来,那么可以允许最多15个初始连接,超过的丢弃</span></span><br><span class="line">iptables -A INPUT -s 192.186.0.0/24 -p tcp --syn -m connlimit --connlimit-above 15 -j DROP</span><br><span class="line"><span class="comment">#为了防止DOS太多连接进来,那么可以允许最多15个初始连接,超过的丢弃</span></span><br><span class="line">iptables -A INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/s -j LOG --<span class="built_in">log</span>-level INFO --<span class="built_in">log</span>-prefix <span class="string">"ICMP packet IN: "</span></span><br><span class="line">iptables -A INPUT -p icmp -j DROP</span><br><span class="line"><span class="comment">#禁止icmp通信-ping 不通</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o ppp0 -s 192.168.0.0/24 -j MASQUERADE</span><br><span class="line"><span class="comment">#内网转发</span></span><br><span class="line">iptables -N syn-flood</span><br><span class="line">iptables -A INPUT -p tcp --syn -j syn-flood</span><br><span class="line">iptables -I syn-flood -p tcp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/s --<span class="built_in">limit</span>-burst 6 -j RETURN</span><br><span class="line">iptables -A syn-flood -j REJECT</span><br><span class="line"><span class="comment">#防止SYN攻击 轻量</span></span><br><span class="line"><span class="comment">#######################FORWARD链###########################</span></span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -A FORWARD -p tcp -s 192.168.0.0/24 -m multiport --dports 80,110,21,25,1723 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p udp -s 192.168.0.0/24 --dport 53 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p gre -s 192.168.0.0/24 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p icmp -s 192.168.0.0/24 -j ACCEPT</span><br><span class="line"><span class="comment">#允许 vpn客户走vpn网络连接外网</span></span><br><span class="line">iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -I FORWARD -p udp --dport 53 -m string --string <span class="string">"tencent"</span> -m time --timestart 8:15 --timestop 12:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的8:00-12:30禁止qq通信</span></span><br><span class="line">iptables -I FORWARD -p udp --dport 53 -m string --string <span class="string">"TENCENT"</span> -m time --timestart 8:15 --timestop 12:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的8:00-12:30禁止qq通信</span></span><br><span class="line">iptables -I FORWARD -p udp --dport 53 -m string --string <span class="string">"tencent"</span> -m time --timestart 13:30 --timestop 20:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line">iptables -I FORWARD -p udp --dport 53 -m string --string <span class="string">"TENCENT"</span> -m time --timestart 13:30 --timestop 20:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的13:30-20:30禁止QQ通信</span></span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/24 -m string --string <span class="string">"qq.com"</span> -m time --timestart 8:15 --timestop 12:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的8:00-12:30禁止qq网页</span></span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/24 -m string --string <span class="string">"qq.com"</span> -m time --timestart 13:00 --timestop 20:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的13:30-20:30禁止QQ网页</span></span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/24 -m string --string <span class="string">"ay2000.net"</span> -j DROP</span><br><span class="line">iptables -I FORWARD -d 192.168.0.0/24 -m string --string <span class="string">"宽频影院"</span> -j DROP</span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/24 -m string --string <span class="string">"色情"</span> -j DROP</span><br><span class="line">iptables -I FORWARD -p tcp --sport 80 -m string --string <span class="string">"广告"</span> -j DROP</span><br><span class="line"><span class="comment">#禁止ay2000.net，宽频影院，色情，广告网页连接 ！但中文 不是很理想</span></span><br><span class="line">iptables -A FORWARD -m ipp2p --edk --kazaa --bit -j DROP</span><br><span class="line">iptables -A FORWARD -p tcp -m ipp2p --ares -j DROP</span><br><span class="line">iptables -A FORWARD -p udp -m ipp2p --kazaa -j DROP</span><br><span class="line"><span class="comment">#禁止BT连接</span></span><br><span class="line">iptables -A FORWARD -p tcp --syn --dport 80 -m connlimit --connlimit-above 15 --connlimit-mask 24</span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">sysctl -w net.ipv4.ip_forward=1 &>/dev/null</span><br><span class="line"><span class="comment">#打开转发</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies=1 &>/dev/null</span><br><span class="line"><span class="comment">#打开 syncookie （轻量级预防 DOS 攻击）</span></span><br><span class="line">sysctl -w net.ipv4.netfilter.ip_conntrack_tcp_timeout_established=3800 &>/dev/null</span><br><span class="line"><span class="comment">#设置默认 TCP 连接痴呆时长为 3800 秒（此选项可以大大降低连接数）</span></span><br><span class="line">sysctl -w net.ipv4.ip_conntrack_max=300000 &>/dev/null</span><br><span class="line"><span class="comment">#设置支持最大连接树为 30W（这个根据你的内存和 iptables 版本来，每个 connection 需要 300 多个字节）</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">iptables -I INPUT -s 192.168.0.50 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -s 192.168.0.50 -j ACCEPT</span><br><span class="line"><span class="comment">#192.168.0.50是我的机子，全部放行！</span></span><br><span class="line"><span class="comment">############################完#########################################</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.gif&quot; class=&quot;full-image&quot; alt=&quot;a
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux awk 命令</title>
    <link href="https://jiemin.wang/2019/04/22/linux-awk/"/>
    <id>https://jiemin.wang/2019/04/22/linux-awk/</id>
    <published>2019-04-22T04:45:12.000Z</published>
    <updated>2019-04-22T06:09:00.982Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="AAA.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>对今天解决不了的事情，也不要着急。因为明天也可能还是解决不了。</strong></p></blockquote><h2 id="awk命令例子："><a href="#awk命令例子：" class="headerlink" title="awk命令例子："></a>awk命令例子：</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打印文件的第一列(域)  awk <span class="string">'{print $1}'</span> filename</span><br><span class="line">打印文件的前两列(域)  awk <span class="string">'{print $1,$2}'</span> filename</span><br><span class="line">打印完第一列，然后打印第二列  awk <span class="string">'{print $1 $2}'</span> filename</span><br><span class="line">打印文本文件的总行数  awk <span class="string">'END{print NR}'</span> filename</span><br><span class="line">打印文本第一行       awk <span class="string">'NR==1{print}'</span> filename</span><br><span class="line">打印文本第二行第一列  sed -n <span class="string">"2, 1p"</span> filename | awk <span class="string">'print $1'</span></span><br></pre></td></tr></tbody></table></figure><p>Bash里面的赋值方法有两种，格式为<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) arg=`(命令)`</span><br><span class="line">2) arg=$(命令)</span><br></pre></td></tr></tbody></table></figure><p></p><p>想要把某一文件的总行数赋值给变量nlines，可以表达为：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) nlines=`(awk <span class="string">'END{print NR}'</span> filename)`</span><br><span class="line">或</span><br><span class="line">2) nlines=$(awk <span class="string">'END{print NR}'</span> filename)</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/[^0-9][0-9].*Starting the backup operation/{print $1,$2}'</span> /data/backup/logs/all.log</span><br><span class="line"><span class="comment">#181217 02:12:48</span></span><br><span class="line"><span class="comment">#181217 02:12:48 innobackupex: Starting the backup operation</span></span><br><span class="line">awk <span class="string">'/[^0-9][0-9].*OK\!/{print $1,$2}'</span> /data/backup/logs/all.log</span><br><span class="line"><span class="comment">#181217 03:51:21</span></span><br><span class="line"><span class="comment">#181217 03:51:21 completed OK!</span></span><br></pre></td></tr></tbody></table></figure><p>时间相减<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN{tstamp1=mktime("2108 12 18 02 12 48");tstamp2=mktime("2018 12 19 03 51 12");print tstamp2-tstamp1;}'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>从库周期性延迟 需要你从binlog中找出找个binlog 各种操作的统计<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --base64-output=<span class="string">'decode-rows'</span> -v -v mysql-bin.004177 | awk <span class="string">'/UPDATE|INSERT|DELETE/{gsub("###","");gsub("INSERT.*INTO","INSERT");gsub("DELETE.*FROM","DELETE");count[$1" "$2]++}END{for(i in count)print i,"\t",count[i]}'</span> |sort -k3nr|head -n 20</span><br></pre></td></tr></tbody></table></figure><p></p><p>netstat and AWK<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | awk <span class="string">'/^tcp/ {++S[$NF]};END {for(a in S) print a,S[a]}'</span></span><br><span class="line">netstat -an | awk <span class="string">'/^tcp/ {++state[$NF]}; END {for(key in state) print key,"\t",state[key]}'</span></span><br><span class="line">netstat -ant | awk <span class="string">'{print $NF}'</span> | grep -v <span class="string">'[a-z]'</span> | sort | uniq -c</span><br><span class="line"></span><br><span class="line">netstat -anlp | grep 3306 | grep tcp | awk <span class="string">'{print $5}'</span> | awk -F: <span class="string">'{print $1}'</span> | sort | uniq -c | sort -nr | head -n20</span><br><span class="line">netstat -ant | awk <span class="string">'/:3306/{split($5,ip,":");++A[ip[1]]}END{for(i in A) print A[i],i}'</span> | sort -nr | head -n20</span><br><span class="line"></span><br><span class="line">netstat -an | grep SYN | awk <span class="string">'{print $5}'</span> | awk -F: <span class="string">'{print $1}'</span> | sort | uniq -c | sort -nr | more</span><br><span class="line">tcpdump -i eno16777736 -tnn dst port 80 -c 1000 | awk -F<span class="string">"."</span> <span class="string">'{print $1"."$2"."$3"."$4}'</span> | sort | uniq -c | sort -nr | head -20</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看表的大小排序<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du -s *|grep ibd|sort|uniq -u|sort -nr|awk <span class="string">'{print $2}'</span>|xargs du -sh</span><br><span class="line">du -s *|grep ibd|sort|uniq -u|sort -nr|awk <span class="string">'{print $2}'</span>|sort|uniq -u|xargs du -sh</span><br></pre></td></tr></tbody></table></figure><p></p><p>僵尸进程<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -o <span class="built_in">stat</span>,ppid,pid,cmd | grep -e <span class="string">'\'</span><span class="string">'^[Zz]'</span>\<span class="string">''</span> | awk <span class="string">'\'</span><span class="string">'{print }'</span>\<span class="string">''</span> | xargs <span class="built_in">kill</span> -9<span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;AAA.jpg&quot; class=&quot;full-image&quot; alt=&quot;al
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用FIO测试主机IOPS及写入读取速度</title>
    <link href="https://jiemin.wang/2019/04/22/linux-fio/"/>
    <id>https://jiemin.wang/2019/04/22/linux-fio/</id>
    <published>2019-04-22T02:30:01.000Z</published>
    <updated>2019-04-22T03:27:56.215Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>别说你一无所长，熬夜玩手机你是一把好手。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安装FIO<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install fio -y</span><br></pre></td></tr></tbody></table></figure><p></p><p>参数说明:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bs=4k                    单次io的块文件大小为4k</span><br><span class="line">bsrange=512-2048         同上，提定数据块的大小范围</span><br><span class="line">size=5g                  本次的测试文件大小为5g，以每次4k的io进行测试</span><br><span class="line">numjobs=30               本次的测试线程为30</span><br><span class="line">runtime=1000             测试时间为1000秒，如果不写则一直将5g文件分4k每次写完为止</span><br><span class="line">ioengine=psync           io引擎使用pync方式，如果要使用libaio引擎，需要yum install libaio-devel包</span><br><span class="line">rwmixwrite=30            在混合读写的模式下，写占30%</span><br><span class="line">group_reporting          关于显示结果的，汇总每个进程的信息此外</span><br><span class="line">lockmem=1g               只使用1g内存进行测试</span><br><span class="line">zero_buffers             用0初始化系统buffer</span><br><span class="line">nrfiles=8                每个进程生成文件的数量</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="FIO-命令"><a href="#FIO-命令" class="headerlink" title="FIO 命令"></a>FIO 命令</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">fio -direct=1 -iodepth=128 -rw=write -ioengine=libaio -bs=4k -size=100G -numjobs=1 -runtime=1000 -group_reporting -name=<span class="built_in">test</span> -filename=/data/test111</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="built_in">test</span>: (g=0): rw=write, bs=4K-4K/4K-4K/4K-4K, ioengine=libaio, iodepth=128</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 1 process</span><br><span class="line"><span class="built_in">test</span>: Laying out IO file(s) (1 file(s) / 102400MB)</span><br><span class="line">Jobs: 1 (f=1): [W] [100.0% <span class="keyword">done</span>] [0K/129.3M/0K /s] [0 /33.1K/0  iops] [eta 00m:00s]</span><br><span class="line"><span class="built_in">test</span>: (groupid=0, <span class="built_in">jobs</span>=1): err= 0: pid=594: Mon May 14 10:27:54 2018</span><br><span class="line">  write: io=102400MB, bw=129763KB/s, iops=32440 , runt=808070msec</span><br><span class="line">    slat (usec): min=0 , max=80322 , avg=12.06, stdev=24.73</span><br><span class="line">    clat (usec): min=222 , max=254410 , avg=3932.47, stdev=5007.90</span><br><span class="line">     lat (usec): min=622 , max=254416 , avg=3944.82, stdev=5007.26</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1288],  5.00th=[ 1560], 10.00th=[ 1736], 20.00th=[ 1992],</span><br><span class="line">     | 30.00th=[ 2224], 40.00th=[ 2480], 50.00th=[ 2736], 60.00th=[ 3088],</span><br><span class="line">     | 70.00th=[ 3536], 80.00th=[ 4320], 90.00th=[ 6624], 95.00th=[ 9664],</span><br><span class="line">     | 99.00th=[21120], 99.50th=[37632], 99.90th=[54528], 99.95th=[78336],</span><br><span class="line">     | 99.99th=[177152]</span><br><span class="line">    bw (KB/s)  : min=20720, max=215424, per=100.00%, avg=129801.50, stdev=19878.75</span><br><span class="line">    lat (usec) : 250=0.01%, 750=0.01%, 1000=0.09%</span><br><span class="line">    lat (msec) : 2=20.47%, 4=56.01%, 10=18.78%, 20=3.20%, 50=1.33%</span><br><span class="line">    lat (msec) : 100=0.09%, 250=0.02%, 500=0.01%</span><br><span class="line">  cpu          : usr=4.88%, sys=36.64%, ctx=9409837, majf=0, minf=23</span><br><span class="line">  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, >=64=100.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.1%</span><br><span class="line">     issued    : total=r=0/w=26214400/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">  WRITE: io=102400MB, aggrb=129763KB/s, minb=129763KB/s, maxb=129763KB/s, mint=808070msec, maxt=808070msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=0/26203032, merge=0/3962, ticks=0/90681446, in_queue=90672667, util=100.00%</span><br></pre></td></tr></tbody></table></figure><p>100%随机，100%读，4K<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=randread -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=rand_100read_4k</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">rand_100read_4k: (g=0): rw=randread, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">rand_100read_4k: (g=0): rw=randread, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr] [100.0% <span class="keyword">done</span>] [47544K/0K/0K /s] [11.9K/0 /0  iops] [eta 00m:00s]</span><br><span class="line">rand_100read_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=25884: Mon May 14 14:59:44 2018</span><br><span class="line">  <span class="built_in">read</span> : io=8454.3MB, bw=48091KB/s, iops=12022 , runt=180018msec</span><br><span class="line">    clat (usec): min=318 , max=167471 , avg=4156.60, stdev=8363.94</span><br><span class="line">     lat (usec): min=318 , max=167472 , avg=4156.89, stdev=8363.95</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1032],  5.00th=[ 1176], 10.00th=[ 1240], 20.00th=[ 1352],</span><br><span class="line">     | 30.00th=[ 1464], 40.00th=[ 1688], 50.00th=[ 1832], 60.00th=[ 1944],</span><br><span class="line">     | 70.00th=[ 2064], 80.00th=[ 2288], 90.00th=[15808], 95.00th=[18560],</span><br><span class="line">     | 99.00th=[20608], 99.50th=[39168], 99.90th=[134144], 99.95th=[144384],</span><br><span class="line">     | 99.99th=[156672]</span><br><span class="line">    bw (KB/s)  : min=  231, max= 7248, per=2.00%, avg=961.78, stdev=384.46</span><br><span class="line">    lat (usec) : 500=0.05%, 750=0.20%, 1000=0.51%</span><br><span class="line">    lat (msec) : 2=64.37%, 4=19.62%, 10=2.88%, 20=10.62%, 50=1.52%</span><br><span class="line">    lat (msec) : 100=0.02%, 250=0.23%</span><br><span class="line">  cpu          : usr=0.00%, sys=0.02%, ctx=1813752, majf=18446744073709550866, minf=18446744073698419008</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     issued    : total=r=2164296/w=0/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">   READ: io=8454.3MB, aggrb=48090KB/s, minb=48090KB/s, maxb=48090KB/s, mint=180018msec, maxt=180018msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=2163559/42, merge=23/10, ticks=8925036/223, in_queue=8922540, util=99.94%</span><br><span class="line">100%随机，100%写， 4K</span><br><span class="line"></span><br><span class="line">[root@<span class="built_in">test</span>-db data]<span class="comment"># fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=randwrite -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=rand_100write_4k</span></span><br><span class="line">运行结果：</span><br><span class="line">rand_100write_4k: (g=0): rw=randwrite, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">rand_100write_4k: (g=0): rw=randwrite, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww] [100.0% <span class="keyword">done</span>] [0K/47996K/0K /s] [0 /11.1K/0  iops] [eta 00m:00s]</span><br><span class="line">rand_100write_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=25963: Mon May 14 15:08:43 2018</span><br><span class="line">  write: io=8445.5MB, bw=48039KB/s, iops=12009 , runt=180024msec</span><br></pre></td></tr></tbody></table></figure><p></p><p>100%顺序，100%读 ，4K<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=<span class="built_in">read</span> -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=sqe_100read_4k</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">sqe_100read_4k: (g=0): rw=<span class="built_in">read</span>, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR] [100.0% <span class="keyword">done</span>] [59996K/0K/0K /s] [14.1K/0 /0  iops] [eta 00m:00s]</span><br><span class="line">sqe_100read_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=26047: Mon May 14 15:13:02 2018</span><br><span class="line">  <span class="built_in">read</span> : io=10599MB, bw=60295KB/s, iops=15073 , runt=180006msec</span><br><span class="line">    clat (usec): min=253 , max=550591 , avg=3315.70, stdev=26406.30</span><br><span class="line">     lat (usec): min=254 , max=550591 , avg=3315.95, stdev=26406.30</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1176],  5.00th=[ 1240], 10.00th=[ 1256], 20.00th=[ 1288],</span><br><span class="line">     | 30.00th=[ 1336], 40.00th=[ 1368], 50.00th=[ 1416], 60.00th=[ 1480],</span><br><span class="line">     | 70.00th=[ 1528], 80.00th=[ 1592], 90.00th=[ 1736], 95.00th=[ 2800],</span><br><span class="line">     | 99.00th=[17792], 99.50th=[18816], 99.90th=[522240], 99.95th=[528384],</span><br><span class="line">     | 99.99th=[536576]</span><br><span class="line">    bw (KB/s)  : min=   15, max= 2475, per=2.00%, avg=1206.47, stdev=634.32</span><br><span class="line">    lat (usec) : 500=0.01%, 750=0.01%, 1000=0.04%</span><br><span class="line">    lat (msec) : 2=92.64%, 4=3.87%, 10=1.05%, 20=2.03%, 50=0.01%</span><br><span class="line">    lat (msec) : 250=0.01%, 500=0.17%, 750=0.15%</span><br><span class="line">  cpu          : usr=0.05%, sys=0.23%, ctx=2697397, majf=0, minf=18446744073708900853</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     issued    : total=r=2713362/w=0/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">   READ: io=10599MB, aggrb=60294KB/s, minb=60294KB/s, maxb=60294KB/s, mint=180006msec, maxt=180006msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=2711304/55, merge=1805/10, ticks=8899022/202, in_queue=8898860, util=100.00%</span><br></pre></td></tr></tbody></table></figure><p></p><p>100%顺序，100%写 ，4K<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=write -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=sqe_100write_4k</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">sqe_100write_4k: (g=0): rw=write, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">sqe_100write_4k: (g=0): rw=write, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW] [100.0% <span class="keyword">done</span>] [0K/55788K/0K /s] [0 /13.1K/0  iops] [eta 00m:00s]</span><br><span class="line">sqe_100write_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=26100: Mon May 14 15:17:24 2018</span><br><span class="line">  write: io=10002MB, bw=56896KB/s, iops=14224 , runt=180019msec</span><br><span class="line">    clat (usec): min=583 , max=457330 , avg=3513.01, stdev=9958.13</span><br><span class="line">     lat (usec): min=584 , max=457331 , avg=3513.60, stdev=9958.13</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1224],  5.00th=[ 1384], 10.00th=[ 1480], 20.00th=[ 1592],</span><br><span class="line">     | 30.00th=[ 1672], 40.00th=[ 1752], 50.00th=[ 1832], 60.00th=[ 1928],</span><br><span class="line">     | 70.00th=[ 2096], 80.00th=[ 2480], 90.00th=[ 6368], 95.00th=[12480],</span><br><span class="line">     | 99.00th=[20608], 99.50th=[37120], 99.90th=[166912], 99.95th=[268288],</span><br><span class="line">     | 99.99th=[346112]</span><br><span class="line">    bw (KB/s)  : min=  152, max= 2432, per=2.01%, avg=1141.03, stdev=401.10</span><br><span class="line">    lat (usec) : 750=0.01%, 1000=0.11%</span><br><span class="line">    lat (msec) : 2=65.06%, 4=21.62%, 10=7.36%, 20=4.40%, 50=1.24%</span><br><span class="line">    lat (msec) : 100=0.08%, 250=0.06%, 500=0.07%</span><br><span class="line">  cpu          : usr=0.05%, sys=0.38%, ctx=2547790, majf=0, minf=18446744073708899536</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     issued    : total=r=0/w=2560604/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">  WRITE: io=10002MB, aggrb=56896KB/s, minb=56896KB/s, maxb=56896KB/s, mint=180019msec, maxt=180019msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=63/2558949, merge=0/275, ticks=12/8897256, in_queue=8895411, util=100.00%</span><br></pre></td></tr></tbody></table></figure><p></p><p>100%随机，70%读，30%写 4K<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=randrw -rwmixread=70 -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=randrw_70read_4k</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">randrw_70read_4k: (g=0): rw=randrw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">randrw_70read_4k: (g=0): rw=randrw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm] [100.0% <span class="keyword">done</span>] [48012K/20800K/0K /s] [12.3K/5200 /0  iops] [eta 00m:00s]</span><br><span class="line">randrw_70read_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=26162: Mon May 14 15:29:18 2018</span><br><span class="line">  <span class="built_in">read</span> : io=8430.4MB, bw=47954KB/s, iops=11988 , runt=180020msec</span><br><span class="line">    clat (usec): min=304 , max=177969 , avg=3045.60, stdev=5103.08</span><br><span class="line">     lat (usec): min=304 , max=177970 , avg=3045.87, stdev=5103.08</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[  860],  5.00th=[ 1048], 10.00th=[ 1160], 20.00th=[ 1320],</span><br><span class="line">     | 30.00th=[ 1448], 40.00th=[ 1560], 50.00th=[ 1656], 60.00th=[ 1768],</span><br><span class="line">     | 70.00th=[ 1896], 80.00th=[ 2128], 90.00th=[ 4384], 95.00th=[17792],</span><br><span class="line">     | 99.00th=[20352], 99.50th=[28544], 99.90th=[41216], 99.95th=[57088],</span><br><span class="line">     | 99.99th=[127488]</span><br><span class="line">    bw (KB/s)  : min=  206, max= 4424, per=2.00%, avg=959.77, stdev=408.18</span><br><span class="line">  write: io=3613.8MB, bw=20556KB/s, iops=5138 , runt=180020msec</span><br><span class="line">    clat (usec): min=569 , max=157336 , avg=2617.23, stdev=2821.20</span><br><span class="line">     lat (usec): min=570 , max=157337 , avg=2617.81, stdev=2821.20</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1096],  5.00th=[ 1432], 10.00th=[ 1592], 20.00th=[ 1768],</span><br><span class="line">     | 30.00th=[ 1912], 40.00th=[ 2040], 50.00th=[ 2160], 60.00th=[ 2288],</span><br><span class="line">     | 70.00th=[ 2416], 80.00th=[ 2576], 90.00th=[ 2864], 95.00th=[ 3472],</span><br><span class="line">     | 99.00th=[19328], 99.50th=[20352], 99.90th=[22400], 99.95th=[37632],</span><br><span class="line">     | 99.99th=[52992]</span><br><span class="line">    bw (KB/s)  : min=   62, max= 1888, per=2.00%, avg=411.23, stdev=178.61</span><br><span class="line">    lat (usec) : 500=0.06%, 750=0.22%, 1000=2.28%</span><br><span class="line">    lat (msec) : 2=61.13%, 4=27.68%, 10=3.02%, 20=4.48%, 50=1.07%</span><br><span class="line">    lat (msec) : 100=0.04%, 250=0.01%</span><br><span class="line">  cpu          : usr=0.01%, sys=0.08%, ctx=2743663, majf=0, minf=18446744073698904078</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     issued    : total=r=2158165/w=925122/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">   READ: io=8430.4MB, aggrb=47953KB/s, minb=47953KB/s, maxb=47953KB/s, mint=180020msec, maxt=180020msec</span><br><span class="line">  WRITE: io=3613.8MB, aggrb=20555KB/s, minb=20555KB/s, maxb=20555KB/s, mint=180020msec, maxt=180020msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=2154562/923535, merge=0/0, ticks=6503566/2394699, in_queue=8896553, util=99.93%</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行结果说明:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">io=执行了多少M的IO</span><br><span class="line">bw=平均IO带宽</span><br><span class="line">iops=IOPS</span><br><span class="line">runt=线程运行时间</span><br><span class="line">slat=提交延迟</span><br><span class="line">clat=完成延迟</span><br><span class="line">lat=响应时间</span><br><span class="line">bw=带宽</span><br><span class="line">cpu=利用率</span><br><span class="line">IO depths=io队列</span><br><span class="line">IO submit=单个IO提交要提交的IO数</span><br><span class="line">IO complete=Like the above submit number, but <span class="keyword">for</span> completions instead.</span><br><span class="line">IO issued=The number of <span class="built_in">read</span>/write requests issued, and how many of them were short.</span><br><span class="line">IO latencies=IO完延迟的分布</span><br><span class="line"></span><br><span class="line">io=总共执行了多少size的IO</span><br><span class="line">aggrb=group总带宽</span><br><span class="line">minb=最小.平均带宽.</span><br><span class="line">maxb=最大平均带宽.</span><br><span class="line">mint=group中线程的最短运行时间.</span><br><span class="line">maxt=group中线程的最长运行时间.</span><br><span class="line"></span><br><span class="line">ios=所有group总共执行的IO数.</span><br><span class="line">merge=总共发生的IO合并数.</span><br><span class="line">ticks=Number of ticks we kept the disk busy.</span><br><span class="line">io_queue=花费在队列上的总共时间.</span><br><span class="line">util=磁盘利用率</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>curl 来测试网站-dns解析时间,响应时间,传输时间</title>
    <link href="https://jiemin.wang/2019/04/22/curl-dns-time/"/>
    <id>https://jiemin.wang/2019/04/22/curl-dns-time/</id>
    <published>2019-04-22T02:16:41.000Z</published>
    <updated>2019-04-22T02:29:18.492Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>有些人努力了一辈子，也就从社会的四流进入了三流。</strong></p></blockquote><h2 id="获取-解析时间-响应时间-传输时间"><a href="#获取-解析时间-响应时间-传输时间" class="headerlink" title="获取 解析时间:响应时间:传输时间"></a>获取 解析时间:响应时间:传输时间</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># curl -o /dev/null -s -w %{time_connect}:%{time_starttransfer}:%{time_total} https://jiemin.wang    </span></span><br><span class="line">0.104:0.000:18.174</span><br></pre></td></tr></tbody></table></figure><img src="/2019/04/22/curl-dns-time/curl.jpg" title="curl"><p>给出对站点执行 <code>curl</code> 命令的情况.输出通常是 <code>HTML 代码</code>,通过 <code>-o</code> 参数发送到 <code>/dev/null</code>. <code>-s</code> 参数去掉所有状态信息. <code>-w</code> 参数让 <code>curl</code> 写出计时器的状态信息。</p><p>参数说明:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time_connect        建立到服务器的 TCP 连接所用的时间</span><br><span class="line">time_starttransfer  在发出请求之后,Web 服务器返回数据的第一个字节所用的时间</span><br><span class="line">time_total          完成请求所用的时间</span><br><span class="line">time_namelookup     DNS解析时间,从请求开始到DNS解析完毕所用时间(记得关掉 Linux 的 nscd 的服务测试)</span><br><span class="line">speed_download      下载速度，单位-字节每秒。</span><br></pre></td></tr></tbody></table></figure><p></p><p>这些计时器都相对于事务的起始时间,甚至要先于 <code>Domain Name Service（DNS</code>）查询.因此,在发出请求之后,Web 服务器处理请求并开始发回数据所用的时间是 0.000 - 0.104 = 0 秒.客户机从服务器下载数据所用的时间是 18.174 - 0.000 = 18 秒.</p><p>通过观察 curl 数据及其随时间变化的趋势,可以很好地了解站点对用户的响应性.以上变量会按CURL认为合适的格式输出，输出变量需要按照<code>%{variable_name}</code>的格式，如果需要<code>输出%</code>，double一下即可，即<code>%%</code>，同时，<code>n是换行</code>，<code>r是回车</code>，<code>t是TAB</code>。</p><p>当然,Web 站点不仅仅由页面组成.它还有图像、JavaScript 代码、CSS 和 cookie 要处理.curl 很适合了解单一元素的响应时间,但是有时候需要了解整个页面的装载速度.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux-TIME-WAIT</title>
    <link href="https://jiemin.wang/2019/04/22/linux-TIME-WAIT/"/>
    <id>https://jiemin.wang/2019/04/22/linux-TIME-WAIT/</id>
    <published>2019-04-22T01:50:20.000Z</published>
    <updated>2019-04-22T01:58:02.955Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>没事听听别人口中的自己，这比看大片还刺激，你会发现你什么都没做，但已经演了好多版本，都是大角色。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>TIME_WAIT</code> 状态原理<br>当客户端主动关闭连接时，会发送最后一个<code>ACK</code>，然后会进入<code>TIME_WAIT</code>状态，再停留2个<code>MSL时间(约1-4分钟)</code>，进入<code>CLOSED</code>状态。<br><img src="/2019/04/22/linux-TIME-WAIT/tcp.png" title="tcp"></p><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>CentOS6/7.x默认没有对系统参数进行设置，当大量<code>TIME_WAIT</code>产生的时候会影响系统性能，</p><p>统计<code>TIME_WAIT</code>状态数量<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | grep TIME_WAIT | wc -l</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看系统当前连接状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk <span class="string">'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</span></span><br><span class="line">TIME_WAIT 1280</span><br><span class="line">FIN_WAIT1 7</span><br><span class="line">SYN_SENT 1</span><br><span class="line">FIN_WAIT2 7</span><br><span class="line">ESTABLISHED 247</span><br><span class="line">LAST_ACK 1</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们只用关心<code>TIME_WAIT</code>的个数，在这里可以看到，有1280多个<code>TIME_WAIT</code>，这样就占用了1280多个端口，端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接，就需调整下Linux的TCP内核参数，让系统更快的释放<code>TIME_WAIT</code>连接。</p><p>解决方法如下：</p><p>修改内核配置<code>vim /etc/sysctl.conf</code> ，加入以下内容：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1         <span class="comment">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1           <span class="comment">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1         <span class="comment">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30       <span class="comment">#修改系統默认的 TIMEOUT 时间。</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>然后执行<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/sysctl -p</span><br></pre></td></tr></tbody></table></figure><p></p><p>让参数生效。</p><p>参数说明:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time = 1200   <span class="comment">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span></span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000   <span class="comment">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192  <span class="comment">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000  <span class="comment">#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认180000，改为6000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。</span></span><br><span class="line"></span><br><span class="line">内核其他TCP参数说明：</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65536  <span class="comment">#记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。</span></span><br><span class="line">net.core.netdev_max_backlog = 32768   <span class="comment">#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span></span><br><span class="line">net.core.somaxconn = 32768   <span class="comment">#web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。</span></span><br><span class="line"></span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">net.core.rmem_max = 16777216           <span class="comment">#最大socket读buffer,可参考的优化值:873200</span></span><br><span class="line">net.core.wmem_max = 16777216           <span class="comment">#最大socket写buffer,可参考的优化值:873200</span></span><br><span class="line">net.ipv4.tcp_timestsmps = 0    <span class="comment">#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。</span></span><br><span class="line">net.ipv4.tcp_synack_retries = 2   <span class="comment">#为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。</span></span><br><span class="line">net.ipv4.tcp_syn_retries = 2  <span class="comment">#在内核放弃建立连接之前发送SYN包的数量。</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1     <span class="comment"># 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_wmem = 8192 436600 873200   <span class="comment"># TCP写buffer,可参考的优化值: 8192 436600 873200</span></span><br><span class="line">net.ipv4.tcp_rmem  = 32768 436600 873200  <span class="comment"># TCP读buffer,可参考的优化值: 32768 436600 873200</span></span><br><span class="line">net.ipv4.tcp_mem = 94500000 91500000 92700000  <span class="comment"># 同样有3个值,意思是:</span></span><br><span class="line">net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。</span><br><span class="line">net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。</span><br><span class="line">net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。</span><br><span class="line">上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800   <span class="comment">#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。</span></span><br><span class="line">如果超过这个数字，连接将即刻被复位并打印出警告信息。</span><br><span class="line">这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，</span><br><span class="line">更应该增加这个值(如果增加了内存之后)。</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30   <span class="comment">#如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;timg.jpeg&quot; class=&quot;full-image&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://jiemin.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jiemin.wang/tags/Linux/"/>
    
  </entry>
  
</feed>
