<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL/MariaDB binlog/relaylog 回滚/闪回,前滚,DML分析报告,DDL信息</title>
      <link href="/2019/07/17/my2fback/"/>
      <url>/2019/07/17/my2fback/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="tupian.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>喜歡就去追阿～ 晚下手，你就是孩子她舅！早下手，就是喜当爹．．．</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>flashback闪回原理<a href="https://jiemin.wang/2019/04/19/mysql-flashback-priciple-and-practice/">上一篇</a></p><p>flashback的概念最早出现于Oracle数据库，用于快速恢复用户的误操作。</p><p>flashback for MySQL用于恢复由DML语句引起的误操作，目前不支持DDL语句。例如下面的语句：<br></p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> DELETE FROM XXX; UPDATE XXX SET YYY=ZZZ;</span><br></pre></td></tr></tbody></table></figure><p></p><p>若没有flashback功能，那么当发生误操作时，用户只能通过全备+二进制日志前滚的方式进行恢复。通常来说，这样所需的恢复时间会非常长。为了缩短误操作恢复的时间，通常可以在slave上搭建LVM，通过定期快照的方式来缩短误操作的恢复时间。但是LVM快照的缺点是会对slave的性能产生一定的影响。</p><p>官方<a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html" target="_blank" rel="noopener">mysqlbinlog</a>命令为解析MySQL的二进制日志。当二进制日志的格式为ROW格式时，可以输出每个操作的每条记录的前项与后项。那么通过逆操作即可进行回滚操作，例如：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始操作：<span class="keyword">INSERT</span> <span class="keyword">INTO</span> ...</span><br><span class="line"><span class="keyword">flashback</span>操作：<span class="keyword">DELETE</span> ...</span><br><span class="line">  </span><br><span class="line">原始操作：<span class="keyword">DELETE</span> <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">flashback</span>操作：<span class="keyword">INSERT</span> <span class="keyword">INTO</span> ...</span><br><span class="line">  </span><br><span class="line">原始操作：<span class="keyword">UPDATE</span> XXX <span class="keyword">SET</span> OLD_VALUES ...</span><br><span class="line"><span class="keyword">flashback</span>操作：<span class="keyword">UPDATE</span> XXX <span class="keyword">SET</span> NEW_VALUES ...</span><br></pre></td></tr></tbody></table></figure><p></p><p>目前flashback功能还没有集成于官方<a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html" target="_blank" rel="noopener">mysqlbinlog</a>g命令。于是自己开发了一套 MySQL Flashback 工具 <strong><code>my2fback</code></strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>my2fback 实现了基于row格式binlog的回滚闪回功能，让误删除或者误更新数据，可以不停机不使用备份而快速回滚误操作。也可以解释binlog（支持非row格式binlog）生成易读的SQL。可以按配置输出各个表的update/insert/delete统计报表， 也会输出大事务与长事务的分析， 应用是否干了坏事一目了然， 也会输出所有DDL。</p><p>my2fback 连接数据库帐号的权限: </p><ul><li><p>MySQL5.6/MariaDB10.1/MariaDB10.2版本</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT, PROCESS ON *.* TO <span class="string">'user'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'xxxxxx'</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>MySQL5.7版本</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql> CREATE USER <span class="string">'user'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'xxxxxx'</span>;</span><br><span class="line">mysql> GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT, PROCESS ON *.* TO <span class="string">'user'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><p>my2fback 通过解释mysql/mariadb binlog/relaylog实现以下三大功能:</p><ol><li><p>flashback/闪回/回滚， DML回滚到任意时间或者位置。</p><ul><li>生成的文件名为rollback.xxx.sql或者db.tb.rollback.xxx.sql</li></ul><ul><li>生成的SQL形式如下<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># datetime=2019-06-15_16:23:58 database=test table=t1 binlog=mysql-bin.000012 startpos=417 stoppos=575</span></span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>前滚，把binlog/relaylog的DML解释成易读的SQL语句。</p><ul><li>支持非row格式的binlog， 默认不解释非row格式的DML， 需要指定参数 -stsql</li><li>生成的文件名为forward.xxx.sql或者db.tb.forward.xxx.sql</li></ul><ul><li>生成的SQL形式如下<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment"># datetime=2019-06-15_16:23:58 database=test table=t1 binlog=mysql-bin.000012 startpos=417 stoppos=575</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`t1`</span> (<span class="string">`id`</span>,<span class="string">`name`</span>,<span class="string">`sr`</span>,<span class="string">`icon`</span>,<span class="string">`points`</span>,<span class="string">`sa`</span>,<span class="string">`sex`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'张三1'</span>,<span class="string">'华南理工大学&SCUT'</span>,X<span class="string">'89504e47'</span>,<span class="number">1.1</span>,<span class="number">1.1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>输出row格式下的原始SQL（5.7）</p><ul><li>结果文件名为original_sql.binlogxxx.sql</li></ul></li><li><p>统计分析， 输出各个表的DML统计， 输出大事务与长事务， 输出所有的DDL </p><ul><li><em>DML统计结果文件</em>：<strong><code>binlog_status.txt</code></strong></li><li><em>大事务与长事务结果文件</em>：<strong><code>binlog_biglong_trx.txt</code></strong></li><li><em>DDL结果文件</em>：<strong><code>ddl_info.txt</code></strong></li></ul></li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>支持V4版本的binlog， 支持传统与GTID的binlog， 支持mysql5.1与mairiadb5.5及以上版本的binlog， 也同样支持relaylog(结果中注释的信息binlog=xxx startpos=xxx stoppos=xx是对应的主库的binlog信息)<ul><li>–mtype=mariadb</li></ul></li><li>支持以时间及位置条件过滤， 并且支持单个以及多个连续binlog的解释。<ul><li>区间范围为左闭右开， [-sxx， -exxx)</li><li>解释binlog的开始位置：<ul><li>-sbin mysql-bin.000101</li><li>-spos 4</li></ul></li><li>解释binlog的结束位置：<ul><li>-ebin mysql-bin.000105</li><li>-epos 4</li></ul></li><li>解释binlog的开始时间<ul><li>-sdt “2019-06-15 00:00:00”</li></ul></li><li>解释binlog的结束时间  </li></ul><ul><li>-edt “2019-06-15 11:00:00”</li></ul></li><li>支持以库及表条件过滤, 以逗号分隔<ul><li>支持正则表达式，如-dbs “db\d+,db_sh\d+”。正则表达式中请使用小写字母，因为数据库名与表名会先转成小写再与正则表达式进行匹配</li></ul></li></ol><ul><li>-dbs db1,db2</li><li>-tbs tb1,tb2</li></ul><ol start="4"><li>支持以DML类型(update,delete,insert)条件过滤<ul><li>-sql delete,update</li></ul></li><li>支持分析本地binlog，也支持复制协议， my2fback作为一个从库从主库拉binlog来本地解释<ul><li>-m file //解释本地binlog</li><li>-m repl //my2fback作为slave连接到主库拉binlog来解释</li></ul></li><li>输出的结果支持一个binlog一个文件， 也可以一个表一个文件<ul><li>-f <ul><li>例如对于binlog mysql-bin.000101, 如果一个表一个文件， 则生成的文件形式为</li></ul></li><li>db.tb.rollback.101.sql(回滚)</li><li>db.tb.forward.101.sql(前滚)，<ul><li>否则是rollback.101.sql(回滚),forward.101.sql(前滚)</li></ul></li></ul></li><li>输出的结果是大家常见的易读形式的SQL，支持表名前是否加数据库名<ul><li>-d<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment"># datetime=2019-06-15_00:14:34 database=test table=t1 binlog=mysql-bin.000012 startpos=21615 stoppos=22822</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`sa`</span>=<span class="number">1001</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="comment"># datetime=2019-06-15_00:14:45 database=test table=t1 binlog=mysql-bin.000012 startpos=22822 stoppos=23930</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`name`</span>=<span class="literal">null</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><p>否则为<br> </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment"># datetime=2019-06-15_00:14:34 database=test table=t1 binlog=mysql-bin.000012 startpos=21615 stoppos=22822</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`sa`</span>=<span class="number">1001</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="comment"># datetime=2019-06-15_00:14:45 database=test table=t1 binlog=mysql-bin.000012 startpos=22822 stoppos=23930</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`name`</span>=<span class="literal">null</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></tbody></table></figure><p></p><ol start="8"><li>输出结果支持是否保留事务<ul><li>-k<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment"># datetime=2019-06-15_00:14:34 database=test table=t1 binlog=mysql-bin.000012 startpos=21615 stoppos=22822</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`sa`</span>=<span class="number">1001</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="comment"># datetime=2019-06-15_00:14:45 database=test table=t1 binlog=mysql-bin.000012 startpos=22822 stoppos=23930</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`name`</span>=<span class="literal">null</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><p>不保留则是这样：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># datetime=2019-06-15_00:14:34 database=test table=t1 binlog=mysql-bin.000012 startpos=21615 stoppos=22822</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`sa`</span>=<span class="number">1001</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="comment"># datetime=2019-06-15_00:14:45 database=test table=t1 binlog=mysql-bin.000012 startpos=22822 stoppos=23930</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`name`</span>=<span class="literal">null</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果复制因为特别大的事务而中断， 则可以以不保留事务的形式生成前滚的SQL, 在从库上执行， 然后跳过这个事务， 再启动复制， 免去重建从库的<br>麻烦， 特别是很大的库</p><ol start="9"><li>支持输出是否包含时间与binlog位置信息</li></ol><ul><li>-e</li></ul><ul><li>包含额外的信息则为<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># datetime=2019-06-15_00:14:34 database=test table=t1 binlog=mysql-bin.000012 startpos=21615 stoppos=22822</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`sa`</span>=<span class="number">1001</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="comment"># datetime=2019-06-15_00:14:45 database=test table=t1 binlog=mysql-bin.000012 startpos=22822 stoppos=23930</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`name`</span>=<span class="literal">null</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><p>否则为<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`sa`</span>=<span class="number">1001</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`name`</span>=<span class="literal">null</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><ol start="10"><li>支持生成的SQL只包含最少必须的字段, 前提下是表含有主键或者唯一索引</li></ol><ul><li><p>默认为</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`sa`</span>=<span class="number">1001</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>-a 则为</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">SET</span> <span class="string">`id`</span>=<span class="number">5</span>, <span class="string">`age`</span>=<span class="number">21</span>, <span class="string">`sex`</span>=<span class="string">'M'</span>,<span class="string">`sa`</span>=<span class="number">1001</span>, <span class="string">`name`</span>=<span class="string">'test'</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span> <span class="keyword">and</span> <span class="string">`age`</span>=<span class="number">21</span> <span class="keyword">and</span> <span class="string">`sex`</span>=<span class="string">'M'</span> <span class="keyword">and</span> <span class="string">`sa`</span>=<span class="number">900</span> <span class="keyword">and</span> <span class="string">`name`</span>=<span class="string">'test'</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`id`</span>=<span class="number">5</span> <span class="keyword">and</span> <span class="string">`age`</span>=<span class="number">21</span> <span class="keyword">and</span> <span class="string">`sex`</span>=<span class="string">'M'</span> <span class="keyword">and</span> <span class="string">`sa`</span>=<span class="number">900</span> <span class="keyword">and</span> <span class="string">`name`</span>=<span class="string">'test'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="11"><li>支持优先使用唯一索引而不是主键来构建where条件<ul><li>-U</li><li>有时不希望使用主健来构建wheret条件， 如发生双写时， 自增主健冲突了， 这时使用非主健的唯一索引来避免生成的SQL主健冲突</li></ul></li><li>支持生成的insert语句不包含主健<ul><li>-I<ul><li>发生双写时， 自增主健冲突了， 这时使用这个参数来让生成的insert语句不包括主健来避免生成的SQL主健冲突</li></ul></li></ul></li><li><p>支持大insert拆分成小insert语句。</p><ul><li>-r 100</li></ul><ul><li>对于一个insert 1000行的插入， 会生成10个insert语句，每个语句插入100行</li></ul></li><li><p>支持非row格式binlog的解释</p><ul><li>当-w 2sql时加上参数-stsql，则会解释非row格式的DML语句。</li></ul><ul><li>由于不是支持所有要SQL， 如create trigger就不支持， 遇到SQL无法解释时会报错退出， 如需要跳过该SQL并继续解释， 请使用参数-ies。-ies 后接正则表达式，</li><li>解释错误或者无法解释的SQL如果匹配-ies指定的正则表达式， 则my2fback不会退出而是跳过该SQL继续解释后面的binlog， 否则错误退出。</li></ul><ul><li>-ies 后接的正则表达式请使用小写字母, my2fback会先把SQL转成小写再与之匹配。</li></ul></li></ol><h2 id="安装与下载"><a href="#安装与下载" class="headerlink" title="安装与下载"></a>安装与下载</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>如果需要编译， 请使用GO>=1.11.x版本来编译。</p><ul><li><p>开启GO111MODULE参数</p><ul><li><p>编译linux 平台</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o releases/my2fback -ldflags <span class="string">"-s -w"</span> main.go</span><br></pre></td></tr></tbody></table></figure></li><li><p>编译windows 平台</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o releases/my2fback -ldflags <span class="string">"-s -w"</span> main.go</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>没有开启GO111MODULE参数</p><ul><li><p>编译linux 平台</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o releases/my2fback -ldflags <span class="string">"-s -w"</span> main.go</span><br></pre></td></tr></tbody></table></figure></li><li><p>编译windows 平台</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o releases/my2fback -ldflags <span class="string">"-s -w"</span> main.go</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><pre><code>* linux版本: [linux_releases](https://github.com/WangJiemin/my2fback/blob/master/releases/my2fback)* windows版本:[windows_releases](https://github.com/WangJiemin/my2fback/blob/master/releases/my2fback.exe)</code></pre><h2 id="使用帮助"><a href="#使用帮助" class="headerlink" title="使用帮助"></a>使用帮助</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># /usr/local/bin/my2fback -h</span></span><br><span class="line">my2fback V2.0 By WangJiemin.</span><br><span class="line">E_mail: 278667010@qq.com</span><br><span class="line"></span><br><span class="line">*****************************************************************************************************</span><br><span class="line">*system_command: /usr/<span class="built_in">local</span>/bin/my2fback*</span><br><span class="line">*system_goos: linux*</span><br><span class="line">*system_arch: amd64*</span><br><span class="line">*hostname: test_dbs2.yz.babytree-ops.org*</span><br><span class="line">*hostaddress: 10.10.1.221*</span><br><span class="line">*blog: https://jiemin.wang*</span><br><span class="line">*<span class="built_in">read</span> binlog from master, work as a fake slave: ./my2fback -m repl opts...*</span><br><span class="line">*<span class="built_in">read</span> binlog from <span class="built_in">local</span> filesystem: ./my2fback -m file opts... mysql-bin.000010*</span><br><span class="line">*****************************************************************************************************</span><br><span class="line"></span><br><span class="line">  -Cworks with -w=<span class="string">'stats'</span>, keep analyzing transations to last binlog <span class="keyword">for</span> -m=file, and keep analyzing <span class="keyword">for</span> -m=repl</span><br><span class="line">  -H string</span><br><span class="line">master host, DONOT need to specify when -w=stats. <span class="keyword">if</span> mode is file, it can be slave or other mysql contains same schema and table structure, not only master. default 127.0.0.1 (default <span class="string">"127.0.0.1"</span>)</span><br><span class="line">  -I<span class="keyword">for</span> insert statement when -wtype=2sql, ignore primary key</span><br><span class="line">  -M string</span><br><span class="line">valid options are:  mysql,mariadb. server of binlog, mysql or mariadb, default mysql (default <span class="string">"mysql"</span>)</span><br><span class="line">  -P uint</span><br><span class="line">master port, default 3306. DONOT need to specify when -w=stats (default 3306)</span><br><span class="line">  -S string</span><br><span class="line">mysql socket file</span><br><span class="line">  -Uprefer to use unique key instead of primary key to build <span class="built_in">where</span> condition <span class="keyword">for</span> delete/update sql</span><br><span class="line">  -aWorks with -w=2sql|rollback. <span class="keyword">for</span> update sql, include unchanged columns. <span class="keyword">for</span> update and delete, use all columns to build <span class="built_in">where</span> condition.</span><br><span class="line">default <span class="literal">false</span>, this is, use changed columns to build <span class="built_in">set</span> part, use primary/unique key to build <span class="built_in">where</span> condition</span><br><span class="line">  -b int</span><br><span class="line">transaction with affected rows greater or equal to this value is considerated as big transaction. Valid values range from 10 to 30000, default 500 (default 500)</span><br><span class="line">  -dWorks with -w=2sql|rollback. Prefix table name with database name <span class="keyword">in</span> sql, ex: insert into db1.tb1 (x1, x1) values (y1, y1). Default <span class="literal">true</span> (default <span class="literal">true</span>)</span><br><span class="line">  -dbs string</span><br><span class="line">only parse database <span class="built_in">which</span> match any of these regular expressions. The regular expression should be <span class="keyword">in</span> lower <span class="keyword">case</span> because database name is translated into lower <span class="keyword">case</span> and <span class="keyword">then</span> matched against it.</span><br><span class="line">Multi regular expressions is seperated by comma, default parse all databases. Useless when -w=stats</span><br><span class="line">  -dj string</span><br><span class="line">dump table structure to this file. default tabSchame.json (default <span class="string">"tabSchame.json"</span>)</span><br><span class="line">  -eWorks with -w=2sql|rollback. Print database/table/datetime/binlogposition...info on the line before sql, default <span class="literal">false</span></span><br><span class="line">  -ebin string</span><br><span class="line">binlog file to stop reading</span><br><span class="line">  -edt string</span><br><span class="line">Stop reading the binlog at first event having a datetime equal or posterior to the argument, it should be like this: <span class="string">"2004-12-25 11:25:56"</span></span><br><span class="line">  -epos uint</span><br><span class="line">Stop reading the binlog at position</span><br><span class="line">  -fWorks with -w=2sql|rollback. one file <span class="keyword">for</span> one table <span class="keyword">if</span> <span class="literal">true</span>, <span class="keyword">else</span> one file <span class="keyword">for</span> all tables. default <span class="literal">false</span>. Attention, always one file <span class="keyword">for</span> one binlog</span><br><span class="line">  -i int</span><br><span class="line">works with -w=<span class="string">'stats'</span>, <span class="built_in">print</span> stats info each PrintInterval. Valid values range from 1 to 600, default 30 (default 30)</span><br><span class="line">  -ies string</span><br><span class="line"><span class="keyword">for</span> sql <span class="built_in">which</span> is error to parsed and matched by this regular expression, just <span class="built_in">print</span> error info, skip it and <span class="built_in">continue</span> parsing, otherwise stop parsing and <span class="built_in">exit</span>.</span><br><span class="line">The regular expression should be <span class="keyword">in</span> lower <span class="keyword">case</span>, because sql is translated into lower <span class="keyword">case</span> and <span class="keyword">then</span> matched against it. (default <span class="string">"^create definer.+trigger"</span>)</span><br><span class="line">  -kWorks with -w=2sql|rollback. wrap result statements with <span class="string">'begin...commit|rollback'</span></span><br><span class="line">  -l int</span><br><span class="line">transaction with duration greater or equal to this value is considerated as long transaction. Valid values range from 1 to 3600, default 300 (default 300)</span><br><span class="line">  -m string</span><br><span class="line">valid options are:  repl,file. repl: as a slave to get binlogs from master. file: get binlogs from <span class="built_in">local</span> filesystem. default file (default <span class="string">"file"</span>)</span><br><span class="line">  -mid uint</span><br><span class="line">works with -m=repl, this program replicates from master as slave to <span class="built_in">read</span> binlogs. Must <span class="built_in">set</span> this server id unique from other slaves, default 1113306 (default 1113306)</span><br><span class="line">  -o string</span><br><span class="line">result output dir, default current work dir. Attension, result files could be large, <span class="built_in">set</span> it to a dir with large free space</span><br><span class="line">  -oj</span><br><span class="line">Only use table structure from -rj, <span class="keyword">do</span> not get or merge table struct from mysql</span><br><span class="line">  -ors</span><br><span class="line"><span class="keyword">for</span> mysql>=5.6.2 and binlog_rows_query_log_events=on, <span class="keyword">if</span> <span class="built_in">set</span>, output original sql. default <span class="literal">false</span></span><br><span class="line">  -p string</span><br><span class="line">mysql user password. DONOT need to specify when -w=stats</span><br><span class="line">  -r int</span><br><span class="line">Works with -w=2sql|rollback. rows <span class="keyword">for</span> each insert sql. Valid values range from 1 to 500, default 30 (default 30)</span><br><span class="line">  -rj string</span><br><span class="line">Works with -w=2sql|rollback, <span class="built_in">read</span> table structure from this file and merge from mysql</span><br><span class="line">  -sbin string</span><br><span class="line">binlog file to start reading</span><br><span class="line">  -sdt string</span><br><span class="line">Start reading the binlog at first event having a datetime equal or posterior to the argument, it should be like this: <span class="string">"2004-12-25 11:25:56"</span></span><br><span class="line">  -spos uint</span><br><span class="line">start reading the binlog at position</span><br><span class="line">  -sql string</span><br><span class="line">valid options are:  insert,update,delete. only parse these types of sql, comma seperated, valid types are: insert, update, delete; default is all(insert,update,delete)</span><br><span class="line">  -stsql</span><br><span class="line">when -w=2sql, also parse plain sql and write into result file even <span class="keyword">if</span> binlog_format is not row. default <span class="literal">false</span></span><br><span class="line">  -t uint</span><br><span class="line">Works with -w=2sql|rollback. threads to run, default 4 (default 2)</span><br><span class="line">  -tbs string</span><br><span class="line">only parse table <span class="built_in">which</span> match any of these regular expressions.The regular expression should be <span class="keyword">in</span> lower <span class="keyword">case</span> because database name is translated into lower <span class="keyword">case</span> and <span class="keyword">then</span> matched against it.</span><br><span class="line"> Multi regular expressions is seperated by comma, default parse all tables. Useless when -w=stats</span><br><span class="line">  -tl string</span><br><span class="line">time location to parse timestamp/datetime column <span class="keyword">in</span> binlog, such as Asia/Shanghai. default Local (default <span class="string">"Local"</span>)</span><br><span class="line">  -u string</span><br><span class="line">mysql user. DONOT need to specify when -w=stats</span><br><span class="line">  -v<span class="built_in">print</span> version</span><br><span class="line">  -w string</span><br><span class="line">valid options are:  tbldef,stats,2sql,rollback. tbldef: only get table definition structure; 2sql: convert binlog to sqls, rollback: generate rollback sqls, stats: analyze transactions. default: stats (default <span class="string">"stats"</span>)</span><br><span class="line">test_dbs2 ~ <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p><strong><code>常用参数</code></strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-m string</span><br><span class="line">valid options are:  repl,file. repl: as a slave to get binlogs from master. file: get binlogs from <span class="built_in">local</span> filesystem. default file (default <span class="string">"file"</span>)</span><br><span class="line">relp: 模仿 SLAVE 的IO_THREAD连接到MASTER获取BINLOG EVENT</span><br><span class="line">file: 解析本地的BINLOG(default: file)</span><br><span class="line">-w string</span><br><span class="line">valid options are:  tbldef,stats,2sql,rollback. tbldef: only get table definition structure; 2sql: convert binlog to sqls, rollback: generate rollback sqls, stats: analyze transactions. default: stats (default <span class="string">"stats"</span>)</span><br><span class="line">2sql: 解析成SQL语句</span><br><span class="line">rollback: 解析为回滚语句</span><br><span class="line">-M string</span><br><span class="line">valid options are:  mysql,mariadb. server of binlog, mysql or mariadb, default mysql (default <span class="string">"mysql"</span>)</span><br><span class="line">选择是MySQL还是Mariadb, 不选择默认为MySQL</span><br><span class="line">-e  Works with -w=2sql|rollback. Print database/table/datetime/binlogposition...info on the line before sql, default <span class="literal">false</span></span><br><span class="line"> 在sql之前的行上打印database/table/datetime/binlogposition...info，默认为<span class="literal">false</span></span><br><span class="line">-f  Works with -w=2sql|rollback. one file <span class="keyword">for</span> one table <span class="keyword">if</span> <span class="literal">true</span>, <span class="keyword">else</span> one file <span class="keyword">for</span> all tables. default <span class="literal">false</span>. Attention, always one file <span class="keyword">for</span> one binlog</span><br><span class="line"> 如果为<span class="literal">true</span>，则为一个表的一个文件，否则为所有表的一个文件。默认为<span class="literal">false</span>。注意，一个binlog总是一个文件</span><br><span class="line">-r int</span><br><span class="line">Works with -w=2sql|rollback. rows <span class="keyword">for</span> each insert sql. Valid values range from 1 to 500, default 30 (default 30)</span><br><span class="line">INSERT SQL 语句每一行包含的values的行数</span><br><span class="line">-t uint</span><br><span class="line">Works with -w=2sql|rollback. threads to run, default 4 (default 2)</span><br><span class="line">开启几个thread进行来执行解析2sql|rollback</span><br><span class="line">-o string</span><br><span class="line">result output dir, default current work dir. Attension, result files could be large, <span class="built_in">set</span> it to a dir with large free space</span><br><span class="line">输入的目录</span><br><span class="line">-k  Works with -w=2sql|rollback. wrap result statements with <span class="string">'begin...commit|rollback'</span></span><br><span class="line"> 使用-w = 2sql | rollback。使用<span class="string">'begin ... commit | rollback'</span>包装结果语句</span><br><span class="line">-l int</span><br><span class="line">transaction with duration greater or equal to this value is considerated as long transaction. Valid values range from 1 to 3600, default 300 (default 300)</span><br><span class="line"> </span><br><span class="line">-b int</span><br><span class="line">transaction with affected rows greater or equal to this value is considerated as big transaction. Valid values range from 10 to 30000, default 500 (default 500)</span><br><span class="line"></span><br><span class="line">-dWorks with -w=2sql|rollback. Prefix table name with database name <span class="keyword">in</span> sql, ex: insert into db1.tb1 (x1, x1) values (y1, y1). Default <span class="literal">true</span> (default <span class="literal">true</span>)</span><br><span class="line"> 使用-w=2sql|rollback。在sql中具有数据库名称的前缀表名</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li><p>测试机器</p><ul><li>CPU 2c</li><li>内存 4G</li><li>磁盘 400G</li></ul></li><li><p>file本地方式解析binlog</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># time /usr/local/bin/my2fback -m file -w 2sql -M mysql -t 6 -H ***.***.***.*** -u test -p test -dbs babytree -tbs userbaby -e -f -d -r 20 -k -b 100 -l 10  -o /data/bak/20190626/tosql /data/bak/20190626/mysql-bin.002938</span></span><br></pre></td></tr></tbody></table></figure></li></ul><img src="/2019/07/17/my2fback/file_jiexi.png" title="file_jiexi"><img src="/2019/07/17/my2fback/file_jiexi_end.png" title="file_jiexi"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># ls /data/bak/20190626/tosql/</span></span><br></pre></td></tr></tbody></table></figure><img src="/2019/07/17/my2fback/file_2sql_output.png" title="file_jiexi"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># cat /data/bak/20190626/tosql/babytree.UserBaby.forward.2938.sql |more</span></span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:18 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=79686 stoppos=80034</span></span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `name`=<span class="string">'双双'</span>, `update_ts`=1561512918, `extra`=<span class="string">'{\"born_preg_week\":30,\"born_preg_day\":5,\"is_premature\":0,\"born_height\":0,\"born_weight\":0,\"is_only_child\":0}'</span> WHE</span><br><span class="line">RE `id`=83758158;</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:18 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=121354 stoppos=121552</span></span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `birthday`=1582905600, `gender`=3, `update_ts`=1561512918, `extra`=<span class="string">'{\"is_premature\":0}'</span> WHERE `id`=87162805;</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:18 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=128088 stoppos=128234</span></span><br><span class="line">INSERT INTO `babytree`.`UserBaby` (`id`,`user_id`,`name`,`birthday`,`gender`,`is_default`,`state`,`photo_url`,`text_info`,`create_ts`,`update_ts`,`baby_status`,`extra`) VALUES (87163008,87041217,<span class="string">''</span>,0,1,1,</span><br><span class="line">1,<span class="string">''</span>,<span class="string">''</span>,1561512918,1561512918,1,<span class="string">''</span>);</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:19 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=159954 stoppos=160134</span></span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `gender`=0, `update_ts`=1561512919 WHERE `id`=87163008;</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:19 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=251027 stoppos=251207</span></span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `update_ts`=1561512919 WHERE `id`=87163007;</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:20 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=342791 stoppos=342971</span></span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `update_ts`=1561512920 WHERE `id`=87163008;</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:22 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=607938 stoppos=608256</span></span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `birthday`=1560268800, `gender`=1, `update_ts`=1561512922, `baby_status`=3, `extra`=<span class="string">'{\"born_height\":0,\"born_weight\":0,\"is_premature\":0,\"born_preg_week\":39,\"born_p</span></span><br><span class="line"><span class="string">reg_day\":0}'</span> WHERE `id`=81204050;</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:22 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=628699 stoppos=628897</span></span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `birthday`=-192551296, `gender`=3, `update_ts`=1561512922, `extra`=<span class="string">'{\"is_premature\":0}'</span> WHERE `id`=87162871;</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:22 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=631950 stoppos=632130</span></span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `update_ts`=1561512922 WHERE `id`=84567514;</span><br><span class="line">commit;</span><br></pre></td></tr></tbody></table></figure><ul><li>file本地方式回滚binlog<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">est_dbs2 ~ <span class="comment"># time /usr/local/bin/my2fback -m file -w rollback -M mysql -t 6 -H ***.***.***.*** -u test -p test -dbs babytree -tbs userbaby -e -f -d -r 20 -k -b 100 -l 10  -o /data/bak/20190626/tosql /data/bak/20190626/mysql-bin.002938</span></span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong><code>-w 修改为 rollback</code></strong><br><img src="/2019/07/17/my2fback/rollback_start.png" title="file_jiexi"><br><img src="/2019/07/17/my2fback/rollback_end.png" title="file_jiexi"><br><img src="/2019/07/17/my2fback/rollback_wenjian.png" title="file_jiexi"></p><p>看上面解析的SQl,用grep 进行搜索下，是不是回滚对了。还有一定要和<strong>业务方确认，业务方确认，业务方确认</strong>。重要的事情说三遍<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># cat /data/bak/20190626/tosql/babytree.UserBaby.rollback.2938.sql|grep -C 2 83758158</span></span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `name`=<span class="string">''</span>, `update_ts`=1548426675, `extra`=<span class="string">'{\"born_preg_week\":30,\"born_preg_day\":5,\"is_premature\":0}'</span> WHERE `id`=83758158;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:18 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=79686 stoppos=80034</span></span><br><span class="line">commit;</span><br><span class="line">test_dbs2 ~ <span class="comment"># cat /data/bak/20190626/tosql/babytree.UserBaby.rollback.2938.sql|grep -C 2 87163008</span></span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `birthday`=0, `gender`=0, `update_ts`=1561512920, `baby_status`=1, `extra`=<span class="string">''</span> WHERE `id`=87163008;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:36:41 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=9292334 stoppos=9292532</span></span><br><span class="line">commit;</span><br><span class="line">--</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `update_ts`=1561512919 WHERE `id`=87163008;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:20 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=342791 stoppos=342971</span></span><br><span class="line">commit;</span><br><span class="line">--</span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line">UPDATE `babytree`.`UserBaby` SET `gender`=1, `update_ts`=1561512918 WHERE `id`=87163008;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:19 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=159954 stoppos=160134</span></span><br><span class="line">commit;</span><br><span class="line">begin;</span><br><span class="line">DELETE FROM `babytree`.`UserBaby` WHERE `id`=87163008;</span><br><span class="line"><span class="comment"># datetime=2019-06-26_09:35:18 database=babytree table=UserBaby binlog=mysql-bin.002938 startpos=128088 stoppos=128234</span></span><br><span class="line">commit;</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>relp 方式解析binlog</li></ul><ul><li>数据库上的binlog文件起始文件和结束文件<img src="/2019/07/17/my2fback/binlog_totle.png" title="binlog_totle"></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># time /usr/local/bin/my2fback -m repl -w 2sql -M mysql -t 6 -H ***.***.***.*** -u test -p test -dbs babytree -tbs userbaby -e -f -d -r 20 -k -b 100 -l 10 -sbin mysql-bin.003045 -spos 4 -ebin mysql-bin.003079 -epos 4 -o /data/bak/20190626/tosql/</span></span><br></pre></td></tr></tbody></table></figure><p>系统资源<br><img src="/2019/07/17/my2fback/top.png" title="top"></p><p>执行截图</p><img src="/2019/07/17/my2fback/repl_jiexi_start.png" title="repl_jiexi_start"><img src="/2019/07/17/my2fback/repl_jiexi1.png" title="repl_jiexi1"><img src="/2019/07/17/my2fback/repl_jiexi_end.png" title="repl_end"><blockquote><p>binlog文件共计有36个。文件大小为36G。解析时间:57m24.978s</p></blockquote><ul><li>repl 方式回滚binlog<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># time /usr/local/bin/my2fback -m repl -w rollback -M mysql -t 6 -H ***.***.***.*** -u test -p test -dbs babytree -tbs userbaby -e -f -d -r 20 -k -b 100 -l 10 -sbin mysql-bin.003045 -spos 4 -ebin mysql-bin.003045 -epos 888888 -o /data/bak/20190626/tosql/</span></span><br></pre></td></tr></tbody></table></figure></li></ul><p>就不贴图了。和file方式一致。</p><blockquote><p>解析文件可以是一个时间范围，也可以是一个positiions范围。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一个小菜鸟撸的菜鸟工具，如果有BUG。请大家多多包容。</p><p>测试通过，已经在宝宝树线上使用。累计恢复数据120G。</p><p>如果不放心。请使用binlog2sql。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用yum源整理</title>
      <link href="/2019/06/05/linux-yumReposSummary/"/>
      <url>/2019/06/05/linux-yumReposSummary/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="fm461.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>出卖自己的灵魂和原则并不丢人，丢人的是没能卖一个好价钱。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CentOS系统带有几个官方源，默认启用的仅有base, updates和extras三个。如果希望从源安装Nginx，高版本的gcc/PHP等软件，则要导入提供软件包的第三方源。本文整理常见的第三方yum源，并以CentOS 7为例介绍其安装方法。</p><h2 id="第三方yum源"><a href="#第三方yum源" class="headerlink" title="第三方yum源"></a>第三方yum源</h2><h4 id="EPEL"><a href="#EPEL" class="headerlink" title="EPEL"></a>EPEL</h4><p>EPEL是Extra Packages for Enterprise Linux的缩写，其为EL6或EL7提供重建的Fedora组件，并且不会替换base中的包。EPEL算得上是最著名的第三方软件源，几乎各个云服务器厂商提供的CentOS 系统均会自带该源并默认启用。其收录了web中常用的Nginx软件包。</p><p>EPEL的官网是：<a href="http://fedoraproject.org/wiki/EPEL，可以通过`yum" target="_blank" rel="noopener">http://fedoraproject.org/wiki/EPEL，可以通过`yum</a> install -y epel-release`安装。</p><h4 id="SCL"><a href="#SCL" class="headerlink" title="SCL"></a>SCL</h4><p>SCL是Software Collections的缩写，由CentOS 特别兴趣小组所维护。其收录了许多程序的新版本，例如gcc, PHP, git, python等。安装的软件可与旧版共存，包名多以rh-为前缀。</p><p>SCL的官网是<a href="https://www.softwarecollections.org，CentOS" target="_blank" rel="noopener">https://www.softwarecollections.org，CentOS</a> 7的安装方法是：<code>yum install centos-release-scl</code>。安装完成后在<code>/etc/yum.repos.d</code>目录下会出现<code>CentOS-SCLo-scl.repo</code>和<code>CentOS-SCLo-scl-rh.repo</code>两个文件。安装后源默认启用。</p><h4 id="ELRepo"><a href="#ELRepo" class="headerlink" title="ELRepo"></a>ELRepo</h4><p>ELRepo是The Community Enterprise Linux Repository的缩写，旨在提供驱动程序来增强系统的硬件支持（包括：显示、文件系统、硬件监控、网络、音效、网络摄像镜驱动程序）。也提供较新版的内核，例如支持BBR算法的4.9+内核。</p><p>ELRepo的官方是<a href="http://elrepo.org/，CentOS" target="_blank" rel="noopener">http://elrepo.org/，CentOS</a> 7系统的安装方法是：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br></pre></td></tr></tbody></table></figure><p></p><p>安装完成后在<code>/etc/yum.repos.d</code>目录下出现<code>elrepo.repo</code>文件，可编辑文件中的<code>enable</code>的值启用具体仓库，也可在运行时用<code>--enablerepo="xxx"</code>指定使用的软件库。</p><h4 id="IUS"><a href="#IUS" class="headerlink" title="IUS"></a>IUS</h4><p>IUS的官网是<a href="https://ius.io/，旨在为RHEL和CentOS提供高质量、最新版的软件，如PHP" target="_blank" rel="noopener">https://ius.io/，旨在为RHEL和CentOS提供高质量、最新版的软件，如PHP</a>, Python, MySQL等。CentOS 7安装该源的命令为：<code>rpm -Uvh https://centos7.iuscommunity.org/ius-release.rpm</code>。</p><h4 id="RPMfusion"><a href="#RPMfusion" class="headerlink" title="RPMfusion"></a>RPMfusion</h4><p>RPMfusion提供Fedora Project或 Red Hat不愿发行的软件，包含“免费（开源软件）”和“非免费（源代码可公开获取但不开源且限非商业用途）”两种类型的仓库。</p><p>RPMfusion的官网是<a href="https://rpmfusion.org/，CentOS" target="_blank" rel="noopener">https://rpmfusion.org/，CentOS</a> 7的安装方法是：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 免费库</span></span><br><span class="line">yum localinstall --nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-7.noarch.rpm</span><br><span class="line"><span class="comment"># 非免费库</span></span><br><span class="line">yum localinstall --nogpgcheck https://download1.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-7.noarch.rpm</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Remi"><a href="#Remi" class="headerlink" title="Remi"></a>Remi</h4><p>Remi维护大量组件，包括最新版的PHP, GLPI等。Remi的safe仓库不会替代系统的基本组件，但remi-phpxx.repo中的软件包会替代系统默认的php。需要注意的是Remi可能会与IUS的软件包冲突，因为双方都提供最新版的PHP。</p><p>Remi的官方网站是<a href="http://rpms.remirepo.net/，CentOS" target="_blank" rel="noopener">http://rpms.remirepo.net/，CentOS</a> 7的安装方法是：<code>yum install -y remi-release</code>。</p><h4 id="Webtatic"><a href="#Webtatic" class="headerlink" title="Webtatic"></a>Webtatic</h4><p>提供较新版的PHP、MySQL及其它组件。建议用IUS或SCL代替。</p><h4 id="软件官方维护的源"><a href="#软件官方维护的源" class="headerlink" title="软件官方维护的源"></a>软件官方维护的源</h4><p>除上述收录多个软件包的综合源外，还有许多由软件官方维护的源，例如<code>Nginx</code>, <code>Gitlab</code>, <code>Nodejs</code>等。这些源的安装和使用方法请参考官方指南。</p><h4 id="源管理"><a href="#源管理" class="headerlink" title="源管理"></a>源管理</h4><p>源的配置文件均位于<code>/etc/yum.repos.d</code>目录下，可用<code>vim</code>, <code>nano</code>等编辑器打开配置文件并编辑。</p><p>一些有用的源管理yum命令：</p><ul><li><code>yum repolist</code>： 列出所有启用的源, 等同于<code>yum repolist enabled</code>；</li><li><code>yum repolist disabled</code>： 列出所有禁用的源；</li><li><code>yum repoinfo [enabled|disabled]</code>：列出启用（禁用）源的更详细信息</li><li><code>yum --disablerepo="*" --enablerepo="xxxx" install/search</code>: 从指定源安装/搜索软件；<code>"–disablerepo"</code>和<code>"–enablerepo"</code>选项可独立或配合使用，动态启用和禁用源。</li></ul><h4 id="国内镜像"><a href="#国内镜像" class="headerlink" title="国内镜像"></a>国内镜像</h4><p>因为某些原因，从位于境外的源镜像安装软件慢的让人抓狂。如果遇到了此种情形，建议使用代理，或者配置源的地址为国内镜像的地址。国内知名的yum源镜像站有：</p><ol><li>阿里云，网址：<a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener">https://opsx.alibaba.com/mirror</a></li><li>网易163，网址：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></li><li>清华大学，网址：<a href="http://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/</a></li><li>中科大，网址：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></li><li>浙大，网址：<a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></li></ol><p>具体仓库的配置方法请参考站内指南。需要注意的是并非所有的镜像都包含上述列出的yum源，本人推荐阿里云、清华大学、中科大镜像站。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://wiki.centos.org/zh/AdditionalResources/Repositories" target="_blank" rel="noopener">https://wiki.centos.org/zh/AdditionalResources/Repositories</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DBA不可不知的操作系统内核参数</title>
      <link href="/2019/05/24/Linux-systemctl-variables/"/>
      <url>/2019/05/24/Linux-systemctl-variables/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="images.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>每当我找到成功的钥匙，就发现有人把锁芯给换了。</strong></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>操作系统为了适应更多的硬件环境，许多初始的设置值，宽容度都很高。    </p><p>如果不经调整，这些值可能无法适应HPC，或者硬件稍好些的环境。    </p><p>无法发挥更好的硬件性能，甚至可能影响某些应用软件的使用，特别是数据库。    </p><h2 id="数据库关心的OS内核参数"><a href="#数据库关心的OS内核参数" class="headerlink" title="数据库关心的OS内核参数"></a>数据库关心的OS内核参数</h2><p>512GB 内存为例      </p><p>1.     </p><p>  参数      </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br></pre></td><td class="code"><pre><span class="line">fs.aio-max-nr  </span><br><span class="line">```    </span><br><span class="line">      </span><br><span class="line">  支持系统      </span><br><span class="line">  </span><br><span class="line">```    </span><br><span class="line">CentOS 6, 7       </span><br><span class="line">```    </span><br><span class="line">      </span><br><span class="line">  参数解释      </span><br><span class="line">  </span><br><span class="line">```    </span><br><span class="line">aio-nr & aio-max-nr:    </span><br><span class="line">.  </span><br><span class="line">aio-nr is the running total of the number of events specified on the    </span><br><span class="line">io_setup system call for all currently active aio contexts.    </span><br><span class="line">.  </span><br><span class="line">If aio-nr reaches aio-max-nr then io_setup will fail with EAGAIN.    </span><br><span class="line">.  </span><br><span class="line">Note that raising aio-max-nr does not result in the pre-allocation or re-sizing    </span><br><span class="line">of any kernel data structures.    </span><br><span class="line">.  </span><br><span class="line">aio-nr & aio-max-nr:    </span><br><span class="line">.  </span><br><span class="line">aio-nr shows the current system-wide number of asynchronous io requests.    </span><br><span class="line">.  </span><br><span class="line">aio-max-nr allows you to change the maximum value aio-nr can grow to.    </span><br><span class="line">```    </span><br><span class="line">      </span><br><span class="line">  推荐设置       </span><br><span class="line">  </span><br><span class="line">```    </span><br><span class="line">fs.aio-max-nr = 1xxxxxx  </span><br><span class="line">.  </span><br><span class="line">PostgreSQL, Greenplum 均未使用io_setup创建aio contexts. 无需设置。    </span><br><span class="line">如果Oracle数据库，要使用aio的话，需要设置它。    </span><br><span class="line">设置它也没什么坏处，如果将来需要适应异步IO，可以不需要重新修改这个设置。   </span><br><span class="line">```    </span><br><span class="line">      </span><br><span class="line">2\.     </span><br><span class="line">  </span><br><span class="line">  参数       </span><br><span class="line">  </span><br><span class="line">```    </span><br><span class="line">fs.file-max  </span><br><span class="line">```    </span><br><span class="line">      </span><br><span class="line">  支持系统      </span><br><span class="line">  </span><br><span class="line">```    </span><br><span class="line">CentOS 6, 7       </span><br><span class="line">```    </span><br><span class="line">      </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">file-max & file-nr:    </span><br><span class="line">.  </span><br><span class="line">The value in file-max denotes the maximum number of file handles that the Linux kernel will allocate.   </span><br><span class="line">.  </span><br><span class="line">When you get lots of error messages about running out of file handles,   </span><br><span class="line">you might want to increase this limit.    </span><br><span class="line">.  </span><br><span class="line">Historically, the kernel was able to allocate file handles dynamically,   </span><br><span class="line">but not to free them again.     </span><br><span class="line">.  </span><br><span class="line">The three values in file-nr denote :      </span><br><span class="line">the number of allocated file handles ,     </span><br><span class="line">the number of allocated but unused file handles ,     </span><br><span class="line">the maximum number of file handles.     </span><br><span class="line">.  </span><br><span class="line">Linux 2.6 always reports 0 as the number of free    </span><br><span class="line">file handles -- this is not an error, it just means that the    </span><br><span class="line">number of allocated file handles exactly matches the number of    </span><br><span class="line">used file handles.    </span><br><span class="line">.  </span><br><span class="line">Attempts to allocate more file descriptors than file-max are reported with printk,   </span><br><span class="line">look for "VFS: file-max limit <number> reached".    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">fs.file-max = 7xxxxxxx  </span><br><span class="line">.  </span><br><span class="line">PostgreSQL 有一套自己管理的VFS，真正打开的FD与内核管理的文件打开关闭有一套映射的机制，所以真实情况不需要使用那么多的file handlers。     </span><br><span class="line">max_files_per_process 参数。     </span><br><span class="line">假设1GB内存支撑100个连接，每个连接打开1000个文件，那么一个PG实例需要打开10万个文件，一台机器按512G内存来算可以跑500个PG实例，则需要5000万个file handler。     </span><br><span class="line">以上设置绰绰有余。     </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">3\.    </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">kernel.core_pattern  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7       </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">core_pattern:    </span><br><span class="line">.  </span><br><span class="line">core_pattern is used to specify a core dumpfile pattern name.    </span><br><span class="line">. max length 128 characters; default value is "core"    </span><br><span class="line">. core_pattern is used as a pattern template for the output filename;    </span><br><span class="line">  certain string patterns (beginning with '%') are substituted with    </span><br><span class="line">  their actual values.    </span><br><span class="line">. backward compatibility with core_uses_pid:    </span><br><span class="line">        If core_pattern does not include "%p" (default does not)    </span><br><span class="line">        and core_uses_pid is set, then .PID will be appended to    </span><br><span class="line">        the filename.    </span><br><span class="line">. corename format specifiers:    </span><br><span class="line">        %<NUL>  '%' is dropped    </span><br><span class="line">        %%      output one '%'    </span><br><span class="line">        %p      pid    </span><br><span class="line">        %P      global pid (init PID namespace)    </span><br><span class="line">        %i      tid    </span><br><span class="line">        %I      global tid (init PID namespace)    </span><br><span class="line">        %u      uid    </span><br><span class="line">        %g      gid    </span><br><span class="line">        %d      dump mode, matches PR_SET_DUMPABLE and    </span><br><span class="line">                /proc/sys/fs/suid_dumpable    </span><br><span class="line">        %s      signal number    </span><br><span class="line">        %t      UNIX time of dump    </span><br><span class="line">        %h      hostname    </span><br><span class="line">        %e      executable filename (may be shortened)    </span><br><span class="line">        %E      executable path    </span><br><span class="line">        %<OTHER> both are dropped    </span><br><span class="line">. If the first character of the pattern is a '|', the kernel will treat    </span><br><span class="line">  the rest of the pattern as a command to run.  The core dump will be    </span><br><span class="line">  written to the standard input of that program instead of to a file.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">kernel.core_pattern = /xxx/core_%e_%u_%t_%s.%p    </span><br><span class="line">.  </span><br><span class="line">这个目录要777的权限，如果它是个软链，则真实目录需要777的权限  </span><br><span class="line">mkdir /xxx  </span><br><span class="line">chmod 777 /xxx  </span><br><span class="line">留足够的空间  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">4\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">kernel.sem   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7       </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">kernel.sem = 4096 2147483647 2147483646 512000    </span><br><span class="line">.  </span><br><span class="line">4096 每组多少信号量 (>=17, PostgreSQL 每16个进程一组, 每组需要17个信号量) ,     </span><br><span class="line">2147483647 总共多少信号量 (2^31-1 , 且大于4096*512000 ) ,     </span><br><span class="line">2147483646 每个semop()调用支持多少操作 (2^31-1),     </span><br><span class="line">512000 多少组信号量 (假设每GB支持100个连接, 512GB支持51200个连接, 加上其他进程, > 51200*2/16 绰绰有余)     </span><br><span class="line">.  </span><br><span class="line"># sysctl -w kernel.sem="4096 2147483647 2147483646 512000"    </span><br><span class="line">.  </span><br><span class="line"># ipcs -s -l    </span><br><span class="line">  ------ Semaphore Limits --------    </span><br><span class="line">max number of arrays = 512000    </span><br><span class="line">max semaphores per array = 4096    </span><br><span class="line">max semaphores system wide = 2147483647    </span><br><span class="line">max ops per semop call = 2147483646    </span><br><span class="line">semaphore max value = 32767    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">kernel.sem = 4096 2147483647 2147483646 512000    </span><br><span class="line">.  </span><br><span class="line">4096可能能够适合更多的场景, 所以大点无妨，关键是512000 arrays也够了。    </span><br><span class="line">```  </span><br><span class="line">      </span><br><span class="line">5\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">kernel.shmall = 107374182    </span><br><span class="line">kernel.shmmax = 274877906944    </span><br><span class="line">kernel.shmmni = 819200    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7        </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">假设主机内存 512GB    </span><br><span class="line">.  </span><br><span class="line">shmmax 单个共享内存段最大 256GB (主机内存的一半，单位字节)      </span><br><span class="line">shmall 所有共享内存段加起来最大 (主机内存的80%，单位PAGE)      </span><br><span class="line">shmmni 一共允许创建819200个共享内存段 (每个数据库启动需要2个共享内存段。  将来允许动态创建共享内存段，可能需求量更大)     </span><br><span class="line">.  </span><br><span class="line"># getconf PAGE_SIZE    </span><br><span class="line">4096    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">kernel.shmall = 107374182    </span><br><span class="line">kernel.shmmax = 274877906944    </span><br><span class="line">kernel.shmmni = 819200    </span><br><span class="line">.  </span><br><span class="line">9.2以及以前的版本，数据库启动时，对共享内存段的内存需求非常大，需要考虑以下几点  </span><br><span class="line">Connections:(1800 + 270 * max_locks_per_transaction) * max_connections  </span><br><span class="line">Autovacuum workers:(1800 + 270 * max_locks_per_transaction) * autovacuum_max_workers  </span><br><span class="line">Prepared transactions:(770 + 270 * max_locks_per_transaction) * max_prepared_transactions  </span><br><span class="line">Shared disk buffers:(block_size + 208) * shared_buffers  </span><br><span class="line">WAL buffers:(wal_block_size + 8) * wal_buffers  </span><br><span class="line">Fixed space requirements:770 kB  </span><br><span class="line">.  </span><br><span class="line">以上建议参数根据9.2以前的版本设置，后期的版本同样适用。  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">6\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.core.netdev_max_backlog  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7     </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">netdev_max_backlog    </span><br><span class="line">  ------------------    </span><br><span class="line">Maximum number  of  packets,  queued  on  the  INPUT  side,    </span><br><span class="line">when the interface receives packets faster than kernel can process them.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.core.netdev_max_backlog=1xxxx    </span><br><span class="line">.  </span><br><span class="line">INPUT链表越长，处理耗费越大，如果用了iptables管理的话，需要加大这个值。    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">7\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.core.rmem_default  </span><br><span class="line">net.core.rmem_max  </span><br><span class="line">net.core.wmem_default  </span><br><span class="line">net.core.wmem_max  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7     </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">rmem_default    </span><br><span class="line">  ------------    </span><br><span class="line">The default setting of the socket receive buffer in bytes.    </span><br><span class="line">.  </span><br><span class="line">rmem_max    </span><br><span class="line">  --------    </span><br><span class="line">The maximum receive socket buffer size in bytes.    </span><br><span class="line">.  </span><br><span class="line">wmem_default    </span><br><span class="line">  ------------    </span><br><span class="line">The default setting (in bytes) of the socket send buffer.    </span><br><span class="line">.  </span><br><span class="line">wmem_max    </span><br><span class="line">  --------    </span><br><span class="line">The maximum send socket buffer size in bytes.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.core.rmem_default = 262144    </span><br><span class="line">net.core.rmem_max = 4194304    </span><br><span class="line">net.core.wmem_default = 262144    </span><br><span class="line">net.core.wmem_max = 4194304    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">8\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.core.somaxconn   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7        </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">somaxconn - INTEGER    </span><br><span class="line">        Limit of socket listen() backlog, known in userspace as SOMAXCONN.    </span><br><span class="line">        Defaults to 128.    </span><br><span class="line">See also tcp_max_syn_backlog for additional tuning for TCP sockets.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.core.somaxconn=4xxx    </span><br><span class="line">```  </span><br><span class="line">      </span><br><span class="line">9\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_max_syn_backlog  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">tcp_max_syn_backlog - INTEGER    </span><br><span class="line">        Maximal number of remembered connection requests, which have not    </span><br><span class="line">        received an acknowledgment from connecting client.    </span><br><span class="line">        The minimal value is 128 for low memory machines, and it will    </span><br><span class="line">        increase in proportion to the memory of machine.    </span><br><span class="line">        If server suffers from overload, try increasing this number.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_max_syn_backlog=4xxx    </span><br><span class="line">pgpool-II 使用了这个值，用于将超过num_init_child以外的连接queue。     </span><br><span class="line">所以这个值决定了有多少连接可以在队列里面等待。    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">10\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_keepalive_intvl=20    </span><br><span class="line">net.ipv4.tcp_keepalive_probes=3    </span><br><span class="line">net.ipv4.tcp_keepalive_time=60     </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7        </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">tcp_keepalive_time - INTEGER    </span><br><span class="line">        How often TCP sends out keepalive messages when keepalive is enabled.    </span><br><span class="line">        Default: 2hours.    </span><br><span class="line">.  </span><br><span class="line">tcp_keepalive_probes - INTEGER    </span><br><span class="line">        How many keepalive probes TCP sends out, until it decides that the    </span><br><span class="line">        connection is broken. Default value: 9.    </span><br><span class="line">.  </span><br><span class="line">tcp_keepalive_intvl - INTEGER    </span><br><span class="line">        How frequently the probes are send out. Multiplied by    </span><br><span class="line">        tcp_keepalive_probes it is time to kill not responding connection,    </span><br><span class="line">        after probes started. Default value: 75sec i.e. connection    </span><br><span class="line">        will be aborted after ~11 minutes of retries.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置    </span><br><span class="line">    </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_keepalive_intvl=20    </span><br><span class="line">net.ipv4.tcp_keepalive_probes=3    </span><br><span class="line">net.ipv4.tcp_keepalive_time=60    </span><br><span class="line">.  </span><br><span class="line">连接空闲60秒后, 每隔20秒发心跳包, 尝试3次心跳包没有响应，关闭连接。 从开始空闲，到关闭连接总共历时120秒。    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">11\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_mem=8388608 12582912 16777216    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">tcp_mem - vector of 3 INTEGERs: min, pressure, max    </span><br><span class="line">单位 page    </span><br><span class="line">        min: below this number of pages TCP is not bothered about its    </span><br><span class="line">        memory appetite.    </span><br><span class="line">.  </span><br><span class="line">        pressure: when amount of memory allocated by TCP exceeds this number    </span><br><span class="line">        of pages, TCP moderates its memory consumption and enters memory    </span><br><span class="line">        pressure mode, which is exited when memory consumption falls    </span><br><span class="line">        under "min".    </span><br><span class="line">.  </span><br><span class="line">        max: number of pages allowed for queueing by all TCP sockets.    </span><br><span class="line">.  </span><br><span class="line">        Defaults are calculated at boot time from amount of available    </span><br><span class="line">        memory.    </span><br><span class="line">64GB 内存，自动计算的值是这样的    </span><br><span class="line">net.ipv4.tcp_mem = 1539615      2052821 3079230    </span><br><span class="line">.  </span><br><span class="line">512GB 内存，自动计算得到的值是这样的    </span><br><span class="line">net.ipv4.tcp_mem = 49621632     66162176        99243264    </span><br><span class="line">.  </span><br><span class="line">这个参数让操作系统启动时自动计算，问题也不大  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_mem=8388608 12582912 16777216    </span><br><span class="line">.  </span><br><span class="line">这个参数让操作系统启动时自动计算，问题也不大  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">12\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_fin_timeout  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7        </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">tcp_fin_timeout - INTEGER    </span><br><span class="line">        The length of time an orphaned (no longer referenced by any    </span><br><span class="line">        application) connection will remain in the FIN_WAIT_2 state    </span><br><span class="line">        before it is aborted at the local end.  While a perfectly    </span><br><span class="line">        valid "receive only" state for an un-orphaned connection, an    </span><br><span class="line">        orphaned connection in FIN_WAIT_2 state could otherwise wait    </span><br><span class="line">        forever for the remote to close its end of the connection.    </span><br><span class="line">        Cf. tcp_max_orphans    </span><br><span class="line">        Default: 60 seconds    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置    </span><br><span class="line">    </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_fin_timeout=5    </span><br><span class="line">.  </span><br><span class="line">加快僵尸连接回收速度   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">13\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_synack_retries  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">tcp_synack_retries - INTEGER    </span><br><span class="line">        Number of times SYNACKs for a passive TCP connection attempt will    </span><br><span class="line">        be retransmitted. Should not be higher than 255. Default value    </span><br><span class="line">        is 5, which corresponds to 31seconds till the last retransmission    </span><br><span class="line">        with the current initial RTO of 1second. With this the final timeout    </span><br><span class="line">        for a passive TCP connection will happen after 63seconds.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_synack_retries=2    </span><br><span class="line">.  </span><br><span class="line">缩短tcp syncack超时时间  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">14\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_syncookies  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">tcp_syncookies - BOOLEAN    </span><br><span class="line">        Only valid when the kernel was compiled with CONFIG_SYN_COOKIES    </span><br><span class="line">        Send out syncookies when the syn backlog queue of a socket    </span><br><span class="line">        overflows. This is to prevent against the common 'SYN flood attack'    </span><br><span class="line">        Default: 1    </span><br><span class="line">.  </span><br><span class="line">        Note, that syncookies is fallback facility.    </span><br><span class="line">        It MUST NOT be used to help highly loaded servers to stand    </span><br><span class="line">        against legal connection rate. If you see SYN flood warnings    </span><br><span class="line">        in your logs, but investigation shows that they occur    </span><br><span class="line">        because of overload with legal connections, you should tune    </span><br><span class="line">        another parameters until this warning disappear.    </span><br><span class="line">        See: tcp_max_syn_backlog, tcp_synack_retries, tcp_abort_on_overflow.    </span><br><span class="line">.  </span><br><span class="line">        syncookies seriously violate TCP protocol, do not allow    </span><br><span class="line">        to use TCP extensions, can result in serious degradation    </span><br><span class="line">        of some services (f.e. SMTP relaying), visible not by you,    </span><br><span class="line">        but your clients and relays, contacting you. While you see    </span><br><span class="line">        SYN flood warnings in logs not being really flooded, your server    </span><br><span class="line">        is seriously misconfigured.    </span><br><span class="line">.  </span><br><span class="line">        If you want to test which effects syncookies have to your    </span><br><span class="line">        network connections you can set this knob to 2 to enable    </span><br><span class="line">        unconditionally generation of syncookies.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_syncookies=1    </span><br><span class="line">.  </span><br><span class="line">防止syn flood攻击   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">15\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_timestamps  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">    </span><br><span class="line">```  </span><br><span class="line">tcp_timestamps - BOOLEAN    </span><br><span class="line">        Enable timestamps as defined in RFC1323.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置      </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_timestamps=1    </span><br><span class="line">.  </span><br><span class="line">tcp_timestamps 是 tcp 协议中的一个扩展项，通过时间戳的方式来检测过来的包以防止 PAWS(Protect Against Wrapped  Sequence numbers)，可以提高 tcp 的性能。  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">16\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_tw_recycle  </span><br><span class="line">net.ipv4.tcp_tw_reuse  </span><br><span class="line">net.ipv4.tcp_max_tw_buckets  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">tcp_tw_recycle - BOOLEAN    </span><br><span class="line">        Enable fast recycling TIME-WAIT sockets. Default value is 0.    </span><br><span class="line">        It should not be changed without advice/request of technical    </span><br><span class="line">        experts.    </span><br><span class="line">.  </span><br><span class="line">tcp_tw_reuse - BOOLEAN    </span><br><span class="line">        Allow to reuse TIME-WAIT sockets for new connections when it is    </span><br><span class="line">        safe from protocol viewpoint. Default value is 0.    </span><br><span class="line">        It should not be changed without advice/request of technical    </span><br><span class="line">        experts.    </span><br><span class="line">.  </span><br><span class="line">tcp_max_tw_buckets - INTEGER  </span><br><span class="line">        Maximal number of timewait sockets held by system simultaneously.  </span><br><span class="line">        If this number is exceeded time-wait socket is immediately destroyed  </span><br><span class="line">        and warning is printed.   </span><br><span class="line">This limit exists only to prevent simple DoS attacks,   </span><br><span class="line">you _must_ not lower the limit artificially,   </span><br><span class="line">        but rather increase it (probably, after increasing installed memory),    </span><br><span class="line">        if network conditions require more than default value.   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置    </span><br><span class="line">    </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_tw_recycle=0    </span><br><span class="line">net.ipv4.tcp_tw_reuse=1    </span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 2xxxxx    </span><br><span class="line">.  </span><br><span class="line">net.ipv4.tcp_tw_recycle和net.ipv4.tcp_timestamps不建议同时开启    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">17\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_rmem  </span><br><span class="line">net.ipv4.tcp_wmem  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">tcp_wmem - vector of 3 INTEGERs: min, default, max    </span><br><span class="line">        min: Amount of memory reserved for send buffers for TCP sockets.    </span><br><span class="line">        Each TCP socket has rights to use it due to fact of its birth.    </span><br><span class="line">        Default: 1 page    </span><br><span class="line">.  </span><br><span class="line">        default: initial size of send buffer used by TCP sockets.  This    </span><br><span class="line">        value overrides net.core.wmem_default used by other protocols.    </span><br><span class="line">        It is usually lower than net.core.wmem_default.    </span><br><span class="line">        Default: 16K    </span><br><span class="line">.  </span><br><span class="line">        max: Maximal amount of memory allowed for automatically tuned    </span><br><span class="line">        send buffers for TCP sockets. This value does not override    </span><br><span class="line">        net.core.wmem_max.  Calling setsockopt() with SO_SNDBUF disables    </span><br><span class="line">        automatic tuning of that socket's send buffer size, in which case    </span><br><span class="line">        this value is ignored.    </span><br><span class="line">        Default: between 64K and 4MB, depending on RAM size.    </span><br><span class="line">.  </span><br><span class="line">tcp_rmem - vector of 3 INTEGERs: min, default, max    </span><br><span class="line">        min: Minimal size of receive buffer used by TCP sockets.    </span><br><span class="line">        It is guaranteed to each TCP socket, even under moderate memory    </span><br><span class="line">        pressure.    </span><br><span class="line">        Default: 1 page    </span><br><span class="line">.  </span><br><span class="line">        default: initial size of receive buffer used by TCP sockets.    </span><br><span class="line">        This value overrides net.core.rmem_default used by other protocols.    </span><br><span class="line">        Default: 87380 bytes. This value results in window of 65535 with    </span><br><span class="line">        default setting of tcp_adv_win_scale and tcp_app_win:0 and a bit    </span><br><span class="line">        less for default tcp_app_win. See below about these variables.    </span><br><span class="line">.  </span><br><span class="line">        max: maximal size of receive buffer allowed for automatically    </span><br><span class="line">        selected receiver buffers for TCP socket. This value does not override    </span><br><span class="line">        net.core.rmem_max.  Calling setsockopt() with SO_RCVBUF disables    </span><br><span class="line">        automatic tuning of that socket's receive buffer size, in which    </span><br><span class="line">        case this value is ignored.    </span><br><span class="line">        Default: between 87380B and 6MB, depending on RAM size.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.tcp_rmem=8192 87380 16777216    </span><br><span class="line">net.ipv4.tcp_wmem=8192 65536 16777216    </span><br><span class="line">.  </span><br><span class="line">许多数据库的推荐设置，提高网络性能  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">18\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.nf_conntrack_max  </span><br><span class="line">net.netfilter.nf_conntrack_max  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">nf_conntrack_max - INTEGER    </span><br><span class="line">        Size of connection tracking table.    </span><br><span class="line">Default value is nf_conntrack_buckets value * 4.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.nf_conntrack_max=1xxxxxx    </span><br><span class="line">net.netfilter.nf_conntrack_max=1xxxxxx    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">19\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.dirty_background_bytes   </span><br><span class="line">vm.dirty_expire_centisecs   </span><br><span class="line">vm.dirty_ratio   </span><br><span class="line">vm.dirty_writeback_centisecs   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7        </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">dirty_background_bytes    </span><br><span class="line">.  </span><br><span class="line">Contains the amount of dirty memory at which the background kernel    </span><br><span class="line">flusher threads will start writeback.    </span><br><span class="line">.  </span><br><span class="line">Note: dirty_background_bytes is the counterpart of dirty_background_ratio. Only    </span><br><span class="line">one of them may be specified at a time. When one sysctl is written it is    </span><br><span class="line">immediately taken into account to evaluate the dirty memory limits and the    </span><br><span class="line">other appears as 0 when read.    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">dirty_background_ratio    </span><br><span class="line">.  </span><br><span class="line">Contains, as a percentage of total system memory, the number of pages at which    </span><br><span class="line">the background kernel flusher threads will start writing out dirty data.    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">dirty_bytes    </span><br><span class="line">.  </span><br><span class="line">Contains the amount of dirty memory at which a process generating disk writes    </span><br><span class="line">will itself start writeback.    </span><br><span class="line">.  </span><br><span class="line">Note: dirty_bytes is the counterpart of dirty_ratio. Only one of them may be    </span><br><span class="line">specified at a time. When one sysctl is written it is immediately taken into    </span><br><span class="line">account to evaluate the dirty memory limits and the other appears as 0 when    </span><br><span class="line">read.    </span><br><span class="line">.  </span><br><span class="line">Note: the minimum value allowed for dirty_bytes is two pages (in bytes); any    </span><br><span class="line">value lower than this limit will be ignored and the old configuration will be    </span><br><span class="line">retained.    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">dirty_expire_centisecs    </span><br><span class="line">.  </span><br><span class="line">This tunable is used to define when dirty data is old enough to be eligible    </span><br><span class="line">for writeout by the kernel flusher threads.  It is expressed in 100'ths    </span><br><span class="line">of a second.  Data which has been dirty in-memory for longer than this    </span><br><span class="line">interval will be written out next time a flusher thread wakes up.    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">dirty_ratio    </span><br><span class="line">.  </span><br><span class="line">Contains, as a percentage of total system memory, the number of pages at which    </span><br><span class="line">a process which is generating disk writes will itself start writing out dirty    </span><br><span class="line">data.    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">dirty_writeback_centisecs    </span><br><span class="line">.  </span><br><span class="line">The kernel flusher threads will periodically wake up and write `old' data    </span><br><span class="line">out to disk.  This tunable expresses the interval between those wakeups, in    </span><br><span class="line">100'ths of a second.    </span><br><span class="line">.  </span><br><span class="line">Setting this to zero disables periodic writeback altogether.    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.dirty_background_bytes = 4096000000    </span><br><span class="line">vm.dirty_expire_centisecs = 6000    </span><br><span class="line">vm.dirty_ratio = 80    </span><br><span class="line">vm.dirty_writeback_centisecs = 50    </span><br><span class="line">.  </span><br><span class="line">减少数据库进程刷脏页的频率，dirty_background_bytes根据实际IOPS能力以及内存大小设置    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">20\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.extra_free_kbytes  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">extra_free_kbytes    </span><br><span class="line">.  </span><br><span class="line">This parameter tells the VM to keep extra free memory   </span><br><span class="line">between the threshold where background reclaim (kswapd) kicks in,   </span><br><span class="line">and the threshold where direct reclaim (by allocating processes) kicks in.    </span><br><span class="line">.  </span><br><span class="line">This is useful for workloads that require low latency memory allocations    </span><br><span class="line">and have a bounded burstiness in memory allocations,   </span><br><span class="line">for example a realtime application that receives and transmits network traffic    </span><br><span class="line">(causing in-kernel memory allocations) with a maximum total message burst    </span><br><span class="line">size of 200MB may need 200MB of extra free memory to avoid direct reclaim    </span><br><span class="line">related latencies.    </span><br><span class="line">.  </span><br><span class="line">目标是尽量让后台进程回收内存，比用户进程提早多少kbytes回收，因此用户进程可以快速分配内存。    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.extra_free_kbytes=4xxxxxx    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">21\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.min_free_kbytes  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">min_free_kbytes:    </span><br><span class="line">.  </span><br><span class="line">This is used to force the Linux VM to keep a minimum number    </span><br><span class="line">of kilobytes free.  The VM uses this number to compute a    </span><br><span class="line">watermark[WMARK_MIN] value for each lowmem zone in the system.    </span><br><span class="line">Each lowmem zone gets a number of reserved free pages based    </span><br><span class="line">proportionally on its size.    </span><br><span class="line">.  </span><br><span class="line">Some minimal amount of memory is needed to satisfy PF_MEMALLOC    </span><br><span class="line">allocations; if you set this to lower than 1024KB, your system will    </span><br><span class="line">become subtly broken, and prone to deadlock under high loads.    </span><br><span class="line">.  </span><br><span class="line">Setting this too high will OOM your machine instantly.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.min_free_kbytes = 2xxxxxx     # vm.min_free_kbytes 建议每32G内存分配1G vm.min_free_kbytes</span><br><span class="line">.  </span><br><span class="line">防止在高负载时系统无响应，减少内存分配死锁概率。    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">22\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.mmap_min_addr  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7       </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">mmap_min_addr    </span><br><span class="line">.  </span><br><span class="line">This file indicates the amount of address space  which a user process will    </span><br><span class="line">be restricted from mmapping.  Since kernel null dereference bugs could    </span><br><span class="line">accidentally operate based on the information in the first couple of pages    </span><br><span class="line">of memory userspace processes should not be allowed to write to them.  By    </span><br><span class="line">default this value is set to 0 and no protections will be enforced by the    </span><br><span class="line">security module.  Setting this value to something like 64k will allow the    </span><br><span class="line">vast majority of applications to work correctly and provide defense in depth    </span><br><span class="line">against future potential kernel bugs.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.mmap_min_addr=6xxxx    </span><br><span class="line">.  </span><br><span class="line">防止内核隐藏的BUG导致的问题  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">23\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.overcommit_memory   </span><br><span class="line">vm.overcommit_ratio   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">overcommit_kbytes:    </span><br><span class="line">.  </span><br><span class="line">When overcommit_memory is set to 2, the committed address space is not    </span><br><span class="line">permitted to exceed swap plus this amount of physical RAM. See below.    </span><br><span class="line">.  </span><br><span class="line">Note: overcommit_kbytes is the counterpart of overcommit_ratio. Only one    </span><br><span class="line">of them may be specified at a time. Setting one disables the other (which    </span><br><span class="line">then appears as 0 when read).    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">overcommit_memory:    </span><br><span class="line">.  </span><br><span class="line">This value contains a flag that enables memory overcommitment.    </span><br><span class="line">.  </span><br><span class="line">When this flag is 0,   </span><br><span class="line">the kernel attempts to estimate the amount    </span><br><span class="line">of free memory left when userspace requests more memory.    </span><br><span class="line">.  </span><br><span class="line">When this flag is 1,   </span><br><span class="line">the kernel pretends there is always enough memory until it actually runs out.    </span><br><span class="line">.  </span><br><span class="line">When this flag is 2,   </span><br><span class="line">the kernel uses a "never overcommit"    </span><br><span class="line">policy that attempts to prevent any overcommit of memory.    </span><br><span class="line">Note that user_reserve_kbytes affects this policy.    </span><br><span class="line">.  </span><br><span class="line">This feature can be very useful because there are a lot of    </span><br><span class="line">programs that malloc() huge amounts of memory "just-in-case"    </span><br><span class="line">and don't use much of it.    </span><br><span class="line">.  </span><br><span class="line">The default value is 0.    </span><br><span class="line">.  </span><br><span class="line">See Documentation/vm/overcommit-accounting and    </span><br><span class="line">security/commoncap.c::cap_vm_enough_memory() for more information.    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">.  </span><br><span class="line">overcommit_ratio:    </span><br><span class="line">.  </span><br><span class="line">When overcommit_memory is set to 2,   </span><br><span class="line">the committed address space is not permitted to exceed   </span><br><span class="line">      swap + this percentage of physical RAM.    </span><br><span class="line">See above.    </span><br><span class="line">.  </span><br><span class="line">==============================================================    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.overcommit_memory = 0    </span><br><span class="line">vm.overcommit_ratio = 90    </span><br><span class="line">.  </span><br><span class="line">vm.overcommit_memory = 0 时 vm.overcommit_ratio可以不设置   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">24\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.swappiness   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">swappiness    </span><br><span class="line">.  </span><br><span class="line">This control is used to define how aggressive the kernel will swap    </span><br><span class="line">memory pages.    </span><br><span class="line">Higher values will increase agressiveness, lower values    </span><br><span class="line">decrease the amount of swap.    </span><br><span class="line">.  </span><br><span class="line">The default value is 60.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.swappiness = 0    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">25\.     </span><br><span class="line">  </span><br><span class="line">  参数     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.zone_reclaim_mode   </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">zone_reclaim_mode:    </span><br><span class="line">.  </span><br><span class="line">Zone_reclaim_mode allows someone to set more or less aggressive approaches to    </span><br><span class="line">reclaim memory when a zone runs out of memory. If it is set to zero then no    </span><br><span class="line">zone reclaim occurs. Allocations will be satisfied from other zones / nodes    </span><br><span class="line">in the system.    </span><br><span class="line">.  </span><br><span class="line">This is value ORed together of    </span><br><span class="line">.  </span><br><span class="line">1       = Zone reclaim on    </span><br><span class="line">2       = Zone reclaim writes dirty pages out    </span><br><span class="line">4       = Zone reclaim swaps pages    </span><br><span class="line">.  </span><br><span class="line">zone_reclaim_mode is disabled by default.  For file servers or workloads    </span><br><span class="line">that benefit from having their data cached, zone_reclaim_mode should be    </span><br><span class="line">left disabled as the caching effect is likely to be more important than    </span><br><span class="line">data locality.    </span><br><span class="line">.  </span><br><span class="line">zone_reclaim may be enabled if it's known that the workload is partitioned    </span><br><span class="line">such that each partition fits within a NUMA node and that accessing remote    </span><br><span class="line">memory would cause a measurable performance reduction.  The page allocator    </span><br><span class="line">will then reclaim easily reusable pages (those page cache pages that are    </span><br><span class="line">currently not used) before allocating off node pages.    </span><br><span class="line">.  </span><br><span class="line">Allowing zone reclaim to write out pages stops processes that are    </span><br><span class="line">writing large amounts of data from dirtying pages on other nodes. Zone    </span><br><span class="line">reclaim will write out dirty pages if a zone fills up and so effectively    </span><br><span class="line">throttle the process. This may decrease the performance of a single process    </span><br><span class="line">since it cannot use all of system memory to buffer the outgoing writes    </span><br><span class="line">anymore but it preserve the memory on other nodes so that the performance    </span><br><span class="line">of other processes running on other nodes will not be affected.    </span><br><span class="line">.  </span><br><span class="line">Allowing regular swap effectively restricts allocations to the local    </span><br><span class="line">node unless explicitly overridden by memory policies or cpuset    </span><br><span class="line">configurations.    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">vm.zone_reclaim_mode=0    </span><br><span class="line">.  </span><br><span class="line">不使用NUMA  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">26\.    </span><br><span class="line">  </span><br><span class="line">  参数  </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.ip_local_port_range  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7         </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">ip_local_port_range - 2 INTEGERS  </span><br><span class="line">        Defines the local port range that is used by TCP and UDP to  </span><br><span class="line">        choose the local port. The first number is the first, the  </span><br><span class="line">        second the last local port number. The default values are  </span><br><span class="line">        32768 and 61000 respectively.  </span><br><span class="line">.  </span><br><span class="line">ip_local_reserved_ports - list of comma separated ranges  </span><br><span class="line">        Specify the ports which are reserved for known third-party  </span><br><span class="line">        applications. These ports will not be used by automatic port  </span><br><span class="line">        assignments (e.g. when calling connect() or bind() with port  </span><br><span class="line">        number 0). Explicit port allocation behavior is unchanged.  </span><br><span class="line">.  </span><br><span class="line">        The format used for both input and output is a comma separated  </span><br><span class="line">        list of ranges (e.g. "1,2-4,10-10" for ports 1, 2, 3, 4 and  </span><br><span class="line">        10). Writing to the file will clear all previously reserved  </span><br><span class="line">        ports and update the current list with the one given in the  </span><br><span class="line">        input.  </span><br><span class="line">.  </span><br><span class="line">        Note that ip_local_port_range and ip_local_reserved_ports  </span><br><span class="line">        settings are independent and both are considered by the kernel  </span><br><span class="line">        when determining which ports are available for automatic port  </span><br><span class="line">        assignments.  </span><br><span class="line">.  </span><br><span class="line">        You can reserve ports which are not in the current  </span><br><span class="line">        ip_local_port_range, e.g.:  </span><br><span class="line">.  </span><br><span class="line">        $ cat /proc/sys/net/ipv4/ip_local_port_range  </span><br><span class="line">        32000   61000  </span><br><span class="line">        $ cat /proc/sys/net/ipv4/ip_local_reserved_ports  </span><br><span class="line">        8080,9148  </span><br><span class="line">.  </span><br><span class="line">        although this is redundant. However such a setting is useful  </span><br><span class="line">        if later the port range is changed to a value that will  </span><br><span class="line">        include the reserved ports.  </span><br><span class="line">.  </span><br><span class="line">        Default: Empty  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置     </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">net.ipv4.ip_local_port_range=40000 65535    </span><br><span class="line">.  </span><br><span class="line">限制本地动态端口分配范围，防止占用监听端口。  </span><br><span class="line">```  </span><br><span class="line">      </span><br><span class="line">27\.    </span><br><span class="line">  </span><br><span class="line">  参数    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">  vm.nr_hugepages  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  支持系统    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">CentOS 6, 7  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  参数解释    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">==============================================================  </span><br><span class="line">nr_hugepages  </span><br><span class="line">Change the minimum size of the hugepage pool.  </span><br><span class="line">See Documentation/vm/hugetlbpage.txt  </span><br><span class="line">==============================================================  </span><br><span class="line">nr_overcommit_hugepages  </span><br><span class="line">Change the maximum size of the hugepage pool. The maximum is  </span><br><span class="line">nr_hugepages + nr_overcommit_hugepages.  </span><br><span class="line">See Documentation/vm/hugetlbpage.txt  </span><br><span class="line">.  </span><br><span class="line">The output of "cat /proc/meminfo" will include lines like:  </span><br><span class="line">......  </span><br><span class="line">HugePages_Total: vvv  </span><br><span class="line">HugePages_Free:  www  </span><br><span class="line">HugePages_Rsvd:  xxx  </span><br><span class="line">HugePages_Surp:  yyy  </span><br><span class="line">Hugepagesize:    zzz kB  </span><br><span class="line">.  </span><br><span class="line">where:  </span><br><span class="line">HugePages_Total is the size of the pool of huge pages.  </span><br><span class="line">HugePages_Free  is the number of huge pages in the pool that are not yet  </span><br><span class="line">                allocated.  </span><br><span class="line">HugePages_Rsvd  is short for "reserved," and is the number of huge pages for  </span><br><span class="line">                which a commitment to allocate from the pool has been made,  </span><br><span class="line">                but no allocation has yet been made.  Reserved huge pages  </span><br><span class="line">                guarantee that an application will be able to allocate a  </span><br><span class="line">                huge page from the pool of huge pages at fault time.  </span><br><span class="line">HugePages_Surp  is short for "surplus," and is the number of huge pages in  </span><br><span class="line">                the pool above the value in /proc/sys/vm/nr_hugepages. The  </span><br><span class="line">                maximum number of surplus huge pages is controlled by  </span><br><span class="line">                /proc/sys/vm/nr_overcommit_hugepages.  </span><br><span class="line">.  </span><br><span class="line">/proc/filesystems should also show a filesystem of type "hugetlbfs" configured  </span><br><span class="line">in the kernel.  </span><br><span class="line">.  </span><br><span class="line">/proc/sys/vm/nr_hugepages indicates the current number of "persistent" huge  </span><br><span class="line">pages in the kernel's huge page pool.  "Persistent" huge pages will be  </span><br><span class="line">returned to the huge page pool when freed by a task.  A user with root  </span><br><span class="line">privileges can dynamically allocate more or free some persistent huge pages  </span><br><span class="line">by increasing or decreasing the value of 'nr_hugepages'.  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">  推荐设置    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">如果要使用PostgreSQL的huge page，建议设置它。    </span><br><span class="line">大于数据库需要的共享内存即可。    </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">28\.</span><br><span class="line"></span><br><span class="line">  参数</span><br></pre></td></tr></tbody></table></figure><p>  fs.nr_open<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">支持系统</span><br></pre></td></tr></tbody></table></figure><p></p><p>CentOS 6, 7<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">参数解释</span><br></pre></td></tr></tbody></table></figure><p></p><p>nr_open:</p><p>This denotes the maximum number of file-handles a process can<br>allocate. Default value is 1024*1024 (1048576) which should be<br>enough for most machines. Actual limit depends on RLIMIT_NOFILE<br>resource limit.</p><p>它还影响security/limits.conf 的文件句柄限制，单个进程的打开句柄不能大于fs.nr_open，所以要加大文件句柄限制，首先要加大nr_open</p><pre><code>推荐设置</code></pre><p>对于有很多对象（表、视图、索引、序列、物化视图等）的PostgreSQL数据库，建议设置为2000万，<br>例如fs.nr_open=20480000</p><pre><code>## 数据库关心的资源限制  1\. 通过/etc/security/limits.conf设置，或者ulimit设置    2\. 通过/proc/$pid/limits查看当前进程的设置    </code></pre><h1 id="core-limits-the-core-file-size-KB"><a href="#core-limits-the-core-file-size-KB" class="headerlink" title="- core - limits the core file size (KB)"></a>- core - limits the core file size (KB)</h1><h1 id="memlock-max-locked-in-memory-address-space-KB"><a href="#memlock-max-locked-in-memory-address-space-KB" class="headerlink" title="- memlock - max locked-in-memory address space (KB)"></a>- memlock - max locked-in-memory address space (KB)</h1><h1 id="nofile-max-number-of-open-files-建议设置为1000万-但是必须设置sysctl-fs-nr-open大于它，否则会导致系统无法登陆。"><a href="#nofile-max-number-of-open-files-建议设置为1000万-但是必须设置sysctl-fs-nr-open大于它，否则会导致系统无法登陆。" class="headerlink" title="- nofile - max number of open files  建议设置为1000万 , 但是必须设置sysctl, fs.nr_open大于它，否则会导致系统无法登陆。"></a>- nofile - max number of open files  建议设置为1000万 , 但是必须设置sysctl, fs.nr_open大于它，否则会导致系统无法登陆。</h1><h1 id="nproc-max-number-of-processes"><a href="#nproc-max-number-of-processes" class="headerlink" title="- nproc - max number of processes"></a>- nproc - max number of processes</h1><p>以上四个是非常关心的配置<br>….  </p><h1 id="data-max-data-size-KB"><a href="#data-max-data-size-KB" class="headerlink" title="- data - max data size (KB)"></a>- data - max data size (KB)</h1><h1 id="fsize-maximum-filesize-KB"><a href="#fsize-maximum-filesize-KB" class="headerlink" title="- fsize - maximum filesize (KB)"></a>- fsize - maximum filesize (KB)</h1><h1 id="rss-max-resident-set-size-KB"><a href="#rss-max-resident-set-size-KB" class="headerlink" title="- rss - max resident set size (KB)"></a>- rss - max resident set size (KB)</h1><h1 id="stack-max-stack-size-KB"><a href="#stack-max-stack-size-KB" class="headerlink" title="- stack - max stack size (KB)"></a>- stack - max stack size (KB)</h1><h1 id="cpu-max-CPU-time-MIN"><a href="#cpu-max-CPU-time-MIN" class="headerlink" title="- cpu - max CPU time (MIN)"></a>- cpu - max CPU time (MIN)</h1><h1 id="as-address-space-limit-KB"><a href="#as-address-space-limit-KB" class="headerlink" title="- as - address space limit (KB)"></a>- as - address space limit (KB)</h1><h1 id="maxlogins-max-number-of-logins-for-this-user"><a href="#maxlogins-max-number-of-logins-for-this-user" class="headerlink" title="- maxlogins - max number of logins for this user"></a>- maxlogins - max number of logins for this user</h1><h1 id="maxsyslogins-max-number-of-logins-on-the-system"><a href="#maxsyslogins-max-number-of-logins-on-the-system" class="headerlink" title="- maxsyslogins - max number of logins on the system"></a>- maxsyslogins - max number of logins on the system</h1><h1 id="priority-the-priority-to-run-user-process-with"><a href="#priority-the-priority-to-run-user-process-with" class="headerlink" title="- priority - the priority to run user process with"></a>- priority - the priority to run user process with</h1><h1 id="locks-max-number-of-file-locks-the-user-can-hold"><a href="#locks-max-number-of-file-locks-the-user-can-hold" class="headerlink" title="- locks - max number of file locks the user can hold"></a>- locks - max number of file locks the user can hold</h1><h1 id="sigpending-max-number-of-pending-signals"><a href="#sigpending-max-number-of-pending-signals" class="headerlink" title="- sigpending - max number of pending signals"></a>- sigpending - max number of pending signals</h1><h1 id="msgqueue-max-memory-used-by-POSIX-message-queues-bytes"><a href="#msgqueue-max-memory-used-by-POSIX-message-queues-bytes" class="headerlink" title="- msgqueue - max memory used by POSIX message queues (bytes)"></a>- msgqueue - max memory used by POSIX message queues (bytes)</h1><h1 id="nice-max-nice-priority-allowed-to-raise-to-values-20-19"><a href="#nice-max-nice-priority-allowed-to-raise-to-values-20-19" class="headerlink" title="- nice - max nice priority allowed to raise to values: [-20, 19]"></a>- nice - max nice priority allowed to raise to values: [-20, 19]</h1><h1 id="rtprio-max-realtime-priority"><a href="#rtprio-max-realtime-priority" class="headerlink" title="- rtprio - max realtime priority"></a>- rtprio - max realtime priority</h1><pre><code>## 数据库关心的IO调度规则  1\. 目前操作系统支持的IO调度策略包括cfq, deadline, noop 等。    </code></pre><p>/kernel-doc-xxx/Documentation/block<br>-r–r–r– 1 root root   674 Apr  8 16:33 00-INDEX<br>-r–r–r– 1 root root 55006 Apr  8 16:33 biodoc.txt<br>-r–r–r– 1 root root   618 Apr  8 16:33 capability.txt<br>-r–r–r– 1 root root 12791 Apr  8 16:33 cfq-iosched.txt<br>-r–r–r– 1 root root 13815 Apr  8 16:33 data-integrity.txt<br>-r–r–r– 1 root root  2841 Apr  8 16:33 deadline-iosched.txt<br>-r–r–r– 1 root root  4713 Apr  8 16:33 ioprio.txt<br>-r–r–r– 1 root root  2535 Apr  8 16:33 null_blk.txt<br>-r–r–r– 1 root root  4896 Apr  8 16:33 queue-sysfs.txt<br>-r–r–r– 1 root root  2075 Apr  8 16:33 request.txt<br>-r–r–r– 1 root root  3272 Apr  8 16:33 stat.txt<br>-r–r–r– 1 root root  1414 Apr  8 16:33 switching-sched.txt<br>-r–r–r– 1 root root  3916 Apr  8 16:33 writeback_cache_control.txt  </p><pre><code>如果你要详细了解这些调度策略的规则，可以查看WIKI或者看内核文档。    从这里可以看到它的调度策略  </code></pre><p>cat /sys/block/vdb/queue/scheduler<br>noop [deadline] cfq   </p><pre><code>修改    </code></pre><p>echo deadline > /sys/block/hda/queue/scheduler  </p><pre><code>或者修改启动参数    </code></pre><p>grub.conf<br>elevator=deadline<br><code>`</code>  </p><p>  从很多测试结果来看，数据库使用deadline调度，性能会更稳定一些。      </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1. 关闭透明大页  </p><p>2. 禁用NUMA  </p><p>3. SSD的对齐  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb 的 forEach用法</title>
      <link href="/2019/05/21/mongodb-forEach/"/>
      <url>/2019/05/21/mongodb-forEach/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="a81fc51f0f.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>努力不一定会成功，可不努力会很轻松哦</strong></p></blockquote><h2 id="MongoDB-forEach-说明"><a href="#MongoDB-forEach-说明" class="headerlink" title="MongoDB forEach 说明"></a>MongoDB <a href="https://docs.mongodb.com/manual/reference/method/cursor.forEach/" target="_blank" rel="noopener">forEach</a> 说明</h2><p>forEach方法中的function回调有三个参数:</p><ul><li>遍历的数组内容</li><li>对应的数组索引</li><li>数组本身</li></ul><h2 id="MongoDB-forEach-使用案例"><a href="#MongoDB-forEach-使用案例" class="headerlink" title="MongoDB forEach 使用案例"></a>MongoDB forEach 使用案例</h2><h4 id="MongoDB数据插入、删除、更新、批量更新某个字段"><a href="#MongoDB数据插入、删除、更新、批量更新某个字段" class="headerlink" title="MongoDB数据插入、删除、更新、批量更新某个字段"></a>MongoDB数据插入、删除、更新、批量更新某个字段</h4><p>批量更新某个字段</p><p>例1<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(<span class="string">'bond_sentiment_news'</span>).find({<span class="string">"source"</span> : 2,<span class="string">"siteUrl"</span> : <span class="string">"http://www.21jingji.com/"</span>}).forEach(</span><br><span class="line">   <span class="keyword">function</span>(item){                </span><br><span class="line">       db.getCollection(<span class="string">'bond_sentiment_news'</span>).update({<span class="string">"_id"</span>:item._id},{<span class="variable">$set</span>:{<span class="string">"siteName"</span>:<span class="string">"21经济网"</span>}})</span><br><span class="line">   }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>例2<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(<span class="string">'my_booking'</span>).find({<span class="string">"hospitalName"</span>:/xx医院/,openId:/^2/}).forEach(</span><br><span class="line">   <span class="keyword">function</span>(item){                </span><br><span class="line">       db.getCollection(<span class="string">'my_booking'</span>).update({<span class="string">"_id"</span>:item._id},{<span class="variable">$set</span>:{<span class="string">"payType"</span>: <span class="string">"1"</span>}})</span><br><span class="line">   }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>查询出hospitalName是xx医院和openId以2开头的所有记录，并且更新my_booking表中的payType为1.</p><p>例3<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(<span class="string">'my_booking'</span>).find({<span class="string">"hospitalName"</span>:/运城市中心医院/,openId:{<span class="variable">$not</span>:/^2/}}).forEach(</span><br><span class="line">   <span class="keyword">function</span>(item){                </span><br><span class="line">       db.getCollection(<span class="string">'my_booking'</span>).update({<span class="string">"_id"</span>:item._id},{<span class="variable">$set</span>:{<span class="string">"outTradeNo1"</span>: item.outTradeNo2}})</span><br><span class="line">   }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>查询出xx医院和不已2开头的openId的所有记录，并且将每条记录的outTradeNo2赋值给outTradeNo1.</p><h4 id="MongoDB-数组遍历操作-forEach"><a href="#MongoDB-数组遍历操作-forEach" class="headerlink" title="MongoDB 数组遍历操作 forEach"></a>MongoDB 数组遍历操作 forEach</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.User.find().forEach(</span><br><span class="line">   <span class="keyword">function</span>(item){                </span><br><span class="line">       db.User.update({<span class="string">"_id"</span>:item._id},{<span class="string">"<span class="variable">$set</span>"</span>:{<span class="string">"LastUpdate"</span>:item.CreateAt}},<span class="literal">false</span>,<span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h4 id="MongoDB-更新每条数据某个字段的值"><a href="#MongoDB-更新每条数据某个字段的值" class="headerlink" title="MongoDB 更新每条数据某个字段的值"></a>MongoDB 更新每条数据某个字段的值</h4><p>例1<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var begin = 1499675090;</span><br><span class="line">var end = 1499675198;</span><br><span class="line">var t = begin;</span><br><span class="line"><span class="keyword">while</span>(t<=end){</span><br><span class="line">    db.getCollection(<span class="string">'event'</span>).find({createdDate:{<span class="variable">$lt</span>:t+100, <span class="variable">$gte</span>:t}}).forEach(</span><br><span class="line">        <span class="keyword">function</span>(item){</span><br><span class="line">            <span class="keyword">if</span>(item.account_login!= undefined && item.account_login!= null){</span><br><span class="line">                item.account_login = item.account_login.substr(0,5)+<span class="string">'123456'</span>;</span><br><span class="line">                db.getCollection(<span class="string">'event'</span>).save(item);</span><br><span class="line">            }</span><br><span class="line">       </span><br><span class="line">        };</span><br><span class="line">    );</span><br><span class="line">    t+=100;</span><br><span class="line">        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>例2<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var begin = 1499675090;</span><br><span class="line">var end = 1499675198;</span><br><span class="line">var t = begin;</span><br><span class="line"><span class="keyword">while</span>(t<=end){</span><br><span class="line">    var aa=db.getCollection(<span class="string">'event'</span>).find({createdDate:{<span class="variable">$lt</span>:t+100, <span class="variable">$gte</span>:t}})</span><br><span class="line">    aa.forEach(</span><br><span class="line">        <span class="keyword">function</span>(item){</span><br><span class="line">            <span class="keyword">if</span>(item.account_login!= undefined && item.account_login!= null){</span><br><span class="line">                item.account_login = item.account_login.substr(0,5)+<span class="string">'123456'</span>;</span><br><span class="line">                db.getCollection(<span class="string">'event'</span>).save(item);</span><br><span class="line">            }</span><br><span class="line">       </span><br><span class="line">        };</span><br><span class="line">    );</span><br><span class="line">    t+=100;</span><br><span class="line">        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(<span class="string">'event'</span>).find().forEach(</span><br><span class="line">     <span class="keyword">function</span>(item){</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(item.account_login!= undefined&&item.account_login!= null){</span><br><span class="line">           </span><br><span class="line">      item.account_login = item.account_login.substr(0,5)+<span class="string">'123456'</span>;</span><br><span class="line">            </span><br><span class="line">      db.getCollection(<span class="string">'event'</span>).save(item);</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">  }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h4 id="MongoDB-更新字段操作"><a href="#MongoDB-更新字段操作" class="headerlink" title="MongoDB 更新字段操作"></a>MongoDB 更新字段操作</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(<span class="string">'book'</span>).find({}).forEach(</span><br><span class="line">    <span class="keyword">function</span>(X){</span><br><span class="line">        x.age = new NumberInt(x.age);// 将字符串转化为数字</span><br><span class="line">        db.book.save(x);//保存数据</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="添加字段或更新值"><a href="#添加字段或更新值" class="headerlink" title="添加字段或更新值"></a>添加字段或更新值</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(<span class="string">'test'</span>).update(</span><br><span class="line">  {},</span><br><span class="line">  {</span><br><span class="line">       <span class="variable">$set</span>:{</span><br><span class="line">             <span class="string">'createTime'</span>:<span class="string">'2017-06-29 08:08'</span>,</span><br><span class="line">             <span class="string">'updateTime'</span>:<span class="string">'2017-06-29 08:08</span></span><br><span class="line"><span class="string">       }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb aggregate 基于UNIX时间戳的聚合</title>
      <link href="/2019/05/20/mongodb-aggregate/"/>
      <url>/2019/05/20/mongodb-aggregate/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="iiiiii.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>对今天解决不了的事情，也不要着急。因为明天也可能还是解决不了。</strong></p></blockquote><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>开发找我问<code>MongoDB</code> 的 <code>aggregate 聚合</code>用过不<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f630.png?v8">😰</span> 。</p><p>我说查查资料吧，发现是<code>aggregate</code>聚合管道 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f628.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f628.png?v8">😨</span> 。</p><p>把SQL 与 Aggergation 对比下<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></p><table><thead><tr><th style="text-align:center">SQL Terms, Functions, and Concepts</th><th style="text-align:center">MongoDB Aggregation Operators</th></tr></thead><tbody><tr><td style="text-align:center">WHERE</td><td style="text-align:center">$match</td></tr><tr><td style="text-align:center">HAVING</td><td style="text-align:center">$match</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">$project</td></tr><tr><td style="text-align:center">ORDER BY</td><td style="text-align:center">$sort</td></tr><tr><td style="text-align:center">LIMIT</td><td style="text-align:center">$limit</td></tr><tr><td style="text-align:center">SUM()</td><td style="text-align:center">$sum</td></tr><tr><td style="text-align:center">COUNT()</td><td style="text-align:center">$sum</td></tr><tr><td style="text-align:center">COUNT()</td><td style="text-align:center">$sortByCount</td></tr><tr><td style="text-align:center">join</td><td style="text-align:center">$lookup</td></tr></tbody></table><p>开发的需求是:</p><ul><li>按照天分组，统计一下数量</li></ul><p>经过查看<code>MongoDB官网</code>的<a href="https://docs.mongodb.com/manual/aggregation/" target="_blank" rel="noopener">aggregate资料</a>实现开发的需求</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>查询数据的状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_image.find({<span class="string">"moduleId"</span>:5,createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}).pretty().<span class="built_in">limit</span>(1);</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">        <span class="string">"_id"</span> : ObjectId(<span class="string">"5c125657372eecd7a0a54e5e"</span>),</span><br><span class="line">        <span class="string">"adRate"</span> : 0,</span><br><span class="line">        <span class="string">"assoId"</span> : <span class="string">"223794113"</span>,</span><br><span class="line">        <span class="string">"assoType"</span> : 201,</span><br><span class="line">        <span class="string">"clientIp"</span> : <span class="string">"183.131.7.23"</span>,</span><br><span class="line">        <span class="string">"clientType"</span> : <span class="string">""</span>,</span><br><span class="line">        <span class="string">"confidence"</span> : 12.655,</span><br><span class="line">        <span class="string">"content"</span> : <span class="string">"****http://videoplayer.babytreeimg.com/lamavideo:2018/1213/Flb_T4qsxRcK7suNqaHo2JbD6zWJ_000001.jpg?id=-1\**"</span>,</span><br><span class="line">        <span class="string">"createTs"</span> : NumberLong(1544705623),</span><br><span class="line">        <span class="string">"emailStatus"</span> : <span class="string">"verified"</span>,</span><br><span class="line">        <span class="string">"handleTs"</span> : NumberLong(1545036013),</span><br><span class="line">        <span class="string">"hotScore"</span> : 14.285,</span><br><span class="line">        <span class="string">"inspectStatus"</span> : 2,</span><br><span class="line">        <span class="string">"message"</span> : <span class="string">""</span>,</span><br><span class="line">        <span class="string">"moduleId"</span> : NumberLong(5),</span><br><span class="line">        <span class="string">"normalScore"</span> : 73.25,</span><br><span class="line">        <span class="string">"ocrKeyword"</span> : [ ],</span><br><span class="line">        <span class="string">"ocrText"</span> : [ ],</span><br><span class="line">        <span class="string">"opUser"</span> : <span class="string">"fanyanning"</span>,</span><br><span class="line">        <span class="string">"opUserId"</span> : NumberLong(31648494),</span><br><span class="line">        <span class="string">"pornScore"</span> : 12.464,</span><br><span class="line">        <span class="string">"qcode"</span> : 0,</span><br><span class="line">        <span class="string">"receiveTs"</span> : NumberLong(1545035885),</span><br><span class="line">        <span class="string">"regTs"</span> : NumberLong(1475385061),</span><br><span class="line">        <span class="string">"requestId"</span> : <span class="string">"6f078c58-1235-4816-96a5-e876ea0cbcf2"</span>,</span><br><span class="line">        <span class="string">"rotOcrKeyword"</span> : [ ],</span><br><span class="line">        <span class="string">"rotOcrText"</span> : [ ],</span><br><span class="line">        <span class="string">"ruleId"</span> : NumberLong(10019),</span><br><span class="line">        <span class="string">"sim"</span> : 0,</span><br><span class="line">        <span class="string">"status"</span> : 1000,</span><br><span class="line">        <span class="string">"trashType"</span> : 0,</span><br><span class="line">        <span class="string">"ts"</span> : NumberLong(1544705623),</span><br><span class="line">        <span class="string">"url"</span> : <span class="string">"http://videoplayer.babytreeimg.com/lamavideo:2018/1213/Flb_T4qsxRcK7suNqaHo2JbD6zWJ_000001.jpg?id=-1"</span>,</span><br><span class="line">        <span class="string">"userId"</span> : NumberLong(56349617),</span><br><span class="line">        <span class="string">"userLevel"</span> : 3,</span><br><span class="line">        <span class="string">"version"</span> : <span class="string">"1.0.0"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>开发给的聚合的查询<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_image.aggregate([</span><br><span class="line">{ <span class="variable">$match</span>: {<span class="string">"moduleId"</span>:5,createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}},</span><br><span class="line">{ <span class="variable">$group</span>: {_id :{<span class="variable">$dateToString</span>: {format: <span class="string">"%Y-%m-%d"</span>, date: <span class="string">"<span class="variable">$createTs</span>"</span> }},count: { <span class="variable">$sum</span>: 1 }}}</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mgset-11469021:SECONDARY> db.antispam_image.aggregate([{<span class="variable">$match</span>: {<span class="string">"moduleId"</span>:5, createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}}, {<span class="variable">$group</span>: {_id: {<span class="variable">$dateToString</span>: {format: <span class="string">"%Y-%m-%d"</span>, date: <span class="string">"<span class="variable">$createTs</span>"</span>}}, count: {<span class="variable">$sum</span>: 1}}}]);</span><br><span class="line">assert: <span class="built_in">command</span> failed: {</span><br><span class="line">        <span class="string">"operationTime"</span> : Timestamp(1558347069, 2),</span><br><span class="line">        <span class="string">"ok"</span> : 0,</span><br><span class="line">        <span class="string">"errmsg"</span> : <span class="string">"can't convert from BSON type long to Date"</span>,</span><br><span class="line">        <span class="string">"code"</span> : 16006,</span><br><span class="line">        <span class="string">"codeName"</span> : <span class="string">"Location16006"</span></span><br><span class="line">} : aggregate failed</span><br><span class="line">_getErrorWithCode@src/mongo/shell/utils.js:25:13</span><br><span class="line">doassert@src/mongo/shell/assert.js:16:14</span><br><span class="line">assert.commandWorked@src/mongo/shell/assert.js:370:5</span><br><span class="line">DBCollection.prototype.aggregate@src/mongo/shell/collection.js:1319:5</span><br><span class="line">@(shell):1:1</span><br><span class="line"></span><br><span class="line">2019-05-20T18:11:10.818+0800 E QUERY    [thread1] Error: <span class="built_in">command</span> failed: {</span><br><span class="line">        <span class="string">"operationTime"</span> : Timestamp(1558347069, 2),</span><br><span class="line">        <span class="string">"ok"</span> : 0,</span><br><span class="line">        <span class="string">"errmsg"</span> : <span class="string">"can't convert from BSON type long to Date"</span>,</span><br><span class="line">        <span class="string">"code"</span> : 16006,</span><br><span class="line">        <span class="string">"codeName"</span> : <span class="string">"Location16006"</span></span><br><span class="line">} : aggregate failed :</span><br><span class="line">_getErrorWithCode@src/mongo/shell/utils.js:25:13</span><br><span class="line">doassert@src/mongo/shell/assert.js:16:14</span><br><span class="line">assert.commandWorked@src/mongo/shell/assert.js:370:5</span><br><span class="line">DBCollection.prototype.aggregate@src/mongo/shell/collection.js:1319:5</span><br><span class="line">@(shell):1:1</span><br></pre></td></tr></tbody></table></figure><p>报错了，问开发。开发又给了一个查询语句<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_image.aggregate([</span><br><span class="line">{ <span class="variable">$match</span>: {<span class="string">"moduleId"</span>:5,createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}},</span><br><span class="line">{ <span class="variable">$group</span>: {</span><br><span class="line">_id :{ <span class="variable">$dateToString</span>: {format: <span class="string">"%Y-%m-%d"</span>, date:{<span class="string">"<span class="variable">$add</span>"</span>:[new Date(0),<span class="string">"<span class="variable">$createTs</span>"</span>]}} },</span><br><span class="line">count: { <span class="variable">$sum</span>: 1 }</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="string">"_id"</span> : <span class="string">"1970-01-19"</span>, <span class="string">"count"</span> : 15131 }</span><br><span class="line">{ <span class="string">"_id"</span> : <span class="string">"1970-01-18"</span>, <span class="string">"count"</span> : 180400 }</span><br></pre></td></tr></tbody></table></figure><p>发现时间戳转化不对</p><p>于是查看官网资料，继续改写先把UNIX时间戳转化为日期。可是MongoDB又没有<code>MySQL</code>那种<code>FROM_UNIXTIME()</code>与<code>UNIX_TIMESTAMP()</code>函数。只能自己造</p><p>通过将值乘以1000将createTs字段转换为毫秒时间戳<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>]}</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>$multiply    将数字相乘以返回产品。接受任意数量的参数表达式。</p></blockquote><p>然后转换为日期<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>]} ]</span><br></pre></td></tr></tbody></table></figure><p></p><p>继续组装查询<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="string">"<span class="variable">$group</span>"</span>: { <span class="string">"_id"</span>: { <span class="string">"year"</span>: { <span class="string">"<span class="variable">$year</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}, <span class="string">"mmonth"</span>: { <span class="string">"<span class="variable">$month</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}, <span class="string">"day"</span>: { <span class="string">"<span class="variable">$dayOfMonth</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}}, <span class="string">"count"</span> : { <span class="string">"<span class="variable">$sum</span>"</span> : 1 }}}</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>在<code>$project</code>管道中完成,方法是将<code>毫秒时间</code>添加到<code>零毫秒Date(0)</code>对象,然后从转换后的<code>日期</code>中提取<code>$year</code>,<code>$month</code>,<code>$dayOfMonth</code>个零件,可以在<code>$group</code>管道中使用这些零件对文档进行分组</p></blockquote><p>完整的查询语句拼接出来<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_image.aggregate([{ <span class="variable">$match</span>: {<span class="string">"moduleId"</span>:5,createTs:{<span class="variable">$gte</span>:1554048000},createTs:{<span class="variable">$lt</span>:1556640000}}}, {<span class="string">"<span class="variable">$group</span>"</span>: { <span class="string">"_id"</span>: { <span class="string">"year"</span>: { <span class="string">"<span class="variable">$year</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}, <span class="string">"mmonth"</span>: { <span class="string">"<span class="variable">$month</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ]}}, <span class="string">"day"</span>: { <span class="string">"<span class="variable">$dayOfMonth</span>"</span>: { <span class="string">"<span class="variable">$add</span>"</span>: [ new Date(0), { <span class="string">"<span class="variable">$multiply</span>"</span>: [1000, <span class="string">"<span class="variable">$createTs</span>"</span>] } ] }}}, <span class="string">"count"</span> : { <span class="string">"<span class="variable">$sum</span>"</span> : 1 }}}]);</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 30 }, <span class="string">"count"</span> : 624 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 28 }, <span class="string">"count"</span> : 695 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 27 }, <span class="string">"count"</span> : 683 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 26 }, <span class="string">"count"</span> : 765 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 1, <span class="string">"day"</span> : 12 }, <span class="string">"count"</span> : 610 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 1, <span class="string">"day"</span> : 4 }, <span class="string">"count"</span> : 429 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 1, <span class="string">"day"</span> : 3 }, <span class="string">"count"</span> : 475 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 29 }, <span class="string">"count"</span> : 732 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 12, <span class="string">"day"</span> : 31 }, <span class="string">"count"</span> : 592 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 12, <span class="string">"day"</span> : 30 }, <span class="string">"count"</span> : 542 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 3, <span class="string">"day"</span> : 14 }, <span class="string">"count"</span> : 1155 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 3, <span class="string">"day"</span> : 13 }, <span class="string">"count"</span> : 1169 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 20 }, <span class="string">"count"</span> : 945 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 3, <span class="string">"day"</span> : 15 }, <span class="string">"count"</span> : 1062 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 24 }, <span class="string">"count"</span> : 751 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 10, <span class="string">"day"</span> : 15 }, <span class="string">"count"</span> : 721 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 18 }, <span class="string">"count"</span> : 895 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 10, <span class="string">"day"</span> : 16 }, <span class="string">"count"</span> : 713 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2019, <span class="string">"mmonth"</span> : 4, <span class="string">"day"</span> : 14 }, <span class="string">"count"</span> : 1278 }</span><br><span class="line">{ <span class="string">"_id"</span> : { <span class="string">"year"</span> : 2018, <span class="string">"mmonth"</span> : 10, <span class="string">"day"</span> : 17 }, <span class="string">"count"</span> : 583 }</span><br><span class="line">Type <span class="string">"it"</span> <span class="keyword">for</span> more</span><br><span class="line">mgset-11469021:SECONDARY></span><br></pre></td></tr></tbody></table></figure><p>拿这样查询出来的数据问开发是否是这样、开发确认这样可以。需求解决。</p><p>开发写了一个查询<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_report.aggregate(</span><br><span class="line">   [</span><br><span class="line">     {</span><br><span class="line">       <span class="variable">$project</span>: {</span><br><span class="line">          createTs: 1,</span><br><span class="line">          date1Str: {<span class="variable">$dateToString</span>: {format: <span class="string">"%Y-%m-%d"</span>, date:{<span class="string">"<span class="variable">$add</span>"</span>:[new Date(0),{<span class="string">"<span class="variable">$multiply</span>"</span>:[<span class="string">"<span class="variable">$createTs</span>"</span>,1000]},28800000]}}}</span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">   ]</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>添加了时区时间28800000</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bd41d96e870a1daab7a0d6d"</span>), <span class="string">"createTs"</span> : NumberLong(1540627862), <span class="string">"date1Str"</span> : <span class="string">"2018-10-27"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bd8fc96e870a1daab5e99c1"</span>), <span class="string">"createTs"</span> : NumberLong(1540947095), <span class="string">"date1Str"</span> : <span class="string">"2018-10-31"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bf9ed96e870a1daabe6b236"</span>), <span class="string">"createTs"</span> : NumberLong(1543105942), <span class="string">"date1Str"</span> : <span class="string">"2018-11-25"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5c025140e870a1daaba6f00c"</span>), <span class="string">"createTs"</span> : NumberLong(1543655744), <span class="string">"date1Str"</span> : <span class="string">"2018-12-01"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bffc529e870a1daabadff49"</span>), <span class="string">"createTs"</span> : NumberLong(1543488809), <span class="string">"date1Str"</span> : <span class="string">"2018-11-29"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5c0ce4b8e870a1daab28b208"</span>), <span class="string">"createTs"</span> : NumberLong(1544348856), <span class="string">"date1Str"</span> : <span class="string">"2018-12-09"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bf23dc4e870a1daab3b698c"</span>), <span class="string">"createTs"</span> : NumberLong(1542602181), <span class="string">"date1Str"</span> : <span class="string">"2018-11-19"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bf1fdc2e870a1daab7729b1"</span>), <span class="string">"createTs"</span> : NumberLong(1542585793), <span class="string">"date1Str"</span> : <span class="string">"2018-11-19"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bf9ed8be870a1daabe57c10"</span>), <span class="string">"createTs"</span> : NumberLong(1543105931), <span class="string">"date1Str"</span> : <span class="string">"2018-11-25"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5c064d15e870a1daabcb43bd"</span>), <span class="string">"createTs"</span> : NumberLong(1543916821), <span class="string">"date1Str"</span> : <span class="string">"2018-12-04"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5be44e5ce870a1daabb1b84f"</span>), <span class="string">"createTs"</span> : NumberLong(1541688924), <span class="string">"date1Str"</span> : <span class="string">"2018-11-08"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bffeafee870a1daab044619"</span>), <span class="string">"createTs"</span> : NumberLong(1543498494), <span class="string">"date1Str"</span> : <span class="string">"2018-11-29"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5c076f01e870a1daabe32b96"</span>), <span class="string">"createTs"</span> : NumberLong(1543991041), <span class="string">"date1Str"</span> : <span class="string">"2018-12-05"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bdc4cc8e870a1daab855084"</span>), <span class="string">"createTs"</span> : NumberLong(1541164232), <span class="string">"date1Str"</span> : <span class="string">"2018-11-02"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bc343d8e870a1daab708be1"</span>), <span class="string">"createTs"</span> : NumberLong(1539523544), <span class="string">"date1Str"</span> : <span class="string">"2018-10-14"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bfcd64de870a1daab0d2617"</span>), <span class="string">"createTs"</span> : NumberLong(1543296589), <span class="string">"date1Str"</span> : <span class="string">"2018-11-27"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bc9adefe870a1daabf4ab80"</span>), <span class="string">"createTs"</span> : NumberLong(1539943919), <span class="string">"date1Str"</span> : <span class="string">"2018-10-19"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bbd8c31e870a1daab26cf3e"</span>), <span class="string">"createTs"</span> : NumberLong(1539148850), <span class="string">"date1Str"</span> : <span class="string">"2018-10-10"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5beff335e870a1daab8be35a"</span>), <span class="string">"createTs"</span> : NumberLong(1542452021), <span class="string">"date1Str"</span> : <span class="string">"2018-11-17"</span> }</span><br><span class="line">{ <span class="string">"_id"</span> : ObjectId(<span class="string">"5bc9ae33e870a1daabf4c03a"</span>), <span class="string">"createTs"</span> : NumberLong(1539943987), <span class="string">"date1Str"</span> : <span class="string">"2018-10-19"</span> }</span><br><span class="line">Type <span class="string">"it"</span> <span class="keyword">for</span> more</span><br></pre></td></tr></tbody></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>针对DBA这个岗位来说。大多数都是从事MongoDB 运维工作 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>。</p><p>很少贴近开发需求，这次开发问了我这个问题。我当然无法立马给出答案。只能不断的查询。拼接，才能马马虎虎的满足了开发的需求 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/2705.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/2705.png?v8">✅</span>。</p><p>刚才问一个架构师，架构师说有一个更简单的方式：</p><ol><li>查出总结出一天的数据，放到管道中临时保存起来</li><li>在用前一次查询的结束时间作为第二天的开始时间，在加上一天的时间(86400s)得出结尾时间。</li><li>查询完成在统一显示打印出来</li></ol><p>这种方式就需要使用<code>MongoDB forEach</code>方式实现了。</p><p>开发又说不能按时间排序<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f631.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f631.png?v8">😱</span> , 妹的<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>哪里来的这么多要求<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f631.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f631.png?v8">😱</span></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>MongoDB 官方资料: <a href="https://docs.mongodb.com/manual/aggregation/" target="_blank" rel="noopener">aggregate资料</a></li><li><a href="https://blog.gaoqixhb.com/p/5938ca473b447c14248d41ad" target="_blank" rel="noopener">MongoDB 聚合查询 - 按时间分组统计</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb数据导出CSV文件</title>
      <link href="/2019/05/17/mongodb-to-csv/"/>
      <url>/2019/05/17/mongodb-to-csv/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="qiong.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>要不是因为我，你能有今天？</strong><br><strong>要不是我伤害你，你能成长？</strong></p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>产品需要分析达人文章的标签，需要把2019年1月1号到现在的标签，从mongo导出来，导出格式为csv，查询条件如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.content_medium_hismatch.find({<span class="string">"content_type_id"</span>:<span class="string">"28"</span>,<span class="string">"update_time"</span>:{<span class="string">"<span class="variable">$gte</span>"</span>:1546272000000},<span class="string">"is_delete"</span>:0}, {<span class="string">"content_id"</span>:1,<span class="string">"content_tags"</span>:1});</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>使用<code>MongoDB</code>中的<code>mongoexport</code>命令<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mongoexport --<span class="built_in">help</span></span><br><span class="line">Usage:</span><br><span class="line">  mongoexport <options></span><br><span class="line"></span><br><span class="line">Export data from MongoDB <span class="keyword">in</span> CSV or JSON format.</span><br><span class="line"></span><br><span class="line">See http://docs.mongodb.org/manual/reference/program/mongoexport/ <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">general options:</span><br><span class="line">      --<span class="built_in">help</span>                                      <span class="built_in">print</span> usage</span><br><span class="line">      --version                                   <span class="built_in">print</span> the tool version and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">verbosity options:</span><br><span class="line">  -v, --verbose=<level>                           more detailed <span class="built_in">log</span> output (include multiple <span class="built_in">times</span> <span class="keyword">for</span> more verbosity, e.g. -vvvvv, or specify a numeric value, e.g. --verbose=N)</span><br><span class="line">      --quiet                                     hide all <span class="built_in">log</span> output</span><br><span class="line"></span><br><span class="line">connection options:</span><br><span class="line">  -h, --host=<hostname>                           mongodb host to connect to (setname/host1,host2 <span class="keyword">for</span> replica sets)</span><br><span class="line">      --port=<port>                               server port (can also use --host hostname:port)</span><br><span class="line"></span><br><span class="line">ssl options:</span><br><span class="line">      --ssl                                       connect to a mongod or mongos that has ssl enabled</span><br><span class="line">      --sslCAFile=<filename>                      the .pem file containing the root certificate chain from the certificate authority</span><br><span class="line">      --sslPEMKeyFile=<filename>                  the .pem file containing the certificate and key</span><br><span class="line">      --sslPEMKeyPassword=<password>              the password to decrypt the sslPEMKeyFile, <span class="keyword">if</span> necessary</span><br><span class="line">      --sslCRLFile=<filename>                     the .pem file containing the certificate revocation list</span><br><span class="line">      --sslAllowInvalidCertificates               bypass the validation <span class="keyword">for</span> server certificates</span><br><span class="line">      --sslAllowInvalidHostnames                  bypass the validation <span class="keyword">for</span> server name</span><br><span class="line">      --sslFIPSMode                               use FIPS mode of the installed openssl library</span><br><span class="line"></span><br><span class="line">authentication options:</span><br><span class="line">  -u, --username=<username>                       username <span class="keyword">for</span> authentication</span><br><span class="line">  -p, --password=<password>                       password <span class="keyword">for</span> authentication</span><br><span class="line">      --authenticationDatabase=<database-name>    database that holds the user<span class="string">'s credentials</span></span><br><span class="line"><span class="string">      --authenticationMechanism=<mechanism>       authentication mechanism to use</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">namespace options:</span></span><br><span class="line"><span class="string">  -d, --db=<database-name>                        database to use</span></span><br><span class="line"><span class="string">  -c, --collection=<collection-name>              collection to use</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">output options:</span></span><br><span class="line"><span class="string">  -f, --fields=<field>[,<field>]*                 comma separated list of field names (required for exporting CSV) e.g. -f "name,age"</span></span><br><span class="line"><span class="string">      --fieldFile=<filename>                      file with field names - 1 per line</span></span><br><span class="line"><span class="string">      --type=<type>                               the output format, either json or csv (defaults to '</span>json<span class="string">') (default: json)</span></span><br><span class="line"><span class="string">  -o, --out=<filename>                            output file; if not specified, stdout is used</span></span><br><span class="line"><span class="string">      --jsonArray                                 output to a JSON array rather than one object per line</span></span><br><span class="line"><span class="string">      --pretty                                    output JSON formatted to be human-readable</span></span><br><span class="line"><span class="string">      --noHeaderLine                              export CSV data without a list of field names at the first line</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">querying options:</span></span><br><span class="line"><span class="string">  -q, --query=<json>                              query filter, as a JSON string, e.g., '</span>{x:{<span class="variable">$gt</span>:1}}<span class="string">'</span></span><br><span class="line"><span class="string">      --queryFile=<filename>                      path to a file containing a query filter (JSON)</span></span><br><span class="line"><span class="string">  -k, --slaveOk                                   allow secondary reads if available (default true) (default: false)</span></span><br><span class="line"><span class="string">      --readPreference=<string>|<json>            specify either a preference name or a preference json object</span></span><br><span class="line"><span class="string">      --forceTableScan                            force a table scan (do not use $snapshot)</span></span><br><span class="line"><span class="string">      --skip=<count>                              number of documents to skip</span></span><br><span class="line"><span class="string">      --limit=<count>                             limit the number of documents to export</span></span><br><span class="line"><span class="string">      --sort=<json>                               sort order, as a JSON string, e.g. '</span>{x:1}<span class="string">'</span></span><br><span class="line"><span class="string">      --assertExists                              if specified, export fails if the collection does not exist (default: false)</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>操作命令如下:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongoexport --port 29001 --host=localhost -user=*** --password=***** --authenticationDatabase=**** --db=db --collection=collection --query=<span class="string">'{"content_type_id":"28","update_time":{"$gte":1546272000000},"is_delete":0}, {"content_id":1,"content_tags":1}'</span> --<span class="built_in">type</span>=csv --out=***.csv</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-05-17T13:18:52.325+0800    error validating settings: query <span class="string">'[123 34 99 111 110 116 101 110 116 95 116 121 112 101 95 105 100 34 58 34 50 56 34 44 34 117 112 100 97 116 101 95 116 105 109 101 34 58 123 34 36 103 116 101 34 58 49 53 52 54 50 55 50 48 48 48 48 48 48 125 44 34 105 115 95 100 101 108 101 116 101 34 58 48 125 44 32 123 34 99 111 110 116 101 110 116 95 105 100 34 58 49 44 34 99 111 110 116 101 110 116 95 116 97 103 115 34 58 49 125]'</span> is not valid JSON: invalid character <span class="string">','</span> after top-level value</span><br><span class="line">2019-05-17T13:18:52.325+0800    try <span class="string">'mongoexport --help'</span> <span class="keyword">for</span> more information</span><br></pre></td></tr></tbody></table></figure><p>初步判断是导出<code>CSV文件</code>中需要的<code>逗号(,)</code>分割。字段发生错误。语句添加–fields _id,content_id,content_tags<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongoexport --port 29001 --host=localhost -user=*** --password=***** --authenticationDatabase=**** --db=db --collection=collection --query=<span class="string">'{"content_type_id":"28","update_time":{"$gte":1546272000000},"is_delete":0}, {"content_id":1,"content_tags":1}'</span> --<span class="built_in">type</span>=csv --fields _id,content_id,content_tags --out=***.csv</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`2019-05-17T13:18:54.325+0800    error validating settings: query <span class="string">'[123 34 99 111 110 116 101 110 116 95 116 121 112 101 95 105 100 34 58 34 50 56 34 44 34 117 112 100 97 116 101 95 116 105 109 101 34 58 123 34 36 103 116 101 34 58 49 53 52 54 50 55 50 48 48 48 48 48 48 125 44 34 105 115 95 100 101 108 101 116 101 34 58 48 125 44 32 123 34 99 111 110 116 101 110 116 95 105 100 34 58 49 44 34 99 111 110 116 101 110 116 95 116 97 103 115 34 58 49 125]'</span> is not valid JSON: invalid character <span class="string">','</span> after top-level value</span><br><span class="line"> 2019-05-17T13:18:54.325+0800    try <span class="string">'mongoexport --help'</span> <span class="keyword">for</span> more information``bash</span><br></pre></td></tr></tbody></table></figure><p>开始排查为什么还继续报错。使用 <code>mongo shell</code> 连接到mongodb中查询发现是能获取到数据的。去掉–query 条件之后再执行一次发现是没问题<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongoexport --port 29001 --host=localhost -user=*** --password=***** --authenticationDatabase=**** --db=db --collection=collection --<span class="built_in">type</span>=csv --fields _id,content_id,content_tags --out=***.csv</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">2019-05-17T13:24:18.176+0800    connected to: localhost:29001</span><br><span class="line">2019-05-17T13:24:19.167+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:20.167+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:21.168+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:22.167+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:23.168+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:24.168+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:25.167+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">2019-05-17T13:24:26.168+0800    [........................]  feeds.content_medium_hismatch  0/138863565  (0.0%)</span><br><span class="line">^C2019-05-17T13:24:26.900+0800  signal <span class="string">'interrupt'</span> received; forcefully terminating</span><br><span class="line">public-ops-mongodb2 seclogin <span class="comment"># ls</span></span><br><span class="line">content_medium_hismatch.csv</span><br><span class="line">public-ops-mongodb2 seclogin <span class="comment"># cat content_medium_hismatch.csv |more</span></span><br><span class="line">_id,content_id,content_tags</span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db599),1229,<span class="string">"["</span><span class="string">"奶瓶"</span><span class="string">","</span><span class="string">"吃奶"</span><span class="string">","</span><span class="string">"吸吮"</span><span class="string">","</span><span class="string">"乳头混淆"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db5c8),1290,<span class="string">"["</span><span class="string">"衣服"</span><span class="string">","</span><span class="string">"二手衣服"</span><span class="string">","</span><span class="string">"清洗"</span><span class="string">","</span><span class="string">"皮肤"</span><span class="string">","</span><span class="string">"细菌"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db5cd),1297,<span class="string">"["</span><span class="string">"身材"</span><span class="string">","</span><span class="string">"产后妈妈"</span><span class="string">","</span><span class="string">"新妈妈"</span><span class="string">","</span><span class="string">"裙子"</span><span class="string">","</span><span class="string">"衣服"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db5e1),1325,<span class="string">"["</span><span class="string">"护肤品"</span><span class="string">","</span><span class="string">"哺乳期"</span><span class="string">","</span><span class="string">"皮肤"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"护肤"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db5e8),1343,<span class="string">"["</span><span class="string">"收纳"</span><span class="string">","</span><span class="string">"家具"</span><span class="string">","</span><span class="string">"奶粉"</span><span class="string">","</span><span class="string">"分享"</span><span class="string">","</span><span class="string">"三角形"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db618),1393,<span class="string">"["</span><span class="string">"背带"</span><span class="string">","</span><span class="string">"婴儿"</span><span class="string">","</span><span class="string">"带宝宝"</span><span class="string">","</span><span class="string">"出门"</span><span class="string">","</span><span class="string">"肌肉发育"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db65e),1465,<span class="string">"["</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"骨骼"</span><span class="string">","</span><span class="string">"眼睛"</span><span class="string">","</span><span class="string">"帮助"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db660),1467,<span class="string">"["</span><span class="string">"晒太阳"</span><span class="string">","</span><span class="string">"紫外线"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"黄疸"</span><span class="string">","</span><span class="string">"眼睛"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db666),1472,<span class="string">"["</span><span class="string">"伞车"</span><span class="string">","</span><span class="string">"推车"</span><span class="string">","</span><span class="string">"婴儿伞车"</span><span class="string">","</span><span class="string">"婴儿推车"</span><span class="string">","</span><span class="string">"优点"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db669),1474,<span class="string">"["</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"味觉发育"</span><span class="string">","</span><span class="string">"口味"</span><span class="string">","</span><span class="string">"食盐"</span><span class="string">","</span><span class="string">"饮食"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db674),1490,<span class="string">"["</span><span class="string">"患病"</span><span class="string">","</span><span class="string">"父母"</span><span class="string">","</span><span class="string">"指甲"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"打呼噜"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db67a),1500,<span class="string">"["</span><span class="string">"睡眠"</span><span class="string">","</span><span class="string">"疾病"</span><span class="string">","</span><span class="string">"父母"</span><span class="string">","</span><span class="string">"症状"</span><span class="string">","</span><span class="string">"医院"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db68c),1513,<span class="string">"["</span><span class="string">"声音"</span><span class="string">","</span><span class="string">"奶睡"</span><span class="string">","</span><span class="string">"美国"</span><span class="string">","</span><span class="string">"摇晃"</span><span class="string">","</span><span class="string">"宝宝睡觉"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db6a0),1535,<span class="string">"["</span><span class="string">"安全"</span><span class="string">","</span><span class="string">"清洗"</span><span class="string">","</span><span class="string">"坐便器"</span><span class="string">","</span><span class="string">"马桶"</span><span class="string">","</span><span class="string">"优点"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db746),2732,<span class="string">"["</span><span class="string">"荔枝"</span><span class="string">","</span><span class="string">"进食"</span><span class="string">","</span><span class="string">"葡萄糖"</span><span class="string">","</span><span class="string">"上火"</span><span class="string">","</span><span class="string">"症状"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db749),2733,<span class="string">"["</span><span class="string">"宝宝喂养"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">","</span><span class="string">"饮食"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db752),2742,<span class="string">"["</span><span class="string">"乳头"</span><span class="string">","</span><span class="string">"喂奶"</span><span class="string">","</span><span class="string">"乳头皲裂"</span><span class="string">","</span><span class="string">"哺乳"</span><span class="string">","</span><span class="string">"乳房"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db758),2745,<span class="string">"["</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"挑食"</span><span class="string">","</span><span class="string">"偏食"</span><span class="string">","</span><span class="string">"爸爸"</span><span class="string">","</span><span class="string">"菠菜"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db75b),2746,<span class="string">"["</span><span class="string">"吃饭"</span><span class="string">","</span><span class="string">"爸爸"</span><span class="string">","</span><span class="string">"咀嚼"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"时间"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db75f),2747,<span class="string">"["</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"小宝"</span><span class="string">","</span><span class="string">"核桃油"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"亚麻酸"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db761),2748,<span class="string">"["</span><span class="string">"油炸"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"食品"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"油脂"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db768),2751,<span class="string">"["</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"膳食纤维"</span><span class="string">","</span><span class="string">"消化不良"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"肠道"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db76d),2753,<span class="string">"["</span><span class="string">"吃饭"</span><span class="string">","</span><span class="string">"饮食习惯"</span><span class="string">","</span><span class="string">"帮助"</span><span class="string">","</span><span class="string">"习惯"</span><span class="string">","</span><span class="string">"爸爸"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db770),2754,<span class="string">"["</span><span class="string">"微波炉"</span><span class="string">","</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db773),2755,<span class="string">"["</span><span class="string">"葡萄糖"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"习惯"</span><span class="string">","</span><span class="string">"家长"</span><span class="string">","</span><span class="string">"宝宝生病"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db775),2756,<span class="string">"["</span><span class="string">"祛湿"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"帮助"</span><span class="string">","</span><span class="string">"食谱"</span><span class="string">","</span><span class="string">"红豆"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db778),2757,<span class="string">"["</span><span class="string">"水果"</span><span class="string">","</span><span class="string">"蔬菜"</span><span class="string">","</span><span class="string">"果汁"</span><span class="string">","</span><span class="string">"配方奶"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db77e),2759,<span class="string">"["</span><span class="string">"挑食"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"宝宝挑食"</span><span class="string">","</span><span class="string">"缺锌"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db781),2760,<span class="string">"["</span><span class="string">"吃肉"</span><span class="string">","</span><span class="string">"健康"</span><span class="string">","</span><span class="string">"水果"</span><span class="string">","</span><span class="string">"饱和脂肪酸"</span><span class="string">","</span><span class="string">"便秘"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db784),2761,<span class="string">"["</span><span class="string">"水果"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"胡萝卜素"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db787),2762,<span class="string">"["</span><span class="string">"体重"</span><span class="string">","</span><span class="string">"宝宝瘦"</span><span class="string">","</span><span class="string">"营养不良"</span><span class="string">","</span><span class="string">"原因"</span><span class="string">","</span><span class="string">"父母"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db789),2763,<span class="string">"["</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"营养"</span><span class="string">","</span><span class="string">"宝宝喂养"</span><span class="string">","</span><span class="string">"进食"</span><span class="string">","</span><span class="string">"时间"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db790),2765,<span class="string">"["</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"宝宝断奶"</span><span class="string">","</span><span class="string">"断奶"</span><span class="string">","</span><span class="string">"保存"</span><span class="string">","</span><span class="string">"冰箱"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db792),2766,<span class="string">"["</span><span class="string">"断奶"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">","</span><span class="string">"环境"</span><span class="string">","</span><span class="string">"夏季"</span><span class="string">","</span><span class="string">"宝宝生病"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db795),2767,<span class="string">"["</span><span class="string">"益生菌"</span><span class="string">","</span><span class="string">"药物"</span><span class="string">","</span><span class="string">"食品"</span><span class="string">","</span><span class="string">"平衡"</span><span class="string">","</span><span class="string">"抗生素"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db798),2768,<span class="string">"["</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"咳嗽"</span><span class="string">","</span><span class="string">"宝宝咳嗽"</span><span class="string">","</span><span class="string">"饮食"</span><span class="string">","</span><span class="string">"辛辣"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db79b),2769,<span class="string">"["</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"饮食"</span><span class="string">","</span><span class="string">"断奶"</span><span class="string">","</span><span class="string">"宝宝断奶"</span><span class="string">","</span><span class="string">"保存"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598eaeeb42d8582db7a1),2773,<span class="string">"["</span><span class="string">"补钙"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"宝宝缺钙"</span><span class="string">","</span><span class="string">"母乳"</span><span class="string">","</span><span class="string">"配方奶"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7a6),2775,<span class="string">"["</span><span class="string">"果泥"</span><span class="string">","</span><span class="string">"水果"</span><span class="string">","</span><span class="string">"维生素"</span><span class="string">","</span><span class="string">"哈密瓜"</span><span class="string">","</span><span class="string">"香蕉"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7a9),2776,<span class="string">"["</span><span class="string">"饮食"</span><span class="string">","</span><span class="string">"食物"</span><span class="string">","</span><span class="string">"辅食"</span><span class="string">","</span><span class="string">"进食"</span><span class="string">","</span><span class="string">"水果"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7ac),2777,<span class="string">"["</span><span class="string">"有机蔬菜"</span><span class="string">","</span><span class="string">"蔬菜"</span><span class="string">","</span><span class="string">"农药"</span><span class="string">","</span><span class="string">"有机"</span><span class="string">","</span><span class="string">"农药残留"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7b4),2780,<span class="string">"["</span><span class="string">"断奶"</span><span class="string">","</span><span class="string">"乳头"</span><span class="string">","</span><span class="string">"乳房"</span><span class="string">","</span><span class="string">"乳腺炎"</span><span class="string">","</span><span class="string">"回奶"</span><span class="string">"]"</span></span><br><span class="line">ObjectId(5b0f598faeeb42d8582db7b8),2783,<span class="string">"["</span><span class="string">"叶黄素"</span><span class="string">","</span><span class="string">"太阳镜"</span><span class="string">","</span><span class="string">"胡萝卜"</span><span class="string">","</span><span class="string">"南瓜"</span><span class="string">","</span><span class="string">"芒果"</span><span class="string">"]"</span></span><br></pre></td></tr></tbody></table></figure><p>就能确定这么执行是没有问题。重点排查<code>--query条件</code>。根据之前报错<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-05-17T13:25:56.341+0800    error validating settings: query <span class="string">'[123 99 111 110 116 101 110 116 95 116 121 112 101 95 105 100 58 50 56 44 117 112 100 97 116 101 95 116 105 109 101 58 123 36 103 116 101 58 49 53 52 54 50 55 50 48 48 48 48 48 48 125 44 105 115 95 100 101 108 101 116 101 58 48 125 44 123 99 111 110 116 101 110 116 95 105 100 58 49 44 99 111 110 116 101 110 116 95 116 97 103 115 58 49 125]'</span> is not valid JSON: invalid character <span class="string">','</span> after top-level value</span><br><span class="line">2019-05-17T13:25:56.341+0800    try <span class="string">'mongoexport --help'</span> <span class="keyword">for</span> more information</span><br></pre></td></tr></tbody></table></figure><p></p><p>发现一个点<code>invalid character ',' after top-level value</code>中提示有<code>逗号,</code>的问题，排查一下<code>--query条件</code>发现有<code>'{"content_type_id":"28","update_time":{"$gte":1546272000000},"is_delete":0}, {"content_id":1,"content_tags":1}'</code>有一个<code>逗号,</code></p><p>去掉<code>逗号,</code>和后面的<code>逗号之后的条件</code>发现执行成功<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongoexport --port 29001 --host=localhost -user=*** --password=***** --authenticationDatabase=**** --db=db --collection=collection --query=<span class="string">'{"content_type_id":"28","update_time":{"$gte":1546272000000},"is_delete":0}'</span> --<span class="built_in">type</span>=csv --fields _id,content_id,content_tags --out=***.csv</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2019-05-17T13:41:33.068+0800    connected to: localhost:29001</span><br><span class="line">2019-05-17T13:41:34.067+0800    feeds.content_medium_hismatch  0</span><br><span class="line">2019-05-17T13:41:35.067+0800    feeds.content_medium_hismatch  0</span><br><span class="line">2019-05-17T13:41:36.067+0800    feeds.content_medium_hismatch  0</span><br><span class="line">2019-05-17T13:41:36.656+0800    feeds.content_medium_hismatch  18870</span><br><span class="line">2019-05-17T13:41:36.656+0800    exported 18870 records</span><br><span class="line">public-ops-mongodb2 seclogin <span class="comment"># cat content_medium_hismatch.csv |wc -l</span></span><br><span class="line">18871</span><br><span class="line">public-ops-mongodb2 seclogin <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>和开发确认一下这个条件能否却掉，开发确认可以去掉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>mongoexport</code>在执行有条件的导出文件，<code>--query</code> 条件要写在一个<code>花括号{}</code>里面，如果要有两个<code>花括号{}</code>的条件，中间用<code>逗号,</code>分割，这样是不行的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细的MySQL高性能优化实战总结</title>
      <link href="/2019/05/16/mysql-innodb/"/>
      <url>/2019/05/16/mysql-innodb/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="iiiii.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>努力不一定成功，但是不努力会很舒服的哦!</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL 对于很多 Linux 从业者而言，是一个非常棘手的问题，多数情况都是因为对数据库出现问题的情况和处理思路不清晰。</p><p>在进行 MySQL 的优化之前必须要了解的就是 MySQL 的查询过程，很多的查询优化工作实际上就是遵循一些原则让 MySQL 的优化器能够按照预想的合理方式运行而已。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><img src="http://www.plantuml.com/plantuml/svg/bLDTIm9157sVNx5i3tt0Rk_Bij3NWv15I0-HFKGj4SKgMeH4q4EKbPfbXPPeQub2k4e41Hh-6MTs_HVDxgop7ndHFDsvSywvToxdHjStTjQtP8OD9a9BymmgLurcnUYUwVLBzX0m-8pDx6xBojwuTLbb2KBlv60ZpwxPIQFsZ4fPMAZxCkZfccRwbHFuSg9dJzqmTD_wYIGbUfqyJDrxmESrGqqPcWgJDpwmhn-I97ZOkKEv37qAA4faTffUWub0Q2f8hxnr79sx5afhzBeo5wBnmY8EZm1OZiinHkHNHsBovXelEUCQ128l-RiK6AXLKF93VsrEec8QNgWu2YlzuuTULuNfAqFJm2ZbSzw9O7f2ZeSL_V4TPQf6znO-blHsWIe2VpLkFyf9TlEuylLNxxE1wTOhS5SXY7-AIsGK0eFUL5GyjsL9qdnqMKCWCVOPyEIvpSY1uc0jAmZwRHabis65ve3VGcRBRWPv8kfUNvb8BzTkvNSAxUc76V5FBL_PB8ydHNFMGpaO7LPiiBLTv7zWk5T5KjulBtWg3-5DqBQfpVy2qWNu2qXNmn5tXZJOazz4Y0LzMq02RBPs3fMABYjYzCHm9O5OSi3v1W00"><h3 id="优化的哲学"><a href="#优化的哲学" class="headerlink" title="优化的哲学"></a>优化的哲学</h3><blockquote><p>注：优化有风险，修改需谨慎。</p></blockquote><ul><li>优化可能带来的问题：</li><li>优化不总是对一个单纯的环境进行，还很可能是一个复杂的已投产的系统。</li><li>优化手段本来就有很大的风险，只不过你没能力意识到和预见到。</li><li>任何的技术可以解决一个问题，但必然存在带来一个问题的风险。</li><li>对于优化来说解决问题而带来的问题，控制在可接受的范围内才是有成果。</li><li>保持现状或出现更差的情况都是失败。</li></ul><p>优化的需求：</p><ul><li>稳定性和业务可持续性，通常比性能更重要。</li><li>优化不可避免涉及到变更，变更就有风险。</li><li>优化使性能变好，维持和变差是等概率事件。</li><li>切记优化，应该是各部门协同，共同参与的工作，任何单一部门都不能对数据库进行优化。</li></ul><p>所以优化工作，是由业务需求驱使的!</p><p>优化由谁参与?在进行数据库优化时，应由数据库管理员、业务部门代表、应用程序架构师、应用程序设计人员、应用程序开发人员、硬件及系统管理员、存储管理员等，业务相关人员共同参与。</p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><h4 id="优化什么"><a href="#优化什么" class="headerlink" title="优化什么"></a>优化什么</h4><p>在数据库优化上有两个主要方面：</p><ul><li>安全：数据可持续性。</li><li>性能：数据的高性能访问。</li></ul><h4 id="优化的范围有哪些"><a href="#优化的范围有哪些" class="headerlink" title="优化的范围有哪些"></a>优化的范围有哪些</h4><p>存储、主机和操作系统方面：</p><ul><li>主机架构稳定性</li><li>I/O 规划及配置</li><li>Swap 交换分区</li><li>OS 内核参数和网络问题</li></ul><p>应用程序方面：</p><ul><li>应用程序稳定性</li><li>SQL 语句性能</li><li>串行访问资源</li><li>性能欠佳会话管理</li><li>这个应用适不适合用 MySQL</li></ul><p>数据库优化方面：</p><ul><li>内存</li><li>数据库结构(物理&逻辑)</li><li>实例配置</li></ul><blockquote><p>说明：不管是设计系统、定位问题还是优化，都可以按照这个顺序执行。</p></blockquote><h4 id="优化维度"><a href="#优化维度" class="headerlink" title="优化维度"></a>优化维度</h4><img src="/2019/05/16/mysql-innodb/weidu.jpeg" title="weidu"><p>数据库优化维度有如下四个:</p><ul><li>硬件</li><li>系统配置</li><li>数据库表结构</li><li>SQL 及索引</li></ul><p>优化选择:</p><ul><li>优化成本：硬件>系统配置>数据库表结构>SQL 及索引。</li><li>优化效果：硬件<系统配置<数据库表结构</li></ul><h4 id="优化工具有啥"><a href="#优化工具有啥" class="headerlink" title="优化工具有啥"></a>优化工具有啥</h4><h2 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h2><p>检查问题常用的 12 个工具:</p><ul><li>MySQL</li><li>mysqladmin：MySQL 客户端，可进行管理操作</li><li>mysqlshow：功能强大的查看 shell 命令</li><li>SHOW [SESSION | GLOBAL] variables：查看数据库参数信息</li><li>SHOW [SESSION | GLOBAL] STATUS：查看数据库的状态信息</li><li>information_schema：获取元数据的方法</li><li>SHOW ENGINE INNODB STATUS：Innodb 引擎的所有状态</li><li>SHOW PROCESSLIST：查看当前所有连接的 session 状态</li><li>explain：获取查询语句的执行计划</li><li>show index：查看表的索引信息</li><li>slow-log：记录慢查询语句</li><li>mysqldumpslow：分析 slowlog 文件的工具</li></ul><p>不常用但好用的 7 个工具:</p><ul><li>Zabbix：监控主机、系统、数据库(部署 Zabbix 监控平台)</li><li>pt-query-digest：分析慢日志</li><li>MySQL slap：分析慢日志</li><li>sysbench：压力测试工具</li><li>MySQL profiling：统计数据库整体状态工具</li><li>Performance Schema：MySQL 性能状态统计的数据</li><li>workbench：管理、备份、监控、分析、优化工具(比较费资源)</li></ul><h4 id="数据库层面问题解决思路"><a href="#数据库层面问题解决思路" class="headerlink" title="数据库层面问题解决思路"></a>数据库层面问题解决思路</h4><p>一般应急调优的思路：针对突然的业务办理卡顿，无法进行正常的业务处理，需要马上解决的场景。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show processlist </span><br><span class="line">explain select id ,name from stu <span class="built_in">where</span> name=<span class="string">'clsn'</span>; <span class="comment"># ALL id name age sex </span></span><br><span class="line"> select id,name from stu <span class="built_in">where</span> id=2-1 函数 结果集>30; </span><br><span class="line">　 show index from table; </span><br><span class="line">通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题 </span><br><span class="line">show status like <span class="string">'%lock%'</span>; <span class="comment"># 查询锁状态 </span></span><br><span class="line"><span class="built_in">kill</span> SESSION_ID; <span class="comment"># 杀掉有问题的session</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>常规调优思路：针对业务周期性的卡顿，例如在每天 10-11 点业务特别慢，但是还能够使用，过了这段时间就好了。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看slowlog，分析slowlog，分析出查询慢的语句； </span><br><span class="line">按照一定优先级，一个一个排查所有慢语句； </span><br><span class="line">分析top SQL，进行explain调试，查看语句执行时间； </span><br><span class="line">调整索引或语句本身。</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a>系统层面</h4><p>CPU方面：vmstat、sar top、htop、nmon、mpstat。</p><p>内存：free、ps-aux。</p><p>IO 设备(磁盘、网络)：iostat、ss、netstat、iptraf、iftop、lsof。</p><p>vmstat 命令说明：</p><ul><li>Procs：r 显示有多少进程正在等待 CPU 时间。b 显示处于不可中断的休眠的进程数量。在等待 I/O。</li><li>Memory：swpd 显示被交换到磁盘的数据块的数量。未被使用的数据块，用户缓冲数据块，用于操作系统的数据块的数量。</li><li>Swap：操作系统每秒从磁盘上交换到内存和从内存交换到磁盘的数据块的数量。s1 和 s0 最好是 0。</li><li>IO：每秒从设备中读入 b1 的写入到设备 b0 的数据块的数量。反映了磁盘 I/O。</li><li>System：显示了每秒发生中断的数量(in)和上下文交换(cs)的数量。</li><li>CPU：显示用于运行用户代码，系统代码，空闲，等待 I/O 的 CPU 时间。</li></ul><p>iostat 命令说明：</p><ul><li>实例命令：iostat -dk 1 5;iostat -d -k -x 5 (查看设备使用率(%util)和响应时间(await))。</li><li>TPS：该设备每秒的传输次数。“一次传输”意思是“一次 I/O 请求”。多个逻辑请求可能会被合并为“一次 I/O 请求”。</li><li>iops ：硬件出厂的时候，厂家定义的一个每秒最大的 IO 次数。</li><li>“一次传输”请求的大小是未知的。</li><li>KB_read/s：每秒从设备(drive expressed)读取的数据量。</li><li>KB_wrtn/s：每秒向设备(drive expressed)写入的数据量。</li><li>KB_read：读取的总数据量。</li><li>KB_wrtn：写入的总数量数据量;这些单位都为 Kilobytes。</li></ul><h4 id="系统层面问题解决办法"><a href="#系统层面问题解决办法" class="headerlink" title="系统层面问题解决办法"></a>系统层面问题解决办法</h4><p>你认为到底负载高好，还是低好呢?在实际的生产中，一般认为 CPU 只要不超过 90% 都没什么问题。当然不排除下面这些特殊情况。</p><p>CPU 负载高，IO 负载低：</p><ul><li>内存不够</li><li>磁盘性能差</li><li>SQL 问题：去数据库层，进一步排查 SQL 问题</li><li>IO 出问题了(磁盘到临界了、raid 设计不好、raid 降级、锁、在单位时间内 TPS 过高)</li><li>TPS 过高：大量的小数据 IO、大量的全表扫描</li></ul><p>IO 负载高，CPU 负载低：</p><ul><li>大量小的 IO 写操作</li><li>autocommit，产生大量小 IO;IO/PS，磁盘的一个定值，硬件出厂的时候，厂家定义的一个每秒最大的 IO 次数。</li><li>大量大的 IO 写操作：SQL 问题的几率比较大</li></ul><p>IO和 CPU 负载都很高：</p><ul><li>硬件不够了或 SQL 存在问题</li></ul><h2 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h2><h4 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h4><p>定位问题点吮吸：硬件>系统>应用>数据库>架构(高可用、读写分离、分库分表)。</p><p>处理方向：明确优化目标、性能和安全的折中、防患未然。</p><h4 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h4><h5 id="主机方面"><a href="#主机方面" class="headerlink" title="主机方面"></a>主机方面</h5><p>根据数据库类型，主机 CPU 选择、内存容量选择、磁盘选择：</p><ul><li>平衡内存和磁盘资源</li><li>随机的 I/O 和顺序的 I/O</li><li>主机 RAID 卡的 BBU(Battery Backup Unit)关闭</li></ul><h5 id="CPU-的选择"><a href="#CPU-的选择" class="headerlink" title="CPU 的选择"></a>CPU 的选择</h5><p>CPU 的两个关键因素：核数、主频。根据不同的业务类型进行选择：</p><ul><li>CPU 密集型：计算比较多，OLTP 主频很高的 CPU、核数还要多。</li><li>IO 密集型：查询比较，OLAP 核数要多，主频不一定高的。</li></ul><h5 id="内存的选择"><a href="#内存的选择" class="headerlink" title="内存的选择"></a>内存的选择</h5><p>OLAP 类型数据库，需要更多内存，和数据获取量级有关。OLTP 类型数据一般内存是 CPU 核心数量的 2 倍到 4 倍，没有最佳实践。</p><h5 id="存储方面"><a href="#存储方面" class="headerlink" title="存储方面"></a>存储方面</h5><p>根据存储数据种类的不同，选择不同的存储设备，配置合理的 RAID 级别(raid5、raid10、热备盘)。</p><p>对于操作系统来讲，不需要太特殊的选择，最好做好冗余(raid1)(ssd、sas、sata)。</p><p>主机 raid 卡选择：</p><ul><li>实现操作系统磁盘的冗余(raid1)</li><li>平衡内存和磁盘资源</li><li>随机的 I/O 和顺序的 I/O</li><li>主机 raid 卡的 BBU(Battery Backup Unit)要关闭</li></ul><h5 id="网络设备方面"><a href="#网络设备方面" class="headerlink" title="网络设备方面"></a>网络设备方面</h5><p>使用流量支持更高的网络设备(交换机、路由器、网线、网卡、HBA 卡)。注意：以上这些规划应该在初始设计系统时就应该考虑好。</p><h4 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h4><p>服务器硬件优化关键点：</p><ul><li>物理状态灯</li><li>自带管理设备：远程控制卡(FENCE设备：ipmi ilo idarc)、开关机、硬件监控。</li><li>第三方的监控软件、设备(snmp、agent)对物理设施进行监控。</li><li>存储设备：自带的监控平台。EMC2(HP 收购了)、 日立(HDS)、IBM 低端 OEM HDS、高端存储是自己技术，华为存储。</li></ul><h4 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h4><p>CPU：基本不需要调整，在硬件选择方面下功夫即可。</p><p>内存：基本不需要调整，在硬件选择方面下功夫即可。</p><p>SWAP：MySQL 尽量避免使用 Swap。阿里云的服务器中默认 swap 为 0。</p><p>IO ：raid、no lvm、ext4 或 xfs、ssd、IO 调度策略。</p><p>Swap 调整(不使用 swap 分区)：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/vm/swappiness的内容改成0(临时)，/etc/sysctl. conf上添加vm.swappiness=0(永久)</span><br></pre></td></tr></tbody></table></figure><p></p><p>这个参数决定了 Linux 是倾向于使用 Swap，还是倾向于释放文件系统 Cache。在内存紧张的情况下，数值越低越倾向于释放文件系统 Cache。</p><p>当然，这个参数只能减少使用 Swap 的概率，并不能避免 Linux 使用 Swap。</p><p>修改 MySQL 的配置参数 innodb_flush_ method，开启 O_DIRECT 模式。</p><p>这种情况下，InnoDB 的 buffer pool 会直接绕过文件系统 Cache 来访问磁盘，但是 redo log 依旧会使用文件系统 Cache。</p><p>值得注意的是，Redo log 是覆写模式的，即使使用了文件系统的 Cache，也不会占用太多。</p><p>IO 调度策略：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#echo deadline>/sys/block/sda/queue/scheduler 临时修改为deadline</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>永久修改<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /boot/grub/grub.conf </span><br><span class="line">更改到如下内容: </span><br><span class="line">kernel /boot/vmlinuz-2.6.18-8.el5 ro root=LABEL=/ elevator=deadline rhgb quiet</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="系统参数调整"><a href="#系统参数调整" class="headerlink" title="系统参数调整"></a>系统参数调整</h4><p>Linux 系统内核参数优化<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/sysctl.conf </span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65535：<span class="comment"># 用户端口范围 </span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096 </span><br><span class="line">net.ipv4.tcp_fin_timeout = 30 </span><br><span class="line">fs.file-max=65535：<span class="comment"># 系统最大文件句柄，控制的是能打开文件最大数量</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>用户限制参数(MySQL 可以不设置以下配置)：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/security/limits.conf </span><br><span class="line">* soft nproc 65535 </span><br><span class="line">* hard nproc 65535 </span><br><span class="line">* soft nofile 65535 </span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><p>业务应用和数据库应用独立。</p><p>防火墙：iptables、selinux 等其他无用服务(关闭)：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 23456 acpid off </span><br><span class="line">chkconfig --level 23456 anacron off </span><br><span class="line">chkconfig --level 23456 autofs off </span><br><span class="line">chkconfig --level 23456 avahi-daemon off </span><br><span class="line">chkconfig --level 23456 bluetooth off </span><br><span class="line">chkconfig --level 23456 cups off </span><br><span class="line">chkconfig --level 23456 firstboot off </span><br><span class="line">chkconfig --level 23456 haldaemon off </span><br><span class="line">chkconfig --level 23456 hplip off </span><br><span class="line">chkconfig --level 23456 ip6tables off </span><br><span class="line">chkconfig --level 23456 iptables off </span><br><span class="line">chkconfig --level 23456 isdn off </span><br><span class="line">chkconfig --level 23456 pcscd off </span><br><span class="line">chkconfig --level 23456 sendmail off </span><br><span class="line">chkconfig --level 23456 yum-updatesd off</span><br></pre></td></tr></tbody></table></figure><p></p><p>安装图形界面的服务器不要启动图形界面 runlevel 3。</p><p>另外，思考将来我们的业务是否真的需要 MySQL，还是使用其他种类的数据库。用数据库的最高境界就是不用数据库。</p><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><p>SQL 优化方向：</p><ul><li>执行计划</li><li>索引</li><li>SQL 改写</li></ul><p>架构优化方向：</p><ul><li>高可用架构</li><li>高性能架构</li><li>分库分表</li></ul><h4 id="数据库参数优化"><a href="#数据库参数优化" class="headerlink" title="数据库参数优化"></a>数据库参数优化</h4><h5 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h5><p>实例整体(高级优化，扩展)：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread_concurrency：<span class="comment"># 并发线程数量个数 </span></span><br><span class="line">sort_buffer_size：<span class="comment"># 排序缓存 </span></span><br><span class="line">read_buffer_size：<span class="comment"># 顺序读取缓存 </span></span><br><span class="line">read_rnd_buffer_size：<span class="comment"># 随机读取缓存 </span></span><br><span class="line">key_buffer_size：<span class="comment"># 索引缓存 </span></span><br><span class="line">thread_cache_size：<span class="comment"># (1G—>8, 2G—>16, 3G—>32, >3G—>64)</span></span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="连接层-基础优化"><a href="#连接层-基础优化" class="headerlink" title="连接层(基础优化)"></a>连接层(基础优化)</h5><p>设置合理的连接客户和连接方式：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">max_connections <span class="comment"># 最大连接数，看交易笔数设置 </span></span><br><span class="line">max_connect_errors <span class="comment"># 最大错误连接数，能大则大 </span></span><br><span class="line">connect_timeout <span class="comment"># 连接超时 </span></span><br><span class="line">max_user_connections <span class="comment"># 最大用户连接数 </span></span><br><span class="line">skip-name-resolve <span class="comment"># 跳过域名解析 </span></span><br><span class="line">wait_timeout <span class="comment"># 等待超时 </span></span><br><span class="line">back_log <span class="comment"># 可以在堆栈中的连接数量 </span></span><br><span class="line">```      </span><br><span class="line"><span class="comment">##### SQL 层(基础优化)</span></span><br><span class="line">query_cache_size： 查询缓存 >>> OLAP 类型数据库，需要重点加大此内存缓存，但是一般不会超过 GB。</span><br><span class="line"></span><br><span class="line">对于经常被修改的数据，缓存会马上失效。我们可以使用内存数据库(redis、memecache)，替代它的功能。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 存储引擎层优化</span></span><br><span class="line">innodb 基础优化参数：</span><br><span class="line">```bash</span><br><span class="line">default-storage-engine </span><br><span class="line">innodb_buffer_pool_size <span class="comment"># 没有固定大小，50%测试值，看看情况再微调。但是尽量设置不要超过物理内存70% </span></span><br><span class="line">innodb_file_per_table=(1,0) </span><br><span class="line">innodb_flush_log_at_trx_commit=(0,1,2) <span class="comment"># 1是最安全的，0是性能最高，2折中 </span></span><br><span class="line">binlog_sync </span><br><span class="line">Innodb_flush_method=(O_DIRECT, fdatasync) </span><br><span class="line">innodb_log_buffer_size <span class="comment"># 100M以下 </span></span><br><span class="line">innodb_log_file_size <span class="comment"># 100M 以下 </span></span><br><span class="line">innodb_log_files_in_group <span class="comment"># 5个成员以下,一般2-3个够用（iblogfile0-N） </span></span><br><span class="line">innodb_max_dirty_pages_pct <span class="comment"># 达到百分之75的时候刷写 内存脏页到磁盘。 </span></span><br><span class="line">log_bin </span><br><span class="line">max_binlog_cache_size <span class="comment"># 可以不设置 </span></span><br><span class="line">max_binlog_size <span class="comment"># 可以不设置 </span></span><br><span class="line">innodb_additional_mem_pool_size <span class="comment">#小于2G内存的机器，推荐值是20M。32G内存以上100M</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>51CTO传媒: <a href="https://www.toutiao.com/i6647024189007987208/?tt_from=weixin&utm_campaign=client_share&wxshare_count=2&from=singlemessage&timestamp=1555614491&app=news_article&utm_source=weixin&isappinstalled=0&utm_medium=toutiao_ios&req_id=201904190308110100230720231370496&group_id=6647024189007987208&pbid=6691541599112283651" target="_blank" rel="noopener">一份超详细的MySQL高性能优化实战总结</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pt-table-checksum fails on older MySQL without utf8mb4-support</title>
      <link href="/2019/05/14/PT-0/"/>
      <url>/2019/05/14/PT-0/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="bs.png" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>“别再抱怨你此生找不到一个对的人，当初的数学选择题就四个，你也找不到对的答案啊”</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天帮同事解决主从同步的问题。</p><p>原因是同事使用<code>Django</code>开发了一套运维平台。但是里面的表使用了<code>FOREIGN KEY</code>，在插入的是报错。造成了<code>主从同步错误</code>，数据量不大，使用<code>pt-table-checksum</code>来校验主从数据</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>一、先跳过主从错误，主从同步关系恢复正常。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STOP SLAVE sql_thread;</span><br><span class="line">SET GLOBAL sql_slave_skip_counter = 1;</span><br><span class="line">START SLAVE sql_thread;</span><br><span class="line">SHOW SLAVE STATUS\G</span><br></pre></td></tr></tbody></table></figure><p></p><p>二、使用 pt-table-checksum<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-table-checksum --<span class="built_in">set</span>-vars innodb_lock_wait_timeout=200 --nocheck-replication-filters --no-check-binlog-format --replicate=test.checksums --create-replicate-table --databases=***** --host=*** --port=*** --user=*** --password=<span class="string">'*****'</span> --recursion-method=<span class="string">'processlist'</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Error setting innodb_lock_wait_timeout: DBD::mysql::db <span class="keyword">do</span> failed: Variable <span class="string">'innodb_lock_wait_timeout'</span> is a <span class="built_in">read</span> only variable [<span class="keyword">for</span> Statement <span class="string">"SET SESSION innodb_lock_wait_timeout=1"</span>].  The current value <span class="keyword">for</span> innodb_lock_wait_timeout is 50.  If the variable is <span class="built_in">read</span> only (not dynamic), specify --<span class="built_in">set</span>-vars innodb_lock_wait_timeout=50 to avoid this warning, <span class="keyword">else</span> manually <span class="built_in">set</span> the variable and restart MySQL.</span><br><span class="line"></span><br><span class="line">Checking <span class="keyword">if</span> all tables can be checksummed ...</span><br><span class="line">Starting checksum ...</span><br><span class="line">Error setting innodb_lock_wait_timeout: DBD::mysql::db <span class="keyword">do</span> failed: Variable <span class="string">'innodb_lock_wait_timeout'</span> is a <span class="built_in">read</span> only variable [<span class="keyword">for</span> Statement <span class="string">"SET SESSION innodb_lock_wait_timeout=1"</span>].  The current value <span class="keyword">for</span> innodb_lock_wait_timeout is 50.  If the variable is <span class="built_in">read</span> only (not dynamic), specify --<span class="built_in">set</span>-vars innodb_lock_wait_timeout=50 to avoid this warning, <span class="keyword">else</span> manually <span class="built_in">set</span> the variable and restart MySQL.</span><br><span class="line"></span><br><span class="line">05-13T18:42:19 Error executing EXPLAIN SELECT COUNT(*) AS cnt, COALESCE(LOWER(CONV(BIT_XOR(CAST(CRC32(CONCAT_WS(<span class="string">'#'</span>, `id`, convert(`uuid` using utf8mb4), convert(`city` using utf8mb4), convert(`bassert` using utf8mb4), convert(`hostname` using utf8mb4), `idc_id`, `dp_id`, convert(`vlanip` using utf8mb4), convert(`wlanip` using utf8mb4), convert(`remote_ip` using utf8mb4), convert(`network_card` using utf8mb4), convert(`mac` using utf8mb4), convert(`serverown` using utf8mb4), convert(`status` using utf8mb4), convert(`rack` using utf8mb4), convert(`unit` using utf8mb4), convert(`sysversion` using utf8mb4), `order_time`, convert(`comment` using utf8mb4), `update_time`, `onlinetime`, `offlinetime`, convert(`roles` using utf8mb4), convert(`services` using utf8mb4), convert(`install_status` using utf8mb4), convert(`service_env` using utf8mb4), convert(`host_type` using utf8mb4), convert(`kvm_local` using utf8mb4), CONCAT(ISNULL(`order_time`), ISNULL(`onlinetime`), ISNULL(`offlinetime`), ISNULL(`roles`), ISNULL(`services`)))) AS UNSIGNED)), 10, 16)), 0) AS crc FROM `bportal`.`server_basic_info` /*explain checksum table*/: DBD::mysql::st execute failed: Unknown character <span class="built_in">set</span>: <span class="string">'utf8mb4'</span> [<span class="keyword">for</span> Statement <span class="string">"EXPLAIN SELECT COUNT(*) AS cnt, COALESCE(LOWER(CONV(BIT_XOR(CAST(CRC32(CONCAT_WS('#', `id`, convert(`uuid` using utf8mb4), convert(`city` using utf8mb4), convert(`bassert` using utf8mb4), convert(`hostname` using utf8mb4), `idc_id`, `dp_id`, convert(`vlanip` using utf8mb4), convert(`wlanip` using utf8mb4), convert(`remote_ip` using utf8mb4), convert(`network_card` using utf8mb4), convert(`mac` using utf8mb4), convert(`serverown` using utf8mb4), convert(`status` using utf8mb4), convert(`rack` using utf8mb4), convert(`unit` using utf8mb4), convert(`sysversion` using utf8mb4), `order_time`, convert(`comment` using utf8mb4), `update_time`, `onlinetime`, `offlinetime`, convert(`roles` using utf8mb4), convert(`services` using utf8mb4), convert(`install_status` using utf8mb4), convert(`service_env` using utf8mb4), convert(`host_type` using utf8mb4), convert(`kvm_local` using utf8mb4), CONCAT(ISNULL(`order_time`), ISNULL(`onlinetime`), ISNULL(`offlinetime`), ISNULL(`roles`), ISNULL(`services`)))) AS UNSIGNED)), 10, 16)), 0) AS crc FROM `bportal`.`server_basic_info` /*explain checksum table*/"</span>] at /usr/bin/pt-table-checksum line 12302.</span><br><span class="line"></span><br><span class="line">05-13T18:42:19 Error checksumming table bportal.server_basic_info: Error executing checksum query: DBD::mysql::st execute failed: Unknown character <span class="built_in">set</span>: <span class="string">'utf8mb4'</span> [<span class="keyword">for</span> Statement <span class="string">"REPLACE INTO `test`.`checksums` (db, tbl, chunk, chunk_index, lower_boundary, upper_boundary, this_cnt, this_crc) SELECT ?, ?, ?, ?, ?, ?, COUNT(*) AS cnt, COALESCE(LOWER(CONV(BIT_XOR(CAST(CRC32(CONCAT_WS('#', `id`, convert(`uuid` using utf8mb4), convert(`city` using utf8mb4), convert(`bassert` using utf8mb4), convert(`hostname` using utf8mb4), `idc_id`, `dp_id`, convert(`vlanip` using utf8mb4), convert(`wlanip` using utf8mb4), convert(`remote_ip` using utf8mb4), convert(`network_card` using utf8mb4), convert(`mac` using utf8mb4), convert(`serverown` using utf8mb4), convert(`status` using utf8mb4), convert(`rack` using utf8mb4), convert(`unit` using utf8mb4), convert(`sysversion` using utf8mb4), `order_time`, convert(`comment` using utf8mb4), `update_time`, `onlinetime`, `offlinetime`, convert(`roles` using utf8mb4), convert(`services` using utf8mb4), convert(`install_status` using utf8mb4), convert(`service_env` using utf8mb4), convert(`host_type` using utf8mb4), convert(`kvm_local` using utf8mb4), CONCAT(ISNULL(`order_time`), ISNULL(`onlinetime`), ISNULL(`offlinetime`), ISNULL(`roles`), ISNULL(`services`)))) AS UNSIGNED)), 10, 16)), 0) AS crc FROM `bportal`.`server_basic_info` /*checksum table*/"</span> with ParamValues: 0=<span class="string">'bportal'</span>, 1=<span class="string">'server_basic_info'</span>, 2=1, 3=undef, 4=undef, 5=undef] at /usr/bin/pt-table-checksum line 11691.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            TS ERRORS  DIFFS     ROWS  DIFF_ROWS  CHUNKS SKIPPED    TIME TABLE</span><br><span class="line">05-13T18:42:19      2      0        0          0       1       0   0.008 bportal.server_basic_info</span><br></pre></td></tr></tbody></table></figure><h4 id="于是排除问题："><a href="#于是排除问题：" class="headerlink" title="于是排除问题："></a>于是排除问题：</h4><ol><li>查看MySQL 版本</li><li>查看MySQL 字符集</li><li>查看数据库和表的字符集<h4 id="google查找问题原因"><a href="#google查找问题原因" class="headerlink" title="google查找问题原因"></a>google查找问题原因</h4>发现篇文章和该错误几乎一致。说到pt-table-checksum已经不支持MySQL 5.1版本。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thank you <span class="keyword">for</span> the report.</span><br><span class="line"></span><br><span class="line">The error is expected since  character <span class="built_in">set</span> utf8mb4 Unknown to the MySQL 5.1</span><br><span class="line"></span><br><span class="line">MySQL 5.1 is not a supported version: https://www.percona.com/services/support/mysql-support/percona-toolkit-supported-platforms-and-versions</span><br></pre></td></tr></tbody></table></figure></li></ol><p>写了一个<a href="./pt-table-checksum.utf8mb4.patch">patch</a></p><h4 id="pt-table-checksum打补丁"><a href="#pt-table-checksum打补丁" class="headerlink" title="pt-table-checksum打补丁"></a>pt-table-checksum打补丁</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch pt-table-checksum < pt-table-checksum.utf8mb4.patch</span><br></pre></td></tr></tbody></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-table-checksum --<span class="built_in">set</span>-vars innodb_lock_wait_timeout=200 --nocheck-replication-filters --no-check-binlog-format --replicate=test.checksums --create-replicate-table --databases=***** --host=*** --port=*** --user=*** --password=<span class="string">'*****'</span> --recursion-method=<span class="string">'processlist'</span></span><br></pre></td></tr></tbody></table></figure><p>发现没有上面的问题，一切都正常。在执行<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-table-sync --replicate=test.checksums --databases=***** --charset=utf8 h=****,P=****,u=****,p=<span class="string">'****'</span> --execute</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用MySQL 5.1版本的数据库赶快升级吧。太折腾人了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Percona: <a href="https://jira.percona.com/browse/PT-1552" target="_blank" rel="noopener">jira</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Toolkit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Toolkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解Go的channel底层原理</title>
      <link href="/2019/05/05/go-channal-graphic/"/>
      <url>/2019/05/05/go-channal-graphic/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="iiii.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>努力不一定成功，但是不努力会很舒服的哦!</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>channel的整体结构图<br><img src="/2019/05/05/go-channal-graphic/hchan.png" title="hchan"></p><p>简单说明：</p><ul><li><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表</li><li><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的~发送或者接收的~index</li><li><code>lock</code>是个互斥锁。</li><li><code>recvq</code>和<code>sendq</code>分别是接收(<-channel)或者发送(channel <- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><p>源码位于<code>/runtime/chan.go</code>中(目前版本：1.11)。结构体为<code>hchan</code>。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>下面我们来详细介绍<code>hchan</code>中各部分是如何使用的。</p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><p>先从创建开始</p><p>我们首先创建一个channel。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/05/05/go-channal-graphic/hchan1.png" title="hchan1"><p>创建channel实际上就是在内存中实例化了一个<code>hchan</code>的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接用channel就行了，因为channel本身就是一个指针。</p><h4 id="channel中发送send-ch-lt-xxx-和recv-lt-ch-接收"><a href="#channel中发送send-ch-lt-xxx-和recv-lt-ch-接收" class="headerlink" title="channel中发送send(ch <- xxx)和recv(<- ch)接收"></a>channel中发送send(ch <- xxx)和recv(<- ch)接收</h4><p>先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？<br>加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁<code>mutex</code></p><h4 id="channel中队列是如何实现的"><a href="#channel中队列是如何实现的" class="headerlink" title="channel中队列是如何实现的"></a>channel中队列是如何实现的</h4><p>channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。<br>还是刚才创建的那个channel<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/05/05/go-channal-graphic/hchan_gif1.png" title="hchan_gif1"><p>当使用<code>send (ch <- xx)</code>或者<code>recv ( <-ch)</code>的时候，首先要锁住<code>hchan</code>这个结构体。</p><img src="/2019/05/05/go-channal-graphic/hchan_gif2.png" title="hchan_gif2"><p>然后开始<code>send (ch <- xx)</code>数据。</p><p>一<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch <- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>二<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch <- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>三<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch <- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>这时候满了，队列塞不进去了</p><p>动态图表示为：<br><img src="/2019/05/05/go-channal-graphic/send.gif" title="send"><br>然后是取<code>recv ( <-ch)</code>的过程，是个逆向的操作，也是需要加锁。<br><img src="/2019/05/05/go-channal-graphic/hchan_gif6.png" title="hchan_gif6"></p><p>然后开始<code>recv (<-ch)</code>数据。<br>一<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><-ch</span><br></pre></td></tr></tbody></table></figure><p></p><p>二<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><-ch</span><br></pre></td></tr></tbody></table></figure><p></p><p>三<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><-ch</span><br></pre></td></tr></tbody></table></figure><p></p><p>图为：<br><img src="/2019/05/05/go-channal-graphic/recv.gif" title="recv"><br>注意以上两幅图中<code>buf</code>和<code>recvx</code>以及<code>sendx</code>的变化，<code>recvx</code>和<code>sendx</code>是根据循环链表<code>buf</code>的变动而改变的。</p><p>至于为什么<code>channel</code>会使用<code>循环链表</code>作为缓存结构，我个人认为是在缓存列表在动态的<code>send</code>和<code>recv</code>过程中，定位当前<code>send</code>或者<code>recvx</code>的位置、选择<code>send</code>的和<code>recvx</code>的位置比较方便吧，只要顺着链表顺序一直旋转操作就好。</p><p>缓存中按链表顺序存放，取数据的时候按链表顺序读取，符合FIFO的原则。</p><h4 id="send-recv的细化操作"><a href="#send-recv的细化操作" class="headerlink" title="send/recv的细化操作"></a>send/recv的细化操作</h4><p>注意：缓存链表中以上每一步的操作，都是需要加锁操作的！</p><p>每一步的操作的细节可以细化为：</p><ul><li>第一，加锁</li><li>第二，把数据从goroutine中copy到“队列”中(或者从队列中copy到goroutine中）。</li><li>第三，释放锁</li></ul><p>每一步的操作总结为动态图为：(发送过程)<br><img src="/2019/05/05/go-channal-graphic/send_single.gif" title="send_single"></p><p>或者为：(接收过程)<br><img src="/2019/05/05/go-channal-graphic/recv_single.gif" title="recv_single"></p><p>所以不难看出，Go中那句经典的话：<code>Do not communicate by sharing memory; instead, share memory by communicating.</code>的具体实现就是利用channel把数据从一端copy到了另一端！</p><p>还真是符合<code>channel</code>的英文含义：<br><img src="/2019/05/05/go-channal-graphic/hchan_channl.gif" title="hchan_channl"></p><h4 id="当channel缓存满了之后会发生什么？这其中的原理是怎样的？"><a href="#当channel缓存满了之后会发生什么？这其中的原理是怎样的？" class="headerlink" title="当channel缓存满了之后会发生什么？这其中的原理是怎样的？"></a>当channel缓存满了之后会发生什么？这其中的原理是怎样的？</h4><p>使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch <- xxx)或者recv(<- ch)会阻塞当前goroutine，但是，是如何实现的呢？</p><p>我们知道，Go的goroutine是用户态的线程(<code>user-space threads</code>)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。关于Go的调度模型GMP模型我在此不做赘述，如果不了解，可以看我另一篇文章(<a href="https://i6448038.github.io/2017/12/04/golang-concurrency-principle/" target="_blank" rel="noopener">Go并发原理</a>)</p><p>goroutine的阻塞操作，实际上是调用<code>send (ch <- xx)</code>或者<code>recv ( <-ch)</code>的时候主动触发的，具体请看以下内容：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goroutine1 中，记做G1</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ch <- <span class="number">1</span></span><br><span class="line">ch <- <span class="number">1</span></span><br><span class="line">ch <- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><img src="/2019/05/05/go-channal-graphic/hchan_block.png" title="hchan_block"><img src="/2019/05/05/go-channal-graphic/hchan_block1.png" title="hchan_block1"><p>这个时候G1正在正常运行,当再次进行send操作(ch<-1)的时候，会主动调用Go的调度器,让G1等待，并从让出M，让其他G去使用<br><img src="/2019/05/05/go-channal-graphic/hchan_block2.png" title="hchan_block2"></p><p>同时G1也会被抽象成含有G1指针和send元素的<code>sudog</code>结构体保存到hchan的<code>sendq</code>中等待被唤醒。<br><img src="/2019/05/05/go-channal-graphic/hchan_blok3.gif" title="hchan_blok3"></p><p>那么，G1什么时候被唤醒呢？这个时候G2隆重登场。<br><img src="/2019/05/05/go-channal-graphic/hchan_block4.png" title="hchan_block4"></p><p>G2执行了recv操作<code>p := <-ch</code>，于是会发生以下的操作：<br><img src="/2019/05/05/go-channal-graphic/hchan_block5.gif" title="hchan_block5"></p><p>G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。<br><img src="/2019/05/05/go-channal-graphic/hchan_block6.gif" title="hchan_block6"></p><h4 id="假如是先进行执行recv操作的G2会怎么样？"><a href="#假如是先进行执行recv操作的G2会怎么样？" class="headerlink" title="假如是先进行执行recv操作的G2会怎么样？"></a>假如是先进行执行recv操作的G2会怎么样？</h4><p>你可能会顺着以上的思路反推。首先：<br><img src="/2019/05/05/go-channal-graphic/hchan_block7_1.png" title="hchan_block7_1"></p><p>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。</p><p>G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒<br><img src="/2019/05/05/go-channal-graphic/hchan_block7.gif" title="hchan_block7"></p><p>此时恰好有个goroutine G1开始向channel中推送数据 <code>ch <- 1</code>。</p><p>此时，非常有意思的事情发生了：<br><img src="/2019/05/05/go-channal-graphic/hchan_block8.gif" title="hchan_block8"></p><p>G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。</p><p>这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。</p><p>之后的事情显而易见：<br><img src="/2019/05/05/go-channal-graphic/hchan_block9.gif" title="hchan_block9"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.youtube.com/watch?v=KBZlN0izeiY" target="_blank" rel="noopener">youtube</a></li><li><a href="https://zhuanlan.zhihu.com/p/27917262" target="_blank" rel="noopener">深入理解Golang Channel</a></li></ul><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><ul><li><a href="https://i6448038.github.io/2019/04/11/go-channel/" target="_blank" rel="noopener">图解Go的channel底层实现(RyuGou)</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最全Oracle DBA日常维护SQL脚本命令</title>
      <link href="/2019/04/26/oracle-ops-sql/"/>
      <url>/2019/04/26/oracle-ops-sql/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="aaa.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>“原谅他们是上帝的事，我们的任务是负责送他们见上帝。”</strong></p></blockquote><h2 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h2><h4 id="查询碎片程度高（实际使用率小于30-）的表"><a href="#查询碎片程度高（实际使用率小于30-）的表" class="headerlink" title="查询碎片程度高（实际使用率小于30%）的表"></a>查询碎片程度高（实际使用率小于30%）的表</h4><p>可以收缩的表条件为什么<code>block>100</code>，因为一些很小的表，只有几行数据实际大小很小，但是block一次性分配就是5个（11g开始默认一次性分配1M的block大小了，见create table storged的NEXT参数），5个block相对于几行小表数据来说就相差太大了。</p><p>算法中<code>/0.9</code>是因为块的<code>pfree</code>一般为<code>10%</code>，所以一个块最多只用了<code>90%</code>，而且一行数据大于<code>8KB</code>时容易产生行链接，把一行分片存储，一样的一个块连<code>90%</code>都用不满 ，<code>AVG_ROW_LEN</code>还是比较准的，比如个人实验情况一表6个字段，一个<code>numbe</code>r，其他5个都是<code>char(100)</code>但是实际数据都是’1111111’7位，AVG_ROW_LEN显示依然为513 。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT TABLE_NAME,</span><br><span class="line">        (BLOCKS * 8192/1024/1024) <span class="string">"理论大小M"</span>,</span><br><span class="line">         (NUM_ROWS * AVG_ROW_LEN/1024/1024/0.9) <span class="string">"实际大小M"</span>,</span><br><span class="line">         ROUND((NUM_ROWS * AVG_ROW_LEN/1024/1024/0.9)/(BLOCKS * 8192/1024/1024),</span><br><span class="line">         3) * 100|| <span class="string">'%'</span> <span class="string">"实际使用率%"</span></span><br><span class="line">FROM USER_TABLES</span><br><span class="line">WHERE blocks > 100</span><br><span class="line">        AND (NUM_ROWS * AVG_ROW_LEN/1024/1024/0.9)/(BLOCKS * 8192/1024/1024) < 0.3</span><br><span class="line">ORDER BY  (NUM_ROWS * AVG_ROW_LEN/1024/1024/0.9)/(BLOCKS * 8192/1024/1024) DESC</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查询索引碎片的比例"><a href="#查询索引碎片的比例" class="headerlink" title="查询索引碎片的比例"></a>查询索引碎片的比例</h4><p>索引删除行数除以索引总行数的百分比>30%即认为索引碎片大，也就是需要重建的索引<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line">         del_lf_rows,</span><br><span class="line">         lf_rows,</span><br><span class="line">         ROUND(del_lf_rows/decode(lf_rows,</span><br><span class="line">         0,</span><br><span class="line">         1,</span><br><span class="line">         lf_rows) * 100,</span><br><span class="line">        0)||<span class="string">'%'</span> frag_pct</span><br><span class="line">FROM index_stats</span><br><span class="line">WHERE ROUND(del_lf_rows/decode(lf_rows, 0, 1, lf_rows) * 100,0) > 30;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="集群因子clustering-factor高的表"><a href="#集群因子clustering-factor高的表" class="headerlink" title="集群因子clustering_factor高的表"></a>集群因子clustering_factor高的表</h4><p>集群因子越接近块数越好，接近行数则说明索引列的列值相等的行分布极度散列，可能不走索引扫描而走全表扫描 ：</p><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT tab.table_name,</span><br><span class="line">         tab.blocks,</span><br><span class="line">         tab.num_rows,</span><br><span class="line">         ind.index_name,</span><br><span class="line">         ind.clustering_factor,</span><br><span class="line">         ROUND(nvl(ind.clustering_factor,</span><br><span class="line">         1)/decode(tab.num_rows,</span><br><span class="line">         0,</span><br><span class="line">         1,</span><br><span class="line">         tab.num_rows),</span><br><span class="line">         3) * 100||<span class="string">'%'</span> <span class="string">"集群因子接近行数"</span></span><br><span class="line">FROM user_tables tab, user_indexes ind</span><br><span class="line">WHERE tab.table_name = ind.table_name</span><br><span class="line">        AND tab.blocks>100</span><br><span class="line">        AND nvl(ind.clustering_factor, 1)/decode(tab.num_rows, 0, 1, tab.num_rows)</span><br><span class="line">    BETWEEN 0.35</span><br><span class="line">        AND 3</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT tab.owner,</span><br><span class="line">         tab.table_name,</span><br><span class="line">         tab.blocks,</span><br><span class="line">         tab.num_rows,</span><br><span class="line">         ind.index_name,</span><br><span class="line">         ind.clustering_factor,</span><br><span class="line">         round(nvl(ind.clustering_factor,</span><br><span class="line">        1)/decode(tab.num_rows,</span><br><span class="line">        0,</span><br><span class="line">        1,</span><br><span class="line">        tab.num_rows),</span><br><span class="line">        3)*100||<span class="string">'%'</span> <span class="string">"集群因子接近行数"</span></span><br><span class="line">FROM dba_tables tab, dba_indexes ind</span><br><span class="line">WHERE tab.table_name=ind.table_name</span><br><span class="line">        AND tab.owner NOT IN (<span class="string">'SYS'</span>, <span class="string">'SYSTEM'</span>, <span class="string">'WMSYS'</span>, <span class="string">'DBSNMP'</span>, <span class="string">'CTXSYS'</span>, <span class="string">'XDB'</span>, <span class="string">'ORDDATA'</span>, <span class="string">'SYSMAN'</span>, <span class="string">'CATALOG'</span>, <span class="string">'APEX_030200'</span>, <span class="string">'MDSYS'</span>, <span class="string">'OLAPSYS'</span>, <span class="string">'EXFSYS'</span>)</span><br><span class="line">        AND tab.blocks > 100</span><br><span class="line">        AND nvl(ind.clustering_factor, 1)/decode(tab.num_rows, 0, 1, tab.num_rows)</span><br><span class="line">    BETWEEN 0.35</span><br><span class="line">        AND 3</span><br></pre></td></tr></tbody></table></figure><h4 id="根据sid查spid或根据spid查sid"><a href="#根据sid查spid或根据spid查sid" class="headerlink" title="根据sid查spid或根据spid查sid"></a>根据sid查spid或根据spid查sid</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">         s.serial<span class="comment">#,</span></span><br><span class="line">         p.spid,</span><br><span class="line">         s.terminal,</span><br><span class="line">         s.LOGON_TIME,</span><br><span class="line">         s.status,</span><br><span class="line">         s.PROGRAM,</span><br><span class="line">         s.CLIENT_IDENTIFIER,</span><br><span class="line">         s.machine,</span><br><span class="line">         s.action,</span><br><span class="line">         s.MODULE,</span><br><span class="line">         s.PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         s.osuser</span><br><span class="line">FROM v<span class="variable">$session</span> s, v<span class="variable">$process</span> p</span><br><span class="line">WHERE s.paddr=p.addr</span><br><span class="line">        AND s.sid=XX</span><br><span class="line">        OR p.spid=YY</span><br></pre></td></tr></tbody></table></figure><h4 id="根据sid查看具体的sql语句，不要加条件v-session-status-39-ACTIVE-39-，比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select-from-v-session时会发现另一个窗口在v-session-status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql-id对应的语句就是select-from-v-session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。"><a href="#根据sid查看具体的sql语句，不要加条件v-session-status-39-ACTIVE-39-，比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select-from-v-session时会发现另一个窗口在v-session-status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql-id对应的语句就是select-from-v-session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。" class="headerlink" title="根据sid查看具体的sql语句，不要加条件v$session.status='ACTIVE'，比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select * from v$session时会发现另一个窗口在v$session.status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql_id对应的语句就是select * from v$session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。"></a>根据<code>sid</code>查看具体的<code>sql语句</code>，不要加条件<code>v$session.status='ACTIVE'</code>，比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询<code>select * from v$session</code>时会发现另一个窗口在<code>v$session.status</code>是<code>INACTIVE</code>，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql_id对应的语句就是<code>select * from v$session</code>而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。</h4><p>一个sid可能执行过很多个sql，所以有时需要的sql通过如下查不到是正常的，比如查询到某死锁源sid，通过如下查询可能只是个<code>select语句</code>，而真正引起死锁的sql却查不到，是因为可能这个sid持续了很长时间，这个sid之前执行的一些sql在<code>v$sql</code>可能已经被清除了。</p><h5 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,</span><br><span class="line">         sid,</span><br><span class="line">        SERIAL<span class="comment">#,</span></span><br><span class="line">         LOGON_TIME,</span><br><span class="line">         status,</span><br><span class="line">         PROGRAM,</span><br><span class="line">         CLIENT_IDENTIFIER,</span><br><span class="line">         machine,</span><br><span class="line">        action,</span><br><span class="line">         PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         osuser,</span><br><span class="line">         sql_text</span><br><span class="line">FROM v<span class="variable">$session</span> a, v<span class="variable">$sqltext_with_newlines</span> b</span><br><span class="line">WHERE DECODE(a.sql_hash_value, 0, prev_hash_value, sql_hash_value) = b.hash_value</span><br><span class="line">        AND a.sid=&sid</span><br><span class="line">ORDER BY  piece; </span><br><span class="line">``` </span><br><span class="line"><span class="comment">##### 方法二:</span></span><br><span class="line">```bash</span><br><span class="line">SELECT username,</span><br><span class="line">         sid,</span><br><span class="line">        SERIAL<span class="comment">#,</span></span><br><span class="line">         LOGON_TIME,</span><br><span class="line">         status,</span><br><span class="line">         sql_fulltext,</span><br><span class="line">         PROGRAM,</span><br><span class="line">         CLIENT_IDENTIFIER,</span><br><span class="line">         machine,</span><br><span class="line">         a.action,</span><br><span class="line">         PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         osuser</span><br><span class="line">FROM v<span class="variable">$session</span> a, v<span class="variable">$sql</span> b</span><br><span class="line">WHERE DECODE(a.sql_hash_value, 0, prev_hash_value, sql_hash_value) = b.hash_value</span><br><span class="line">        AND a.sid=&sid</span><br></pre></td></tr></tbody></table></figure><h5 id="如果上面语句执行太慢，则按如下两步"><a href="#如果上面语句执行太慢，则按如下两步" class="headerlink" title="如果上面语句执行太慢，则按如下两步"></a>如果上面语句执行太慢，则按如下两步</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT sql_hash_value,</span><br><span class="line">         prev_hash_value,</span><br><span class="line">         username,</span><br><span class="line">         sid.SERIAL<span class="comment">#,</span></span><br><span class="line">         LOGON_TIME,</span><br><span class="line">         status,</span><br><span class="line">         PROGRAM,</span><br><span class="line">         CLIENT_IDENTIFIER,</span><br><span class="line">         machine,</span><br><span class="line">         action,</span><br><span class="line">         PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         osuser</span><br><span class="line">FROM v<span class="variable">$session</span></span><br><span class="line">WHERE sid=&sidSELECT sql_fulltext</span><br><span class="line">FROM v<span class="variable">$sql</span></span><br><span class="line">WHERE hash_value=XX</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li>XX为上面 <code>sql_hash_value</code>，如果 <code>sql_hash_value为0</code>，则XX为上面 <code>prev_hash_value</code></li></ul></blockquote><h4 id="根据spid查询具体的sql语句-不要加条件v-session-status-’-ACTIVE’-比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select-from-v-session时会发现另一个窗口在v-session-status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql-id对应的语句就是select-from-v-session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。"><a href="#根据spid查询具体的sql语句-不要加条件v-session-status-’-ACTIVE’-比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select-from-v-session时会发现另一个窗口在v-session-status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql-id对应的语句就是select-from-v-session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。" class="headerlink" title="根据spid查询具体的sql语句(不要加条件v$session.status=’ ACTIVE’,比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select  from v$session时会发现另一个窗口在v$session.status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql_id对应的语句就是select  from v$session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。)"></a>根据spid查询具体的sql语句(不要加条件v$session.status=’ ACTIVE’,比如toad对同一数据库开两个连接会话，都执行了一些语句，其中一个窗口查询select <em> from v$session时会发现另一个窗口在v$session.status是INACTIVE，并不代表另一个窗口没有执行过sql语句，而当前窗口是active状态，对应的sql_id对应的语句就是select </em> from v$session而不是之前执行过的sql语句，ACTIVE表示当前正在执行sql。)</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT ss.SID,</span><br><span class="line">         ss.SERIAL<span class="comment">#,</span></span><br><span class="line">         ss.LOGON_TIME,</span><br><span class="line">         pr.SPID,</span><br><span class="line">         sa.SQL_FULLTEXT,</span><br><span class="line">         ss.machine,</span><br><span class="line">         ss.TERMINAL,</span><br><span class="line">         ss.PROGRAM,</span><br><span class="line">         ss.USERNAME,</span><br><span class="line">         ss.CLIENT_IDENTIFIER,</span><br><span class="line">         ss.action,</span><br><span class="line">         ss.PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         ss.STATUS,</span><br><span class="line">         ss.OSUSER,</span><br><span class="line">         ss.status,</span><br><span class="line">         ss.last_call_et,</span><br><span class="line">         sa.sql_text</span><br><span class="line">FROM v<span class="variable">$process</span> pr, v<span class="variable">$session</span> ss, v<span class="variable">$sql</span> sa</span><br><span class="line">WHERE pr.ADDR = ss.PADDR</span><br><span class="line">        AND DECODE(ss.sql_hash_value, 0, prev_hash_value, sql_hash_value)=sa.hash_value</span><br><span class="line">        AND pr.spid=&spid</span><br></pre></td></tr></tbody></table></figure><h4 id="查看历史session-id的SQL来自哪个IP"><a href="#查看历史session-id的SQL来自哪个IP" class="headerlink" title="查看历史session_id的SQL来自哪个IP"></a>查看历史session_id的SQL来自哪个IP</h4><p>查看trace文件名就可以知道spid,trace文件里面有sid和具体sql，如果trace存在incident，那trace就看不到具体sql，但是可以在incident文件中看到具体的sql，如DW_ora_17751.trc中17751就是spid，里面有这样的内容Incident 115 created, dump file: /XX/incident/incdir_115/DW_ora_17751_i115.trc，那么在DW_ora_17751_i115.trc就可以看到具体的sql语句)</p><p>DB_ora_29349.trc中出现<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** SESSION ID:(5057.12807) 2016-10-26 14:45:52.726</span><br></pre></td></tr></tbody></table></figure><p></p><p>通过表<code>V$ACTIVE_SESSION_HISTORY</code>来查<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.sql_id,</span><br><span class="line">         a.machine,</span><br><span class="line">         a.*</span><br><span class="line">FROM V<span class="variable">$ACTIVE_SESSION_HISTORY</span> a</span><br><span class="line">WHERE a.session_id=5057</span><br><span class="line">        AND a.SESSION_SERIAL<span class="comment">#=12807</span></span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查询上面的machine的IP"><a href="#查询上面的machine的IP" class="headerlink" title="查询上面的machine的IP"></a>查询上面的machine的IP</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">         s.serial<span class="comment">#,</span></span><br><span class="line">         s.LOGON_TIME,</span><br><span class="line">         s.machine,</span><br><span class="line">         p.spid,</span><br><span class="line">         p.terminal</span><br><span class="line">FROM v<span class="variable">$session</span> s, v<span class="variable">$process</span> p</span><br><span class="line">WHERE s.paddr=p.addr</span><br><span class="line">        AND s.machine=<span class="string">'localhost'</span></span><br></pre></td></tr></tbody></table></figure><p>通过上面的<code>spid</code>在oracle服务器上执行<code>netstat -anp |grep spid</code>即可<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[oracle@dwdb trace]$ netstat -anp |grep 17630 </span><br><span class="line">tcp      210      0 192.168.64.228:11095        192.168.21.16:1521          ESTABLISHED 17630/oracleDB </span><br><span class="line">tcp        0      0 ::ffff:192.168.64.228:1521  ::ffff:192.168.64.220:59848 ESTABLISHED 17630/oracleDB</span><br></pre></td></tr></tbody></table></figure><p></p><p>出现两个，说明来自220，连接了228数据库服务器，但是又通过228服务器的dblink去连接了16服务器 </p><h4 id="查询死锁堵塞的会话sid"><a href="#查询死锁堵塞的会话sid" class="headerlink" title="查询死锁堵塞的会话sid"></a>查询死锁堵塞的会话sid</h4><p>最简单的一个SQL<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from V<span class="variable">$SESSION_BLOCKERS</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from dba_waiters</span><br></pre></td></tr></tbody></table></figure><p></p><p>最常用的一个SQL<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT sid,</span><br><span class="line">         status,</span><br><span class="line">         LOGON_TIME,</span><br><span class="line">         sql_id,</span><br><span class="line">         blocking_session <span class="string">"死锁直接源"</span>,</span><br><span class="line">         FINAL_BLOCKING_SESSION <span class="string">"死锁最终源"</span>,</span><br><span class="line">         event,</span><br><span class="line">        seconds_in_wait <span class="string">"会话锁住时间_S"</span>,</span><br><span class="line">         LAST_CALL_ET <span class="string">"会话STATUS持续时间_S"</span></span><br><span class="line">FROM v<span class="variable">$session</span></span><br><span class="line">WHERE state=<span class="string">'WAITING'</span></span><br><span class="line">        AND BLOCKING_SESSION_STATUS=<span class="string">'VALID'</span></span><br><span class="line">        AND FINAL_BLOCKING_SESSION_STATUS=<span class="string">'VALID'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>可以把两者<code>SID</code>放入<code>v$session</code>，发现<code>LOGON_TIME</code>字段<code>FINAL_BLOCKING_SESSION</code>比<code>SID</code>要早 </p><blockquote><p>BLOCKING_SESSION:Session identifier of the blocking session. This column is valid only if BLOCKING_SESSION_STATUS has the value VALID. </p></blockquote><blockquote><p>FINAL_BLOCKING_SESSION:Session identifier of the blocking session. This column is valid only if FINAL_BLOCKING_SESSION_STATUS has the value VALID. </p></blockquote><p>如果遇到<code>RAC环境</code>，一定要用<code>gv$</code>来查，并且执行<code>alter system kill session 'sid,serial#'</code>要到<code>RAC</code>对应的实例上去执行   </p><p>把上面被堵塞会话的<code>sid</code>代入如下语句，可以发现锁住的对象和对象的哪一行(如果<code>sid</code>是堵塞源的会话，则 <code>row_wait_obj#=-1</code>，表示锁持有者，就是死锁源了 )<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">         s.username,</span><br><span class="line">         d.owner,</span><br><span class="line">         d.object_name,</span><br><span class="line">         s.row_wait_obj<span class="comment">#,</span></span><br><span class="line">         s.row_wait_row<span class="comment">#,</span></span><br><span class="line">         s.row_wait_file<span class="comment">#,</span></span><br><span class="line">         s.row_wait_block<span class="comment">#</span></span><br><span class="line">FROM v<span class="variable">$session</span> s, dba_objects d</span><br><span class="line">WHERE s.row_wait_obj<span class="comment"># = d.object_id</span></span><br><span class="line">        AND s.sid <span class="keyword">in</span>(XX,XX)</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查询锁住的DDL对象"><a href="#查询锁住的DDL对象" class="headerlink" title="查询锁住的DDL对象"></a>查询锁住的DDL对象</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT d.session_id,</span><br><span class="line">         s.SERIAL<span class="comment">#,</span></span><br><span class="line">         d.name</span><br><span class="line">FROM dba_ddl_locks d, v<span class="variable">$session</span> s</span><br><span class="line">WHERE d.owner = <span class="string">'MKLMIGEM'</span></span><br><span class="line">        AND d.SESSION_ID=s.sid</span><br></pre></td></tr></tbody></table></figure><h4 id="查询超过两个小时的不活动会话"><a href="#查询超过两个小时的不活动会话" class="headerlink" title="查询超过两个小时的不活动会话"></a>查询超过两个小时的不活动会话</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">         s.serial<span class="comment">#,</span></span><br><span class="line">         p.spid,</span><br><span class="line">         s.LOGON_TIME,</span><br><span class="line">         s.LAST_CALL_ET,</span><br><span class="line">         s.status,</span><br><span class="line">         s.PROGRAM,</span><br><span class="line">         s.CLIENT_IDENTIFIER,</span><br><span class="line">         s.machine,</span><br><span class="line">         s.terminal,</span><br><span class="line">         s.action,</span><br><span class="line">         s.PROCESS <span class="string">"客户端机器进程号"</span>,</span><br><span class="line">         s.osuser</span><br><span class="line">FROM v<span class="variable">$session</span> s, v<span class="variable">$process</span> p</span><br><span class="line">WHERE s.paddr=p.addr</span><br><span class="line">        AND s.sid IN </span><br><span class="line">    (SELECT sid</span><br><span class="line">    FROM v<span class="variable">$session</span></span><br><span class="line">    WHERE machine <> &DB服务器名称</span><br><span class="line">            AND status=<span class="string">'INACTIVE'</span></span><br><span class="line">            AND sql_id is null</span><br><span class="line">            AND LAST_CALL_ET > 7200 )</span><br></pre></td></tr></tbody></table></figure><h4 id="查询堵塞别的会话超过30分钟且自身是不活动的会话"><a href="#查询堵塞别的会话超过30分钟且自身是不活动的会话" class="headerlink" title="查询堵塞别的会话超过30分钟且自身是不活动的会话"></a>查询堵塞别的会话超过30分钟且自身是不活动的会话</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,</span><br><span class="line">        sid,</span><br><span class="line">        serial<span class="comment">#,</span></span><br><span class="line">        status,</span><br><span class="line">        seconds_in_wait,</span><br><span class="line">        LAST_CALL_ET</span><br><span class="line">FROM v<span class="variable">$session</span></span><br><span class="line">WHERE sid IN </span><br><span class="line">    (SELECT FINAL_BLOCKING_SESSION</span><br><span class="line">    FROM v<span class="variable">$session</span></span><br><span class="line">    WHERE state=<span class="string">'WAITING'</span></span><br><span class="line">            AND BLOCKING_SESSION_STATUS=<span class="string">'VALID'</span></span><br><span class="line">            AND FINAL_BLOCKING_SESSION_STATUS=<span class="string">'VALID'</span>)</span><br><span class="line">        AND status=<span class="string">'INACTIVE'</span></span><br><span class="line">        AND sql_id is null</span><br><span class="line">        AND seconds_in_wait>1800</span><br></pre></td></tr></tbody></table></figure><h4 id="查询可能存在连接池空闲初始配置过大的连接（来自同一台机器的同一个程序的状态为INACTIVE的连接非常多）"><a href="#查询可能存在连接池空闲初始配置过大的连接（来自同一台机器的同一个程序的状态为INACTIVE的连接非常多）" class="headerlink" title="查询可能存在连接池空闲初始配置过大的连接（来自同一台机器的同一个程序的状态为INACTIVE的连接非常多）"></a>查询可能存在连接池空闲初始配置过大的连接（来自同一台机器的同一个程序的状态为INACTIVE的连接非常多）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(ss.SID),</span><br><span class="line">        ss.machine,</span><br><span class="line">        ss.status,</span><br><span class="line">        ss.TERMINAL,</span><br><span class="line">        ss.PROGRAM,</span><br><span class="line">        ss.USERNAME,</span><br><span class="line">        ss.CLIENT_IDENTIFIER</span><br><span class="line">FROM v<span class="variable">$session</span> ss</span><br><span class="line">GROUP BY  ss.machine,ss.status,ss.TERMINAL,ss.PROGRAM,ss.USERNAME,ss.CLIENT_IDENTIFIER</span><br><span class="line">HAVING count(ss.SID)>10</span><br></pre></td></tr></tbody></table></figure><h4 id="查询当前正在执行的sql"><a href="#查询当前正在执行的sql" class="headerlink" title="查询当前正在执行的sql"></a>查询当前正在执行的sql</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">        s.serial<span class="comment">#,</span></span><br><span class="line">        s.username,</span><br><span class="line">        spid,</span><br><span class="line">        v<span class="variable">$sql</span>.sql_id,</span><br><span class="line">        machine,</span><br><span class="line">        s.terminal,</span><br><span class="line">        s.program,</span><br><span class="line">        sql_text</span><br><span class="line">FROM v<span class="variable">$process</span>,v<span class="variable">$session</span> s,v<span class="variable">$sql</span></span><br><span class="line">WHERE addr=paddr</span><br><span class="line">        AND s.sql_id=v<span class="variable">$sql</span>.sql_id</span><br><span class="line">        AND sql_hash_value=hash_value</span><br><span class="line">        AND s.STATUS=<span class="string">'ACTIVE'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查询正在执行的SCHEDULER-JOB"><a href="#查询正在执行的SCHEDULER-JOB" class="headerlink" title="查询正在执行的SCHEDULER_JOB"></a>查询正在执行的SCHEDULER_JOB</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT owner,</span><br><span class="line">        job_name,</span><br><span class="line">        sid,</span><br><span class="line">        b.SERIAL<span class="comment">#,</span></span><br><span class="line">        b.username,</span><br><span class="line">        spid</span><br><span class="line">FROM ALL_SCHEDULER_RUNNING_JOBS,v<span class="variable">$session</span> b,v<span class="variable">$process</span></span><br><span class="line">WHERE session_id=sid</span><br><span class="line">        AND paddr=addr</span><br></pre></td></tr></tbody></table></figure><h4 id="查询正在执行的dbms-job"><a href="#查询正在执行的dbms-job" class="headerlink" title="查询正在执行的dbms_job"></a>查询正在执行的dbms_job</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT job,</span><br><span class="line">        b.sid,</span><br><span class="line">        b.SERIAL<span class="comment">#,</span></span><br><span class="line">        b.username,</span><br><span class="line">        spid</span><br><span class="line">FROM DBA_JOBS_RUNNING a ,v<span class="variable">$session</span> b,v<span class="variable">$process</span></span><br><span class="line">WHERE a.sid=b.sid</span><br><span class="line">        AND paddr=addr</span><br></pre></td></tr></tbody></table></figure><h4 id="查询一个会话session、process平均消耗多少PGA内存，查看下面avg-used-M值"><a href="#查询一个会话session、process平均消耗多少PGA内存，查看下面avg-used-M值" class="headerlink" title="查询一个会话session、process平均消耗多少PGA内存，查看下面avg_used_M值"></a>查询一个会话session、process平均消耗多少PGA内存，查看下面avg_used_M值</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT round(sum(pga_used_mem)/1024/1024,</span><br><span class="line">        0) total_used_M,</span><br><span class="line">         round(sum(pga_used_mem)/count(1)/1024/1024,</span><br><span class="line">        0) avg_used_M,</span><br><span class="line">         round(sum(pga_alloc_mem)/1024/1024,</span><br><span class="line">        0) total_alloc_M,</span><br><span class="line">         round(sum(pga_alloc_mem)/count(1)/1024/1024,</span><br><span class="line">        0) avg_alloc_M</span><br><span class="line">FROM v<span class="variable">$process</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="TOP-10-执行次数排序"><a href="#TOP-10-执行次数排序" class="headerlink" title="TOP 10 执行次数排序"></a>TOP 10 执行次数排序</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT executions,</span><br><span class="line">        username,</span><br><span class="line">        PARSING_USER_ID,</span><br><span class="line">        sql_id,</span><br><span class="line">        sql_text</span><br><span class="line">    FROM v<span class="variable">$sql</span>,dba_users</span><br><span class="line">    WHERE user_id=PARSING_USER_ID</span><br><span class="line">    ORDER BY  executions desc)</span><br><span class="line">WHERE rownum <=5;</span><br></pre></td></tr></tbody></table></figure><h4 id="TOP-10-物理读排序（消耗IO排序，即最差性能SQL、低效SQL排序）"><a href="#TOP-10-物理读排序（消耗IO排序，即最差性能SQL、低效SQL排序）" class="headerlink" title="TOP 10 物理读排序（消耗IO排序，即最差性能SQL、低效SQL排序）"></a>TOP 10 物理读排序（消耗IO排序，即最差性能SQL、低效SQL排序）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT DISK_READS,</span><br><span class="line">        username,</span><br><span class="line">        PARSING_USER_ID,</span><br><span class="line">        sql_id,</span><br><span class="line">        ELAPSED_TIME/1000000,</span><br><span class="line">        sql_text</span><br><span class="line">    FROM v<span class="variable">$sql</span>,dba_users</span><br><span class="line">    WHERE user_id=PARSING_USER_ID</span><br><span class="line">    ORDER BY  DISK_READS desc)</span><br><span class="line">WHERE rownum <=5;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：不要使用DISK_READS/ EXECUTIONS来排序，因为任何一条语句不管执行几次都会耗逻辑读和cpu，可能不会耗物理读（遇到LRU还会耗物理读，LRU规则是执行最不频繁的且最后一次执行时间距离现在最久远的就会被交互出buffer cache），是因为buffer cache存放的是数据块，去数据块里找行一定会消耗cpu和逻辑读的。Shared pool执行存放sql的解析结果，sql执行的时候只是去share pool中找hash value，如果有匹配的就是软解析。所以物理读逻辑读是在buffer cache中，软解析硬解析是在shared pool</p></blockquote><h4 id="TOP-10-逻辑读排序（消耗内存排序）"><a href="#TOP-10-逻辑读排序（消耗内存排序）" class="headerlink" title="TOP 10 逻辑读排序（消耗内存排序）"></a>TOP 10 逻辑读排序（消耗内存排序）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT BUFFER_GETS,</span><br><span class="line">        username,</span><br><span class="line">        PARSING_USER_ID,</span><br><span class="line">        sql_id,</span><br><span class="line">        ELAPSED_TIME/1000000,</span><br><span class="line">        sql_text</span><br><span class="line">    FROM v<span class="variable">$sql</span>,dba_users</span><br><span class="line">    WHERE user_id=PARSING_USER_ID</span><br><span class="line">    ORDER BY  BUFFER_GETS desc)</span><br><span class="line">WHERE rownum <=5;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：不要使用BUFFER_GETS/ EXECUTIONS来排序，因为任何一条语句不管执行几次都会耗逻辑读和cpu，可能不会耗物理读（遇到LRU还会耗物理读，LRU规则是执行最不频繁的且最后一次执行时间距离现在最久远的就会被交互出buffer cache），是因为buffer cache存放的是数据块，去数据块里找行一定会消耗cpu和逻辑读的。Shared pool执行存放sql的解析结果，sql执行的时候只是去share pool中找hash value，如果有匹配的就是软解析。所以物理读逻辑读是在buffer cache中，软解析硬解析是在shared pool）</p></blockquote><h4 id="TOP-10-CPU排序-单位秒-cpu-time-1000000"><a href="#TOP-10-CPU排序-单位秒-cpu-time-1000000" class="headerlink" title="TOP 10 CPU排序(单位秒=cpu_time/1000000)"></a>TOP 10 CPU排序(单位秒=cpu_time/1000000)</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT CPU_TIME/1000000,</span><br><span class="line">        username,</span><br><span class="line">        PARSING_USER_ID,</span><br><span class="line">        sql_id,</span><br><span class="line">        ELAPSED_TIME/1000000,</span><br><span class="line">        sql_text</span><br><span class="line">    FROM v<span class="variable">$sql</span>,dba_users</span><br><span class="line">    WHERE user_id=PARSING_USER_ID</span><br><span class="line">    ORDER BY  CPU_TIME/1000000 desc)</span><br><span class="line">WHERE rownum <=5;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：不要使用CPU_TIME/ EXECUTIONS来排序，因为任何一条语句不管执行几次都会耗逻辑读和cpu，可能不会耗物理读（遇到LRU还会耗物理读，LRU规则是执行最不频繁的且最后一次执行时间距离现在最久远的就会被交互出buffer cache），是因为buffer cache存放的是数据块，去数据块里找行一定会消耗cpu和逻辑读的。Shared pool执行存放sql的解析结果，sql执行的时候只是去share pool中找hash value，如果有匹配的就是软解析。所以物理读逻辑读是在buffer cache中，软解析硬解析是在shared pool。</p></blockquote><h4 id="查询等待事件"><a href="#查询等待事件" class="headerlink" title="查询等待事件"></a>查询等待事件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT event,</span><br><span class="line">        sum(decode(wait_time,</span><br><span class="line">        0,</span><br><span class="line">        0,</span><br><span class="line">        1)) <span class="string">"之前等待次数"</span>,</span><br><span class="line">         sum(decode(wait_time,</span><br><span class="line">        0,</span><br><span class="line">        1,</span><br><span class="line">        0)) <span class="string">"正在等待次数"</span>,</span><br><span class="line">        count(*)</span><br><span class="line">FROM v<span class="variable">$session_wait</span></span><br><span class="line">GROUP BY  event</span><br><span class="line">ORDER BY  4 DESC </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 查询当前等待事件对应的对象</span></span><br><span class="line">```bash</span><br><span class="line">SELECT DISTINCT wait_class<span class="comment">#,</span></span><br><span class="line">        wait_class</span><br><span class="line">FROM v<span class="variable">$session_wait_class</span></span><br><span class="line">ORDER BY  1</span><br></pre></td></tr></tbody></table></figure><h4 id="以上sql发现wait-class-6的是空闲等待"><a href="#以上sql发现wait-class-6的是空闲等待" class="headerlink" title="以上sql发现wait_class#=6的是空闲等待"></a>以上sql发现wait_class#=6的是空闲等待</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT sid,</span><br><span class="line">        event,</span><br><span class="line">        p1text,</span><br><span class="line">        p1,</span><br><span class="line">        p2text,</span><br><span class="line">        p2,</span><br><span class="line">        p3text,</span><br><span class="line">        p3,</span><br><span class="line">        WAIT_TIME,</span><br><span class="line">        SECONDS_IN_WAIT,</span><br><span class="line">        wait_class<span class="comment">#</span></span><br><span class="line">    FROM v<span class="variable">$session_wait</span></span><br><span class="line">    WHERE wait_class<span class="comment"># <> 6</span></span><br><span class="line">    ORDER BY  wait_time desc)</span><br><span class="line">WHERE rownum <=10;</span><br></pre></td></tr></tbody></table></figure><h4 id="能查出等待的对象是否来自数据文件（如果以上查到p1text是file-或file-number）"><a href="#能查出等待的对象是否来自数据文件（如果以上查到p1text是file-或file-number）" class="headerlink" title="能查出等待的对象是否来自数据文件（如果以上查到p1text是file#或file number）"></a>能查出等待的对象是否来自数据文件（如果以上查到p1text是file#或file number）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT owner,</span><br><span class="line">        segment_name,</span><br><span class="line">        segment_type,</span><br><span class="line">        block_id,</span><br><span class="line">        bytes</span><br><span class="line">    FROM dba_extents</span><br><span class="line">    WHERE file_id=p1</span><br><span class="line">            AND block_id<p2 order=<span class="string">""</span> by=<span class="string">""</span> block_id=<span class="string">""</span> desc)</span><br><span class="line">WHERE rownum<2</span><br></pre></td></tr></tbody></table></figure><p>把上面第二个sql结果的p1、p2值代入上述sql的file_id、block_id</p><p>通过<code>AWR</code>的<code>top sql</code>或<code>v$sql.sql_text</code>查看是否有该对象的语句，检查该语句的执行计划就可以查出问题所在。</p><h4 id="查询当前正在消耗临时空间的sql语句"><a href="#查询当前正在消耗临时空间的sql语句" class="headerlink" title="查询当前正在消耗临时空间的sql语句"></a>查询当前正在消耗临时空间的sql语句</h4><h5 id="方法一：-2"><a href="#方法一：-2" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT se.username,</span><br><span class="line">         se.sid,</span><br><span class="line">         su.blocks * to_number(rtrim(p.value))/1024/1024 AS space_G,</span><br><span class="line">         su.tablespace,</span><br><span class="line">         sql_text</span><br><span class="line">FROM V<span class="variable">$TEMPSEG_USAGE</span> su, v<span class="variable">$parameter</span> p, v<span class="variable">$session</span> se, v<span class="variable">$sql</span> s</span><br><span class="line">WHERE p.name = <span class="string">'db_block_size'</span></span><br><span class="line">        AND su.session_addr=se.saddr</span><br><span class="line">        AND su.sqlhash=s.hash_value</span><br><span class="line">        AND su.sqladdr=s.address</span><br><span class="line">        AND se.STATUS=<span class="string">'ACTIVE'</span></span><br><span class="line">``` </span><br><span class="line"><span class="comment">##### 方法二：</span></span><br><span class="line">```bash</span><br><span class="line">SELECT v<span class="variable">$sql</span>.sql_id,</span><br><span class="line">        v<span class="variable">$sql</span>.sql_fulltext,</span><br><span class="line">        swa.TEMPSEG_SIZE/1024/1024 TEMPSEG_M,</span><br><span class="line">         swa.*</span><br><span class="line">FROM v<span class="variable">$sql_workarea_active</span> swa,v<span class="variable">$sql</span></span><br><span class="line">WHERE swa.sql_id=v<span class="variable">$sql</span>.sql_id</span><br><span class="line">        AND swa.NUMBER_PASSES>0</span><br></pre></td></tr></tbody></table></figure><h4 id="查询因PGA不足而使用临时表空间的最频繁的10条SQL语句"><a href="#查询因PGA不足而使用临时表空间的最频繁的10条SQL语句" class="headerlink" title="查询因PGA不足而使用临时表空间的最频繁的10条SQL语句"></a>查询因PGA不足而使用临时表空间的最频繁的10条SQL语句</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT OPERATION_TYPE,</span><br><span class="line">        ESTIMATED_OPTIMAL_SIZE,</span><br><span class="line">        ESTIMATED_ONEPASS_SIZE,</span><br><span class="line">         sum(OPTIMAL_EXECUTIONS) optimal_cnt,</span><br><span class="line">        sum(ONEPASS_EXECUTIONS) AS onepass_cnt,</span><br><span class="line">         sum(MULTIPASSES_EXECUTIONS) AS mpass_cnt,</span><br><span class="line">        s.sql_text</span><br><span class="line">    FROM V<span class="variable">$SQL_WORKAREA</span> swa, v<span class="variable">$sql</span> s</span><br><span class="line">    WHERE swa.sql_id=s.sql_id</span><br><span class="line">    GROUP BY  OPERATION_TYPE,ESTIMATED_OPTIMAL_SIZE,ESTIMATED_ONEPASS_SIZE,sql_text</span><br><span class="line">    HAVING sum(ONEPASS_EXECUTIONS+MULTIPASSES_EXECUTIONS)>0</span><br><span class="line">    ORDER BY  sum(ONEPASS_EXECUTIONS) DESC )</span><br><span class="line">WHERE rownum<10</span><br></pre></td></tr></tbody></table></figure><h4 id="查询正在消耗PGA的SQL"><a href="#查询正在消耗PGA的SQL" class="headerlink" title="查询正在消耗PGA的SQL"></a>查询正在消耗PGA的SQL</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sql_text,</span><br><span class="line">         sw.EXPECTED_SIZE,</span><br><span class="line">         sw.ACTUAL_MEM_USED,</span><br><span class="line">        sw.NUMBER_PASSES,</span><br><span class="line">         sw.TEMPSEG_SIZE</span><br><span class="line">FROM v<span class="variable">$sql_workarea_active</span> sw, v<span class="variable">$sql</span> s</span><br><span class="line">WHERE sw.sql_id=s.sql_id;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询需要使用绑定变量的sql，10G以后推荐第二种"><a href="#查询需要使用绑定变量的sql，10G以后推荐第二种" class="headerlink" title="查询需要使用绑定变量的sql，10G以后推荐第二种"></a>查询需要使用绑定变量的sql，10G以后推荐第二种</h4><blockquote><p>注意：任何一条执行过的语句不管执行了几次在V$SQL中都只有一条记录，V$SQL中会记录执行了几次。两条一模一样的语句但是在不同的schema下执行的两种结果，如select <em> from t1.test在sye、system下执行则V$SQL只有一条记录(谁先执行则PARSING_SCHEMA_NAME显示谁)。如在sys和system都执行select </em> from test则V$SQL中有两条记录，两条记录的CHILD_NUMBER和PARSING_SCHEMA_NAME不一样。</p></blockquote><p>同一个用户下执行一样的语句如果大小写不一样或加了hint的话则会出现多个V$SQL记录，说明V$SQL对应的sql语句必须一模一样，如果alter system flush shared_pool（主站慎用）后再执行一样的语句，发现语句在V$SQL中的SQL_ID和HASH_VALUE与之前的一样，说明SQL_ID和HASH_VALUE应该是oracle自己的一套算法来的，只是根据sql语句内容来进行转换，sql语句不变则SQL_ID和HASH_VALUE也不变。</p><h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">    (SELECT count(*),</span><br><span class="line">        sql_id,</span><br><span class="line">         substr(sql_text,</span><br><span class="line">        1,</span><br><span class="line">        40)</span><br><span class="line">    FROM v<span class="variable">$sql</span></span><br><span class="line">    GROUP BY  sql_id, substr(sql_text,1,40)</span><br><span class="line">    HAVING count(*) > 10</span><br><span class="line">    ORDER BY  count(*) desc)</span><br><span class="line">WHERE rownum<10</span><br></pre></td></tr></tbody></table></figure><h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">count(1)>10表示类语句运行了10次以上SELECT sql_id,</span><br><span class="line">         FORCE_MATCHING_SIGNATURE,</span><br><span class="line">         sql_text</span><br><span class="line">FROM v<span class="variable">$SQL</span></span><br><span class="line">WHERE FORCE_MATCHING_SIGNATURE IN </span><br><span class="line">    (SELECT /*+ unnest */ FORCE_MATCHING_SIGNATURE</span><br><span class="line">    FROM v<span class="variable">$sql</span></span><br><span class="line">    WHERE FORCE_MATCHING_SIGNATURE > 0</span><br><span class="line">            AND FORCE_MATCHING_SIGNATURE != EXACT_MATCHING_SIGNATURE</span><br><span class="line">    GROUP BY  FORCE_MATCHING_SIGNATURE</span><br><span class="line">    HAVING count(1) > 10)</span><br></pre></td></tr></tbody></table></figure><h4 id="查看数据文件可用百分比"><a href="#查看数据文件可用百分比" class="headerlink" title="查看数据文件可用百分比"></a>查看数据文件可用百分比</h4><p><code>dba_free_space</code>并不会包含所有<code>file_id</code>，如果该数据文件满了，则 <code>dba_free_space.file_id</code>没有该数据文件，所以以下sql中 <code>a.file_id=b.file_id</code>的条件过滤后是不会有所有file_id的<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.file_id,</span><br><span class="line">        b.tablespace_name,</span><br><span class="line">        b.file_name,</span><br><span class="line">        b.AUTOEXTENSIBLE,</span><br><span class="line">         ROUND(b.MAXBYTES/1024/1024/1024,</span><br><span class="line">        2) ||<span class="string">'G'</span> <span class="string">"文件最大可用总容量"</span>, ROUND(b.bytes/1024/1024/1024,2) ||<span class="string">'G'</span> <span class="string">"文件总容量"</span>, ROUND((b.bytes-sum(nvl(a.bytes,0)))/1024/1024/1024,2)||<span class="string">'G'</span> <span class="string">"文件已用容量"</span>, ROUND(sum(nvl(a.bytes,0))/1024/1024/1024,2)||<span class="string">'G'</span> <span class="string">"文件可用容量"</span>, ROUND(sum(nvl(a.bytes,0))/(b.bytes),2)*100||<span class="string">'%'</span> <span class="string">"文件可用百分比"</span></span><br><span class="line">FROM dba_free_space a,dba_data_files b</span><br><span class="line">WHERE a.file_id=b.file_id</span><br><span class="line">GROUP BY  b.tablespace_name,b.file_name,b.file_id,b.bytes,b.AUTOEXTENSIBLE,b.MAXBYTES</span><br><span class="line">ORDER BY  b.tablespace_name;</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>如下为标准版<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.file_id,</span><br><span class="line">        b.tablespace_name,</span><br><span class="line">        b.file_name,</span><br><span class="line">        b.AUTOEXTENSIBLE,</span><br><span class="line">         ROUND(b.MAXBYTES/1024/1024/1024,</span><br><span class="line">        2) ||<span class="string">'G'</span> <span class="string">"文件最大可用总容量"</span>, ROUND(b.bytes/1024/1024/1024,2) ||<span class="string">'G'</span> <span class="string">"文件当前总容量"</span>, ROUND((b.bytes-sum(nvl(a.bytes,0)))/1024/1024/1024,2)||<span class="string">'G'</span> <span class="string">"文件当前已用容量"</span>, ROUND((decode(AUTOEXTENSIBLE,<span class="string">'NO'</span>,b.BYTES,b.MAXBYTES)+sum(nvl(a.bytes,0))-b.bytes)/1024/1024/1024,2)||<span class="string">'G'</span> <span class="string">"文件可用容量"</span>, ROUND((decode(AUTOEXTENSIBLE,<span class="string">'NO'</span>,b.BYTES,b.MAXBYTES)+sum(nvl(a.bytes,0))-b.bytes)/(decode(AUTOEXTENSIBLE,<span class="string">'NO'</span>,b.BYTES,b.MAXBYTES)),2)*100||<span class="string">'%'</span> <span class="string">"文件可用百分比"</span></span><br><span class="line">FROM dba_free_space a,dba_data_files b</span><br><span class="line">WHERE a.file_id=b.file_id</span><br><span class="line">GROUP BY  b.tablespace_name,b.file_name,b.file_id,b.bytes,b.AUTOEXTENSIBLE,b.MAXBYTES</span><br><span class="line">ORDER BY  decode(AUTOEXTENSIBLE,<span class="string">'NO'</span>,b.BYTES,b.MAXBYTES)+sum(nvl(a.bytes,0))-b.bytes;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="查看数据库文件的实际总量，单位G"><a href="#查看数据库文件的实际总量，单位G" class="headerlink" title="查看数据库文件的实际总量，单位G"></a>查看数据库文件的实际总量，单位G</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.datafile_size+b.tempfile_size-c.free_size</span><br><span class="line">FROM </span><br><span class="line">    (SELECT sum(bytes/1024/1024/1024) datafile_size</span><br><span class="line">    FROM dba_data_files ) a, </span><br><span class="line">    (SELECT sum(bytes/1024/1024/1024) tempfile_size</span><br><span class="line">    FROM dba_temp_files ) b, </span><br><span class="line">    (SELECT sum(bytes/1024/1024/1024) free_size</span><br><span class="line">    FROM dba_free_space ) c</span><br></pre></td></tr></tbody></table></figure><h4 id="查看表空间可用百分比（-dba-free-space不会包含所有tablespace，如果一个表空间的数据文件都满了，则这个表空间不会出现在dba-free-space中-）"><a href="#查看表空间可用百分比（-dba-free-space不会包含所有tablespace，如果一个表空间的数据文件都满了，则这个表空间不会出现在dba-free-space中-）" class="headerlink" title="查看表空间可用百分比（ dba_free_space不会包含所有tablespace，如果一个表空间的数据文件都满了，则这个表空间不会出现在dba_free_space中 ）"></a>查看表空间可用百分比（ dba_free_space不会包含所有tablespace，如果一个表空间的数据文件都满了，则这个表空间不会出现在dba_free_space中 ）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.tablespace_name,</span><br><span class="line">        a.maxsize max_M,</span><br><span class="line">        a.total total_M,</span><br><span class="line">        b.free free_M,</span><br><span class="line">        round((b.free/a.total)*100) <span class="string">"% Free"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         sum(bytes/(1024*1024)) total ,</span><br><span class="line">        sum(MAXBYTES/(1024*1024)) maxsize</span><br><span class="line">    FROM dba_data_files</span><br><span class="line">    GROUP BY  tablespace_name) a, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         round(sum(bytes/(1024*1024))) free</span><br><span class="line">    FROM dba_free_space</span><br><span class="line">    GROUP BY  tablespace_name) b</span><br><span class="line">WHERE a.tablespace_name = b.tablespace_name</span><br><span class="line">ORDER BY  <span class="string">"% Free"</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如下为标准版 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.tablespace_name,</span><br><span class="line">        a.maxsize max_M,</span><br><span class="line">        a.total total_M,</span><br><span class="line">        b.free free_M,</span><br><span class="line">        round(((a.maxsize+b.free-a.total)/a.maxsize)*100) <span class="string">"% Free"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         sum(bytes/(1024*1024)) total ,</span><br><span class="line">        sum((decode(AUTOEXTENSIBLE,</span><br><span class="line">        <span class="string">'NO'</span>,BYTES,MAXBYTES))/(1024*1024)) maxsize</span><br><span class="line">    FROM dba_data_files</span><br><span class="line">    GROUP BY  tablespace_name) a, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         round(sum(bytes/(1024*1024))) free</span><br><span class="line">    FROM dba_free_space</span><br><span class="line">    GROUP BY  tablespace_name) b</span><br><span class="line">WHERE a.tablespace_name = b.tablespace_name</span><br><span class="line">ORDER BY  <span class="string">"% Free"</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="查看临时表空间使用率"><a href="#查看临时表空间使用率" class="headerlink" title="查看临时表空间使用率"></a>查看临时表空间使用率</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT temp_used.tablespace_name,</span><br><span class="line">        round(total),</span><br><span class="line">        used,</span><br><span class="line">         round(total - used) AS <span class="string">"Free"</span>,</span><br><span class="line">         round(nvl(total-used,</span><br><span class="line">         0) * 100/total,</span><br><span class="line">        1) <span class="string">"Free percent"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         SUM(bytes_used)/1024/1024 used</span><br><span class="line">    FROM GV<span class="variable">$TEMP_SPACE_HEADER</span></span><br><span class="line">    GROUP BY  tablespace_name) temp_used, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         SUM(decode(autoextensible,</span><br><span class="line">        <span class="string">'YES'</span>,MAXBYTES,bytes))/1024/1024 total</span><br><span class="line">    FROM dba_temp_files</span><br><span class="line">    GROUP BY  tablespace_name) temp_total</span><br><span class="line">WHERE temp_used.tablespace_name = temp_total.tablespace_name</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.tablespace_name,</span><br><span class="line">         round(a.BYTES/1024/1024) total_M,</span><br><span class="line">         round(a.bytes/1024/1024 - nvl(b.bytes/1024/1024,</span><br><span class="line">         0)) free_M,</span><br><span class="line">         round(b.bytes/1024/1024) used,</span><br><span class="line">        round(b.using/1024/1024) using</span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         SUM (decode(autoextensible,</span><br><span class="line">        <span class="string">'YES'</span>,MAXBYTES,bytes)) bytes</span><br><span class="line">    FROM dba_temp_files</span><br><span class="line">    GROUP BY  tablespace_name) a, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         SUM (bytes_cached) bytes,</span><br><span class="line">        sum(bytes_used) using</span><br><span class="line">    FROM v<span class="variable">$temp_extent_pool</span></span><br><span class="line">    GROUP BY  tablespace_name) b</span><br><span class="line">WHERE a.tablespace_name = b.tablespace_name(+)</span><br></pre></td></tr></tbody></table></figure><h4 id="查询undo表空间使用情况"><a href="#查询undo表空间使用情况" class="headerlink" title="查询undo表空间使用情况"></a>查询undo表空间使用情况</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT tablespace_name,</span><br><span class="line">        status,</span><br><span class="line">        sum(bytes)/1024/1024 M</span><br><span class="line">FROM dba_undo_extents</span><br><span class="line">GROUP BY  tablespace_name,status</span><br></pre></td></tr></tbody></table></figure><h4 id="查询使用undo比较多的SQL"><a href="#查询使用undo比较多的SQL" class="headerlink" title="查询使用undo比较多的SQL"></a>查询使用undo比较多的SQL</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT *from </span><br><span class="line">    (SELECT maxqueryid,</span><br><span class="line">         round(sum(undoblks )*8/1024) consumed_size_MB</span><br><span class="line">    FROM v<span class="variable">$undostat</span></span><br><span class="line">    GROUP BY  maxqueryid</span><br><span class="line">    ORDER BY  consumed_size_MB DESC )</span><br><span class="line">WHERE rownum<10;</span><br></pre></td></tr></tbody></table></figure><h4 id="估计undo需要多大"><a href="#估计undo需要多大" class="headerlink" title="估计undo需要多大"></a>估计undo需要多大</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT (UR * (UPS * DBS)) AS <span class="string">"Bytes"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT max(tuned_undoretention) AS UR</span><br><span class="line">    FROM v<span class="variable">$undostat</span>), </span><br><span class="line">    (SELECT undoblks/((end_time-begin_time)*86400) AS UPS</span><br><span class="line">    FROM v<span class="variable">$undostat</span></span><br><span class="line">    WHERE undoblks = </span><br><span class="line">        (SELECT MAX(undoblks)</span><br><span class="line">        FROM v<span class="variable">$undostat</span>)), </span><br><span class="line">        (SELECT block_size AS DBS</span><br><span class="line">        FROM dba_tablespaces</span><br><span class="line">        WHERE tablespace_name = </span><br><span class="line">            (SELECT UPPER(value)</span><br><span class="line">            FROM v<span class="variable">$parameter</span></span><br><span class="line">            WHERE name = <span class="string">'undo_tablespace'</span>));</span><br></pre></td></tr></tbody></table></figure><h4 id="产生undo的当前活动会话是哪些"><a href="#产生undo的当前活动会话是哪些" class="headerlink" title="产生undo的当前活动会话是哪些"></a>产生undo的当前活动会话是哪些</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.inst_id,</span><br><span class="line">         a.sid,</span><br><span class="line">         c.username,</span><br><span class="line">         c.osuser,</span><br><span class="line">         c.program,</span><br><span class="line">         b.name,</span><br><span class="line">         a.value,</span><br><span class="line">         d.used_urec,</span><br><span class="line">         d.used_ublk</span><br><span class="line">FROM gv<span class="variable">$sesstat</span> a, v<span class="variable">$statname</span> b, gv<span class="variable">$session</span> c, gv<span class="variable">$transaction</span> d</span><br><span class="line">WHERE a.statistic<span class="comment"># = b.statistic#</span></span><br><span class="line">        AND a.inst_id = c.inst_id</span><br><span class="line">        AND a.sid = c.sid</span><br><span class="line">        AND c.inst_id = d.inst_id</span><br><span class="line">        AND c.saddr = d.ses_addr</span><br><span class="line">        AND b.name = <span class="string">'undo change vector size'</span></span><br><span class="line">        AND a.value>0</span><br><span class="line">ORDER BY  a.value DESC</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">        s.serial<span class="comment">#,</span></span><br><span class="line">        s.sql_id,</span><br><span class="line">        v.usn,</span><br><span class="line">        r.status,</span><br><span class="line">         v.rssize/1024/1024 mb</span><br><span class="line">FROM dba_rollback_segs r, v<span class="variable">$rollstat</span> v,v<span class="variable">$transaction</span> t,v<span class="variable">$session</span> s</span><br><span class="line">WHERE r.segment_id = v.usn</span><br><span class="line">        AND v.usn=t.xidusn</span><br><span class="line">        AND t.addr=s.taddr</span><br><span class="line">ORDER BY  6 desc;</span><br></pre></td></tr></tbody></table></figure><h4 id="查看ASM磁盘组使用率"><a href="#查看ASM磁盘组使用率" class="headerlink" title="查看ASM磁盘组使用率"></a>查看ASM磁盘组使用率</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line">        round(total_mb/1024) <span class="string">"总容量"</span>,</span><br><span class="line">        round(free_mb/1024) <span class="string">"空闲空间"</span>,</span><br><span class="line">        round((free_mb/total_mb)*100) <span class="string">"可用空间比例"</span></span><br><span class="line">FROM gv<span class="variable">$asm_diskgroup</span></span><br></pre></td></tr></tbody></table></figure><h4 id="统计每个用户使用表空间率"><a href="#统计每个用户使用表空间率" class="headerlink" title="统计每个用户使用表空间率"></a>统计每个用户使用表空间率</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.owner <span class="string">"用户"</span>,</span><br><span class="line">         a.tablespace_name <span class="string">"表空间名"</span>,</span><br><span class="line">         total/1024/1024 <span class="string">"表空间大小M"</span>,</span><br><span class="line">         free/1024/1024 <span class="string">"表空间剩余大小M"</span>,</span><br><span class="line">         ( total - free )/1024/1024 <span class="string">"表空间使用大小M"</span>,</span><br><span class="line">         Round(( total - free ) / total,</span><br><span class="line">         4) * 100 <span class="string">"表空间总计使用率 %"</span>,</span><br><span class="line">         c.schemas_use/1024/1024 <span class="string">"用户使用表空间大小M"</span>,</span><br><span class="line">         round((schemas_use)/total,</span><br><span class="line">        4)*100 <span class="string">"用户使用表空间率 %"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         Sum(bytes) free</span><br><span class="line">    FROM DBA_FREE_SPACE</span><br><span class="line">    GROUP BY  tablespace_name) a, </span><br><span class="line">    (SELECT tablespace_name,</span><br><span class="line">         Sum(bytes) total</span><br><span class="line">    FROM DBA_DATA_FILES</span><br><span class="line">    GROUP BY  tablespace_name) b, </span><br><span class="line">    (SELECT owner ,</span><br><span class="line">        Tablespace_Name,</span><br><span class="line">         Sum(bytes) schemas_use</span><br><span class="line">    FROM Dba_Segments</span><br><span class="line">    GROUP BY  owner,Tablespace_Name) c</span><br><span class="line">WHERE a.tablespace_name = b.tablespace_name</span><br><span class="line">        AND a.tablespace_name =c.Tablespace_Name</span><br><span class="line">ORDER BY  <span class="string">"用户"</span>,<span class="string">"表空间名"</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查看闪回区-快速恢复区空间使用率"><a href="#查看闪回区-快速恢复区空间使用率" class="headerlink" title="查看闪回区\快速恢复区空间使用率"></a>查看闪回区\快速恢复区空间使用率</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT sum(percent_space_used)||<span class="string">'%'</span> <span class="string">"已使用空间比例"</span></span><br><span class="line">FROM V<span class="variable">$RECOVERY_AREA_USAGE</span> </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">SELECT round(100*(a.space_used/space_limit),</span><br><span class="line">        2)||<span class="string">'%'</span> <span class="string">"已使用空间比例"</span>,a.*</span><br><span class="line">FROM v<span class="variable">$recovery_file_dest</span> a;</span><br></pre></td></tr></tbody></table></figure><h4 id="查看僵死进程，分两种（一种是会话不在的，另一种是会话标记为killed的但是会话还在的）"><a href="#查看僵死进程，分两种（一种是会话不在的，另一种是会话标记为killed的但是会话还在的）" class="headerlink" title="查看僵死进程，分两种（一种是会话不在的，另一种是会话标记为killed的但是会话还在的）"></a>查看僵死进程，分两种（一种是会话不在的，另一种是会话标记为killed的但是会话还在的）</h4><p><code>alter system kill session</code>一执行则<code>session</code>即标记为<code>KILLED</code>，但是如果会话产生的数据量大则这个kill可能会比较久，在这个过程中session标记为KILLED但是这个会话还在<code>V$session</code>中，则<code>V$session.paddr</code>还在，所以可以匹配到<code>V$process.addr</code>，所以process进程还在；当kill过程执行完毕，则这个会话即不在<code>V$session</code>中</p><h5 id="会话不在的"><a href="#会话不在的" class="headerlink" title="会话不在的"></a>会话不在的</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM v<span class="variable">$process</span></span><br><span class="line">WHERE addr NOT IN </span><br><span class="line">    (SELECT paddr</span><br><span class="line">    FROM v<span class="variable">$session</span>)</span><br><span class="line">        AND pid NOT IN (1,17,18)</span><br></pre></td></tr></tbody></table></figure><h5 id="会话还在的，但是会话标记为killed"><a href="#会话还在的，但是会话标记为killed" class="headerlink" title="会话还在的，但是会话标记为killed"></a>会话还在的，但是会话标记为killed</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM v<span class="variable">$process</span></span><br><span class="line">WHERE addr IN </span><br><span class="line">    (SELECT paddr</span><br><span class="line">    FROM v<span class="variable">$session</span></span><br><span class="line">    WHERE status=<span class="string">'KILLED'</span>)</span><br></pre></td></tr></tbody></table></figure><p>再根据上述结果中的SPID通过如下命令可以查看到process的启动时间<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|head -1;ps auxw|grep SPID</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查看行迁移或行链接的表"><a href="#查看行迁移或行链接的表" class="headerlink" title="查看行迁移或行链接的表"></a>查看行迁移或行链接的表</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_tables</span><br><span class="line">WHERE nvl(chain_cnt,0)<>0 chain_cnt ：Number of rows IN the table that are chained</span><br><span class="line">FROM one data block to another</span><br><span class="line">        OR that have migrated to a new block, requiring a link to preserve the old rowid. This column is updated only after you analyze the table.</span><br></pre></td></tr></tbody></table></figure><h4 id="数据缓冲区命中率（百分比小于90就要加大db-cache-size）"><a href="#数据缓冲区命中率（百分比小于90就要加大db-cache-size）" class="headerlink" title="数据缓冲区命中率（百分比小于90就要加大db_cache_size）"></a>数据缓冲区命中率（百分比小于90就要加大db_cache_size）</h4><h5 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.VALUE+b.VALUE logical_reads,</span><br><span class="line">         c.VALUE phys_reads,</span><br><span class="line">         round(100*(1-c.value/(a.value+b.value)),</span><br><span class="line">        2)||<span class="string">'%'</span> hit_ratio</span><br><span class="line">FROM v<span class="variable">$sysstat</span> a,v<span class="variable">$sysstat</span> b,v<span class="variable">$sysstat</span> c</span><br><span class="line">WHERE a.NAME=<span class="string">'db block gets'</span></span><br><span class="line">        AND b.NAME=<span class="string">'consistent gets'</span></span><br><span class="line">        AND c.NAME=<span class="string">'physical reads'</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DB_BLOCK_GETS+CONSISTENT_GETS Logical_reads,</span><br><span class="line">        PHYSICAL_READS phys_reads,</span><br><span class="line">         round(100*(1-(PHYSICAL_READS/(DB_BLOCK_GETS+CONSISTENT_GETS))),</span><br><span class="line">        2)||<span class="string">'%'</span> <span class="string">"Hit Ratio"</span></span><br><span class="line">FROM V<span class="variable">$BUFFER_POOL_STATISTICS</span></span><br><span class="line">WHERE NAME=<span class="string">'DEFAULT'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="共享池命中率（百分比小于90就要加大shared-pool-size）"><a href="#共享池命中率（百分比小于90就要加大shared-pool-size）" class="headerlink" title="共享池命中率（百分比小于90就要加大shared_pool_size）"></a>共享池命中率（百分比小于90就要加大shared_pool_size）</h4><p>以下两者可以根据个人理解运用<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT sum(pinhits)/sum(pins)*100</span><br><span class="line">FROM v<span class="variable">$librarycache</span>;</span><br><span class="line"></span><br><span class="line">SELECT sum(pinhits-reloads)/sum(pins)*100</span><br><span class="line">FROM v<span class="variable">$librarycache</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查询归档日志切换频率"><a href="#查询归档日志切换频率" class="headerlink" title="查询归档日志切换频率"></a>查询归档日志切换频率</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SELECT sequence<span class="comment">#,</span></span><br><span class="line">        to_char(first_time,</span><br><span class="line">        <span class="string">'yyyymmdd_hh24:mi:ss'</span>) firsttime,round((first_time-lag(first_time) over(order by first_time))*24*60,2) minutes</span><br><span class="line">FROM v<span class="variable">$log_history</span></span><br><span class="line">WHERE first_time > sysdate - 3</span><br><span class="line">ORDER BY  first_time,</span><br><span class="line">        minutes; </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">SELECT sequence<span class="comment">#,</span></span><br><span class="line">        to_char(first_time,</span><br><span class="line">        <span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) First_time,First_change<span class="comment">#,switch_change#</span></span><br><span class="line">FROM v<span class="variable">$loghist</span></span><br><span class="line">WHERE first_time>sysdate-3</span><br><span class="line">ORDER BY  1;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">SELECT TO_CHAR(first_time,</span><br><span class="line">         <span class="string">'MM/DD'</span>) DAY, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'00'</span>, 1, 0)) H00, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'01'</span>, 1, 0)) H01, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'02'</span>, 1, 0)) H02, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'03'</span>, 1, 0)) H03, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'04'</span>, 1, 0)) H04, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'05'</span>, 1, 0)) H05, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'06'</span>, 1, 0)) H06, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'07'</span>, 1, 0)) H07, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'08'</span>, 1, 0)) H08, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'09'</span>, 1, 0)) H09, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'10'</span>, 1, 0)) H10, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'11'</span>, 1, 0)) H11, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'12'</span>, 1, 0)) H12, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'13'</span>, 1, 0)) H13, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'14'</span>, 1, 0)) H14, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'15'</span>, 1, 0)) H15, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'16'</span>, 1, 0)) H16, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'17'</span>, 1, 0)) H17, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'18'</span>, 1, 0)) H18, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'19'</span>, 1, 0)) H19, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'20'</span>, 1, 0)) H20, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'21'</span>, 1, 0)) H21, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'22'</span>, 1, 0)) H22, SUM(DECODE(TO_CHAR(first_time, <span class="string">'HH24'</span>), <span class="string">'23'</span>, 1, 0)) H23, COUNT(*) TOTAL</span><br><span class="line">FROM </span><br><span class="line">    (SELECT ROWNUM RN,</span><br><span class="line">         FIRST_TIME</span><br><span class="line">    FROM V<span class="variable">$LOG_HISTORY</span></span><br><span class="line">    WHERE first_time>sysdate-18</span><br><span class="line">            AND FIRST_TIME>ADD_MONTHS(SYSDATE,-1)</span><br><span class="line">    ORDER BY  FIRST_TIME)</span><br><span class="line">GROUP BY  TO_CHAR(first_time, <span class="string">'MM/DD'</span>)</span><br><span class="line">ORDER BY  MIN(RN);</span><br></pre></td></tr></tbody></table></figure><h4 id="查询lgwr进程写日志时每执行一次lgwr需要多少秒，在state是waiting的情况下，某个等待编号seq-下，seconds-in-wait达多少秒，就是lgwr进程写一次IO需要多少秒"><a href="#查询lgwr进程写日志时每执行一次lgwr需要多少秒，在state是waiting的情况下，某个等待编号seq-下，seconds-in-wait达多少秒，就是lgwr进程写一次IO需要多少秒" class="headerlink" title="查询lgwr进程写日志时每执行一次lgwr需要多少秒，在state是waiting的情况下，某个等待编号seq#下，seconds_in_wait达多少秒，就是lgwr进程写一次IO需要多少秒"></a>查询lgwr进程写日志时每执行一次lgwr需要多少秒，在state是waiting的情况下，某个等待编号seq#下，seconds_in_wait达多少秒，就是lgwr进程写一次IO需要多少秒</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT event,</span><br><span class="line">        state,</span><br><span class="line">        seq<span class="comment">#,</span></span><br><span class="line">        seconds_in_wait,</span><br><span class="line">        program</span><br><span class="line">FROM v<span class="variable">$session</span></span><br><span class="line">WHERE program LIKE <span class="string">'%LGWR%'</span></span><br><span class="line">        AND state=<span class="string">'WAITING'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查询没有索引的表"><a href="#查询没有索引的表" class="headerlink" title="查询没有索引的表"></a>查询没有索引的表</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT table_name</span><br><span class="line">FROM user_tables</span><br><span class="line">WHERE table_name NOT IN </span><br><span class="line">    (SELECT table_name</span><br><span class="line">    FROM user_indexes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT table_name</span><br><span class="line">FROM user_tables</span><br><span class="line">WHERE table_name NOT IN </span><br><span class="line">    (SELECT table_name</span><br><span class="line">    FROM user_ind_columns)</span><br></pre></td></tr></tbody></table></figure><h4 id="查询一个AWR周期内的平均session数、OS平均负载、平均db-time、平均每秒多少事务"><a href="#查询一个AWR周期内的平均session数、OS平均负载、平均db-time、平均每秒多少事务" class="headerlink" title="查询一个AWR周期内的平均session数、OS平均负载、平均db time、平均每秒多少事务"></a>查询一个AWR周期内的平均session数、OS平均负载、平均db time、平均每秒多少事务</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT to_char(max(BEGIN_TIME),</span><br><span class="line">        <span class="string">'yyyy-mm-dd hh24:mi'</span>)||to_char(max(end_time),<span class="string">'* hh24:mi'</span>) time, snap_id, trunc(sum(<span class="keyword">case</span> metric_name</span><br><span class="line">    WHEN <span class="string">'Session Count'</span> THEN</span><br><span class="line">    average end),2) sessions, trunc(sum(<span class="keyword">case</span> metric_name</span><br><span class="line">    WHEN <span class="string">'Current OS Load'</span> THEN</span><br><span class="line">    average end),2) OS_LOAD, (trunc(sum(<span class="keyword">case</span> metric_name</span><br><span class="line">    WHEN <span class="string">'Database Time Per Sec'</span> THEN</span><br><span class="line">    average end),2)/100)*(ceil((max(end_time)-max(BEGIN_TIME))*24*60*60)) Database_Time_second, trunc(sum(<span class="keyword">case</span> metric_name</span><br><span class="line">    WHEN <span class="string">'User Transaction Per Sec'</span> THEN</span><br><span class="line">    average end),2) User_Transaction_Per_Sec</span><br><span class="line">FROM dba_hist_sysmetric_summary</span><br><span class="line">GROUP BY  snap_id</span><br><span class="line">ORDER BY  snap_id;</span><br></pre></td></tr></tbody></table></figure><ul><li>Database Time Per Sec对应值的单位是百分一秒/每秒 </li><li>(/100)<em>(ceil((max(end_time)-max(BEGIN_TIME))</em>24<em>60</em>60))是代表每个snap周期内的总秒数，oracle 两个时间相减默认的是天数,<em>24</em>60*60 为相差的秒数 </li><li>这个SQL查到的DB TIME比较准确，和awr上面的db time比较一致 </li></ul><h4 id="查询产生热块较多的对象"><a href="#查询产生热块较多的对象" class="headerlink" title="查询产生热块较多的对象"></a>查询产生热块较多的对象</h4><p>x$bh .tch(Touch)表示访问次数越高，热点快竞争问题就存在<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.owner,</span><br><span class="line">         e.segment_name,</span><br><span class="line">         e.segment_type</span><br><span class="line">FROM dba_extents e, </span><br><span class="line">    (SELECT *</span><br><span class="line">    FROM </span><br><span class="line">        (SELECT addr,</span><br><span class="line">        ts<span class="comment">#,</span></span><br><span class="line">        file<span class="comment">#,</span></span><br><span class="line">        dbarfil,</span><br><span class="line">        dbablk,</span><br><span class="line">        tch</span><br><span class="line">        FROM x<span class="variable">$bh</span></span><br><span class="line">        ORDER BY  tch DESC)</span><br><span class="line">        WHERE ROWNUM < 11) b</span><br><span class="line">    WHERE e.relative_fno = b.dbarfil</span><br><span class="line">        AND e.block_id <= b.dbablk</span><br><span class="line">        AND e.block_id + e.blocks > b.dbablk;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="手工创建快照的语句"><a href="#手工创建快照的语句" class="headerlink" title="手工创建快照的语句"></a>手工创建快照的语句</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> dbms_workload_repository.create_snapshot;</span><br></pre></td></tr></tbody></table></figure><h4 id="AWR设置每隔30分钟收集一次报告，保留14天的报告"><a href="#AWR设置每隔30分钟收集一次报告，保留14天的报告" class="headerlink" title="AWR设置每隔30分钟收集一次报告，保留14天的报告"></a>AWR设置每隔30分钟收集一次报告，保留14天的报告</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> DBMS_WORKLOAD_REPOSITORY.MODIFY_SNAPSHOT_SETTINGS(retention=>14*24*60, interval=>30); </span><br><span class="line"></span><br><span class="line">select * from dba_hist_wr_control;</span><br></pre></td></tr></tbody></table></figure><h4 id="AWR基线查看和创建"><a href="#AWR基线查看和创建" class="headerlink" title="AWR基线查看和创建"></a>AWR基线查看和创建</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from dba_hist_baseline; </span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> DBMS_WORKLOAD_REPOSITORY.CREATE_BASELINE(start_snap_id=>7550,end_snap_id=>7660,baseline_name=><span class="string">'am_baseline'</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="导出AWR报告的SQL语句"><a href="#导出AWR报告的SQL语句" class="headerlink" title="导出AWR报告的SQL语句"></a>导出AWR报告的SQL语句</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_hist_snapshot</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM table(dbms_workload_repository.awr_report_html(DBID, INSTANCE_NUMBER, startsnapid,endsnapid))</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM TABLE(DBMS_WORKLOAD_REPOSITORY.awr_diff_report_html(DBID, INSTANCE_NUMBER, startsnapid,endsnapid, DBID, INSTANCE_NUMBER, startsnapid,endsnapid));</span><br></pre></td></tr></tbody></table></figure><h4 id="导出最新ADDM的报告（需要sys用户）"><a href="#导出最新ADDM的报告（需要sys用户）" class="headerlink" title="导出最新ADDM的报告（需要sys用户）"></a>导出最新ADDM的报告（需要sys用户）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT dbms_advisor.get_task_report(task_name)</span><br><span class="line">FROM dba_advisor_tasks</span><br><span class="line">WHERE task_id =</span><br><span class="line">    (SELECT max(t.task_id)</span><br><span class="line">    FROM dba_advisor_tasks t, dba_advisor_log l</span><br><span class="line">    WHERE t.task_id=l.task_id</span><br><span class="line">            AND t.advisor_name=<span class="string">'ADDM'</span></span><br><span class="line">            AND l.status=<span class="string">'COMPLETED'</span> );SELECT task_id,</span><br><span class="line">        task_name,</span><br><span class="line">        description</span><br><span class="line">FROM dba_advisor_tasks</span><br><span class="line">ORDER BY  1 DESCSELECT dbms_advisor.get_task_report(task_name)</span><br><span class="line">FROM dba_advisor_tasks</span><br><span class="line">WHERE task_id =XX</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某个SQL的执行计划"><a href="#查询某个SQL的执行计划" class="headerlink" title="查询某个SQL的执行计划"></a>查询某个SQL的执行计划</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table(dbms_xplan.display_cursor(<span class="string">'sql_id'</span>,0,<span class="string">' advanced '</span>));</span><br></pre></td></tr></tbody></table></figure><p>上面的0表示<code>v$sql.child_number</code>为0，如果一个sql_id在v$sql中有多行说明有多个child_number，要看哪儿child_number的执行计划，就写哪个的值，比如要看child_number为2的执行计划，就把上面sql的0改为2 。</p><h4 id="官方文档对display-cursor这个函数的说明里面没有advanced这个参数值，只有BASIC、TYPICAL、ALL这几个，不过实践中发现advanced这个参数值显示的内容比这几个参数值显示的都多。"><a href="#官方文档对display-cursor这个函数的说明里面没有advanced这个参数值，只有BASIC、TYPICAL、ALL这几个，不过实践中发现advanced这个参数值显示的内容比这几个参数值显示的都多。" class="headerlink" title="官方文档对display_cursor这个函数的说明里面没有advanced这个参数值，只有BASIC、TYPICAL、ALL这几个，不过实践中发现advanced这个参数值显示的内容比这几个参数值显示的都多。"></a>官方文档对display_cursor这个函数的说明里面没有advanced这个参数值，只有BASIC、TYPICAL、ALL这几个，不过实践中发现advanced这个参数值显示的内容比这几个参数值显示的都多。</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table(xplan.display_cursor(<span class="string">'v$sql.sql_id'</span>,0,<span class="string">'advanced'</span>));</span><br></pre></td></tr></tbody></table></figure><h4 id="创建xplan包，再执行"><a href="#创建xplan包，再执行" class="headerlink" title="创建xplan包，再执行"></a>创建xplan包，再执行</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL> CREATE PUBLIC SYNONYM XPLAN FOR SYS.XPLAN; </span><br><span class="line">SQL> grant execute on sys.xplan to public;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询Rman的配置信息"><a href="#查询Rman的配置信息" class="headerlink" title="查询Rman的配置信息"></a>查询Rman的配置信息</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT NAME,</span><br><span class="line">        VALUE</span><br><span class="line">FROM V<span class="variable">$RMAN_CONFIGURATION</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询Rman备份集详细信息（未过期的，过期并已删除的查不到）"><a href="#查询Rman备份集详细信息（未过期的，过期并已删除的查不到）" class="headerlink" title="查询Rman备份集详细信息（未过期的，过期并已删除的查不到）"></a>查询Rman备份集详细信息（未过期的，过期并已删除的查不到）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT B.RECID BackupSet_ID,</span><br><span class="line">        </span><br><span class="line">         A.SET_STAMP,</span><br><span class="line">        </span><br><span class="line">         DECODE (B.INCREMENTAL_LEVEL,</span><br><span class="line">        </span><br><span class="line">         <span class="string">''</span>, DECODE (BACKUP_TYPE, <span class="string">'L'</span>, <span class="string">'Archivelog'</span>, <span class="string">'Full'</span>), 1, <span class="string">'Incr-1级'</span>, 0, <span class="string">'Incr-0级'</span>, B.INCREMENTAL_LEVEL) <span class="string">"Type LV"</span>, B.CONTROLFILE_INCLUDED <span class="string">"包含CTL"</span>, DECODE (A.STATUS, <span class="string">'A'</span>, <span class="string">'AVAILABLE'</span>, <span class="string">'D'</span>, <span class="string">'DELETED'</span>, <span class="string">'X'</span>, <span class="string">'EXPIRED'</span>, <span class="string">'ERROR'</span>) <span class="string">"STATUS"</span>, A.DEVICE_TYPE <span class="string">"Device Type"</span>, A.START_TIME <span class="string">"Start Time"</span>, A.COMPLETION_TIME <span class="string">"Completion Time"</span>, A.ELAPSED_SECONDS <span class="string">"Elapsed Seconds"</span>, A.BYTES/1024/1024/1024 <span class="string">"Size(G)"</span>, A.COMPRESSED, A.TAG <span class="string">"Tag"</span>, A.HANDLE <span class="string">"Path"</span></span><br><span class="line">FROM GV<span class="variable">$BACKUP_PIECE</span> A,</span><br><span class="line">         GV<span class="variable">$BACKUP_SET</span> B</span><br><span class="line">WHERE A.SET_STAMP = B.SET_STAMP</span><br><span class="line">        AND A.DELETED = <span class="string">'NO'</span></span><br><span class="line">ORDER BY  A.COMPLETION_TIME DESC;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询Rman备份进度"><a href="#查询Rman备份进度" class="headerlink" title="查询Rman备份进度"></a>查询Rman备份进度</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT SID,</span><br><span class="line">         SERIAL<span class="comment">#,</span></span><br><span class="line">         opname,</span><br><span class="line">        ROUND(SOFAR/TOTALWORK*100)||<span class="string">'%'</span> <span class="string">"%_COMPLETE"</span>, TRUNC(elapsed_seconds/60) || <span class="string">':'</span> || MOD(elapsed_seconds,60) elapsed, TRUNC(time_remaining/60) || <span class="string">':'</span> || MOD(time_remaining,60) remaining, CONTEXT,target,SOFAR, TOTALWORK</span><br><span class="line">FROM V<span class="variable">$SESSION_LONGOPS</span></span><br><span class="line">WHERE OPNAME LIKE <span class="string">'RMAN%'</span></span><br><span class="line">        AND OPNAME NOT LIKE <span class="string">'%aggregate%'</span></span><br><span class="line">        AND TOTALWORK != 0</span><br><span class="line">        AND SOFAR <> TOTALWORK;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询执行过全表扫描的sql语句的SQL-ID和sql-fulltext"><a href="#查询执行过全表扫描的sql语句的SQL-ID和sql-fulltext" class="headerlink" title="查询执行过全表扫描的sql语句的SQL_ID和sql_fulltext"></a>查询执行过全表扫描的sql语句的SQL_ID和sql_fulltext</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sid,</span><br><span class="line">        s.serial<span class="comment">#,</span></span><br><span class="line">        s.inst_id,</span><br><span class="line">        s.sql_id,</span><br><span class="line">        s.username,</span><br><span class="line">        s.target,</span><br><span class="line">        s.ELAPSED_SECONDS,</span><br><span class="line">        s.START_TIME,</span><br><span class="line">        s.LAST_UPDATE_TIME,</span><br><span class="line">        v.sql_fulltext</span><br><span class="line">FROM gv<span class="variable">$session_longops</span> s,gv<span class="variable">$sql</span> v</span><br><span class="line">WHERE s.OPNAME = <span class="string">'Table Scan'</span></span><br><span class="line">        AND s.SQL_PLAN_OPERATION = <span class="string">'TABLE ACCESS'</span></span><br><span class="line">        AND s.SQL_PLAN_OPTIONS = <span class="string">'FULL'</span></span><br><span class="line">        AND s.sql_id=v.sql_id</span><br><span class="line">ORDER BY  s.LAST_UPDATE_TIME DESC</span><br></pre></td></tr></tbody></table></figure><h4 id="查询死事务需要多长的回滚时间"><a href="#查询死事务需要多长的回滚时间" class="headerlink" title="查询死事务需要多长的回滚时间"></a>查询死事务需要多长的回滚时间</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="variable">$KTUXE</span>：[K]ernel [T]ransaction [U]ndo Transa[x]tion [E]ntry (table)`</span><br></pre></td></tr></tbody></table></figure><p><code>X$KTUXE</code>表的一个重要功能是，可以获得无法通过<code>v$transaction</code>来观察的死事务信息，当一个数据库发生异常中断，或者进行延迟事务恢复时，数据库启动后，无法通过V$TRANSACTION来观察事务信息，但是<code>X$KTUXE</code>可以帮助我们获得这些信息。该表中的KTUXECFL代表了事务的Flag标记，通过这个标记可以找到那些Dead事务：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL> select distinct KTUXECFL,count(*) from x<span class="variable">$ktuxe</span> group by KTUXECFL; </span><br><span class="line">    KTUXECFL                  COUNT(*) </span><br><span class="line">    ------------------------ ---------- </span><br><span class="line">    DEAD                              1 </span><br><span class="line">NONE                          2393</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="KTUXESIZ用来记录事务使用的回滚段块数，可以通过观察这个字段来评估恢复进度-例如如下事务回滚经过测算需要大约3小时"><a href="#KTUXESIZ用来记录事务使用的回滚段块数，可以通过观察这个字段来评估恢复进度-例如如下事务回滚经过测算需要大约3小时" class="headerlink" title="KTUXESIZ用来记录事务使用的回滚段块数，可以通过观察这个字段来评估恢复进度,例如如下事务回滚经过测算需要大约3小时"></a>KTUXESIZ用来记录事务使用的回滚段块数，可以通过观察这个字段来评估恢复进度,例如如下事务回滚经过测算需要大约3小时</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SQL> select ADDR,KTUXEUSN,KTUXESLT,KTUXESQN,KTUXESIZ from x<span class="variable">$ktuxe</span> <span class="built_in">where</span>  KTUXECFL =<span class="string">'DEAD'</span>; </span><br><span class="line">    ADDR              KTUXEUSN  KTUXESLT  KTUXESQN  KTUXESIZ </span><br><span class="line">    ---------------- ---------- ---------- ---------- ---------- </span><br><span class="line">FFFFFFFF7D07B91C        10        39    2567412    1086075 </span><br><span class="line"></span><br><span class="line">SQL> select ADDR,KTUXEUSN,KTUXESLT,KTUXESQN,KTUXESIZ from x<span class="variable">$ktuxe</span> <span class="built_in">where</span>  KTUXECFL =<span class="string">'DEAD'</span>; </span><br><span class="line">    ADDR              KTUXEUSN  KTUXESLT  KTUXESQN  KTUXESIZ </span><br><span class="line">    ---------------- ---------- ---------- ---------- ---------- </span><br><span class="line">    FFFFFFFF7D07B91C        10        39    2567412    1086067 </span><br><span class="line"></span><br><span class="line">SQL> <span class="built_in">declare</span> </span><br><span class="line">   l_start number; </span><br><span class="line">   l_end    number; </span><br><span class="line">   begin </span><br><span class="line">    select ktuxesiz into l_start from x<span class="variable">$ktuxe</span> <span class="built_in">where</span>  KTUXEUSN=10 and KTUXESLT=39; </span><br><span class="line">    dbms_lock.sleep(60); </span><br><span class="line">    select ktuxesiz into l_end from x<span class="variable">$ktuxe</span> <span class="built_in">where</span>  KTUXEUSN=10 and KTUXESLT=39; </span><br><span class="line">    dbms_output.put_line(<span class="string">'time_H:'</span>|| round(l_end/(l_start -l_end)/60,2)); </span><br><span class="line">  end; </span><br><span class="line">  / </span><br><span class="line"></span><br><span class="line">time_H:3</span><br></pre></td></tr></tbody></table></figure><h4 id="把XXX用户下面的某些YYY表赋权给user-XXX-YYY要大写"><a href="#把XXX用户下面的某些YYY表赋权给user-XXX-YYY要大写" class="headerlink" title="把XXX用户下面的某些YYY表赋权给user,XXX\YYY要大写"></a>把XXX用户下面的某些YYY表赋权给user,XXX\YYY要大写</h4><ul><li>XXX要大写<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> tablename varchar2(200);     </span><br><span class="line">    begin </span><br><span class="line">    <span class="keyword">for</span> x IN (SELECT * FROM dba_tables <span class="built_in">where</span> owner=<span class="string">'XXX'</span> and table_name like <span class="string">'%YYY%'</span>) loop   </span><br><span class="line">    tablename:=x.table_name; </span><br><span class="line">    dbms_output.put_line(<span class="string">'GRANT SELECT ON XXX.'</span>||tablename||<span class="string">' to user'</span>); </span><br><span class="line">    EXECUTE IMMEDIATE <span class="string">'GRANT SELECT ON XXX.'</span>||tablename||<span class="string">' TO user'</span>;  </span><br><span class="line">    end loop; </span><br><span class="line">end;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Oracle查出一个用户具有的所有系统权限和对象权限"><a href="#Oracle查出一个用户具有的所有系统权限和对象权限" class="headerlink" title="Oracle查出一个用户具有的所有系统权限和对象权限"></a>Oracle查出一个用户具有的所有系统权限和对象权限</h4><p>系统权限（和用户自己查询<code>select * from session_privs</code>的结果一致）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM DBA_SYS_PRIVS</span><br><span class="line">WHERE GRANTEE = <span class="string">'用户名'</span></span><br><span class="line">UNION</span><br><span class="line">ALLSELECT *</span><br><span class="line">FROM DBA_SYS_PRIVS</span><br><span class="line">WHERE GRANTEE IN </span><br><span class="line">    (SELECT GRANTED_ROLE</span><br><span class="line">    FROM DBA_ROLE_PRIVS</span><br><span class="line">    WHERE GRANTEE = <span class="string">'用户名'</span>);</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="对象权限（和用户自己查询select-FROM-TABLE-PRIVILEGES-where-GRANTEE-39-当前用户-39-的结果一致）"><a href="#对象权限（和用户自己查询select-FROM-TABLE-PRIVILEGES-where-GRANTEE-39-当前用户-39-的结果一致）" class="headerlink" title="对象权限（和用户自己查询select * FROM TABLE_PRIVILEGES where GRANTEE='当前用户'的结果一致）"></a>对象权限（和用户自己查询<code>select * FROM TABLE_PRIVILEGES where GRANTEE='当前用户'</code>的结果一致）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM DBA_TAB_PRIVS</span><br><span class="line">WHERE GRANTEE = <span class="string">'用户名'</span></span><br><span class="line">UNION</span><br><span class="line">ALLSELECT *</span><br><span class="line">FROM DBA_TAB_PRIVS</span><br><span class="line">WHERE GRANTEE IN </span><br><span class="line">    (SELECT GRANTED_ROLE</span><br><span class="line">    FROM DBA_ROLE_PRIVS</span><br><span class="line">    WHERE GRANTEE = <span class="string">'用户名'</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某个用户拥有的角色"><a href="#查询某个用户拥有的角色" class="headerlink" title="查询某个用户拥有的角色"></a>查询某个用户拥有的角色</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_role_privs</span><br><span class="line">WHERE GRANTEE=<span class="string">'用户名'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询拥有DBA角色权限的用户"><a href="#查询拥有DBA角色权限的用户" class="headerlink" title="查询拥有DBA角色权限的用户"></a>查询拥有DBA角色权限的用户</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_role_privs</span><br><span class="line">WHERE GRANTED_ROLE=<span class="string">'DBA'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某个角色拥有的系统权限"><a href="#查询某个角色拥有的系统权限" class="headerlink" title="查询某个角色拥有的系统权限"></a>查询某个角色拥有的系统权限</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM ROLE_SYS_PRIVS</span><br><span class="line">WHERE role=<span class="string">'角色名'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="清除某个SQL的执行计划"><a href="#清除某个SQL的执行计划" class="headerlink" title="清除某个SQL的执行计划"></a>清除某个SQL的执行计划</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec DBMS_SHARED_POOL.PURGE(<span class="string">'v$sqlarea.ADDRESS,v$sqlarea.HASH_VALUE'</span>,<span class="string">'c'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="查询密码是否有过期限制，默认是180天，一般修改为unlimited"><a href="#查询密码是否有过期限制，默认是180天，一般修改为unlimited" class="headerlink" title="查询密码是否有过期限制，默认是180天，一般修改为unlimited"></a>查询密码是否有过期限制，默认是180天，一般修改为unlimited</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_profiles</span><br><span class="line">WHERE profile=<span class="string">'DEFAULT'</span></span><br><span class="line">        AND RESOURCE_NAME LIKE <span class="string">'PASSWORD%'</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED</span><br></pre></td></tr></tbody></table></figure><h4 id="查询和修改隐含参数（必须在sysdba权限下操作）"><a href="#查询和修改隐含参数（必须在sysdba权限下操作）" class="headerlink" title="查询和修改隐含参数（必须在sysdba权限下操作）"></a>查询和修改隐含参数（必须在sysdba权限下操作）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.ksppinm name,</span><br><span class="line">         b.ksppstvl value,</span><br><span class="line">         a.ksppdesc description</span><br><span class="line">FROM x<span class="variable">$ksppi</span> a, x<span class="variable">$ksppcv</span> b</span><br><span class="line">WHERE a.indx = b.indx</span><br><span class="line">        AND a.ksppinm LIKE <span class="string">'%_small_table_threshold%'</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">alter system <span class="built_in">set</span> <span class="string">"_small_table_threshold"</span>=value scope=both sid=<span class="string">'*'</span>;</span><br></pre></td></tr></tbody></table></figure><p>不加sid则说明在默认在RAC的所有实例中修改 </p><p>需要注意的是一定要加上双引号, 另外引号内不能有空格, 只能包含参数的名字 </p><h4 id="评估SGA该设置多少"><a href="#评估SGA该设置多少" class="headerlink" title="评估SGA该设置多少"></a>评估SGA该设置多少</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT SGA_SIZE</span><br><span class="line">FROM </span><br><span class="line">    (SELECT *</span><br><span class="line">    FROM V<span class="variable">$SGA_TARGET_ADVICE</span></span><br><span class="line">    WHERE ESTD_DB_TIME_FACTOR=1</span><br><span class="line">    ORDER BY  1)</span><br><span class="line">WHERE rownum=1;</span><br></pre></td></tr></tbody></table></figure><h4 id="查看shared-pool还剩多少"><a href="#查看shared-pool还剩多少" class="headerlink" title="查看shared pool还剩多少"></a>查看shared pool还剩多少</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM v<span class="variable">$sgastat</span></span><br><span class="line">WHERE name=<span class="string">'free memory'</span></span><br><span class="line">        AND pool=<span class="string">'shared pool'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="统计所有表的容量大小-含分区字段、LOB字段"><a href="#统计所有表的容量大小-含分区字段、LOB字段" class="headerlink" title="统计所有表的容量大小(含分区字段、LOB字段)"></a>统计所有表的容量大小(含分区字段、LOB字段)</h4><p>一般先执行<code>select distinct SEGMENT_TYPE from dba_segments where owner<>'SYS' and tablespace_name<>'SYSAUX'</code>查看到所有的<code>segment_type</code><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">SELECT owner,</span><br><span class="line">        table_name,</span><br><span class="line">         TRUNC(sum(bytes)/1024/1024) Meg</span><br><span class="line">FROM </span><br><span class="line">    (SELECT segment_name table_name,</span><br><span class="line">         owner,</span><br><span class="line">         bytes</span><br><span class="line">    FROM dba_segments</span><br><span class="line">    WHERE segment_type = <span class="string">'TABLE'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT s.segment_name table_name,</span><br><span class="line">         pt.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_segments s, dba_part_tables pt</span><br><span class="line">    WHERE s.segment_name = pt.table_name</span><br><span class="line">            AND s.owner = pt.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'TABLE PARTITION'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT i.table_name,</span><br><span class="line">         i.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_indexes i, dba_segments s</span><br><span class="line">    WHERE s.segment_name = i.index_name</span><br><span class="line">            AND s.owner = i.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'INDEX'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT pi.table_name,</span><br><span class="line">         pi.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_part_indexes pi, dba_segments s</span><br><span class="line">    WHERE s.segment_name = pi.index_name</span><br><span class="line">            AND s.owner = pi.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'INDEX PARTITION'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT l.table_name,</span><br><span class="line">         l.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_lobs l, dba_segments s</span><br><span class="line">    WHERE s.segment_name = l.segment_name</span><br><span class="line">            AND s.owner = l.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'LOBSEGMENT'</span></span><br><span class="line">    UNION</span><br><span class="line">    ALLSELECT l.table_name,</span><br><span class="line">         l.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_lobs l, dba_segments s</span><br><span class="line">    WHERE s.segment_name = l.index_name</span><br><span class="line">            AND s.owner = l.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'LOBINDEX'</span></span><br><span class="line">    UNION</span><br><span class="line">    allSELECT l.table_name,</span><br><span class="line">         l.owner,</span><br><span class="line">         s.bytes</span><br><span class="line">    FROM dba_lobs l, dba_segments s</span><br><span class="line">    WHERE s.segment_name = l.segment_name</span><br><span class="line">            AND s.owner = l.owner</span><br><span class="line">            AND s.segment_type = <span class="string">'LOB PARTITION'</span> )</span><br><span class="line">GROUP BY  owner,table_name</span><br><span class="line">HAVING SUM(bytes)/1024/1024 > 10</span><br><span class="line">ORDER BY  SUM(bytes) DESC</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="查看当前会话的SID"><a href="#查看当前会话的SID" class="headerlink" title="查看当前会话的SID"></a>查看当前会话的SID</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM V<span class="variable">$MYSTAT</span></span><br><span class="line">WHERE rownum<2</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某个SID的某个统计信息，比如consistent-gets一致性读"><a href="#查询某个SID的某个统计信息，比如consistent-gets一致性读" class="headerlink" title="查询某个SID的某个统计信息，比如consistent gets一致性读"></a>查询某个SID的某个统计信息，比如consistent gets一致性读</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.SID,</span><br><span class="line">        A.STATISTIC<span class="comment">#,</span></span><br><span class="line">        A.VALUE SID_VALUE,</span><br><span class="line">        B.NAME,</span><br><span class="line">        B.VALUE ALL_SID_VALUE</span><br><span class="line">FROM V<span class="variable">$SESSTAT</span> A ,V<span class="variable">$SYSSTAT</span> B</span><br><span class="line">WHERE A.STATISTIC<span class="comment">#=B.STATISTIC#</span></span><br><span class="line">        AND A.SID=1187</span><br><span class="line">        AND B.NAME=<span class="string">'consistent gets'</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>V$SYSSTAT</code>统计整个DB的统计信息，<code>V$SYSSTAT</code>已经取代了<code>V$STATNAME</code>，并且多了VALUE这一列 <code>V$SESSTAT</code>统计每个用户的统计信息 </li></ul><h4 id="查询某个SID的某个等待事件的信息，比如log-file-sync"><a href="#查询某个SID的某个等待事件的信息，比如log-file-sync" class="headerlink" title="查询某个SID的某个等待事件的信息，比如log file sync"></a>查询某个SID的某个等待事件的信息，比如log file sync</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.SID,</span><br><span class="line">        A.EVENT,</span><br><span class="line">        C.NAME,</span><br><span class="line">        C.PARAMETER1,</span><br><span class="line">        C.PARAMETER2,</span><br><span class="line">        C.PARAMETER3,</span><br><span class="line">         A.TIME_WAITED SID_TIMEWAITED,</span><br><span class="line">        B.TIME_WAITED ALL_SID_TIMEWAITED,</span><br><span class="line">        A.TOTAL_WAITS SID_TOTALWAITS,</span><br><span class="line">        B.TOTAL_WAITS ALL_SID_TOTALWAITS</span><br><span class="line">FROM V<span class="variable">$SESSION_EVENT</span> A ,V<span class="variable">$SYSTEM_EVENT</span> B,V<span class="variable">$EVENT_NAME</span> C</span><br><span class="line">WHERE A.EVENT=B.EVENT</span><br><span class="line">        AND A.EVENT=C.NAME</span><br><span class="line">        AND A.SID=1</span><br><span class="line">        AND C.NAME=<span class="string">'log file sync'</span> V<span class="variable">$SESSION_EVENT</span>描述每个用户的等待事件信息 V<span class="variable">$SYSTEM_EVENT</span>描述整个DB等待事件信息 V<span class="variable">$EVENT_NAME</span>描述等待事件信本身的信息(比如V<span class="variable">$ACTIVE_SESSION_HISTORY</span>的P1TEXT、P2TEXT、P2TEXT匹配V<span class="variable">$EVENT_NAME</span>的PARAMETER1、PARAMETER2、PARAMETER3)</span><br></pre></td></tr></tbody></table></figure><h4 id="RAC跨节点杀会话"><a href="#RAC跨节点杀会话" class="headerlink" title="RAC跨节点杀会话"></a>RAC跨节点杀会话</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter system <span class="built_in">kill</span> session <span class="string">'SID,serial#,@1'</span>  --杀掉1节点的进程 </span><br><span class="line">alter system <span class="built_in">kill</span> session <span class="string">'SID,serial#,@2'</span>  --杀掉2节点的进程</span><br></pre></td></tr></tbody></table></figure><h4 id="Truncate-分区的SQL"><a href="#Truncate-分区的SQL" class="headerlink" title="Truncate 分区的SQL"></a>Truncate 分区的SQL</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name TRUNCATE PARTITION p1 DROP STORAGE UPDATE GLOBAL INDEXES;</span><br></pre></td></tr></tbody></table></figure><h4 id="Drop分区的SQL"><a href="#Drop分区的SQL" class="headerlink" title="Drop分区的SQL"></a>Drop分区的SQL</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP PARTITION p1 UPDATE GLOBAL INDEXES;</span><br></pre></td></tr></tbody></table></figure><h4 id="DATAGUARD主备延迟多少时间的查询方法"><a href="#DATAGUARD主备延迟多少时间的查询方法" class="headerlink" title="DATAGUARD主备延迟多少时间的查询方法"></a>DATAGUARD主备延迟多少时间的查询方法</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">备 库sqlplus></span><br><span class="line">SELECT value</span><br><span class="line">FROM v<span class="variable">$dataguard_stats</span></span><br><span class="line">WHERE name=<span class="string">'apply lag'</span> </span><br><span class="line">或 </span><br><span class="line">备库sqlplus></span><br><span class="line">SELECT ceil((sysdate-next_time)*24*60) <span class="string">"M"</span></span><br><span class="line">FROM v<span class="variable">$archived_log</span></span><br><span class="line">WHERE applied=<span class="string">'YES'</span></span><br><span class="line">        AND SEQUENCE<span class="comment">#=</span></span><br><span class="line">    (SELECT MAX(SEQUENCE<span class="comment">#)</span></span><br><span class="line">    FROM V<span class="variable">$ARCHIVED_LOG</span></span><br><span class="line">    WHERE applied=<span class="string">'YES'</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="查看某个包或存储过程是否正在被调用-如果如下有结果，则此时不能编译，否则会锁住"><a href="#查看某个包或存储过程是否正在被调用-如果如下有结果，则此时不能编译，否则会锁住" class="headerlink" title="查看某个包或存储过程是否正在被调用,如果如下有结果，则此时不能编译，否则会锁住"></a>查看某个包或存储过程是否正在被调用,如果如下有结果，则此时不能编译，否则会锁住</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM V<span class="variable">$DB_OBJECT_CACHE</span></span><br><span class="line">WHERE pin>0</span><br><span class="line">        AND name=upper(<span class="string">'XX'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="查询数据库打补丁的记录"><a href="#查询数据库打补丁的记录" class="headerlink" title="查询数据库打补丁的记录"></a>查询数据库打补丁的记录</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM dba_registry_history;</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某表的索引字段的distinct行数和CLUSTERING-FACTOR信息"><a href="#查询某表的索引字段的distinct行数和CLUSTERING-FACTOR信息" class="headerlink" title="查询某表的索引字段的distinct行数和CLUSTERING_FACTOR信息"></a>查询某表的索引字段的distinct行数和CLUSTERING_FACTOR信息</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.table_name,</span><br><span class="line">        a.index_name,</span><br><span class="line">        b.COLUMN_NAME,</span><br><span class="line">        a.blevel,</span><br><span class="line">        a.distinct_keys,</span><br><span class="line">        A.CLUSTERING_FACTOR,</span><br><span class="line">        A.NUM_ROWS,</span><br><span class="line">        trunc((a.distinct_keys/A.NUM_ROWS),</span><br><span class="line">        2)*100||<span class="string">'%'</span> <span class="string">"distinct%"</span>,trunc((a.CLUSTERING_FACTOR/A.NUM_ROWS),2)*100||<span class="string">'%'</span> <span class="string">"CLUSTERING_FACTOR%"</span></span><br><span class="line">FROM DBA_IND_STATISTICS a,DBA_IND_COLUMNS b</span><br><span class="line">WHERE a.table_name=<span class="string">'XX'</span></span><br><span class="line">        AND a.INDEX_NAME=b.index_name</span><br><span class="line">ORDER BY  5 desc</span><br></pre></td></tr></tbody></table></figure><h4 id="查询某表的所有字段的distinct行数"><a href="#查询某表的所有字段的distinct行数" class="headerlink" title="查询某表的所有字段的distinct行数"></a>查询某表的所有字段的distinct行数</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.table_name,</span><br><span class="line">        b.num_rows,</span><br><span class="line">        a.column_name,</span><br><span class="line">        a.data_type,</span><br><span class="line">        a.data_length,</span><br><span class="line">        a.num_distinct,</span><br><span class="line">        trunc((a.num_distinct/b.num_rows),</span><br><span class="line">        2)*100||<span class="string">'%'</span></span><br><span class="line">FROM dba_TAB_COLS a,dba_tables b</span><br><span class="line">WHERE a.table_name=<span class="string">'XX'</span></span><br><span class="line">        AND a.table_name=b.table_name</span><br><span class="line">ORDER BY  6 DESC</span><br></pre></td></tr></tbody></table></figure><h4 id="查询5G以上空闲空间可以进行收缩的数据文件"><a href="#查询5G以上空闲空间可以进行收缩的数据文件" class="headerlink" title="查询5G以上空闲空间可以进行收缩的数据文件"></a>查询5G以上空闲空间可以进行收缩的数据文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="string">'alter database datafile '</span><span class="string">''</span> || a.file_name || <span class="string">''</span><span class="string">' resize '</span> || round(a.filesize -(a.filesize - c.hwmsize) * 0.8) || <span class="string">'M;'</span>, a.filesize || <span class="string">'M'</span> AS <span class="string">"数据文件的总大小"</span>, c.hwmsize || <span class="string">'M'</span> AS <span class="string">"数据文件的实用大小"</span></span><br><span class="line">FROM </span><br><span class="line">    (SELECT file_id,</span><br><span class="line">         file_name,</span><br><span class="line">         round(bytes / 1024 / 1024) AS filesize</span><br><span class="line">    FROM dba_data_files) a, </span><br><span class="line">    (SELECT file_id,</span><br><span class="line">         round(max(block_id) * 8 / 1024) AS HWMsize</span><br><span class="line">    FROM dba_extents</span><br><span class="line">    GROUP BY  file_id) c</span><br><span class="line">WHERE a.file_id = c.file_id</span><br><span class="line">        AND a.filesize - c.hwmsize > 5000;</span><br></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>廖学强,<a href="http://blog.itpub.net/30126024/viewspace-2057474/" target="_blank" rel="noopener">DBA日常维护SQL脚本</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库拆分</title>
      <link href="/2019/04/24/databaseSplitting/"/>
      <url>/2019/04/24/databaseSplitting/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="aaaa.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>童话里灰姑娘都很穷，但都很漂亮，你漂亮吗？</strong></p></blockquote><h2 id="数据库水平垂直拆分"><a href="#数据库水平垂直拆分" class="headerlink" title="数据库水平垂直拆分"></a>数据库水平垂直拆分</h2><p>当数据库量非常大的时候，DB 已经成为系统瓶颈时就可以考虑进行水平垂直拆分了。</p><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>一般水平拆分是根据表中的某一字段(通常是主键 ID )取模处理，将一张表的数据拆分到多个表中。这样每张表的表结构是相同的但是数据不同。</p><p>不但可以通过 ID 取模分表还可以通过时间分表，比如每月生成一张表。<br>按照范围分表也是可行的:一张表只存储 <code>0~1000W</code>的数据，超过只就进行分表，这样分表的优点是扩展灵活，但是存在热点数据。</p><p>按照取模分表拆分之后我们的查询、修改、删除也都是取模。比如新增一条数据的时候往往需要一张临时表来生成 ID,然后根据生成的 ID 取模计算出需要写入的是哪张表(也可以使用<a href="https://jiemin.wang/2019/04/24/Distributed-ID-Generation/">分布式 ID 生成器</a>来生成 ID)。</p><p>分表之后不能避免的就是查询要比以前复杂，通常不建议 <code>join</code> ，一般的做法是做两次查询。</p><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p>当一张表的字段过多时则可以考虑垂直拆分。<br>通常是将一张表的字段才分为主表以及扩展表，使用频次较高的字段在一张表，其余的在一张表。</p><p>这里的多表查询也不建议使用 <code>join</code> ，依然建议使用两次查询。</p><h2 id="拆分之后带来的问题"><a href="#拆分之后带来的问题" class="headerlink" title="拆分之后带来的问题"></a>拆分之后带来的问题</h2><p>拆分之后由一张表变为了多张表，一个库变为了多个库。最突出的一个问题就是事务如何保证。</p><h3 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h3><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>如果业务对强一致性要求不是那么高那么最终一致性则是一种比较好的方案。</p><p>通常的做法就是补偿，比如 一个业务是 A 调用 B，两个执行成功才算最终成功，当 A 成功之后，B 执行失败如何来通知 A 呢。</p><p>比较常见的做法是 失败时 B 通过 MQ 将消息告诉 A，A 再来进行回滚。这种的前提是 A 的回滚操作得是幂等的，不然 B 重复发消息就会出现问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式 ID 生成策略</title>
      <link href="/2019/04/24/Distributed-ID-Generation/"/>
      <url>/2019/04/24/Distributed-ID-Generation/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="images.png" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>胸小的姑娘一般脾气都特大，胸大的姑娘一般脾气都特好，因为古语有云：穷凶极恶有容乃大！</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于系统中的一组数据而言，必不可少地对应有唯一标识。简单的单体应用可以使用数据库的自增 ID 作为唯一标识。而在复杂的分布式系统中，就需要一些特定的策略去生成对应的分布式 ID。</p><p>常见的项目中 ID 会有以下两个特点：</p><ol><li>全局唯一性。</li><li>趋势递增（对于使用 MySQL 的项目而言）。</li><li><blockquote><p>因为一般 ID 会作为数据库的主键存储，而在 MySQL InnoDB 中使用的是聚簇索引，使用有序的 ID 可以保证写入性能。</p></blockquote></li></ol><p>一般在分布式系统中，会有一个单独的服务来生成 ID。而这个服务则需要保证高可用性、高QPS 与安全性。另外生成的 ID 是不应该对外暴露的，如果非要对外展示，最好是无规则、不规律的编码。</p><h2 id="生成策略"><a href="#生成策略" class="headerlink" title="生成策略"></a>生成策略</h2><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>UUID (Universally Unique Identifier) 生成的是一个长度为 32 的 16 进制格式的字符串。UUID 有多个版本，各版本算法不同。但核心思想是一致的，基本上都是结合机器的网卡、当前时间、一个随机数来生成特定长度的字符串。</p><p>优点：性能好、高可扩展性：本地生成，无网络消耗，不需要考虑性能瓶颈。</p><p>缺点：</p><ul><li>无法保证趋势递增。</li><li>UUID 过长，如果需要在数据库存储，作为主键建立索引效率低。</li></ul><p>适用场景：不需要考虑空间占用，不需要生成有递增趋势，且不在 MySQL 中存储。</p><h4 id="Snowflake"><a href="#Snowflake" class="headerlink" title="Snowflake"></a>Snowflake</h4><p>snowflake 是 Twitter 开源的一个 ID 生成算法。<br><img src="/2019/04/24/Distributed-ID-Generation/640.webp" width="640"></p><ul><li>首位符号位：因为 ID 一般为正数，该值为 0。</li><li>41 位时间戳（毫秒级）：</li><li><blockquote><p>时间戳不是当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 起始时间戳（起始时间戳需要程序指定））理论上可以最多使用 <code>(1 << 41) / (1000x60x60x24x365) = 69年</code>。</p></blockquote></li><li><p>10 位数据机器位：包括 5 位数据标识位和 5 位机器标识位，也就是说最多可以部署节点数为：<code>1 << 10 = 1024</code>。</p></li><li>12 位毫秒内的序列：同一节点、同一时刻最多生成 ID 数 <code>1 << 12 = 4096</code>。</li></ul><p>最后生成结果为 64 位 Long 型数值。</p><p>优点</p><ul><li>趋势递增，且按照时间有序。</li><li>性能高、稳定性高、不依赖数据库等第三方系统。</li><li>可以按照自身业务特性灵活分配 bit 位。</li></ul><p>缺点</p><ul><li>依赖于机器时钟，时钟回拨会造成暂不可用或重复发号。<blockquote><p>在分布式系统中，每台机器上的时钟不可能完全同步。在同步各个服务器的时间时，有一定几率发生时钟回拨。</p></blockquote></li></ul><p>适用场景：要求高性能，可以不连续，数据类型为 long 型。</p><h4 id="Flicker"><a href="#Flicker" class="headerlink" title="Flicker"></a>Flicker</h4><p>Flicker 方案主要思路是设计单独的库表，利用数据库的自增 ID 来生成全局 ID。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ticket_center (  </span><br><span class="line">    id bigint(20) unsigned NOT NULL auto_increment,  </span><br><span class="line">    stub char(1) NOT NULL default <span class="string">''</span>,  </span><br><span class="line">    PRIMARY KEY (id),  </span><br><span class="line">    UNIQUE KEY unq_stub (stub)  </span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li><blockquote><p>stub: 票根，对应需要生成 Id 的业务方编码，可以是项目名、表名甚至是服务器 IP 地址。</p></blockquote></li><li><blockquote><p>MyISAM：默认表类型，基于传统的 ISAM 类型。ISAM是 Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键。如果执行大量的 select，MySql 存储引擎选用 MyISAM 比较适合。</p></blockquote></li></ul><p>可以使用下面的SQL 获取 ID:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO ticket_center (stub) VALUES (<span class="string">'test'</span>);  </span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p><code>Replace into</code> 先尝试插入数据到表中，如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据， 否则直接插入新数据</p></blockquote><p>为了解决单点故障问题：Flicker 方案启用了两台数据库服务器来生成 ID，通过区分 auto_increment 的起始值和步长来生成奇偶数的 ID。（也可以根据情况部署多台服务器）</p><p>优点</p><p>充分利用了数据库自增 ID 机制，生成的 ID 有序递增。</p><p>缺点</p><p>依赖于数据库，可用性低</p><p>水平扩展困难：定义好了起始值、步长和机器台数之后，如果要添加机器就比较麻烦了。</p><p>适用场景：数据量不多，并发量不大。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>因为 Redis 中的所有命令都是单线程的，可以利用 Incrby命令来模拟 ID 的递增。并且可以通过使用集群来提升吞吐量。我们可以为不同的 Redis 节点设置不同的初始值并统一步长，这样就能利用 Redis 生成唯一且趋势递增的 ID 了。例如有 3 个 Redis 节点，分别设置初始值为 1、2、3 ，这时步长就应该定为 3 。这样每个节点不会生成重复的 ID。</p><blockquote><p>Incrby ：将 key 中储存的数字加上指定的增量值。这是一个 “INCR AND GET” 的原子操作, 业务方可以定义一个自己的 key 值，通过 INCR 命令来获取对应的 ID。</p></blockquote><p>优点：<br>不依赖数据库，且性能优于依赖数据库的 Flicker 方案。</p><p>缺点：</p><ul><li>扩展性低，Redis 集群需要设置好初始值与步长。</li><li>Reids 宕机可能会生成重复的Id。</li></ul><p>适用场景：Redis 集群高可用，并发量高。</p><h4 id="Leaf"><a href="#Leaf" class="headerlink" title="Leaf"></a>Leaf</h4><p>上面提到的这些常见的 ID 生成策略，有时并不能完全满足实际生产中的需求，在实际项目中会对其做一些改造和优化。</p><p>美团的 Leaf 分布式 ID 生成系统 ，在 Flicker 策略 与 Snowflake 算法的基础上做了两套优化的方案。下文会简单介绍一下 Leaf 方案做的一些优化，并不会深入分析。详细方案大家可以查看这里：《Leaf 分布式 ID 生成系统 》</p><p>Leaf-segment 数据库方案</p><p>相比于 Flicker 方案每次都需要读取数据库，Leaf-segment 改为了利用 proxy server 批量获取，且做了双 buffer 的优化。设计图如下：<br><img src="/2019/04/24/Distributed-ID-Generation/640_1.webp" title="640_1"></p><blockquote><p>双 buffer：ID 分号段加载，且当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。</p></blockquote><p>Leaf-snowflake 方案</p><p>主要是针对时钟回拨问题做了特殊处理。 若发生时钟回拨则拒绝发号，并进行告警。<br><img src="/2019/04/24/Distributed-ID-Generation/640_2.webp" title="640_2"></p><p>适用场景：服务规模较大，调用频繁。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于分布式 ID 的生成策略暂且介绍到这里。其实还有一些优秀的解决方案，比如百度的 uid-generator，微信的 SEQSVR。基本上都是都上面一些方案的优化，这里就不做详细介绍了。在实际使用中，需要根据自身业务场景来选取合适的方案，也并非大而全的方案就是好的方案。</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p>牛在舒，<a href="https://mp.weixin.qq.com/s/h8dphDS4D36nWyhPCLC7ag" target="_blank" rel="noopener">分布式 ID 生成策略</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 水平拆分表的一次踩坑</title>
      <link href="/2019/04/24/mysql-sharding/"/>
      <url>/2019/04/24/mysql-sharding/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="cbC80KVt.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>胸小的姑娘一般脾气都特大，胸大的姑娘一般脾气都特好，因为古语有云：穷凶极恶有容乃大！</strong></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前不少人问我”能否分享一些分库分表相关的实践”，其实不是我不分享，而是真的经验不多🤣；和大部分人一样都是停留在理论阶段。</p><p>不过这次多少有些可以说道了。</p><p>先谈谈背景，我们生产数据库随着业务发展量也逐渐起来；好几张单表已经突破<strong>亿级</strong>数据，并且保持每天 200+W 的数据量增加。</p><p>而我们有些业务需要进行关联查询、或者是报表统计；在这样的背景下大表的问题更加突出（比如一个查询功能需要跑好几分钟）。</p><a id="more"></a><blockquote><p>可能很多人会说：为啥单表都过亿了才想方案解决？其实不是不想，而是由于历史原因加上错误预估了数据增长才导致这个局面。总之原因比较复杂，也不是本次讨论的重点。</p></blockquote><h1 id="临时方案"><a href="#临时方案" class="headerlink" title="临时方案"></a>临时方案</h1><p>由于需求紧、人手缺的情况下，整个处理的过程分为几个阶段。</p><p>第一阶段应该是去年底，当时运维反应 <code>MySQL</code> 所在的主机内存占用很高，整体负载也居高不下，导致整个 MySQL 的吞吐量明显降低（写入、查询数据都明显减慢）。</p><p>为此我们找出了数据量最大的几张表，发现大部分数据量在7/8000W 左右，少数的已经突破一亿。</p><p>通过业务层面进行分析发现，这些数据多数都是用户产生的一些<strong>日志型数据</strong>，而且这些数据在业务上并不是强相关的，甚至两三个月前的数据其实已经不需要实时查询了。</p><p>因为接近年底，尽可能的不想去动应用，考虑是否可以在运维层面缓解压力；主要的目的就是把单表的数据量降低。</p><p>原本是想把两个月之前的数据直接迁移出来放到备份表中，但在准备实施的过程中发现一个大坑。</p><blockquote><p>表中没有一个可以排序的索引，导致我们无法快速的筛选出一部分数据！这真是一个深坑，为后面的一些优化埋了个地雷；即便是加索引也需要花几个小时（具体多久没敢在生产测试）。</p></blockquote><p>如果我们强行按照时间进行筛选，可能查询出 4000W 的数据就得花上好几个小时；这显然是行不通的。</p><p>于是我们便想到了一个大胆的想法：这部分数据是否可以直接不要了？</p><p>这可能是最有效及最快的方式了，和产品沟通后得知这部分数据真的只是日志型的数据，即便是报表出不来今后补上也是可以的。</p><p>于是我们就简单粗暴的做了以下事情：</p><ul><li>修改原有表的表名，比如加上(<code>_190416bak</code>)。</li><li>再新建一张和原有表名称相同的表。</li></ul><p>这样新的数据就写到了新表，同时业务上也是使用的这个数据量较小的新表。</p><p>虽说过程不太优雅，但至少是解决了问题同时也给我们做技术改造预留了时间。</p><h1 id="分表方案"><a href="#分表方案" class="headerlink" title="分表方案"></a>分表方案</h1><p>之前的方案虽说可以缓解压力，但不能根本解决问题。</p><p>有些业务必须得查询之前的数据，导致之前那招行不通了，所以正好我们就借助这个机会把表分了。</p><p>我相信大部分人虽说没有做过实际做过分表，但也见过猪跑；网上一搜各种方案层出不穷。</p><p>我认为最重要的一点是要结合实际业务找出需要 sharding 的字段，同时还有上线阶段的数据迁移也非常重要。</p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>可能大家都会说用 hash 的方式分配得最均匀，但我认为这还是需要使用历史数据的场景才用哈希分表。</p><p>而对于不需要历史数据的场景，比如业务上只查询近三个月的数据。</p><p>这类需求完成可以采取时间分表，按照月份进行划分，这样改动简单，同时对历史数据也比较好迁移。</p><p>于是我们首先将这类需求的表筛选出来，按照月份进行拆分，只是在查询的时候拼接好表名即可；也比较好理解。</p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>刚才也提到了：需要根据业务需求进行分表策略。</p><p>而一旦所有的数据都有可能查询时，按照时间分表也就行不通了。（也能做，只是如果不是按照时间进行查询时需要遍历所有的表）</p><p>因此我们计划采用 <code>hash</code> 的方式分表，这算是业界比较主流的方式就不再赘述。</p><p>采用哈希时需要将 <code>sharding</code> 字段选好，由于我们的业务比较单纯；是一个物联网应用，所有的数据都包含有物联网设备的唯一标识（IMEI），并且这个字段天然的就保持了唯一性；大多数的业务也都是根据这个字段来的，所以它非常适合来做这个 <code>sharding</code> 字段。</p><p>在做分表之前也调研过 <code>MyCAT</code> 及 <code>sharding-jdbc</code>(现已升级为 <code>shardingsphere</code>)，最终考虑到对开发的友好性及不增加运维复杂度还是决定在 jdbc 层 sharding 的方式。</p><p>但由于历史原因我们并不太好集成 <code>sharding-jdbc</code>，但基于 <code>sharding</code> 的特点自己实现了一个分表策略。</p><p>这个简单也好理解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = hash(sharding字段) % 分表数量 ;</span><br><span class="line"></span><br><span class="line">select xx from <span class="string">'busy_'</span>+index where sharding字段 = xxx;</span><br></pre></td></tr></tbody></table></figure><p>其实就是算出了表名，然后路由过去查询即可。</p><p>只是我们实现的非常简单：修改了所有的底层查询方法，每个方法都里都做了这样的一个判断。</p><p>并没有像 <code>sharding-jdbc</code> 一样，代理了数据库的查询方法；其中还要做 <code>SQL解析-->SQL路由-->执行SQL-->合并结果</code> 这一系列的流程。</p><p>如果自己再做一遍无异于重新造了一个轮子，并且并不专业，只是在现有的技术条件下选择了一个快速实现达成效果的方法。</p><p>不过这个过程中我们节省了将 sharding 字段哈希的过程，因为每一个 IMEI 号其实都是一个唯一的整型，直接用它做 mod 运算即可。</p><p>还有一个是需要一个统一的组件生成规则，分表后不能再依赖于单表的字段自增了；方法还是挺多的：</p><ul><li>比如时间戳+随机数可满足大部分业务。</li><li>UUID，生成简单，但没法做排序。</li><li>雪花算法统一生成主键ID。</li></ul><p>大家可以根据自己的实际情况做选择。</p><h1 id="业务调整"><a href="#业务调整" class="headerlink" title="业务调整"></a>业务调整</h1><p>因为我们并没有使用第三方的 sharding-jdbc 组件，所有没有办法做到对代码的低侵入性；每个涉及到分表的业务代码都需要做底层方法的改造（也就是路由到正确的表）。</p><p>考虑到后续业务的发展，我们决定将拆分的表分为 64 张；加上后续引入大数据平台足以应对几年的数据增长。</p><blockquote><p>这里还有个小细节需要注意：分表的数量需要为 2∧N 次方，因为在取模的这种分表方式下，即便是今后再需要分表影响的数据也会尽量的小。</p></blockquote><p>再修改时只能将表名称进行全局搜索，然后加以修改，同时根据修改的方法倒推到表现的业务并记录下来，方便后续回归测试。</p><hr><p>当然无法避免查询时利用非 sharding 字段导致的全表扫描，这是所有分片后都会遇到的问题。</p><p>因此我们在修改分表方法的底层查询时同时也会查看是否有走分片字段，如果不是，那是否可以调整业务。</p><p>比如对于一个上亿的数据是否还有必要存在按照分页查询、日期查询？这样的业务是否真的具有意义？</p><p>我们尽可能的引导产品按照这样的方式来设计产品或者做出调整。</p><p>但对于报表这类的需求确实也没办法，比如统计表中某种类型的数据；这种我们也可以利用多线程的方式去并行查询然后汇总统计来提高查询效率。</p><p>有时也有一些另类场景：</p><blockquote><p>比如一个千万表中有某一特殊类型的数据只占了很小一部分，比如说几千上万条。</p></blockquote><p>这时页面上需要对它进行分页查询是比较正常的（比如某种投诉消息，客户需要一条一条的单独处理），但如果我们按照 IMEI 号或者是主键进行分片后再分页查询那就比较蛋疼了。</p><p>所以这类型的数据建议单独新建一张表来维护，不要和其他数据混合在一起，这样不管是做分页还是 like 都比较简单和独立。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>代码改完，开发也单测完成后怎么来验证分表的业务是否正常也比较麻烦。</p><p>一个是测试麻烦，再一个是万一哪里改漏了还是查询的原表，但这样在测试环境并不会有异常，一旦上线产生了生产数据到新的 64 张表后想要再修复就比较麻烦了。</p><p>所以我们取了个巧，直接将原表的表名修改，比如加一个后缀；这样在测试过程中观察前后台有无报错就比较容易提前发现这个问题。</p><h1 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h1><p>测试验收通过后只是分表这个需求的80%，剩下如何上线也是比较头疼。</p><p>一旦应用上线后所有的查询、写入、删除都会先走路由然后到达新表；而老数据在原表里是不会发生改变的。</p><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>所以我们上线前的第一步自然是需要将原有的数据进行迁移，迁移的目的是要分片到新的 64 张表中，这样才会对原有的业务无影响。</p><p>因此我们需要额外准备一个程序，它需要将老表里的数据按照分片规则复制到新表中；</p><p>在我们这个场景下，生产数据有些已经上亿了，这个迁移过程我们在测试环境模拟发现耗时是非常久的。而且我们老表中对于 <code>create_time</code> 这样用于筛选数据的字段没有索引（以前的技术债），所以查询起来就更加慢了。</p><p>最后没办法，我们只能和产品协商告知用户对于之前产生的数据短期可能会查询不到，这个时间最坏可能会持续几天（我们只能在凌晨迁移，白天会影响到数据库负载）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这便是我们这次的分表实践，虽说不少过程都不优雅，但受限于条件也只能折中处理。</p><p>但我们后续的计划是，修改我们底层的数据连接（目前是自己封装的一个 jar 包，导致集成 sharding-jdbc 比较麻烦）最终逐渐迁移到 <code>sharding-jdbc</code> .</p><p>最后得出了几个结论：</p><ul><li>一个好的产品规划非常有必要，可以在合理的时间对数据处理（不管是分表还是切入归档）。</li><li>每张表都需要一个可以用于排序查询的字段（自增ID、创建时间），整个过程由于没有这个字段导致耽搁了很长时间。</li><li>分表字段需要谨慎，要全盘的考虑业务情况，尽量避免出现查询扫表的情况。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL5.7 GTID原理与实战</title>
      <link href="/2019/04/22/mysql-GTID/"/>
      <url>/2019/04/22/mysql-GTID/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="aaa.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>工作多年，当人家问你是不是初入社会，不是因为你看起来年轻，而是因为觉得你怎么这么笨。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="GTID是什么？"><a href="#GTID是什么？" class="headerlink" title="GTID是什么？"></a>GTID是什么？</h4><p>GTID 是<a href="https://dev.mysql.com/doc/refman/5.7/en/replication-gtids.html" target="_blank" rel="noopener">Global Transaction Identifiers</a>的缩写，简称GTID</p><h4 id="GTID组成和架构"><a href="#GTID组成和架构" class="headerlink" title="GTID组成和架构"></a>GTID组成和架构</h4><p>1) <code>GTID = source_id:transaction_id</code><br>2) server_uuid 来源于 auto.cnf<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3E11FA47-71CA-11E1-9E33-C80AA9429562</span><br></pre></td></tr></tbody></table></figure><p></p><p>3) GTID: 在一组复制中，全局唯一</p><p>The syntax for a GTID set is as follows:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gtid_set:</span><br><span class="line">    uuid_set [, uuid_set] ...</span><br><span class="line">    | <span class="string">''</span></span><br><span class="line"></span><br><span class="line">uuid_set:</span><br><span class="line">    uuid:interval[:interval]...</span><br><span class="line"></span><br><span class="line">uuid:</span><br><span class="line">    hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh</span><br><span class="line"></span><br><span class="line">h:</span><br><span class="line">    [0-9|A-F]</span><br><span class="line"></span><br><span class="line">interval:</span><br><span class="line">    n[-n]</span><br><span class="line"></span><br><span class="line">    (n >= 1)</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>mysql.gtid_executed表</code>的压缩由名为<code>thread</code>/<code>sql</code>/<code>compress_gtid_table</code>的专用前台线程执行。 此线程未在<code>SHOW PROCESSLIST</code>的输出中列出，但可以将其视为线程表中的一行，如下所示：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql> SELECT * FROM performance_schema.threads WHERE NAME LIKE <span class="string">'%gtid%'</span>\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          THREAD_ID: 26</span><br><span class="line">               NAME: thread/sql/compress_gtid_table</span><br><span class="line">               TYPE: FOREGROUND</span><br><span class="line">     PROCESSLIST_ID: 1</span><br><span class="line">   PROCESSLIST_USER: NULL</span><br><span class="line">   PROCESSLIST_HOST: NULL</span><br><span class="line">     PROCESSLIST_DB: NULL</span><br><span class="line">PROCESSLIST_COMMAND: Daemon</span><br><span class="line">   PROCESSLIST_TIME: 1509</span><br><span class="line">  PROCESSLIST_STATE: Suspending</span><br><span class="line">   PROCESSLIST_INFO: NULL</span><br><span class="line">   PARENT_THREAD_ID: 1</span><br><span class="line">               ROLE: NULL</span><br><span class="line">       INSTRUMENTED: YES</span><br><span class="line">            HISTORY: YES</span><br><span class="line">    CONNECTION_TYPE: NULL</span><br><span class="line">       THREAD_OS_ID: 18677</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="GTID和Binlog的关系"><a href="#GTID和Binlog的关系" class="headerlink" title="GTID和Binlog的关系"></a>GTID和Binlog的关系</h5><ul><li><p>GTID在binlog中的结构</p><img src="/2019/04/22/mysql-GTID/binlog_gtid.jpg" title="binlog_gtid"></li><li><p>GTID event 结构</p></li><li><p>Previous_gtid_log_event</p></li></ul><ol><li><code>Previous_gtid_log_event</code> 在每个binlog 头部都会有</li><li>每次<code>binlog rotate</code>的时候存储在binlog头部</li><li><code>Previous-GTIDs</code>在binlog中只会存储在这台机器上执行过的所有binlog，不包括手动设置<code>gtid_purged</code>值。</li><li>换句话说，如果你手动<code>set global gtid_purged=xx;</code> 那么xx是不会记录在<code>Previous_gtid_log_event</code>中的。</li></ol><ul><li>GTID和Binlog之间的关系是怎么对应的呢<br>  如何才能找到GTID=?对应的binlog文件呢？<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 假设有4个binlog: bin.001,bin.002,bin.003,bin.004</span><br><span class="line">* bin.001 : Previous-GTIDs=empty; binlog_event有：1-40  </span><br><span class="line">* bin.002 : Previous-GTIDs=1-40;  binlog_event有：41-80 </span><br><span class="line">* bin.003 : Previous-GTIDs=1-80;  binlog_event有：81-120  </span><br><span class="line">* bin.004 : Previous-GTIDs=1-120;  binlog_event有：121-160  </span><br><span class="line">    1. 假设现在我们要找GTID=<span class="variable">$A</span>，那么MySQL的扫描顺序为： 从最后一个binlog开始扫描（即：bin.004）      </span><br><span class="line">    2. bin.004的Previous-GTIDs=1-120，如果<span class="variable">$A</span>=140 > Previous-GTIDs,那么肯定在bin.004中  </span><br><span class="line">    3. bin.004的Previous-GTIDs=1-120，如果<span class="variable">$A</span>=88 包含在Previous-GTIDs中,那么继续对比上一个binlog文件 bin.003,然后再循环前面2个步骤，直到找到为止</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="重要参数的持久化"><a href="#重要参数的持久化" class="headerlink" title="重要参数的持久化"></a>重要参数的持久化</h5><ul><li>GTID相关参数</li></ul><table><thead><tr><th style="text-align:center">variables</th><th style="text-align:center">comment</th></tr></thead><tbody><tr><td style="text-align:center">gtid_executed</td><td style="text-align:center">执行过的所有GTID</td></tr><tr><td style="text-align:center">gtid_purged</td><td style="text-align:center">丢弃掉的GTID</td></tr><tr><td style="text-align:center">gtid_mode</td><td style="text-align:center">gtid模式</td></tr><tr><td style="text-align:center">gtid_next</td><td style="text-align:center">session级别的变量，下一个gtid</td></tr><tr><td style="text-align:center">gtid_owned</td><td style="text-align:center">正在运行的gtid</td></tr><tr><td style="text-align:center">enforce_gtid_consistency</td><td style="text-align:center">保证GTID安全的参数</td></tr></tbody></table><ul><li>重要参数如何持久化</li></ul><ol><li>如何持久化<code>gtid_executed</code> <code>[ log-bin=on,log_slave_update=on ]</code><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gtid_executed = mysql.gtid_executed <span class="comment">#[normal]</span></span><br><span class="line">or</span><br><span class="line">gtid_executed = mysql.gtid_executed + last_binlog 中最后没写到mysql.gtid_executed中的gtid_event  <span class="comment">#[recover]</span></span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li>如何持久化重置的gtid_purged值?<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reset master;</span><br><span class="line"><span class="built_in">set</span> global gtid_purged=<span class="string">'$A:a-b'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 由于有可能手动设置过gtid_purged=<span class="variable">$A</span>:a-b, binlog.index中，last_binlog的Previous-GTIDs并不会包含<span class="variable">$A</span>:a-b  </span><br><span class="line">2. 由于有可能手动设置过gtid_purged=<span class="variable">$A</span>:a-b, binlog.index中，first_binlog的Previous-GTIDs肯定不会出现<span class="variable">$A</span>:a-b  </span><br><span class="line">3. 重置的gtid_purged = @@global.gtid_executed(mysql.gtid_executed:注意，考虑到这个表的更新触发条件，所以这里用@@global.gtid_executed代替) - last_binlog的Previous-GTIDs  - last_binlog所有的gtid_event  </span><br><span class="line">4. 下面就用 <span class="variable">$reset_gtid_purged</span> 来表示重置的gtid</span><br></pre></td></tr></tbody></table></figure><ul><li>如何持久化<code>gtid_purged</code> <code>[ log-bin=on,log_slave_update=on ]</code><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gtid_purged=binlog.index:first_binlog的Previous-GTIDs  + <span class="variable">$reset_gtid_purged</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="开启GTID的必备条件"><a href="#开启GTID的必备条件" class="headerlink" title="开启GTID的必备条件"></a>开启GTID的必备条件</h5><ul><li><p>MySQL 5.6</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=ON                (必选)    </span><br><span class="line">log_bin=ON                  (必选)    </span><br><span class="line"><span class="built_in">log</span>-slave-updates=ON        (必选)    </span><br><span class="line">enforce-gtid-consistency    (必选)</span><br></pre></td></tr></tbody></table></figure></li><li><p>MySQL 5.7</p><blockquote><p>MySQL5.7.13 or higher</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=ON                (必选)  </span><br><span class="line">enforce-gtid-consistency    （必选）</span><br><span class="line">log_bin=ON                  （可选）--高可用切换，最好设置ON  </span><br><span class="line"><span class="built_in">log</span>-slave-updates=ON        （可选）--高可用切换，最好设置ON</span><br></pre></td></tr></tbody></table></figure></blockquote></li></ul><h5 id="新的复制协议-COM-BINLOG-DUMP-GTID"><a href="#新的复制协议-COM-BINLOG-DUMP-GTID" class="headerlink" title="新的复制协议 COM_BINLOG_DUMP_GTID"></a>新的复制协议 COM_BINLOG_DUMP_GTID</h5><ul><li><p>slave会将已经执行过的gtid，以及以及接受到relay log中的gtid的并集发送给master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* http://dev.mysql.com/doc/refman/5.7/en/change-master-to.html</span><br><span class="line">UNION(@@global.gtid_executed, Retrieved_gtid_set - last_received_GTID)</span><br></pre></td></tr></tbody></table></figure></li><li><p>Master send all other transactions to slave</p></li><li>同样的GTID不能被执行两次，如果有同样的GTID，会自动被skip掉。</li></ul><img src="/2019/04/22/mysql-GTID/com_binlog_dump_gtid.jpg" title="com_binlog_dump_gtid"><pre><code>- slave1 : 将自身的UUID1:1 发送给 master，然后接收到了 UUID1:2,UUID1:3 event- slave2 : 将自身的UUID1:1,UUID1:2 发送给 master，然后接收到了UUID1:3 event</code></pre><h5 id="GTID重要函数和新语法"><a href="#GTID重要函数和新语法" class="headerlink" title="GTID重要函数和新语法"></a>GTID重要函数和新语法</h5><ul><li>重要函数</li></ul><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">GTID_SUBSET(subset, set)</td><td style="text-align:center">returns true (1) if all GTIDs in subset are also in set</td></tr><tr><td style="text-align:center">GTID_SUBTRACT(set,subset)</td><td style="text-align:center">returns only those GTIDs from set that are not in subset</td></tr><tr><td style="text-align:center">WAIT_FOR_EXECUTED_GTID_SET(gtid_set[, timeout])</td><td style="text-align:center">Wait until the given GTIDs have executed on slave.</td></tr><tr><td style="text-align:center">WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(gtid_set[, timeout][,channel])</td><td style="text-align:center">Wait until the given GTIDs have executed on slave.</td></tr></tbody></table><ul><li><p>新语法</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">START SLAVE [thread_types] [until_option] [connection_options]</span><br><span class="line">thread_types:</span><br><span class="line">    [thread_type [, thread_type] ... ]</span><br><span class="line">thread_type: </span><br><span class="line">    IO_THREAD | SQL_THREAD</span><br><span class="line">until_option:</span><br><span class="line">    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = gtid_set</span><br><span class="line">          |   MASTER_LOG_FILE = <span class="string">'log_name'</span>, MASTER_LOG_POS = log_pos</span><br><span class="line">          |   RELAY_LOG_FILE = <span class="string">'log_name'</span>, RELAY_LOG_POS = log_pos</span><br><span class="line">          |   SQL_AFTER_MTS_GAPS  }</span><br></pre></td></tr></tbody></table></figure></li><li><p>举个栗子: </p></li></ul><ol><li><p>START SLAVE SQL_THREAD UNTIL SQL_BEFORE_GTIDS = 3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56   </p><blockquote><p>表示，当SQL_thread 执行到3E11FA47-71CA-11E1-9E33-C80AA9429562:10 的时候停止，下一个事务是11  </p></blockquote></li><li><p>START SLAVE SQL_THREAD UNTIL SQL_AFTER_GTIDS = 3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56  </p><blockquote><p>表示，当SQL_thread 执行到3E11FA47-71CA-11E1-9E33-C80AA9429562:56 的时候停止，56是最后一个提交的事务。</p></blockquote></li></ol><h4 id="GTID有什么好处"><a href="#GTID有什么好处" class="headerlink" title="GTID有什么好处"></a>GTID有什么好处</h4><h5 id="classic-replication-运维之伤"><a href="#classic-replication-运维之伤" class="headerlink" title="classic replication [运维之伤]"></a>classic replication [运维之伤]</h5><img src="/2019/04/22/mysql-GTID/classic_rpl.jpg" title="classic_rpl"><h5 id="GTID-replication-so-easy"><a href="#GTID-replication-so-easy" class="headerlink" title="GTID replication [so easy]"></a>GTID replication [so easy]</h5><img src="/2019/04/22/mysql-GTID/GTID_rpl.jpg" title="GTID_rpl"><h4 id="GTID的Limitation"><a href="#GTID的Limitation" class="headerlink" title="GTID的Limitation"></a>GTID的Limitation</h4><ul><li>不安全的事务<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置enforce-gtid-consistency=ON</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. CREATE TABLE ... SELECT statements  </span><br><span class="line">2. CREATE TEMPORARY TABLE or DROP TEMPORARY TABLE statements inside transactions</span><br><span class="line">3. 同时更新 事务引擎 和 非事务引擎。</span><br></pre></td></tr></tbody></table></figure><h4 id="MySQL5-7-GTID-crash-safe"><a href="#MySQL5-7-GTID-crash-safe" class="headerlink" title="MySQL5.7 GTID crash-safe"></a>MySQL5.7 GTID crash-safe</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-solutions-unexpected-slave-halt.html" target="_blank" rel="noopener">关于 GTID crash safe 可以参考官方文档列出的安全配置</a></p><ul><li>单线程复制<br>Non-GTID 推荐配置:<ul><li>relay_log_recovery=1</li><li>relay_log_info_repository=TABLE</li><li>master_info_repository=TABLE</li></ul></li></ul><p>GTID 推荐配置:</p><pre><code>* MASTER_AUTO_POSITION=on* relay_log_recovery=0</code></pre><img src="/2019/04/22/mysql-GTID/replication_slave_halt.jpg" title="replication_slave_halt"><ul><li>多线程复制<br>Non-GTID 推荐配置:<ul><li>relay_log_recovery=1</li><li>sync_relay_log=1</li><li>relay_log_info_repository=TABLE</li><li>master_info_repository=TABLE<br>GTID 推荐配置:</li><li>MASTER_AUTO_POSITION=on</li><li>relay_log_recovery=0</li></ul></li></ul><img src="/2019/04/22/mysql-GTID/replication_slave_halt_duoble.jpg" title="replication_slave_halt_duoble"><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h4 id="使用GTID搭建Replication"><a href="#使用GTID搭建Replication" class="headerlink" title="使用GTID搭建Replication"></a>使用GTID搭建Replication</h4><h5 id="从0开始搭建"><a href="#从0开始搭建" class="headerlink" title="从0开始搭建"></a>从0开始搭建</h5><ul><li><p>step 1: 让所有server处于同一个点</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> SET @@global.read_only = ON;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 2: 关闭所有MySQL</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell> mysqladmin -uusername -p shutdown</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 3: 重启所有MySQL，并开启GTID</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell> mysqld --gtid-mode=ON --<span class="built_in">log</span>-bin --enforce-gtid-consistency &</span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>当然，在my.cnf中配置好最佳</p></blockquote><ul><li><p>step 4: change master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> CHANGE MASTER TO MASTER_HOST = host, MASTER_PORT = port, MASTER_USER = user, MASTER_PASSWORD = password, MASTER_AUTO_POSITION = 1, MASTER_CONNECT_RETRY=10;</span><br><span class="line"></span><br><span class="line">mysql> START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 5: 让master 可读可写</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> SET @@global.read_only = OFF;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="从备份中恢复-amp-搭建"><a href="#从备份中恢复-amp-搭建" class="headerlink" title="从备份中恢复&搭建"></a>从备份中恢复&搭建</h5><ul><li><p>step 1: 备份</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump xx 获取并且记录gtid_purged值  </span><br><span class="line">or</span><br><span class="line">冷备份 --获取并且记录gtid_executed值，这个就相当于mysqldump中得到的gtid_purged</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 2: 在新服务器上reset master，导入备份</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reset master; --清空gtid信息  </span><br><span class="line">导入备份； --如果是逻辑导入，请设置sql_log_bin=off  </span><br><span class="line"><span class="built_in">set</span> global gtid_purged=<span class="string">'xx'</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 3: change master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> CHANGE MASTER TO MASTER_HOST = host, MASTER_PORT = port, MASTER_USER = user, MASTER_PASSWORD = password, MASTER_AUTO_POSITION = 1, MASTER_CONNECT_RETRY=10;</span><br><span class="line"></span><br><span class="line">mysql> START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="如何从classic-replication-升级成-GTID-replication"><a href="#如何从classic-replication-升级成-GTID-replication" class="headerlink" title="如何从classic replication 升级成 GTID replication"></a>如何从classic replication 升级成 GTID replication</h4><h5 id="offline-方式升级"><a href="#offline-方式升级" class="headerlink" title="offline 方式升级"></a>offline 方式升级</h5><p>offline 的方式升级最简单。全部关机，然后配置好GTID，重启，<code>CHANGE MASTER TO MASTER_AUTO_POSITION=1</code>。</p><h5 id="online-方式升级"><a href="#online-方式升级" class="headerlink" title="online 方式升级"></a>online 方式升级</h5><p>这里先介绍几个重要<code>GTID_MODE</code>的<code>value</code></p><ul><li>GTID_MODE = OFF               不产生Normal_GTID，只接受来自master的ANONYMOUS_GTID</li><li>GTID_MODE = OFF_PERMISSIVE    不产生Normal_GTID，可以接受来自master的ANONYMOUS_GTID & Normal_GTID</li><li>GTID_MODE = ON_PERMISSIVE     产生Normal_GTID，可以接受来自master的ANONYMOUS_GTID & Normal_GTID</li><li>GTID_MODE = ON                产生Normal_GTID，只接受来自master的Normal_GTID</li></ul><p>master和slave的gtid_mode 组合搭配矩阵图</p><blockquote><p>水平的GTID_MODE为：master</p></blockquote><blockquote><p>垂直的GTID_MODE为：slave</p></blockquote><table><thead><tr><th style="text-align:left">gtid_mode</th><th style="text-align:left">OFF(master)</th><th style="text-align:left">OFF_PERMISSIVE(master)</th><th style="text-align:left">ON_PERMISSIVE(master)</th><th style="text-align:left">ON(master)</th></tr></thead><tbody><tr><td style="text-align:left">OFF(slave)</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">N</td><td style="text-align:left">N</td></tr><tr><td style="text-align:left">OFF_PERMISSIVE(slave)</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y(auto_position可以开启)</td></tr><tr><td style="text-align:left">ON_PERMISSIVE(slave)</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y(auto_position可以开启)</td></tr><tr><td style="text-align:left">ON(slave)</td><td style="text-align:left">N</td><td style="text-align:left">N</td><td style="text-align:left">Y</td><td style="text-align:left">Y(auto_position可以开启)</td></tr></tbody></table><p>归纳总结：</p><ol><li>当master产生Normal_GTID的时候（ON_PERMISSIVE，ON），如果slave的gtid_mode（OFF）不能接受Normal_GTID，那么就会报错</li><li>当master产生ANONYMOUS_GTID的时候（OFF_PERMISSIVE，OFF），如果slave的gtid_mode（ON）不能接受ANONYMOUS_GTID，那么就会报错</li><li>设置auto_position的条件： 当master gtid_mode=ON时，slave可以为OFF_PERMISSIVE，ON_PERMISSIVE，ON。除此之外，都不能设置auto_position = on</li></ol><p>下面罗列下，如何online 升级为GTID模式。</p><ul><li><p>step 1: 每台server执行</p><blockquote><p>检查错误日志，直到没有错误出现，才能进行下一步</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = WARN;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>step 2: 每台server执行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = ON;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 3: 每台server执行</p><blockquote><p>不用关心一组复制集群的server的执行顺序，只需要保证每个Server都执行了，才能进行下一步</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>step 4: 每台server执行</p><blockquote><p>不用关心一组复制集群的server的执行顺序，只需要保证每个Server都执行了，才能进行下一步</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.GTID_MODE = ON_PERMISSIVE;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>step 5: 在每台server上执行，如果ONGOING_ANONYMOUS_TRANSACTION_COUNT=0就可以</p><blockquote><p>不需要一直为0，只要出现过0一次，就ok</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE <span class="string">'ONGOING_ANONYMOUS_TRANSACTION_COUNT'</span>;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>step 6： 确保所有anonymous事务传递到slave上了</p></li></ul><ul><li><p>master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></tbody></table></figure></li><li><p>每个slave  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MASTER_POS_WAIT(file, position);</span><br></pre></td></tr></tbody></table></figure></li></ul><p>或者，等一段时间，只要不是大的延迟，一般都没问题</p><ul><li><p>step 7: 每台Server上执行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.GTID_MODE = ON;</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 8: 在每台server上将my.cnf中添加好gtid配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=ON                (必选) </span><br><span class="line">enforce-gtid-consistency    (必选)</span><br><span class="line">log_bin=ON                  (可选)--高可用切换，最好设置ON  </span><br><span class="line"><span class="built_in">log</span>-slave-updates=ON        (可选)--高可用切换，最好设置ON</span><br></pre></td></tr></tbody></table></figure></li><li><p>step 9: change master</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STOP SLAVE;  </span><br><span class="line">CHANGE MASTER TO MASTER_AUTO_POSITION = 1;  </span><br><span class="line">START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="GTID-failover"><a href="#GTID-failover" class="headerlink" title="GTID failover"></a>GTID failover</h4><h5 id="MySQL-crash"><a href="#MySQL-crash" class="headerlink" title="MySQL crash"></a>MySQL crash</h5><pre><code>> 配置好loss-less semi-sync replication，可以更可靠的保证数据零丢失。  以下说的都是crash 后，起不来的情况</code></pre><ul><li>binlog 在master还有日志没有传递到 slave<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 选取最新的slave, CHANGE MASTER TO maseter_auto_position 同步好  </span><br><span class="line">2. mysqlbinlog 将没传递过来的binlog在新master上replay  </span><br><span class="line">3. 打开新 master 的 SET GLOBAL surper_read_only=off;</span><br><span class="line">``` </span><br><span class="line">* binlog 已经传递到slave</span><br><span class="line">```bash</span><br><span class="line">1. 选取最新的slave, CHANGE MASTER TO maseter_auto_position同步好  </span><br><span class="line">2. 打开新master的 SET GLOBAL surper_read_only=off;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="OS-crash"><a href="#OS-crash" class="headerlink" title="OS crash"></a>OS crash</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 选取最新的slave, CHANGE MASTER TO maseter_auto_position同步好  </span><br><span class="line">2. 打开新master的 SET GLOBAL surper_read_only=off;</span><br></pre></td></tr></tbody></table></figure><blockquote><blockquote><p>以上操作，在传统模式复制下，只能通过MHA来实现，MHA比较复杂。<br>   现在，在GTID模式下，实现起来非常简单，且非常方便。</p></blockquote></blockquote><h4 id="GTID-运维和错误处理"><a href="#GTID-运维和错误处理" class="headerlink" title="GTID 运维和错误处理"></a>GTID 运维和错误处理</h4><ol><li>使用GTID后，对原来传统的运维有不同之处了，需要调整过来。</li><li>使用Row模式且复制配置正确的情况下，基本上很少发现有复制出错的情况。</li><li>slave 设置 super_read_only=on</li></ol><h5 id="错误场景-Errant-transaction"><a href="#错误场景-Errant-transaction" class="headerlink" title="错误场景: Errant transaction"></a>错误场景: Errant transaction</h5><p>出现这种问题基本有两种情况</p><blockquote><ol><li>复制参数没有配置正确，当slave crash后，会出现重复键问题</li><li>DBA操作不正确，不小心在slave上执行了事务</li></ol></blockquote><p>对于第一个重复键问题</p><ul><li><p>对于第一个重复键问题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* skip transation; </span><br><span class="line">SQL> SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1;</span><br><span class="line">SQL> START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li><li><p>GTID模式</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQL> SET GTID_NEXT=<span class="string">'b9b4712a-df64-11e3-b391-60672090eb04:7'</span>;   --设置需要跳过的gtid event</span><br><span class="line">SQL> BEGIN;COMMIT;</span><br><span class="line">SQL> SET GTID_NEXT=<span class="string">'AUTOMATIC'</span>;</span><br><span class="line">SQL> START SLAVE;</span><br></pre></td></tr></tbody></table></figure></li></ul><p>对于第二种不小心多执行了事务</p><blockquote><p>这种情况就比较难了，这样已经导致了数据不一致，大多数情况，建议slave重做<br>  如何避免： slave 设置 super_read_only=on;</p></blockquote><p><strong><em>重点： 当发生inject empty transction后，有可能会丢失事务</em></strong></p><pre><code>这里说下inject empty transction的隐患    当slave上inject empty transction，说明有一个master的事务被忽略了（这里假设是 $uuid:100）    事务丢失一：如果此时此刻master挂了，这个slave被选举为新master，那么其他的slave如果还没有执行到$uuid:100,就会丢失掉$uuid:100这个事务。    事务丢失二：如果从备份中重新搭建一个slave，需要重新执行之前的所有事务，而此时，master挂了， 又回到了事务丢失一的场景。</code></pre><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h4 id="如何重置gtid-executed，gtid-purged。"><a href="#如何重置gtid-executed，gtid-purged。" class="headerlink" title="如何重置gtid_executed，gtid_purged。"></a>如何重置gtid_executed，gtid_purged。</h4><ul><li><p>设置gtid_executed</p><blockquote><p>现在只能执行:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> reset master;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>设置gtid_purged</p></li><li>当gtid_executed 非空的时候，不能设置gtid_purged</li><li>当gtid_executed 为空的时候(即刚刚备份好的镜像，刚搭建的mysql)<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> SET @@GLOBAL.GTID_PURGED=<span class="string">'0ad6eae9-2d66-11e6-864f-ecf4bbf1f42c:1-3'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="如果auto-cnf-被删掉了，对于GTID的复制会有什么影响？"><a href="#如果auto-cnf-被删掉了，对于GTID的复制会有什么影响？" class="headerlink" title="如果auto.cnf 被删掉了，对于GTID的复制会有什么影响？"></a>如果auto.cnf 被删掉了，对于GTID的复制会有什么影响？</h5><pre><code>> 如果被删掉，重启后，server-uuid 会变</code></pre><h5 id="手动设置-set-gtid-purged-xx-yy-mysql会去主动修改binlog的头么"><a href="#手动设置-set-gtid-purged-xx-yy-mysql会去主动修改binlog的头么" class="headerlink" title="手动设置 set @@gtid_purged = xx:yy, mysql会去主动修改binlog的头么"></a>手动设置 set @@gtid_purged = xx:yy, mysql会去主动修改binlog的头么</h5><pre><code>> 不会</code></pre><h5 id="GTID和复制过滤规则之间如何协同工作？MySQL，test还能愉快的过滤掉吗？"><a href="#GTID和复制过滤规则之间如何协同工作？MySQL，test还能愉快的过滤掉吗？" class="headerlink" title="GTID和复制过滤规则之间如何协同工作？MySQL，test还能愉快的过滤掉吗？"></a>GTID和复制过滤规则之间如何协同工作？MySQL，test还能愉快的过滤掉吗？</h5><pre><code>> 可以，改过滤的会自己过滤，不用担心</code></pre><h2 id="Automatic-failover-with-mysqlfailover-GTID"><a href="#Automatic-failover-with-mysqlfailover-GTID" class="headerlink" title="Automatic failover with mysqlfailover+GTID"></a>Automatic failover with mysqlfailover+GTID</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-solutions-switch.html" target="_blank" rel="noopener">mysqlfailover+GTID</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询重复记录,删除重复记录方法</title>
      <link href="/2019/04/22/mysql-duplicate/"/>
      <url>/2019/04/22/mysql-duplicate/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>善良没用，因为只有你先漂亮，别人才能看到你的善良。</strong></p></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查找全部重复记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表 WHERE 重复字段 IN (SELECT 重复字段 FROM 表 GROUP BY 重复字段 HAVING COUNT(*)>1);</span><br></pre></td></tr></tbody></table></figure><p></p><p>过滤重复记录(只显示一条)<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表 WHERE ID IN (SELECT MAX(ID) FROM 表 GROUP BY Title);     <span class="comment">#显示ID最大一条记录</span></span><br><span class="line">SELECT * FROM 表 WHERE ID IN (SELECT MIN(ID) FROM 表 GROUP BY Title);     <span class="comment">#显示ID最小一条记录</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>删除全部重复记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE 表 WHERE 重复字段 IN (SELECT 重复字段 FROM 表 GROUP BY 重复字段 HAVING COUNT(*)>1);</span><br></pre></td></tr></tbody></table></figure><p></p><p>删除全部重复记录保留最大ID最大一条记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表 WHERE ID NOT IN (SELECT MAX(ID) FROM 表 GROUP BY Title)    <span class="comment">#保留ID最大一条记录</span></span><br><span class="line">DELETE FROM 表 WHERE ID NOT IN (SELECT MIN(ID) FROM 表 GROUP BY Title)    <span class="comment">#保留ID最小一条记录</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>删除表中多余的重复记录（多个字段），只留有rowid最小的记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM vitae a WHERE (a.peopleId, a.seq) IN (SELECT peopleId, seq FROM vitae GROUP BY peopleId, seq HAVING COUNT(*) > 1) AND rowid NOT IN (SELECT MIN(rowid) FROM vitae GROUP BY peopleId, seq HAVING COUNT(*)>1)</span><br></pre></td></tr></tbody></table></figure><p></p><p>查找表中多余的重复记录（多个字段），不包含rowid最小的记录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM vitae a WHERE (a.peopleId, a.seq) IN (SELECT peopleId, seq FROM vitae GROUP BY peopleId, seq HAVING COUNT(*) > 1) AND rowid NOT IN (SELECT MIN(rowid) FROM vitae GROUP BY peopleId, seq HAVING COUNT(*)>1)</span><br></pre></td></tr></tbody></table></figure><p></p><p>查找表中多余的重复记录（多个字段）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM vitae a WHERE (a.peopleId, a.seq) IN (SELECT peopleId, seq FROM vitae GROUP BY peopleId, seq HAVING COUNT(*) > 1)</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说明：</p><ul><li>单表的唯一查询用：distinct</li><li>多表的唯一查询用：group by</li><li>distinct 查询多表时，left join 还有效，全连接无效</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL修改表、字段、库的字符集及字符集</title>
      <link href="/2019/04/22/mysql-character/"/>
      <url>/2019/04/22/mysql-character/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>一直对发型和身材不满意的人，有一个共同点：不肯承认这是脸的问题。</strong></p></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>修改数据库字符集<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE db_name DEFAULT CHARACTER SET character_name [COLLATE ...];</span><br></pre></td></tr></tbody></table></figure><p></p><p>把表默认的字符集和所有字符列（CHAR,VARCHAR,TEXT）改为新的字符集：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name CONVERT TO CHARACTER SET character_name [COLLATE ...]</span><br><span class="line">如：ALTER TABLE logtest CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></tbody></table></figure><p></p><p>只是修改表的默认字符集<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name DEFAULT CHARACTER SET character_name [COLLATE...];</span><br><span class="line">如：ALTER TABLE logtest DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></tbody></table></figure><p></p><p>修改字段的字符集<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name CHANGE c_name c_name CHARACTER SET character_name [COLLATE ...];</span><br><span class="line">如：ALTER TABLE logtest CHANGE title title VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看字段编码<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW FULL COLUMNS FROM tbl_name;</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看系统的编码字符<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE <span class="string">'character\_set\_%'</span> OR Variable_name LIKE <span class="string">'collation%'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="MySQL字符集设置"><a href="#MySQL字符集设置" class="headerlink" title="MySQL字符集设置"></a>MySQL字符集设置</h2><p>系统变量：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">– character_set_server：默认的内部操作字符集</span><br><span class="line">– character_set_client：客户端来源数据使用的字符集</span><br><span class="line">– character_set_connection：连接层字符集</span><br><span class="line">– character_set_results：查询结果字符集</span><br><span class="line">– character_set_database：当前选中数据库的默认字符集</span><br><span class="line">– character_set_system：系统元数据(字段名等)字符集</span><br><span class="line">– 还有以collation_开头的同上面对应的变量，用来描述字符序。</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="用introducer指定文本字符串的字符集"><a href="#用introducer指定文本字符串的字符集" class="headerlink" title="用introducer指定文本字符串的字符集"></a>用introducer指定文本字符串的字符集</h2><p>格式为：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_charset] ‘string’ [COLLATE collation]</span><br></pre></td></tr></tbody></table></figure><p></p><p>例子:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT _latin1 ‘string’;</span><br><span class="line">• SELECT _utf8 ‘你好’ COLLATE utf8_general_ci;</span><br><span class="line">– 由introducer修饰的文本字符串在请求过程中不经过多余的转码，直接转换为内部字符集处理。</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="MySQL中的字符集转换过程"><a href="#MySQL中的字符集转换过程" class="headerlink" title="MySQL中的字符集转换过程"></a>MySQL中的字符集转换过程</h2><ol><li>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</li><li>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：<ul><li>使用每个数据字段的CHARACTER SET设定值；</li><li>若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；</li><li>若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</li><li>若上述值不存在，则使用character_set_server设定值。</li></ul></li><li>将操作结果从内部操作字符集转换为character_set_results</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Systemd详解</title>
      <link href="/2019/04/22/linux-systemd/"/>
      <url>/2019/04/22/linux-systemd/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>一场说走就走的旅行，回来等着你的就是一段吃土的日子。</strong></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Systemd是Linux系统工具，用来启动守护进程，已成为大多数发行版的标配，PID为1最先启动；</p><p>历史上，Linux 的启动一直采用init进程。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/apache2 start</span><br><span class="line">或者</span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></tbody></table></figure><p></p><p>这种方法有两个缺点。</p><ul><li>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li></ul><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。<br>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。<br>CentOS/RHEL7 以上版本中Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。<br>查看版本：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/04/22/linux-systemd/systemd.png" title="systemd"><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl 命令"></a>systemctl 命令</h4><p>重启系统<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot</span><br></pre></td></tr></tbody></table></figure><p></p><p>关闭系统，切断电源<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl poweroff</span><br></pre></td></tr></tbody></table></figure><p></p><p>CPU停止工作<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl halt</span><br></pre></td></tr></tbody></table></figure><p></p><p>暂停系统<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>让系统进入冬眠状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl hibernate</span><br></pre></td></tr></tbody></table></figure><p></p><p>让系统进入交互式休眠状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl hybrid-sleep</span><br></pre></td></tr></tbody></table></figure><p></p><p>启动进入救援状态（单用户状态）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl rescue</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>systemd-analyze</code> 是查看启动耗时</p><p>查看启动耗时<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看每个服务的启动耗时<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze blame</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示瀑布状的启动过程流<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze critical-chain</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示指定服务的启动流<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze critical-chain atd.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="hostnamectl命令用于查看当前主机的信息。"><a href="#hostnamectl命令用于查看当前主机的信息。" class="headerlink" title="hostnamectl命令用于查看当前主机的信息。"></a><code>hostnamectl</code>命令用于查看当前主机的信息。</h4><p>显示当前主机的信息<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl</span><br><span class="line">```bash</span><br><span class="line">设置主机名。</span><br><span class="line">```bash</span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname rhel7</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="localectl命令用于查看本地化设置。"><a href="#localectl命令用于查看本地化设置。" class="headerlink" title="localectl命令用于查看本地化设置。"></a><code>localectl</code>命令用于查看本地化设置。</h4><p>查看本地化设置<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localectl</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置本地化参数。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localectl <span class="built_in">set</span>-locale LANG=en_GB.utf8</span><br><span class="line">localectl <span class="built_in">set</span>-keymap en_GB</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="timedatectl命令用于查看当前时区设置。"><a href="#timedatectl命令用于查看当前时区设置。" class="headerlink" title="timedatectl命令用于查看当前时区设置。"></a><code>timedatectl</code>命令用于查看当前时区设置。</h4><p>查看当前时区设置<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示所有可用的时区<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl list-timezones</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置当前时区<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-timezone America/New_York</span><br><span class="line">timedatectl <span class="built_in">set</span>-time YYYY-MM-DD</span><br><span class="line">timedatectl <span class="built_in">set</span>-time HH:MM:SS</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="loginctl命令用于查看当前登录的用户。"><a href="#loginctl命令用于查看当前登录的用户。" class="headerlink" title="loginctl命令用于查看当前登录的用户。"></a><code>loginctl</code>命令用于查看当前登录的用户。</h4><p>列出当前session<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginctl list-sessions</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出当前登录用户<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginctl list-users</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出显示指定用户的信息<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginctl show-user ruanyf</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><code>Systemd</code> 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p><p><code>Unit</code> 一共分成12种。</p><ul><li><code>Service unit</code>：系统服务</li><li><code>Target unit</code>：多个 Unit 构成的一个组</li><li><code>Device Unit</code>：硬件设备</li><li><code>Mount Unit</code>：文件系统的挂载点</li><li><code>Automount Unit</code>：自动挂载点</li><li><code>Path Unit</code>：文件或路径</li><li><code>Scope Unit</code>：不是由 Systemd 启动的外部进程</li><li><code>Slice Unit</code>：进程组</li><li><code>Snapshot Unit</code>：Systemd 快照，可以切回某个快照</li><li><code>Socket Unit</code>：进程间通信的 socket</li><li><code>Swap Unit</code>：swap 文件</li><li><code>Timer Unit</code>：定时器</li></ul><p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p><p>列出正在运行的 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有Unit，包括没有找到配置文件的或者启动失败的<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --all</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有没有运行的 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --all --state=inactive</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有加载失败的 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --failed</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有正在运行的、类型为 service 的 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Unit-的状态"><a href="#Unit-的状态" class="headerlink" title="Unit 的状态"></a><code>Unit</code> 的状态</h4><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p><p>显示系统状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示单个 Unit 的状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysystemctl status bluetooth.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示远程主机的某个 Unit 的状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p><p>显示某个 Unit 是否正在运行<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-active application.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示某个 Unit 是否处于启动失败状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-failed application.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示某个 Unit 服务是否建立了启动链接<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled application.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Unit-管理"><a href="#Unit-管理" class="headerlink" title="Unit 管理"></a><code>Unit</code> 管理</h4><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p><p>立即启动一个服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>立即停止一个服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>重启一个服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>杀死一个服务的所有子进程<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">kill</span> apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>重新加载一个服务的配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload apache.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>重载所有修改过的配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示某个 Unit 的所有底层参数<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl show httpd.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示某个 Unit 的指定属性的值<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl show -p CPUShares httpd.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置某个 Unit 的指定属性<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">set</span>-property httpd.service CPUShares=500</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p><code>Unit</code> 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p><p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies nginx.service</span><br><span class="line">```bash</span><br><span class="line">上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用--all参数。</span><br><span class="line">```bash</span><br><span class="line">systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Unit-的配置文件"><a href="#Unit-的配置文件" class="headerlink" title="Unit 的配置文件"></a>Unit 的配置文件</h4><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p><p><code>Systemd</code> 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p><p><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> clamd@scan.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>等同于<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/clamd@scan.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/clamd@scan.service'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。</p><p>与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> clamd@scan.service</span><br></pre></td></tr></tbody></table></figure><p></p><p>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p><p>配置文件的状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files命令用于列出所有配置文件。</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出所有配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files</span><br></pre></td></tr></tbody></table></figure><p></p><p>列出指定类型的配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=service</span><br><span class="line">这个命令会输出一个列表。</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files</span><br></pre></td></tr></tbody></table></figure><h4 id="UNIT-FILE-STATE"><a href="#UNIT-FILE-STATE" class="headerlink" title="UNIT FILE STATE"></a>UNIT FILE STATE</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chronyd.service enabled</span><br><span class="line">clamd@.service static</span><br><span class="line">clamd@scan.service disabled</span><br></pre></td></tr></tbody></table></figure><p>这个列表显示每个配置文件的状态，一共有四种。</p><ul><li>enabled：已建立启动链接</li><li>disabled：没建立启动链接</li><li>static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖</li><li>masked：该配置文件被禁止建立启动链接<blockquote><p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status bluetooth.service</span><br></pre></td></tr></tbody></table></figure></blockquote></li></ul><p>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart httpd.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="配置文件的格式"><a href="#配置文件的格式" class="headerlink" title="配置文件的格式"></a>配置文件的格式</h4><p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p><p><code>systemctl cat</code>命令可以查看配置文件的内容。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl cat atd.service</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="unit-配置文件"><a href="#unit-配置文件" class="headerlink" title="unit 配置文件"></a>unit 配置文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=ATD daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/bin/atd</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。</span><br><span class="line">每个区块内部是一些等号连接的键值对。</span><br><span class="line"></span><br><span class="line">[Section]</span><br><span class="line">Directive1=value</span><br><span class="line">Directive2=value</span><br><span class="line"></span><br><span class="line">. . .</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意，键值对的等号两侧不能有空格。</p></blockquote><h4 id="配置文件的区域"><a href="#配置文件的区域" class="headerlink" title="配置文件的区域"></a>配置文件的区域</h4><p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p><ul><li>Description：简短描述</li><li>Documentation：文档地址</li><li>Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li><li>Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li><li>BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li><li>Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li><li>After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li><li>Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行</li><li>Condition…：当前 Unit 运行必须满足的条件，否则不会运行</li><li>Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败</li></ul><p><code>[Install]</code>通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><ul><li>WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</li><li>RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</li><li>Alias：当前 Unit 可用于启动的别名</li><li>Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li></ul><p><code>[Service]</code>区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><ul><li>Type：定义启动时的进程行为。它有以下几种值。</li><li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li><li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li><li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li><li>Type=dbus：当前服务通过D-Bus启动</li><li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li><li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li><li>ExecStart：启动当前服务的命令</li><li>ExecStartPre：启动当前服务之前执行的命令</li><li>ExecStartPost：启动当前服务之后执行的命令</li><li>ExecReload：重启当前服务时执行的命令</li><li>ExecStop：停止当前服务时执行的命令</li><li>ExecStopPost：停止当其服务之后执行的命令</li><li>RestartSec：自动重启当前服务间隔的秒数</li><li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li><li>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</li><li>Environment：指定环境变量</li></ul><blockquote><p>Unit 配置文件的完整字段清单，请参考官方文档。</p></blockquote><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。<br>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。<br>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><p>查看当前系统的所有 Target<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=target</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看一个 Target 包含的所有 Unit<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies multi-user.target</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看启动时的默认 Target<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置启动时的默认 Target<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">set</span>-default multi-user.target</span><br></pre></td></tr></tbody></table></figure><p></p><p>切换 Target 时，默认不关闭前一个 Target 启动的进程，<code>systemctl isolate</code> 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl isolate multi-user.target</span><br></pre></td></tr></tbody></table></figure><p></p><p>Target 与 传统 RunLevel 的对应关系如下。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Traditional runlevel New target name Symbolically linked to...</span><br><span class="line"></span><br><span class="line">Runlevel 0 | runlevel0.target -> poweroff.target</span><br><span class="line">Runlevel 1 | runlevel1.target -> rescue.target</span><br><span class="line">Runlevel 2 | runlevel2.target -> multi-user.target</span><br><span class="line">Runlevel 3 | runlevel3.target -> multi-user.target</span><br><span class="line">Runlevel 4 | runlevel4.target -> multi-user.target</span><br><span class="line">Runlevel 5 | runlevel5.target -> graphical.target</span><br><span class="line">Runlevel 6 | runlevel6.target -> reboot.target</span><br></pre></td></tr></tbody></table></figure><p></p><p>它与init进程的主要差别如下:</p><ol><li>默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li><li>启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</li><li>配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</li></ol><h4 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h4><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。</p><p><code>journalctl</code>功能强大，用法非常多。</p><p>查看所有日志（默认情况下 ，只保存本次启动的日志）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看内核日志（不显示应用日志）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -k</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看系统本次启动的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b</span><br><span class="line">journalctl -b -0</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看上一次启动的日志（需更改设置）<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b -1</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定时间的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></span><br><span class="line">journalctl --since <span class="string">"20 min ago"</span></span><br><span class="line">journalctl --since yesterday</span><br><span class="line">journalctl --since <span class="string">"2015-01-10"</span> --until <span class="string">"2015-01-11 03:00"</span></span><br><span class="line">journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>显示尾部的最新10行日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -n</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示尾部指定行数的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -n 20</span><br></pre></td></tr></tbody></table></figure><p></p><p>实时滚动显示最新日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -f</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定服务的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl /usr/lib/systemd/systemd</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定进程的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl _PID=1</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看某个路径的脚本的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl /usr/bin/bash</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定用户的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl _UID=33 --since today</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看某个 Unit 的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service</span><br><span class="line">journalctl -u nginx.service --since today</span><br></pre></td></tr></tbody></table></figure><p></p><p>实时滚动显示某个 Unit 的最新日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service -f</span><br></pre></td></tr></tbody></table></figure><p></p><p>合并显示多个 Unit 的日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service -u php-fpm.service --since today</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看指定优先级（及其以上级别）的日志，共有8级</p><ol start="0"><li>0:emerg</li><li>1:alert</li><li>2:crit</li><li>3:err</li><li>4:warning</li><li>5:notice</li><li>6:info</li><li>7:debug<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -p err -b</span><br></pre></td></tr></tbody></table></figure></li></ol><p>日志默认分页输出，–no-pager 改为正常的标准输出<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --no-pager</span><br></pre></td></tr></tbody></table></figure><p></p><p>以 JSON 格式（单行）输出<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b -u nginx.service -o json</span><br></pre></td></tr></tbody></table></figure><p></p><p>以 JSON 格式（多行）输出，可读性更好<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b -u nginx.serviceqq -o json-pretty</span><br></pre></td></tr></tbody></table></figure><p></p><p>显示日志占据的硬盘空间<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --disk-usage</span><br></pre></td></tr></tbody></table></figure><p></p><p>指定日志文件占据的最大空间<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --vacuum-size=1G</span><br></pre></td></tr></tbody></table></figure><p></p><p>指定日志文件保存多久<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --vacuum-time=1years</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看最消耗CPU和内存的进程</title>
      <link href="/2019/04/22/cpu-memory/"/>
      <url>/2019/04/22/cpu-memory/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>真正努力过的人才知道，智商上的差距是不可逾越的。</strong></p></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li><p>CPU占用最多的前10个进程： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|head -1;ps auxw|sort -rn -k3|head -10</span><br></pre></td></tr></tbody></table></figure></li><li><p>内存消耗最多的前10个进程 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|head -1;ps auxw|sort -rn -k4|head -10</span><br></pre></td></tr></tbody></table></figure></li><li><p>虚拟内存使用最多的前10个进程 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|head -1;ps auxw|sort -rn -k5|head -10</span><br></pre></td></tr></tbody></table></figure></li></ol><p>几个参数含义:</p><ul><li>%MEM 进程的内存占用率</li><li>VSZ 进程所使用的虚存的大小</li><li>RSS 进程使用的驻留集大小或者是实际内存的大小(RSS is the “resident set size” meaning physical memory used)</li><li>TTY 与进程关联的终端（tty）</li><li>串行端口终端（/dev/ttySn）</li><li>伪终端（/dev/pty/）</li><li>控制终端（/dev/tty）</li><li>控制台终端（/dev/ttyn, /dev/console）</li><li>虚拟终端(/dev/pts/n)</li><li>STAT 检查的状态：进程状态使用字符表示的，如R（running正在运行或准备运行）、S（sleeping睡眠）、I（idle空闲）、Z (僵死)、D（不可中断的睡眠，通常是I/O）、P（等待交换页）、W（换出,表示当前页面不在内存）、N（低优先级任务）T(terminate终止)、W has no resident pages</li><li>D 不可中断 Uninterruptible sleep (usually IO)</li><li>R 正在运行，或在队列中的进程</li><li>S 处于休眠状态</li><li>T 停止或被追踪</li><li>Z 僵尸进程</li><li>W 进入内存交换（从内核2.6开始无效）</li><li>X 死掉的进程</li><li>< 高优先级</li><li>N 低优先级</li><li>L 有些页被锁进内存</li><li>s 包含子进程</li></ul><p>位于后台的进程组</p><ul><li>l 多线程</li><li>克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx查看截取切割日志</title>
      <link href="/2019/04/22/nginx-log/"/>
      <url>/2019/04/22/nginx-log/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="AAA.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>这个世界没有错，谁让你长得不好看又没钱。</strong></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>nginx日志最好实现每天定时切割下，特别是在访问量比较大的时候，方便查看与处理，如果没切割，可以用sed直接切割</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查找7月17日访问log导出到17.log文件中<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat gelin_web_access.log | egrep <span class="string">"17/Jul/2017"</span> | sed  -n <span class="string">'/00:00:00/,/23:59:59/p'</span> > /tmp/17.log</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看访问量前10的IP<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $1}'</span> 17.log | sort | uniq -c | sort -nr | head -n 10</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看访问前10的URL<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $11}'</span> gelin_web_access.log | sort | uniq -c | sort -nr | head -n 10</span><br></pre></td></tr></tbody></table></figure><p></p><p>查询访问最频繁的URL<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $7}'</span> gelin_web_access.log | sort | uniq -c | sort -n -k 1 -r | more</span><br></pre></td></tr></tbody></table></figure><p></p><p>查询访问最频繁的IP<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $1}'</span> gelin_web_access.log | sort | uniq -c | sort -n -k 1 -r | more</span><br></pre></td></tr></tbody></table></figure><p></p><p>根据访问IP统计UV<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $1}'</span> gelin_web_access.log | sort | uniq -c | wc -l</span><br></pre></td></tr></tbody></table></figure><p></p><p>统计访问URL统计PV<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'{print $7}'</span> gelin_web_access.log | wc -l</span><br></pre></td></tr></tbody></table></figure><p></p><p>根据时间段统计查看日志<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat gelin_web_access.log | sed -n <span class="string">'/17\/Jul\/2017:12/,/17\/Jul\/2017:13/p'</span> | more</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux iptables 整理</title>
      <link href="/2019/04/22/linux-iptables/"/>
      <url>/2019/04/22/linux-iptables/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>你总嫌有些人懒，说得好像你勤快了就真能干出什么大事儿一样。</strong></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>iptables是Linux中重要的访问控制手段，是俗称的 Linux 防火墙系统的重要组成部分。这里记录了iptables 防火墙规则的一些常用的操作指令。</p><p>iptables的基本语法：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t filter/nat] [-A/I] [INPUT/OUTPUT/FORWARD] [-i/o interface] [-p tcp/udp/icmp/all] [-s ip/network] [--sport ports] [-d ip/network] [--dport ports] [-j ACCEPT/DROP]</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">参数说明:</span><br><span class="line">     不加-t时默认是filter</span><br><span class="line">     </span><br><span class="line">     语法参数：</span><br><span class="line">     -I：第一行插入</span><br><span class="line">     -A：最后追加 </span><br><span class="line">     -i/o：指的是数据要进入或出去所要经过的端口，如eth1,eth0,pppoe等</span><br><span class="line">     -p：你所要指定的协议 </span><br><span class="line">     -s：指定来源ip，可以是单个ip如192.168.109.131，也可以是一个网络 192.168.109.0/24，还可以是一个域名如163.com，如果你填写的是域名系统会自动解析出他的ip并在iptables里显示</span><br><span class="line">     --sport：来源端口 </span><br><span class="line">     -d：指定目标ip</span><br><span class="line">     --dport：目标端口 </span><br><span class="line">     -j：执行参数ACCEPT或DROP，REJECT一般不用</span><br><span class="line">     -A 在指定链的末尾添加（append）一条新的规则</span><br><span class="line">     -D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除</span><br><span class="line">     -I 在指定链中插入（insert）一条新的规则，默认在第一行添加</span><br><span class="line">     -R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换</span><br><span class="line">     -L 列出（list）指定链中所有的规则进行查看</span><br><span class="line">     -E 重命名用户定义的链，不改变链本身</span><br><span class="line">     -F 清空（flush）</span><br><span class="line">     -N 新建（new-chain）一条用户自己定义的规则链</span><br><span class="line">     -X 删除指定表中用户自定义的规则链（delete-chain）</span><br><span class="line">     -P 设置指定链的默认策略（policy）</span><br><span class="line">     -Z 将所有表的所有链的字节和数据包计数器清零</span><br><span class="line">     -n 使用数字形式（numeric）显示输出结果</span><br><span class="line">     -v 查看规则表详细信息（verbose）的信息</span><br><span class="line">     -V 查看版本(version)</span><br><span class="line">     -h 获取帮助（<span class="built_in">help</span>）</span><br></pre></td></tr></tbody></table></figure><p>如果配置的是INPUT（进入）,则来源ip是运程ip，目标端口就是本机；OUTPUT相反</p><img src="/2019/04/22/linux-iptables/iptables.jpeg" title="iptables"><img src="/2019/04/22/linux-iptables/iptables1.png" title="iptables1"><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>当数据包到达目标主机时，经过PREROUTING链,经路由之后决定是否转发，不转发则进入INPUT链，到达用户空间。进程对外通信时，经由OUTPUT链出去，路由之后到达POSTROUTING链，经网卡出去。当一数据包经过PREROUTING链发现其不是到达本主机，那么数据包经过FORWARD链，到达 POSTROUTING链转发出去。本机进程对发送数据时，经由OUTPUT链路由之后进入POSTROUTING链出去。<br>iptables匹配规则时，是自上而下匹配的，匹配到第一条规则时既跳出，否则一直往下匹配，没有则使用默认规则。<br>iptables规则建立时，首先需要确定功能（表），确定报文流向，确定要实现的目标，确定匹配条件。<br>尽量遵循以下规则：尽量减少规则条目，彼此间无关联，访问条目大放上面，有关联（同一功能），规则更严格的放上面</p><p>五个hook函数分别是<code>PREROUTING</code>,<code>INPUT</code> ,<code>OUTPUT</code>,<code>POSTROUTING</code>,<code>FORWARD</code>，我们把这五个钩子函数称为链，Netfilter实现了几功能，<code>raw</code> ，<code>mangle</code>，<code>nat</code>，<code>filter</code>。我们一般把这几个功能称为表，表之间有优先级关系，从低到高为<code>filter—-nat—-mangle—-raw</code>,表与链之间有对应关系，具体见图表。<br><img src="/2019/04/22/linux-iptables/iptables-hook.png" title="iptables-hook"></p><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul><li>raw表： 对报文设置一个标志，决定数据包是否被状态跟踪机制处理</li><li>mangle表： 主要用于修改数据包</li><li>nat表： 主要用处是网络地址转换、端口映射</li><li>fileter表： 主要用于过滤包</li></ul><p>一般情况我们对filter表做配置的更多。</p><h4 id="链"><a href="#链" class="headerlink" title="链"></a>链</h4><ul><li>INPUT： 作用于进入本机的包</li><li>OUTPUT： 作用于本机送出的包 </li><li>FORWARD： 匹配穿过本机的数据包（转发） </li><li>PREROUTING： 用于修改目的地址（DNAT） </li><li>POSTROUTING：用于修改源地址 （SNAT）</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">启动指令:service iptables start    </span><br><span class="line">重启指令:service iptables restart    </span><br><span class="line">关闭指令:service iptables stop</span><br><span class="line">保存指令:service iptables save</span><br><span class="line">清除规则：iptables -F   </span><br><span class="line">将链的记数的流量清零: iptables -Z</span><br><span class="line">清除链: iptables -X</span><br><span class="line">清空iptables时一般-F -Z -X一起使用</span><br></pre></td></tr></tbody></table></figure><h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><ul><li>ACCEPT 允许</li><li>DROP 丢弃</li><li>REJECT 拒绝</li></ul><p>ROP和REJECT的区别：DROP是直接不让进入，而REJECT是先让进入然后再拒绝，LOG在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则.</p><p>DROP更安全，所以一般拒绝都用DROP</p><p>-A默认是插入到尾部的，可以-I来插入到指定位置</p><p>iptables的两种配置思路:</p><ol><li>默认允许，拒绝特别</li><li>默认拒绝，允许特别</li></ol><p>二者都有自己的特点，看情况而定。但是注意：如果要选择第二种配置思路，配置前切记先把ssh设置为ACCEPT，因为一般机器不在我们身边，一旦配置默认拒绝，那我们的远程登录就会断开连接，那问题就大了。<br>配置默认拒绝前设置:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT    </span><br><span class="line">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>还有一种方法：做一个计划任务，让iptables定期停止，即执行service iptables stop，这样的话即使配置默认拒绝前没有允许ssh也没关系，等到计划任务生效的时间iptables就会自动清除所有的配置，包括默认规则。</p><p>iptables的执行优先级:</p><ul><li>iptables的执行顺序是自上而下，当有配置产生冲突时，前面执行的生效。</li></ul><p>删除iptables规则<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT 3  //删除input的第3条规则</span><br><span class="line">iptables -t nat -D POSTROUTING 1  //删除nat表中postrouting的第一条规则</span><br><span class="line">iptables -F INPUT   //清空 filter表INPUT所有规则</span><br><span class="line">iptables -F    //清空所有规则</span><br><span class="line">iptables -t nat -F POSTROUTING   //清空nat表POSTROUTING所有规则</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h2><p>第一种方法：修改配置文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line">删除相应的行，然后</span><br><span class="line">service iptables restart </span><br><span class="line">service iptables save</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>注意:</p></blockquote><blockquote><p>修改完配置文件不能先save，一定要先restart才能save，要不然就白做了。因为save会在iptables服务启动时重新加载，要是在重启之前直接先调用了service iptables save 那么你的/etc/sysconfig/iptables 配置就回滚到上次启动服务的配置了。</p></blockquote><p>第二种方法：直接用命令删除</p><p>如果你记得配置时的写法，那么可以直接<code>iptables -D</code> 后跟上配置时的写法。如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT -s 10.72.11.12 -p tcp --sport 1234 -d 10.10.2.58 --dport 80 -j DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>或者查看每条iptables的序号<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -L INPUT --line-numbers</span><br><span class="line">然后删除</span><br><span class="line">iptables -D INPUT 2  <span class="comment">#删除第2条规则，即时生效</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="防火墙常用的策略"><a href="#防火墙常用的策略" class="headerlink" title="防火墙常用的策略"></a>防火墙常用的策略</h2><p>拒绝进入防火墙的所有ICMP协议数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p icmp -j REJECT</span><br></pre></td></tr></tbody></table></figure><p></p><p>允许防火墙转发除ICMP协议以外的所有数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -p ! icmp -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/24网段的数据<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -s 192.168.1.11 -j REJECT </span><br><span class="line">iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP </span><br><span class="line">iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP </span><br><span class="line">iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>封堵网段（192.168.1.0/24），两小时后解封。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 10.20.30.0/24 -j DROP </span><br><span class="line">iptables -I FORWARD -s 10.20.30.0/24 -j DROP </span><br><span class="line">at now 2 hours at> iptables -D INPUT 1 at> iptables -D FORWARD 1</span><br></pre></td></tr></tbody></table></figure><p></p><p>只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT </span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>允许本机开放从TCP端口20-1024提供的应用服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT </span><br><span class="line">iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT </span><br><span class="line">iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p icmp --icmp-type Echo-Request -j DROP </span><br><span class="line">iptables -I INPUT -p icmp --icmp-type Echo-Reply -j ACCEPT </span><br><span class="line">iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>禁止转发来自MAC地址为00：0C：29：27：55：3F的和主机的数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP</span><br><span class="line">说明：iptables中使用“-m 模块关键字”的形式调用显示匹配。这里用“-m mac –mac-source”来表示数据包的源MAC地址。</span><br></pre></td></tr></tbody></table></figure><p></p><p>允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT</span><br><span class="line">说明：这里用“-m multiport –dport”来指定目的端口及范围</span><br></pre></td></tr></tbody></table></figure><p></p><p>禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP</span><br><span class="line">说明：此处用“-m –iprange –src-range”指定IP范围。</span><br></pre></td></tr></tbody></table></figure><p></p><p>禁止转发与正常TCP连接无关的非—syn请求数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -m state --state NEW -p tcp ! --syn -j DROP</span><br><span class="line">说明：“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关的</span><br></pre></td></tr></tbody></table></figure><p></p><p>拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m state --state NEW -j DROP </span><br><span class="line">iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></tbody></table></figure><p></p><p>说明：“ESTABLISHED”表示已经响应请求或者已经建立连接的数据包，“RELATED”表示与已建立的连接有相关性的，比如FTP数据连接等。</p><p>只开放本机的web服务（80）、FTP(20、21、20450-20480)，放行外部主机发住服务器其它端口的应答数据包，将其他入站数据包均予以丢弃处理。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp -m multiport --dport 20,21,80 -j ACCEPT </span><br><span class="line">iptables -I INPUT -p tcp --dport 20450:20480 -j ACCEPT </span><br><span class="line">iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT </span><br><span class="line">iptables -P INPUT DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>下面两句话可以定义默认全部丢弃数据包：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br></pre></td></tr></tbody></table></figure><p></p><p>-P参数的意思是policy，翻译成策略～那么这两句话就好理解了。</p><p>第一句的意思是：</p><p>输入(INPUT)的数据包默认的策略(-P)是丢弃(DROP)的</p><p>第二句的意思是：</p><p>输出(OUTPUT)的数据包默认的策略(-P)是丢弃(DROP)的</p><p>其实到这里已经是一个有用的防火墙了，只不过，没有什么意义，和拔掉网线的概念没有什么不同</p><p>首先写下这6句话<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type any -j ACCEPT</span><br><span class="line">允许icmp包进入</span><br><span class="line">iptables -A INPUT -s localhost -d localhost -j ACCEPT</span><br><span class="line">允许本地的数据包</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">允许已经建立和相关的数据包进入</span><br><span class="line">iptables -A OUTPUT -p icmp --icmp any -j ACCEPT</span><br><span class="line">允许icmp包出去</span><br><span class="line">iptables -A OUTPUT -s localhost -d localhost -j ACCEPT</span><br><span class="line">允许本地数据包</span><br><span class="line">iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">允许已经建立和相关的数据包出去</span><br></pre></td></tr></tbody></table></figure><p></p><p>说明一下，这6句基本上都是要的</p><p>查看nat表<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -vnL POSTROUTING --line-number  </span><br><span class="line">Chain POSTROUTING (policy ACCEPT 38 packets, 2297 bytes)  </span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination  </span><br><span class="line">1        0     0 MASQUERADE  all  --  *      *       192.168.10.0/24      0.0.0.0/0</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看filter表<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n --line-number |grep 21 //--line-number可以显示规则序号，在删除的时候比较方便  </span><br><span class="line">5    ACCEPT     tcp  --  192.168.1.0/24       0.0.0.0/0           tcp dpt:21</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="附最经典的iptables脚本"><a href="#附最经典的iptables脚本" class="headerlink" title="附最经典的iptables脚本"></a>附最经典的iptables脚本</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">modprobe ipt_MASQUERADE</span><br><span class="line">modprobe ip_conntrack_ftp</span><br><span class="line">modprobe ip_nat_ftp</span><br><span class="line">iptables -F</span><br><span class="line">iptables -t nat -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -t nat -X</span><br><span class="line"><span class="comment">###########################INPUT键###################################</span></span><br><span class="line"></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -m multiport --dports 110,80,25 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -s 192.168.0.0/24 --dport 139 -j ACCEPT</span><br><span class="line"><span class="comment">#允许内网samba,smtp,pop3,连接</span></span><br><span class="line">iptables -A INPUT -i eth1 -p udp -m multiport --dports 53 -j ACCEPT</span><br><span class="line"><span class="comment">#允许dns连接</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 1723 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p gre -j ACCEPT</span><br><span class="line"><span class="comment">#允许外网vpn连接</span></span><br><span class="line">iptables -A INPUT -s 192.186.0.0/24 -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -A INPUT -i ppp0 -p tcp --syn -m connlimit --connlimit-above 15 -j DROP</span><br><span class="line"><span class="comment">#为了防止DOS太多连接进来,那么可以允许最多15个初始连接,超过的丢弃</span></span><br><span class="line">iptables -A INPUT -s 192.186.0.0/24 -p tcp --syn -m connlimit --connlimit-above 15 -j DROP</span><br><span class="line"><span class="comment">#为了防止DOS太多连接进来,那么可以允许最多15个初始连接,超过的丢弃</span></span><br><span class="line">iptables -A INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/s -j LOG --<span class="built_in">log</span>-level INFO --<span class="built_in">log</span>-prefix <span class="string">"ICMP packet IN: "</span></span><br><span class="line">iptables -A INPUT -p icmp -j DROP</span><br><span class="line"><span class="comment">#禁止icmp通信-ping 不通</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o ppp0 -s 192.168.0.0/24 -j MASQUERADE</span><br><span class="line"><span class="comment">#内网转发</span></span><br><span class="line">iptables -N syn-flood</span><br><span class="line">iptables -A INPUT -p tcp --syn -j syn-flood</span><br><span class="line">iptables -I syn-flood -p tcp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/s --<span class="built_in">limit</span>-burst 6 -j RETURN</span><br><span class="line">iptables -A syn-flood -j REJECT</span><br><span class="line"><span class="comment">#防止SYN攻击 轻量</span></span><br><span class="line"><span class="comment">#######################FORWARD链###########################</span></span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -A FORWARD -p tcp -s 192.168.0.0/24 -m multiport --dports 80,110,21,25,1723 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p udp -s 192.168.0.0/24 --dport 53 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p gre -s 192.168.0.0/24 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p icmp -s 192.168.0.0/24 -j ACCEPT</span><br><span class="line"><span class="comment">#允许 vpn客户走vpn网络连接外网</span></span><br><span class="line">iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -I FORWARD -p udp --dport 53 -m string --string <span class="string">"tencent"</span> -m time --timestart 8:15 --timestop 12:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的8:00-12:30禁止qq通信</span></span><br><span class="line">iptables -I FORWARD -p udp --dport 53 -m string --string <span class="string">"TENCENT"</span> -m time --timestart 8:15 --timestop 12:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的8:00-12:30禁止qq通信</span></span><br><span class="line">iptables -I FORWARD -p udp --dport 53 -m string --string <span class="string">"tencent"</span> -m time --timestart 13:30 --timestop 20:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line">iptables -I FORWARD -p udp --dport 53 -m string --string <span class="string">"TENCENT"</span> -m time --timestart 13:30 --timestop 20:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的13:30-20:30禁止QQ通信</span></span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/24 -m string --string <span class="string">"qq.com"</span> -m time --timestart 8:15 --timestop 12:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的8:00-12:30禁止qq网页</span></span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/24 -m string --string <span class="string">"qq.com"</span> -m time --timestart 13:00 --timestop 20:30 --days Mon,Tue,Wed,Thu,Fri,Sat  -j DROP</span><br><span class="line"><span class="comment">#星期一到星期六的13:30-20:30禁止QQ网页</span></span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/24 -m string --string <span class="string">"ay2000.net"</span> -j DROP</span><br><span class="line">iptables -I FORWARD -d 192.168.0.0/24 -m string --string <span class="string">"宽频影院"</span> -j DROP</span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/24 -m string --string <span class="string">"色情"</span> -j DROP</span><br><span class="line">iptables -I FORWARD -p tcp --sport 80 -m string --string <span class="string">"广告"</span> -j DROP</span><br><span class="line"><span class="comment">#禁止ay2000.net，宽频影院，色情，广告网页连接 ！但中文 不是很理想</span></span><br><span class="line">iptables -A FORWARD -m ipp2p --edk --kazaa --bit -j DROP</span><br><span class="line">iptables -A FORWARD -p tcp -m ipp2p --ares -j DROP</span><br><span class="line">iptables -A FORWARD -p udp -m ipp2p --kazaa -j DROP</span><br><span class="line"><span class="comment">#禁止BT连接</span></span><br><span class="line">iptables -A FORWARD -p tcp --syn --dport 80 -m connlimit --connlimit-above 15 --connlimit-mask 24</span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">sysctl -w net.ipv4.ip_forward=1 &>/dev/null</span><br><span class="line"><span class="comment">#打开转发</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies=1 &>/dev/null</span><br><span class="line"><span class="comment">#打开 syncookie （轻量级预防 DOS 攻击）</span></span><br><span class="line">sysctl -w net.ipv4.netfilter.ip_conntrack_tcp_timeout_established=3800 &>/dev/null</span><br><span class="line"><span class="comment">#设置默认 TCP 连接痴呆时长为 3800 秒（此选项可以大大降低连接数）</span></span><br><span class="line">sysctl -w net.ipv4.ip_conntrack_max=300000 &>/dev/null</span><br><span class="line"><span class="comment">#设置支持最大连接树为 30W（这个根据你的内存和 iptables 版本来，每个 connection 需要 300 多个字节）</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">iptables -I INPUT -s 192.168.0.50 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -s 192.168.0.50 -j ACCEPT</span><br><span class="line"><span class="comment">#192.168.0.50是我的机子，全部放行！</span></span><br><span class="line"><span class="comment">############################完#########################################</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux awk 命令</title>
      <link href="/2019/04/22/linux-awk/"/>
      <url>/2019/04/22/linux-awk/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="AAA.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>对今天解决不了的事情，也不要着急。因为明天也可能还是解决不了。</strong></p></blockquote><h2 id="awk命令例子："><a href="#awk命令例子：" class="headerlink" title="awk命令例子："></a>awk命令例子：</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打印文件的第一列(域)  awk <span class="string">'{print $1}'</span> filename</span><br><span class="line">打印文件的前两列(域)  awk <span class="string">'{print $1,$2}'</span> filename</span><br><span class="line">打印完第一列，然后打印第二列  awk <span class="string">'{print $1 $2}'</span> filename</span><br><span class="line">打印文本文件的总行数  awk <span class="string">'END{print NR}'</span> filename</span><br><span class="line">打印文本第一行       awk <span class="string">'NR==1{print}'</span> filename</span><br><span class="line">打印文本第二行第一列  sed -n <span class="string">"2, 1p"</span> filename | awk <span class="string">'print $1'</span></span><br></pre></td></tr></tbody></table></figure><p>Bash里面的赋值方法有两种，格式为<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) arg=`(命令)`</span><br><span class="line">2) arg=$(命令)</span><br></pre></td></tr></tbody></table></figure><p></p><p>想要把某一文件的总行数赋值给变量nlines，可以表达为：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) nlines=`(awk <span class="string">'END{print NR}'</span> filename)`</span><br><span class="line">或</span><br><span class="line">2) nlines=$(awk <span class="string">'END{print NR}'</span> filename)</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/[^0-9][0-9].*Starting the backup operation/{print $1,$2}'</span> /data/backup/logs/all.log</span><br><span class="line"><span class="comment">#181217 02:12:48</span></span><br><span class="line"><span class="comment">#181217 02:12:48 innobackupex: Starting the backup operation</span></span><br><span class="line">awk <span class="string">'/[^0-9][0-9].*OK\!/{print $1,$2}'</span> /data/backup/logs/all.log</span><br><span class="line"><span class="comment">#181217 03:51:21</span></span><br><span class="line"><span class="comment">#181217 03:51:21 completed OK!</span></span><br></pre></td></tr></tbody></table></figure><p>时间相减<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN{tstamp1=mktime("2108 12 18 02 12 48");tstamp2=mktime("2018 12 19 03 51 12");print tstamp2-tstamp1;}'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>从库周期性延迟 需要你从binlog中找出找个binlog 各种操作的统计<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --base64-output=<span class="string">'decode-rows'</span> -v -v mysql-bin.004177 | awk <span class="string">'/UPDATE|INSERT|DELETE/{gsub("###","");gsub("INSERT.*INTO","INSERT");gsub("DELETE.*FROM","DELETE");count[$1" "$2]++}END{for(i in count)print i,"\t",count[i]}'</span> |sort -k3nr|head -n 20</span><br></pre></td></tr></tbody></table></figure><p></p><p>netstat and AWK<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | awk <span class="string">'/^tcp/ {++S[$NF]};END {for(a in S) print a,S[a]}'</span></span><br><span class="line">netstat -an | awk <span class="string">'/^tcp/ {++state[$NF]}; END {for(key in state) print key,"\t",state[key]}'</span></span><br><span class="line">netstat -ant | awk <span class="string">'{print $NF}'</span> | grep -v <span class="string">'[a-z]'</span> | sort | uniq -c</span><br><span class="line"></span><br><span class="line">netstat -anlp | grep 3306 | grep tcp | awk <span class="string">'{print $5}'</span> | awk -F: <span class="string">'{print $1}'</span> | sort | uniq -c | sort -nr | head -n20</span><br><span class="line">netstat -ant | awk <span class="string">'/:3306/{split($5,ip,":");++A[ip[1]]}END{for(i in A) print A[i],i}'</span> | sort -nr | head -n20</span><br><span class="line"></span><br><span class="line">netstat -an | grep SYN | awk <span class="string">'{print $5}'</span> | awk -F: <span class="string">'{print $1}'</span> | sort | uniq -c | sort -nr | more</span><br><span class="line">tcpdump -i eno16777736 -tnn dst port 80 -c 1000 | awk -F<span class="string">"."</span> <span class="string">'{print $1"."$2"."$3"."$4}'</span> | sort | uniq -c | sort -nr | head -20</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看表的大小排序<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du -s *|grep ibd|sort|uniq -u|sort -nr|awk <span class="string">'{print $2}'</span>|xargs du -sh</span><br><span class="line">du -s *|grep ibd|sort|uniq -u|sort -nr|awk <span class="string">'{print $2}'</span>|sort|uniq -u|xargs du -sh</span><br></pre></td></tr></tbody></table></figure><p></p><p>僵尸进程<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -o <span class="built_in">stat</span>,ppid,pid,cmd | grep -e <span class="string">'\'</span><span class="string">'^[Zz]'</span>\<span class="string">''</span> | awk <span class="string">'\'</span><span class="string">'{print }'</span>\<span class="string">''</span> | xargs <span class="built_in">kill</span> -9<span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用FIO测试主机IOPS及写入读取速度</title>
      <link href="/2019/04/22/linux-fio/"/>
      <url>/2019/04/22/linux-fio/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>别说你一无所长，熬夜玩手机你是一把好手。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安装FIO<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install fio -y</span><br></pre></td></tr></tbody></table></figure><p></p><p>参数说明:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bs=4k                    单次io的块文件大小为4k</span><br><span class="line">bsrange=512-2048         同上，提定数据块的大小范围</span><br><span class="line">size=5g                  本次的测试文件大小为5g，以每次4k的io进行测试</span><br><span class="line">numjobs=30               本次的测试线程为30</span><br><span class="line">runtime=1000             测试时间为1000秒，如果不写则一直将5g文件分4k每次写完为止</span><br><span class="line">ioengine=psync           io引擎使用pync方式，如果要使用libaio引擎，需要yum install libaio-devel包</span><br><span class="line">rwmixwrite=30            在混合读写的模式下，写占30%</span><br><span class="line">group_reporting          关于显示结果的，汇总每个进程的信息此外</span><br><span class="line">lockmem=1g               只使用1g内存进行测试</span><br><span class="line">zero_buffers             用0初始化系统buffer</span><br><span class="line">nrfiles=8                每个进程生成文件的数量</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="FIO-命令"><a href="#FIO-命令" class="headerlink" title="FIO 命令"></a>FIO 命令</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">fio -direct=1 -iodepth=128 -rw=write -ioengine=libaio -bs=4k -size=100G -numjobs=1 -runtime=1000 -group_reporting -name=<span class="built_in">test</span> -filename=/data/test111</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="built_in">test</span>: (g=0): rw=write, bs=4K-4K/4K-4K/4K-4K, ioengine=libaio, iodepth=128</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 1 process</span><br><span class="line"><span class="built_in">test</span>: Laying out IO file(s) (1 file(s) / 102400MB)</span><br><span class="line">Jobs: 1 (f=1): [W] [100.0% <span class="keyword">done</span>] [0K/129.3M/0K /s] [0 /33.1K/0  iops] [eta 00m:00s]</span><br><span class="line"><span class="built_in">test</span>: (groupid=0, <span class="built_in">jobs</span>=1): err= 0: pid=594: Mon May 14 10:27:54 2018</span><br><span class="line">  write: io=102400MB, bw=129763KB/s, iops=32440 , runt=808070msec</span><br><span class="line">    slat (usec): min=0 , max=80322 , avg=12.06, stdev=24.73</span><br><span class="line">    clat (usec): min=222 , max=254410 , avg=3932.47, stdev=5007.90</span><br><span class="line">     lat (usec): min=622 , max=254416 , avg=3944.82, stdev=5007.26</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1288],  5.00th=[ 1560], 10.00th=[ 1736], 20.00th=[ 1992],</span><br><span class="line">     | 30.00th=[ 2224], 40.00th=[ 2480], 50.00th=[ 2736], 60.00th=[ 3088],</span><br><span class="line">     | 70.00th=[ 3536], 80.00th=[ 4320], 90.00th=[ 6624], 95.00th=[ 9664],</span><br><span class="line">     | 99.00th=[21120], 99.50th=[37632], 99.90th=[54528], 99.95th=[78336],</span><br><span class="line">     | 99.99th=[177152]</span><br><span class="line">    bw (KB/s)  : min=20720, max=215424, per=100.00%, avg=129801.50, stdev=19878.75</span><br><span class="line">    lat (usec) : 250=0.01%, 750=0.01%, 1000=0.09%</span><br><span class="line">    lat (msec) : 2=20.47%, 4=56.01%, 10=18.78%, 20=3.20%, 50=1.33%</span><br><span class="line">    lat (msec) : 100=0.09%, 250=0.02%, 500=0.01%</span><br><span class="line">  cpu          : usr=4.88%, sys=36.64%, ctx=9409837, majf=0, minf=23</span><br><span class="line">  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, >=64=100.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.1%</span><br><span class="line">     issued    : total=r=0/w=26214400/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">  WRITE: io=102400MB, aggrb=129763KB/s, minb=129763KB/s, maxb=129763KB/s, mint=808070msec, maxt=808070msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=0/26203032, merge=0/3962, ticks=0/90681446, in_queue=90672667, util=100.00%</span><br></pre></td></tr></tbody></table></figure><p>100%随机，100%读，4K<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=randread -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=rand_100read_4k</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">rand_100read_4k: (g=0): rw=randread, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">rand_100read_4k: (g=0): rw=randread, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr] [100.0% <span class="keyword">done</span>] [47544K/0K/0K /s] [11.9K/0 /0  iops] [eta 00m:00s]</span><br><span class="line">rand_100read_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=25884: Mon May 14 14:59:44 2018</span><br><span class="line">  <span class="built_in">read</span> : io=8454.3MB, bw=48091KB/s, iops=12022 , runt=180018msec</span><br><span class="line">    clat (usec): min=318 , max=167471 , avg=4156.60, stdev=8363.94</span><br><span class="line">     lat (usec): min=318 , max=167472 , avg=4156.89, stdev=8363.95</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1032],  5.00th=[ 1176], 10.00th=[ 1240], 20.00th=[ 1352],</span><br><span class="line">     | 30.00th=[ 1464], 40.00th=[ 1688], 50.00th=[ 1832], 60.00th=[ 1944],</span><br><span class="line">     | 70.00th=[ 2064], 80.00th=[ 2288], 90.00th=[15808], 95.00th=[18560],</span><br><span class="line">     | 99.00th=[20608], 99.50th=[39168], 99.90th=[134144], 99.95th=[144384],</span><br><span class="line">     | 99.99th=[156672]</span><br><span class="line">    bw (KB/s)  : min=  231, max= 7248, per=2.00%, avg=961.78, stdev=384.46</span><br><span class="line">    lat (usec) : 500=0.05%, 750=0.20%, 1000=0.51%</span><br><span class="line">    lat (msec) : 2=64.37%, 4=19.62%, 10=2.88%, 20=10.62%, 50=1.52%</span><br><span class="line">    lat (msec) : 100=0.02%, 250=0.23%</span><br><span class="line">  cpu          : usr=0.00%, sys=0.02%, ctx=1813752, majf=18446744073709550866, minf=18446744073698419008</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     issued    : total=r=2164296/w=0/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">   READ: io=8454.3MB, aggrb=48090KB/s, minb=48090KB/s, maxb=48090KB/s, mint=180018msec, maxt=180018msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=2163559/42, merge=23/10, ticks=8925036/223, in_queue=8922540, util=99.94%</span><br><span class="line">100%随机，100%写， 4K</span><br><span class="line"></span><br><span class="line">[root@<span class="built_in">test</span>-db data]<span class="comment"># fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=randwrite -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=rand_100write_4k</span></span><br><span class="line">运行结果：</span><br><span class="line">rand_100write_4k: (g=0): rw=randwrite, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">rand_100write_4k: (g=0): rw=randwrite, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww] [100.0% <span class="keyword">done</span>] [0K/47996K/0K /s] [0 /11.1K/0  iops] [eta 00m:00s]</span><br><span class="line">rand_100write_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=25963: Mon May 14 15:08:43 2018</span><br><span class="line">  write: io=8445.5MB, bw=48039KB/s, iops=12009 , runt=180024msec</span><br></pre></td></tr></tbody></table></figure><p></p><p>100%顺序，100%读 ，4K<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=<span class="built_in">read</span> -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=sqe_100read_4k</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">sqe_100read_4k: (g=0): rw=<span class="built_in">read</span>, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR] [100.0% <span class="keyword">done</span>] [59996K/0K/0K /s] [14.1K/0 /0  iops] [eta 00m:00s]</span><br><span class="line">sqe_100read_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=26047: Mon May 14 15:13:02 2018</span><br><span class="line">  <span class="built_in">read</span> : io=10599MB, bw=60295KB/s, iops=15073 , runt=180006msec</span><br><span class="line">    clat (usec): min=253 , max=550591 , avg=3315.70, stdev=26406.30</span><br><span class="line">     lat (usec): min=254 , max=550591 , avg=3315.95, stdev=26406.30</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1176],  5.00th=[ 1240], 10.00th=[ 1256], 20.00th=[ 1288],</span><br><span class="line">     | 30.00th=[ 1336], 40.00th=[ 1368], 50.00th=[ 1416], 60.00th=[ 1480],</span><br><span class="line">     | 70.00th=[ 1528], 80.00th=[ 1592], 90.00th=[ 1736], 95.00th=[ 2800],</span><br><span class="line">     | 99.00th=[17792], 99.50th=[18816], 99.90th=[522240], 99.95th=[528384],</span><br><span class="line">     | 99.99th=[536576]</span><br><span class="line">    bw (KB/s)  : min=   15, max= 2475, per=2.00%, avg=1206.47, stdev=634.32</span><br><span class="line">    lat (usec) : 500=0.01%, 750=0.01%, 1000=0.04%</span><br><span class="line">    lat (msec) : 2=92.64%, 4=3.87%, 10=1.05%, 20=2.03%, 50=0.01%</span><br><span class="line">    lat (msec) : 250=0.01%, 500=0.17%, 750=0.15%</span><br><span class="line">  cpu          : usr=0.05%, sys=0.23%, ctx=2697397, majf=0, minf=18446744073708900853</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     issued    : total=r=2713362/w=0/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">   READ: io=10599MB, aggrb=60294KB/s, minb=60294KB/s, maxb=60294KB/s, mint=180006msec, maxt=180006msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=2711304/55, merge=1805/10, ticks=8899022/202, in_queue=8898860, util=100.00%</span><br></pre></td></tr></tbody></table></figure><p></p><p>100%顺序，100%写 ，4K<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=write -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=sqe_100write_4k</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">sqe_100write_4k: (g=0): rw=write, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">sqe_100write_4k: (g=0): rw=write, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW] [100.0% <span class="keyword">done</span>] [0K/55788K/0K /s] [0 /13.1K/0  iops] [eta 00m:00s]</span><br><span class="line">sqe_100write_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=26100: Mon May 14 15:17:24 2018</span><br><span class="line">  write: io=10002MB, bw=56896KB/s, iops=14224 , runt=180019msec</span><br><span class="line">    clat (usec): min=583 , max=457330 , avg=3513.01, stdev=9958.13</span><br><span class="line">     lat (usec): min=584 , max=457331 , avg=3513.60, stdev=9958.13</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1224],  5.00th=[ 1384], 10.00th=[ 1480], 20.00th=[ 1592],</span><br><span class="line">     | 30.00th=[ 1672], 40.00th=[ 1752], 50.00th=[ 1832], 60.00th=[ 1928],</span><br><span class="line">     | 70.00th=[ 2096], 80.00th=[ 2480], 90.00th=[ 6368], 95.00th=[12480],</span><br><span class="line">     | 99.00th=[20608], 99.50th=[37120], 99.90th=[166912], 99.95th=[268288],</span><br><span class="line">     | 99.99th=[346112]</span><br><span class="line">    bw (KB/s)  : min=  152, max= 2432, per=2.01%, avg=1141.03, stdev=401.10</span><br><span class="line">    lat (usec) : 750=0.01%, 1000=0.11%</span><br><span class="line">    lat (msec) : 2=65.06%, 4=21.62%, 10=7.36%, 20=4.40%, 50=1.24%</span><br><span class="line">    lat (msec) : 100=0.08%, 250=0.06%, 500=0.07%</span><br><span class="line">  cpu          : usr=0.05%, sys=0.38%, ctx=2547790, majf=0, minf=18446744073708899536</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     issued    : total=r=0/w=2560604/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">  WRITE: io=10002MB, aggrb=56896KB/s, minb=56896KB/s, maxb=56896KB/s, mint=180019msec, maxt=180019msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=63/2558949, merge=0/275, ticks=12/8897256, in_queue=8895411, util=100.00%</span><br></pre></td></tr></tbody></table></figure><p></p><p>100%随机，70%读，30%写 4K<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb1 -direct=1 -iodepth 1 -thread -rw=randrw -rwmixread=70 -ioengine=psync -bs=4k -size=100G -numjobs=50 -runtime=180 -group_reporting -name=randrw_70read_4k</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">randrw_70read_4k: (g=0): rw=randrw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">randrw_70read_4k: (g=0): rw=randrw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1</span><br><span class="line">fio-2.0.13</span><br><span class="line">Starting 50 threads</span><br><span class="line">Jobs: 50 (f=50): [mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm] [100.0% <span class="keyword">done</span>] [48012K/20800K/0K /s] [12.3K/5200 /0  iops] [eta 00m:00s]</span><br><span class="line">randrw_70read_4k: (groupid=0, <span class="built_in">jobs</span>=50): err= 0: pid=26162: Mon May 14 15:29:18 2018</span><br><span class="line">  <span class="built_in">read</span> : io=8430.4MB, bw=47954KB/s, iops=11988 , runt=180020msec</span><br><span class="line">    clat (usec): min=304 , max=177969 , avg=3045.60, stdev=5103.08</span><br><span class="line">     lat (usec): min=304 , max=177970 , avg=3045.87, stdev=5103.08</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[  860],  5.00th=[ 1048], 10.00th=[ 1160], 20.00th=[ 1320],</span><br><span class="line">     | 30.00th=[ 1448], 40.00th=[ 1560], 50.00th=[ 1656], 60.00th=[ 1768],</span><br><span class="line">     | 70.00th=[ 1896], 80.00th=[ 2128], 90.00th=[ 4384], 95.00th=[17792],</span><br><span class="line">     | 99.00th=[20352], 99.50th=[28544], 99.90th=[41216], 99.95th=[57088],</span><br><span class="line">     | 99.99th=[127488]</span><br><span class="line">    bw (KB/s)  : min=  206, max= 4424, per=2.00%, avg=959.77, stdev=408.18</span><br><span class="line">  write: io=3613.8MB, bw=20556KB/s, iops=5138 , runt=180020msec</span><br><span class="line">    clat (usec): min=569 , max=157336 , avg=2617.23, stdev=2821.20</span><br><span class="line">     lat (usec): min=570 , max=157337 , avg=2617.81, stdev=2821.20</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1096],  5.00th=[ 1432], 10.00th=[ 1592], 20.00th=[ 1768],</span><br><span class="line">     | 30.00th=[ 1912], 40.00th=[ 2040], 50.00th=[ 2160], 60.00th=[ 2288],</span><br><span class="line">     | 70.00th=[ 2416], 80.00th=[ 2576], 90.00th=[ 2864], 95.00th=[ 3472],</span><br><span class="line">     | 99.00th=[19328], 99.50th=[20352], 99.90th=[22400], 99.95th=[37632],</span><br><span class="line">     | 99.99th=[52992]</span><br><span class="line">    bw (KB/s)  : min=   62, max= 1888, per=2.00%, avg=411.23, stdev=178.61</span><br><span class="line">    lat (usec) : 500=0.06%, 750=0.22%, 1000=2.28%</span><br><span class="line">    lat (msec) : 2=61.13%, 4=27.68%, 10=3.02%, 20=4.48%, 50=1.07%</span><br><span class="line">    lat (msec) : 100=0.04%, 250=0.01%</span><br><span class="line">  cpu          : usr=0.01%, sys=0.08%, ctx=2743663, majf=0, minf=18446744073698904078</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%</span><br><span class="line">     issued    : total=r=2158165/w=925122/d=0, short=r=0/w=0/d=0</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">   READ: io=8430.4MB, aggrb=47953KB/s, minb=47953KB/s, maxb=47953KB/s, mint=180020msec, maxt=180020msec</span><br><span class="line">  WRITE: io=3613.8MB, aggrb=20555KB/s, minb=20555KB/s, maxb=20555KB/s, mint=180020msec, maxt=180020msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  vdb: ios=2154562/923535, merge=0/0, ticks=6503566/2394699, in_queue=8896553, util=99.93%</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行结果说明:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">io=执行了多少M的IO</span><br><span class="line">bw=平均IO带宽</span><br><span class="line">iops=IOPS</span><br><span class="line">runt=线程运行时间</span><br><span class="line">slat=提交延迟</span><br><span class="line">clat=完成延迟</span><br><span class="line">lat=响应时间</span><br><span class="line">bw=带宽</span><br><span class="line">cpu=利用率</span><br><span class="line">IO depths=io队列</span><br><span class="line">IO submit=单个IO提交要提交的IO数</span><br><span class="line">IO complete=Like the above submit number, but <span class="keyword">for</span> completions instead.</span><br><span class="line">IO issued=The number of <span class="built_in">read</span>/write requests issued, and how many of them were short.</span><br><span class="line">IO latencies=IO完延迟的分布</span><br><span class="line"></span><br><span class="line">io=总共执行了多少size的IO</span><br><span class="line">aggrb=group总带宽</span><br><span class="line">minb=最小.平均带宽.</span><br><span class="line">maxb=最大平均带宽.</span><br><span class="line">mint=group中线程的最短运行时间.</span><br><span class="line">maxt=group中线程的最长运行时间.</span><br><span class="line"></span><br><span class="line">ios=所有group总共执行的IO数.</span><br><span class="line">merge=总共发生的IO合并数.</span><br><span class="line">ticks=Number of ticks we kept the disk busy.</span><br><span class="line">io_queue=花费在队列上的总共时间.</span><br><span class="line">util=磁盘利用率</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl 来测试网站-dns解析时间,响应时间,传输时间</title>
      <link href="/2019/04/22/curl-dns-time/"/>
      <url>/2019/04/22/curl-dns-time/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>有些人努力了一辈子，也就从社会的四流进入了三流。</strong></p></blockquote><h2 id="获取-解析时间-响应时间-传输时间"><a href="#获取-解析时间-响应时间-传输时间" class="headerlink" title="获取 解析时间:响应时间:传输时间"></a>获取 解析时间:响应时间:传输时间</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># curl -o /dev/null -s -w %{time_connect}:%{time_starttransfer}:%{time_total} https://jiemin.wang    </span></span><br><span class="line">0.104:0.000:18.174</span><br></pre></td></tr></tbody></table></figure><img src="/2019/04/22/curl-dns-time/curl.jpg" title="curl"><p>给出对站点执行 <code>curl</code> 命令的情况.输出通常是 <code>HTML 代码</code>,通过 <code>-o</code> 参数发送到 <code>/dev/null</code>. <code>-s</code> 参数去掉所有状态信息. <code>-w</code> 参数让 <code>curl</code> 写出计时器的状态信息。</p><p>参数说明:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time_connect        建立到服务器的 TCP 连接所用的时间</span><br><span class="line">time_starttransfer  在发出请求之后,Web 服务器返回数据的第一个字节所用的时间</span><br><span class="line">time_total          完成请求所用的时间</span><br><span class="line">time_namelookup     DNS解析时间,从请求开始到DNS解析完毕所用时间(记得关掉 Linux 的 nscd 的服务测试)</span><br><span class="line">speed_download      下载速度，单位-字节每秒。</span><br></pre></td></tr></tbody></table></figure><p></p><p>这些计时器都相对于事务的起始时间,甚至要先于 <code>Domain Name Service（DNS</code>）查询.因此,在发出请求之后,Web 服务器处理请求并开始发回数据所用的时间是 0.000 - 0.104 = 0 秒.客户机从服务器下载数据所用的时间是 18.174 - 0.000 = 18 秒.</p><p>通过观察 curl 数据及其随时间变化的趋势,可以很好地了解站点对用户的响应性.以上变量会按CURL认为合适的格式输出，输出变量需要按照<code>%{variable_name}</code>的格式，如果需要<code>输出%</code>，double一下即可，即<code>%%</code>，同时，<code>n是换行</code>，<code>r是回车</code>，<code>t是TAB</code>。</p><p>当然,Web 站点不仅仅由页面组成.它还有图像、JavaScript 代码、CSS 和 cookie 要处理.curl 很适合了解单一元素的响应时间,但是有时候需要了解整个页面的装载速度.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-TIME-WAIT</title>
      <link href="/2019/04/22/linux-TIME-WAIT/"/>
      <url>/2019/04/22/linux-TIME-WAIT/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>没事听听别人口中的自己，这比看大片还刺激，你会发现你什么都没做，但已经演了好多版本，都是大角色。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>TIME_WAIT</code> 状态原理<br>当客户端主动关闭连接时，会发送最后一个<code>ACK</code>，然后会进入<code>TIME_WAIT</code>状态，再停留2个<code>MSL时间(约1-4分钟)</code>，进入<code>CLOSED</code>状态。<br><img src="/2019/04/22/linux-TIME-WAIT/tcp.png" title="tcp"></p><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>CentOS6/7.x默认没有对系统参数进行设置，当大量<code>TIME_WAIT</code>产生的时候会影响系统性能，</p><p>统计<code>TIME_WAIT</code>状态数量<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | grep TIME_WAIT | wc -l</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看系统当前连接状态<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk <span class="string">'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</span></span><br><span class="line">TIME_WAIT 1280</span><br><span class="line">FIN_WAIT1 7</span><br><span class="line">SYN_SENT 1</span><br><span class="line">FIN_WAIT2 7</span><br><span class="line">ESTABLISHED 247</span><br><span class="line">LAST_ACK 1</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们只用关心<code>TIME_WAIT</code>的个数，在这里可以看到，有1280多个<code>TIME_WAIT</code>，这样就占用了1280多个端口，端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接，就需调整下Linux的TCP内核参数，让系统更快的释放<code>TIME_WAIT</code>连接。</p><p>解决方法如下：</p><p>修改内核配置<code>vim /etc/sysctl.conf</code> ，加入以下内容：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1         <span class="comment">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1           <span class="comment">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1         <span class="comment">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30       <span class="comment">#修改系統默认的 TIMEOUT 时间。</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>然后执行<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/sysctl -p</span><br></pre></td></tr></tbody></table></figure><p></p><p>让参数生效。</p><p>参数说明:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time = 1200   <span class="comment">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span></span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000   <span class="comment">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192  <span class="comment">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000  <span class="comment">#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认180000，改为6000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。</span></span><br><span class="line"></span><br><span class="line">内核其他TCP参数说明：</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65536  <span class="comment">#记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。</span></span><br><span class="line">net.core.netdev_max_backlog = 32768   <span class="comment">#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span></span><br><span class="line">net.core.somaxconn = 32768   <span class="comment">#web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。</span></span><br><span class="line"></span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">net.core.rmem_max = 16777216           <span class="comment">#最大socket读buffer,可参考的优化值:873200</span></span><br><span class="line">net.core.wmem_max = 16777216           <span class="comment">#最大socket写buffer,可参考的优化值:873200</span></span><br><span class="line">net.ipv4.tcp_timestsmps = 0    <span class="comment">#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。</span></span><br><span class="line">net.ipv4.tcp_synack_retries = 2   <span class="comment">#为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。</span></span><br><span class="line">net.ipv4.tcp_syn_retries = 2  <span class="comment">#在内核放弃建立连接之前发送SYN包的数量。</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1     <span class="comment"># 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_wmem = 8192 436600 873200   <span class="comment"># TCP写buffer,可参考的优化值: 8192 436600 873200</span></span><br><span class="line">net.ipv4.tcp_rmem  = 32768 436600 873200  <span class="comment"># TCP读buffer,可参考的优化值: 32768 436600 873200</span></span><br><span class="line">net.ipv4.tcp_mem = 94500000 91500000 92700000  <span class="comment"># 同样有3个值,意思是:</span></span><br><span class="line">net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。</span><br><span class="line">net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。</span><br><span class="line">net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。</span><br><span class="line">上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800   <span class="comment">#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。</span></span><br><span class="line">如果超过这个数字，连接将即刻被复位并打印出警告信息。</span><br><span class="line">这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，</span><br><span class="line">更应该增加这个值(如果增加了内存之后)。</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30   <span class="comment">#如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux dd 命令详解</title>
      <link href="/2019/04/22/linux-dd/"/>
      <url>/2019/04/22/linux-dd/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>一直对发型和身材不满意的人，有一个共同点：不肯承认这是脸的问题。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p><p>注意：指定数字的地方若以下列字符结尾，则乘以相应的数字</p><ul><li>b=512</li><li>c=1</li><li>k=1024</li><li>w=2</li></ul><h2 id="dd-命令例子"><a href="#dd-命令例子" class="headerlink" title="dd 命令例子"></a>dd 命令例子</h2><h4 id="dd-创建测试文件"><a href="#dd-创建测试文件" class="headerlink" title="dd 创建测试文件"></a>dd 创建测试文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">CODE:[Copy to clipboard]dd 〔选项〕</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> =输入文件(或设备名称)。</span><br><span class="line">of =输出文件(或设备名称)。</span><br><span class="line">ibs = bytes 一次读取bytes字节，即读入缓冲区的字节数。</span><br><span class="line">skip = blocks 跳过读入缓冲区开头的ibs*blocks块。</span><br><span class="line">obs = bytes 一次写入bytes字节，即写 入缓冲区的字节数。</span><br><span class="line">bs = bytes 同时设置读/写缓冲区的字节数(等于设置obs和obs)。</span><br><span class="line">cbs = bytes 一次转换bytes字节。</span><br><span class="line">count = blocks 只拷贝输入的blocks块。</span><br><span class="line">conv = ASCII 把EBCDIC码转换为ASCII码。</span><br><span class="line">conv = ebcdic 把ASCII码转换为EBCDIC码。</span><br><span class="line">conv = ibm 把ASCII码转换为alternate EBCDIC码。</span><br><span class="line">conv = blick 把变动位转换成固定字符。</span><br><span class="line">conv = ublock 把固定们转换成变动位</span><br><span class="line">conv = ucase 把字母由小写变为大写。</span><br><span class="line">conv = lcase 把字母由大写变为小写。</span><br><span class="line">conv = notrunc 不截短输出文件。</span><br><span class="line">conv = swab 交换每一对输入字节。</span><br><span class="line">conv = noerror 出错时不停止处理。</span><br><span class="line">conv = sync 把每个输入记录的大小都调到ibs的大小(用ibs填充)。</span><br><span class="line">fdformat命令</span><br><span class="line">低级格式化软盘。</span><br></pre></td></tr></tbody></table></figure><h4 id="创建一个2G的文件"><a href="#创建一个2G的文件" class="headerlink" title="创建一个2G的文件"></a>创建一个2G的文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero  of=/tmp/<span class="built_in">test</span> bs=1M count=2048</span><br></pre></td></tr></tbody></table></figure><h4 id="测试硬盘读写速度"><a href="#测试硬盘读写速度" class="headerlink" title="测试硬盘读写速度"></a>测试硬盘读写速度</h4><p>通过两个命令输出的执行时间，可以计算出测试硬盘的读／写速度:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/root/1Gb.file bs=64k | dd of=/dev/null</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/root/1Gb.file bs=1024 count=1000000</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="销毁磁盘数据"><a href="#销毁磁盘数据" class="headerlink" title="销毁磁盘数据"></a>销毁磁盘数据</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/urandom of=/dev/hda1</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：<strong><code>利用随机的数据填充硬盘</code></strong>，在某些必要的场合可以用来销毁数据。</p></blockquote><h4 id="确定硬盘的最佳块大小"><a href="#确定硬盘的最佳块大小" class="headerlink" title="确定硬盘的最佳块大小"></a>确定硬盘的最佳块大小</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=2048 count=500000 of=/root/1Gb.file</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=4096 count=250000 of=/root/1Gb.file</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=8192 count=125000 of=/root/1Gb.file</span><br></pre></td></tr></tbody></table></figure><blockquote><p>通过比较以上命令输出中所显示的<strong><code>命令执行时间</code></strong>，即可确定系统最佳的块大小。</p></blockquote><h4 id="备份与恢复MBR"><a href="#备份与恢复MBR" class="headerlink" title="备份与恢复MBR"></a>备份与恢复MBR</h4><p>备份磁盘开始的512个字节大小的MBR信息到指定文件：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/hda of=/root/image count=1 bs=512</span><br><span class="line"><span class="comment"># count=1指仅拷贝一个块；bs=512指块大小为512个字节。</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>将备份的MBR信息写到磁盘开始部分<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/root/image of=/dev/had</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="拷贝内存内容到硬盘"><a href="#拷贝内存内容到硬盘" class="headerlink" title="拷贝内存内容到硬盘"></a>拷贝内存内容到硬盘</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/mem of=/root/mem.bin bs=1024</span><br><span class="line"><span class="comment"># 指定块大小为1k</span></span><br></pre></td></tr></tbody></table></figure><h4 id="修复硬盘"><a href="#修复硬盘" class="headerlink" title="修复硬盘"></a>修复硬盘</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/dev/sda</span><br><span class="line">或者</span><br><span class="line">dd <span class="keyword">if</span>=/dev/hda of=/dev/hda</span><br></pre></td></tr></tbody></table></figure><h4 id="将一个很大的视频文件中的第i个字节的值改成0x41（也就是大写字母A的ASCII值）"><a href="#将一个很大的视频文件中的第i个字节的值改成0x41（也就是大写字母A的ASCII值）" class="headerlink" title="将一个很大的视频文件中的第i个字节的值改成0x41（也就是大写字母A的ASCII值）"></a>将一个很大的视频文件中的第i个字节的值改成0x41（也就是大写字母A的ASCII值）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> A | dd of=bigfile seek=<span class="variable">$i</span> bs=1 count=1 conv=notrunc</span><br></pre></td></tr></tbody></table></figure><h2 id="结尾总结"><a href="#结尾总结" class="headerlink" title="结尾总结"></a>结尾总结</h2><h4 id="dev-null和-dev-zero的区别"><a href="#dev-null和-dev-zero的区别" class="headerlink" title="/dev/null和/dev/zero的区别"></a>/dev/null和/dev/zero的区别</h4><ul><li>/dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！</li><li>/dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！</li><li><p>/dev/null，它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶。</p></li><li><p>/dev/zero,是一个输入设备，你可你用它来初始化文件。</p></li><li>/dev/zero,是一个输入设备，你可你用它来初始化文件。</li><li>/dev/zero，该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改sync_binlog innodb_flush_log_at_trx_commit和sync_binlog参数 提高写入速度</title>
      <link href="/2019/04/22/sync-binlog-innodb-flush-log-at-trx-commit/"/>
      <url>/2019/04/22/sync-binlog-innodb-flush-log-at-trx-commit/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>胸小的姑娘一般脾气都特大，胸大的姑娘一般脾气都特好，因为古语有云：穷凶极恶有容乃大！</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>innodb_flush_log_at_trx_commit</code>和<code>sync_binlog</code> 两个参数是控制MySQL 磁盘写入策略以及数据安全性的关键参数。</p><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><h4 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h4><ul><li>如果<code>innodb_flush_log_at_trx_commit</code>设置为<code>0</code>，<code>log buffer</code>将每秒一次地写入<code>log file</code>中，并且<code>log file</code>的<code>flush(刷到磁盘)</code>操作同时进行，该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。</li><li>如果<code>innodb_flush_log_at_trx_commit</code>设置为<code>1</code>，每次事务提交时MySQL都会把<code>log buffer</code>的数据写入<code>log file</code>，并且<code>flush(刷到磁盘)</code>中去。</li><li>如果<code>innodb_flush_log_at_trx_commit</code>设置为<code>2</code>，每次事务提交时MySQL都会把<code>log buffer</code>的数据写入<code>log file</code>.但是<code>flush(刷到磁盘)</code>操作并不会同时进行。该模式下,MySQL会每秒执行一次 <code>flush(刷到磁盘)</code>操作。<blockquote><p>注：<br>由于进程调度策略问题,这个”每秒执行一次 <code>flush(刷到磁盘)</code>操作”并不是保证100%的”每秒”。</p></blockquote></li></ul><h5 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync_binlog"></a>sync_binlog</h5><p><code>sync_binlog</code> 的默认值是<code>0</code>，像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中去而是依赖操作系统来刷新<code>binary log</code>。</p><p>当<code>sync_binlog =N (N>0)</code> ，MySQL 在每写 <code>N次</code> 二进制日志<code>binary log</code>时，会使用<code>fdatasync()函数</code>将它的写二进制日志<code>binary log</code>同步到磁盘中去。</p><p>如果启用了<code>autocommit</code>，那么每一个语句<code>statement</code>就会有一次写操作；否则每个事务对应一个写操作。</p><p>由此可见，当两个参数设置为双1的时候，写入性能最差，<code>sync_binlog=N (N>1 )</code> and <code>innodb_flush_log_at_trx_commit=2</code> 时，(在当前模式下)MySQL的写操作才能达到最高性能。 </p><ul><li>当<code>innodb_flush_log_at_trx_commit</code>和<code>sync_binlog</code> 都为 <code>1</code> 时是最安全的，在mysqld 服务崩溃或者服务器主机<code>crash</code>的情况下，<code>binary log</code> 只有可能丢失最多一个语句或者一个事务。但是鱼与熊掌不可兼得，双11 会导致频繁的io操作，因此该模式也是最慢的一种方式。</li><li>当<code>innodb_flush_log_at_trx_commit</code>设置为<code>0</code>，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li><li>当<code>innodb_flush_log_at_trx_commit</code>设置为<code>2</code>，只有在操作系统崩溃或者系统掉电的情况下，上一秒钟所有事务数据才可能丢失。</li></ul><p>双1适合数据安全性要求非常高，而且磁盘IO写能力足够支持业务，比如订单,交易,充值,支付消费系统。</p><p>推荐的做法是 <code>innodb_flush_log_at_trx_commit=2</code> ，<code>sync_binlog=N (N为500 或1000)</code> 且使用<code>带蓄电池后备电源</code>的<code>缓存cache</code>，防止系统断电异常。</p><p>系统性能和数据安全是业务系统高可用稳定的必要因素。我们对系统的优化需要寻找一个平衡点，合适的才是最好的，根据不同的业务场景需求，可以将两个参数做组合调整，以便是db系统的性能达到最优化。</p><blockquote><p>PS: 两个都为1的时候，导入数据约18分钟，优化后导入整库约3分钟。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit=2 </span><br><span class="line">sync_binlog=1000</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 执行 command</title>
      <link href="/2019/04/20/go-command/"/>
      <url>/2019/04/20/go-command/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.gif" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>你并不是一无所有，至少你有肉。</strong></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>golang中会经常遇到要 fork 子进程的需求。go 标准库为我们封装了 os/exec标准包,当我们要运行外部命令时应该优先使用这个库。这里我简单结合context 和 Cmd 模块写一个通用的执行 command 方法。代码如下:<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">    <span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunCmd</span><span class="params">(ctx context.Context, cmd *exec.Cmd)</span> <span class="title">error</span></span> {</span><br><span class="line">    cmd.SysProcAttr = &syscall.SysProcAttr{</span><br><span class="line">        Setpgid: <span class="literal">true</span>,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        errCh <- cmd.Wait()</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    done := ctx.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> <-done:</span><br><span class="line">            done = <span class="literal">nil</span></span><br><span class="line">            pid := cmd.Process.Pid</span><br><span class="line">            <span class="keyword">if</span> err := syscall.Kill(<span class="number">-1</span>*pid, syscall.SIGKILL); err != <span class="literal">nil</span> {</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">case</span> err := <-errCh:</span><br><span class="line">            <span class="keyword">if</span> done == <span class="literal">nil</span> {</span><br><span class="line">                <span class="keyword">return</span> ctx.Err()</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>可以通过 context 控制命令执行, 调用方可以调用cancel 或者设置超时控制命令执行生命周期</li><li>如果进程执行失败, 应当 kill 整个进程组, 防止该进程 fork 的子进程逃逸</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL闪回原理与实战</title>
      <link href="/2019/04/19/mysql-flashback-priciple-and-practice/"/>
      <url>/2019/04/19/mysql-flashback-priciple-and-practice/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>能用钱解决的问题都不是问题，可问题是我是穷人。</strong></p></blockquote><p>DBA或开发人员，有时会误删或者误更新数据，如果是线上环境并且影响较大，就需要能快速回滚。传统恢复方法是利用备份重搭实例，再应用去除错误sql后的binlog来恢复数据。此法费时费力，甚至需要停机维护，并不适合快速回滚。也有团队利用LVM快照来缩短恢复时间，但快照的缺点是会影响mysql的性能。</p><p>MySQL闪回(flashback)利用binlog直接进行回滚，能快速恢复且不用停机。本文将介绍闪回原理，给出笔者的实战经验，并对现存的闪回工具作比较。</p><h1 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h1><p>某天，小明因种种原因，误删了大批线上用户表的数据。他急忙找到公司DBA请求帮助，“客服电话已被打爆，大量用户投诉无法登陆，领导非常恼火。请问多久能恢复数据？”DBA一脸懵逼，沉默十秒后，伸出一根手指。“你的意思是一分钟就能恢复？太好了。”小明终于有些放松，露出了一丝笑容。“不，我们中有个人将会离开公司。”DBA沉痛的说道。</p><p>勿让悲剧发生，尽早将此文转给公司DBA。</p><h1 id="闪回原理"><a href="#闪回原理" class="headerlink" title="闪回原理"></a>闪回原理</h1><p><strong>binlog概述</strong></p><p>MySQL binlog以event的形式，记录了MySQL server从启用binlog以来所有的变更信息，能够帮助重现这之间的所有变化。MySQL引入binlog主要有两个目的：一是为了主从复制；二是某些备份还原操作后需要重新应用binlog。</p><p>有三种可选的binlog格式，各有优缺点：</p><ul><li>statement：基于SQL语句的模式，binlog数据量小，但是某些语句和函数在复制过程可能导致数据不一致甚至出错；</li><li>row：基于行的模式，记录的是行的完整变化。很安全，但是binlog会比其他两种模式大很多；</li><li>mixed：混合模式，根据语句来选用是statement还是row模式；</li></ul><p>利用binlog闪回，<strong>需要将binlog格式设置为row</strong>。row模式下，一条使用innodb的insert会产生如下格式的binlog：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># at 1129</span><br><span class="line">#161225 23:15:38 server id 3773306082  end_log_pos 1197         Query   thread_id=1903021       exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1482678938/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1197</span><br><span class="line">#161225 23:15:38 server id 3773306082  end_log_pos 1245         Table_map: `test`.`user` mapped to number 290</span><br><span class="line"># at 1245</span><br><span class="line">#161225 23:15:38 server id 3773306082  end_log_pos 1352         Write_rows: table id 290 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG '</span><br><span class="line">muJfWBPiFOjgMAAAAN0EAAAAACIBAAAAAAEABHRlc3QABHVzZXIAAwMPEQMeAAAC</span><br><span class="line">muJfWB7iFOjgawAAAEgFAAAAACIBAAAAAAEAAgAD//gBAAAABuWwj+i1tVhK1hH4AgAAAAblsI/p</span><br><span class="line">krFYStYg+AMAAAAG5bCP5a2ZWE/onPgEAAAABuWwj+adjlhNeAD4BQAAAAJ0dFhRYJM=</span><br><span class="line">'/*!*/;</span><br><span class="line"># at 1352</span><br><span class="line">#161225 23:15:38 server id 3773306082  end_log_pos 1379         Xid = 5327954</span><br><span class="line">COMMIT/*!*/;</span><br></pre></td></tr></tbody></table></figure><p><strong>闪回原理</strong></p><blockquote><p>既然binlog以event形式记录了所有的变更信息，那么我们把需要回滚的event，从后往前回滚回去即可。</p></blockquote><p>对于单个event的回滚，我们以表test.user来演示原理</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql> show create table test.user\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: user</span><br><span class="line">Create Table: CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8</span><br></pre></td></tr></tbody></table></figure><ul><li><p>对于delete操作，我们从binlog提取出delete信息，生成的回滚语句是insert。(注：为了方便解释，我们用binlog2sql将原始binlog转化成了可读SQL)</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始：DELETE FROM `test`.`user` WHERE `id`=1 AND `name`='小赵';</span><br><span class="line">回滚：INSERT INTO `test`.`user`(`id`, `name`) VALUES (1, '小赵');</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于insert操作，回滚SQL是delete。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始：INSERT INTO `test`.`user`(`id`, `name`) VALUES (2, '小钱');</span><br><span class="line">回滚：DELETE FROM `test`.`user` WHERE `id`=2 AND `name`='小钱';</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于update操作，回滚sql应该交换SET和WHERE的值。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始：UPDATE `test`.`user` SET `id`=3, `name`='小李' WHERE `id`=3 AND `name`='小孙';</span><br><span class="line">回滚：UPDATE `test`.`user` SET `id`=3, `name`='小孙' WHERE `id`=3 AND `name`='小李';</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><ul><li>闪回的目标：快速筛选出真正需要回滚的数据。</li><li>先根据库、表、时间做一次过滤，再根据位置做更准确的过滤。</li><li>由于数据一直在写入，要确保回滚sql中不包含其他数据。可根据是否是同一事务、误操作行数、字段值的特征等等来帮助判断。</li><li>执行回滚sql时如有报错，需要查实具体原因，一般是因为对应的数据已发生变化。由于是严格的行模式，只要有唯一键(包括主键)存在，就只会报某条数据不存在的错，不必担心会更新不该操作的数据。业务如果有特殊逻辑，数据回滚可能会带来影响。</li><li>如果只回滚某张表，并且该表有关联表，关联表并不会被回滚，需与业务方沟通清楚。</li></ul><h4 id="哪些数据需要回滚，让业务方来判断！"><a href="#哪些数据需要回滚，让业务方来判断！" class="headerlink" title="哪些数据需要回滚，让业务方来判断！"></a><strong>哪些数据需要回滚，让业务方来判断！</strong></h4><h1 id="闪回工具"><a href="#闪回工具" class="headerlink" title="闪回工具"></a>闪回工具</h1><p>MySQL闪回特性最早由阿里彭立勋开发，彭在2012年给官方提交了一个patch，并对<a href="http://www.penglixun.com/tech/database/mysql_flashback_feature.html" target="_blank" rel="noopener">闪回设计思路</a>做了说明(设计思路很有启发性，强烈推荐阅读)。但是因为种种原因，业内安装这个patch的团队至今还是少数，真正应用到线上的更是少之又少。彭之后，又有多位人员针对不同mysql版本不同语言开发了闪回工具，原理用的都是彭的思路。</p><p>我将这些闪回工具按实现方式分成了三类。</p><ul><li><p>第一类是以patch形式集成到官方工具mysqlbinlog中。以彭提交的patch为代表。</p><blockquote><p>优点</p><ul><li>上手成本低。mysqlbinlog原有的选项都能直接利用，只是多加了一个闪回选项。闪回特性未来有可能被官方收录。</li><li>支持离线解析。</li></ul><p>缺点</p><ul><li>兼容性差、项目活跃度不高。由于binlog格式的变动，如果闪回工具作者不及时对补丁升级，则闪回工具将无法使用。目前已有多位人员分别针对mysql5.5，5.6，5.7开发了patch，部分项目代码公开，但总体上活跃度都不高。</li><li>难以添加新功能，实战效果欠佳。在实战中，经常会遇到现有patch不满足需求的情况，比如要加个表过滤，很简单的一个需求，代码改动也不会大，但对大部分DBA来说，改mysql源码还是很困难的事。</li><li>安装稍显麻烦。需要对mysql源码打补丁再编译生成。</li></ul></blockquote><blockquote><p>这些缺点，可能都是闪回没有流行开来的原因。</p></blockquote></li><li><p>第二类是独立工具，通过伪装成slave拉取binlog来进行处理。以binlog2sql为代表。</p><blockquote><p>优点</p><ul><li>兼容性好。伪装成slave拉binlog这项技术在业界应用的非常广泛，多个开发语言都有这样的活跃项目，MySQL版本的兼容性由这些项目搞定，闪回工具的兼容问题不再突出。</li><li>添加新功能的难度小。更容易被改造成DBA自己喜欢的形式。更适合实战。</li><li>安装和使用简单。</li></ul><p>缺点</p><ul><li>必须开启MySQL server。</li></ul></blockquote></li><li><p>第三类是简单脚本。先用mysqlbinlog解析出文本格式的binlog，再根据回滚原理用正则进行匹配并替换。</p><blockquote><p>优点</p><ul><li>脚本写起来方便，往往能快速搞定某个特定问题。</li><li>安装和使用简单。</li><li>支持离线解析。</li></ul><p>缺点</p><ul><li>通用性不好。</li><li>可靠性不好。</li></ul></blockquote></li></ul><p>就目前的闪回工具而言，线上环境的闪回，笔者建议使用binlog2sql，离线解析使用mysqlbinlog。</p><h3 id="关于DDL的flashback"><a href="#关于DDL的flashback" class="headerlink" title="关于DDL的flashback"></a>关于DDL的flashback</h3><p>本文所述的flashback仅针对DML语句的快速回滚。但如果误操作是DDL的话，是无法利用binlog做快速回滚的，因为即使在row模式下，binlog对于DDL操作也不会记录每行数据的变化。要实现DDL快速回滚，必须修改MySQL源码，使得在执行DDL前先备份老数据。目前有多个mysql定制版本实现了DDL闪回特性，阿里林晓斌团队提交了patch给MySQL官方，MariaDB预计在不久后加入包含DDL的flashback特性。DDL闪回的副作用是会增加额外存储。考虑到其应用频次实在过低，本文不做详述，有兴趣的同学可以自己去了解，重要的几篇文章我在参考资料中做了引用。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] MySQL Internals Manual, <a href="http://dev.mysql.com/doc/internals/en/binary-log.html" target="_blank" rel="noopener">Chapter 20 The Binary Log</a></p><p>[2] 彭立勋，<a href="http://www.penglixun.com/tech/database/mysql_flashback_feature.html" target="_blank" rel="noopener">MySQL下实现闪回的设计思路</a></p><p>[3] Lixun Peng, <a href="https://bugs.mysql.com/bug.php?id=65178" target="_blank" rel="noopener">Provide the flashback feature by binlog</a></p><p>[4] 王广友，<a href="http://www.cnblogs.com/youge-OneSQL/p/5249736.html" target="_blank" rel="noopener">mysqlbinlog flashback 5.6完全使用手册与原理</a></p><p>[5] 姜承尧, <a href="http://mp.weixin.qq.com/s?__biz=MjM5MjIxNDA4NA==&mid=2649737874&idx=1&sn=a993322ae58db541c2cf4d9a1efa3063&chksm=beb2d7b989c55eafb7ddcadb28f45bb6018b3e9e65df20b30217fe8cb26d3d444d58076f2d76&mpshare=1&scene=1&srcid=1228ta3qs3QIN6FS4AUCuCKm#rd" target="_blank" rel="noopener">拿走不谢，Flashback for MySQL 5.7</a></p><p>[6] 林晓斌, <a href="http://dinglin.iteye.com/blog/1539167" target="_blank" rel="noopener">MySQL闪回方案讨论及实现</a></p><p>[7] xiaobin lin, <a href="https://bugs.mysql.com/bug.php?id=65861" target="_blank" rel="noopener">flashback from binlog for MySQL</a></p><p>[8] mariadb.com, <a href="https://mariadb.com/resources/blog/alisql-and-some-features-have-made-it-mariadb-server" target="_blank" rel="noopener">AliSQL and some features that have made it into MariaDB Server</a></p><p>[9] danfengcao, <a href="https://github.com/danfengcao/binlog2sql" target="_blank" rel="noopener">binlog2sql: Parse MySQL binlog to SQL you want</a></p><h1 id="文章来自"><a href="#文章来自" class="headerlink" title="文章来自"></a>文章来自</h1><p><a href="https://github.com/danfengcao/binlog2sql/blob/master/example/mysql-flashback-priciple-and-practice.md" target="_blank" rel="noopener">MySQL闪回原理与实战</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 添加索引引发的故障</title>
      <link href="/2019/04/17/mongodb-creata-index/"/>
      <url>/2019/04/17/mongodb-creata-index/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>咸鱼翻身，还是咸鱼。</strong></p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>线上MongoDB服务器资源报警，查看MongoDB log发现有大量的查询没有走索引。于是添加索引</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>具体的查询语句列子:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> feeds.content_medium_hismatch <span class="built_in">command</span>: count { count: <span class="string">"content_medium_hismatch"</span>, query: { update_time: { <span class="variable">$gte</span>: 1384099200000, <span class="variable">$lt</span>: 1384185600000 }, content_type_id: <span class="string">"28"</span> } } planSummary: IXSCAN { content_type_id: 1 } keysExamined:191146 docsExamined:191146 fromMultiPlanner:1 replanned:1 numYields:10767 reslen:44 locks:{ Global: { acquireCount: { r: 21536 } }, Database: { acquireCount: { r: 10768 } }, Collection: { acquireCount: { r: 10768 } } } protocol:op_query 84011ms</span><br></pre></td></tr></tbody></table></figure><p></p><p>通过MongoDB explain()<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">repset:PRIMARY> db.content_medium_hismatch.find({ count: <span class="string">"content_medium_hismatch"</span>, query: { update_time: { <span class="variable">$gte</span>: 1384099200000, <span class="variable">$lt</span>: 1384185600000 }, content_type_id: <span class="string">"28"</span> }}).explain()</span><br><span class="line">{</span><br><span class="line">        <span class="string">"queryPlanner"</span> : {</span><br><span class="line">                <span class="string">"plannerVersion"</span> : 1,</span><br><span class="line">                <span class="string">"namespace"</span> : <span class="string">"feeds.content_medium_hismatch"</span>,</span><br><span class="line">                <span class="string">"indexFilterSet"</span> : <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"parsedQuery"</span> : {</span><br><span class="line">                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"count"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"content_medium_hismatch"</span></span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"query"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000,</span><br><span class="line">                                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                        },</span><br><span class="line">                                                        <span class="string">"content_type_id"</span> : <span class="string">"28"</span></span><br><span class="line">                                                }</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        ]</span><br><span class="line">                },</span><br><span class="line">                <span class="string">"winningPlan"</span> : {</span><br><span class="line">                        <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>,</span><br><span class="line">                        <span class="string">"filter"</span> : {</span><br><span class="line">                                <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                        {</span><br><span class="line">                                                <span class="string">"count"</span> : {</span><br><span class="line">                                                        <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"content_medium_hismatch"</span></span><br><span class="line">                                                }</span><br><span class="line">                                        },</span><br><span class="line">                                        {</span><br><span class="line">                                                <span class="string">"query"</span> : {</span><br><span class="line">                                                        <span class="string">"<span class="variable">$eq</span>"</span> : {</span><br><span class="line">                                                                <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                        <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000,</span><br><span class="line">                                                                        <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                                },</span><br><span class="line">                                                                <span class="string">"content_type_id"</span> : <span class="string">"28"</span></span><br><span class="line">                                                        }</span><br><span class="line">                                                }</span><br><span class="line">                                        }</span><br><span class="line">                                ]</span><br><span class="line">                        },</span><br><span class="line">                        <span class="string">"direction"</span> : <span class="string">"forward"</span></span><br><span class="line">                },</span><br><span class="line">                <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">        },</span><br><span class="line">        <span class="string">"serverInfo"</span> : {</span><br><span class="line">                <span class="string">"host"</span> : <span class="string">"public-ops-mongodb2.wj.babytree-ops.org"</span>,</span><br><span class="line">                <span class="string">"port"</span> : 29001,</span><br><span class="line">                <span class="string">"version"</span> : <span class="string">"3.4.2"</span>,</span><br><span class="line">                <span class="string">"gitVersion"</span> : <span class="string">"3f76e40c105fc223b3e5aac3e20dcd026b83b38b"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="string">"ok"</span> : 1</span><br><span class="line">}</span><br><span class="line">repset:PRIMARY> </span><br><span class="line"></span><br><span class="line">repset:PRIMARY> db.content_medium_hismatch.find({ count: <span class="string">"content_medium_hismatch"</span>, query: { update_time: { <span class="variable">$gte</span>: 1384099200000, <span class="variable">$lt</span>: 1384185600000 }, content_type_id: <span class="string">"28"</span> }}).explain()</span><br><span class="line">{</span><br><span class="line">        <span class="string">"queryPlanner"</span> : {</span><br><span class="line">                <span class="string">"plannerVersion"</span> : 1,</span><br><span class="line">                <span class="string">"namespace"</span> : <span class="string">"feeds.content_medium_hismatch"</span>,</span><br><span class="line">                <span class="string">"indexFilterSet"</span> : <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"parsedQuery"</span> : {</span><br><span class="line">                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"count"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"content_medium_hismatch"</span></span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"query"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000,</span><br><span class="line">                                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                        },</span><br><span class="line">                                                        <span class="string">"content_type_id"</span> : <span class="string">"28"</span></span><br><span class="line">                                                }</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        ]</span><br><span class="line">                },</span><br><span class="line">                <span class="string">"winningPlan"</span> : {</span><br><span class="line">                        <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>,</span><br><span class="line">                        <span class="string">"filter"</span> : {</span><br><span class="line">                                <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                        {</span><br><span class="line">                                                <span class="string">"count"</span> : {</span><br><span class="line">                                                        <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"content_medium_hismatch"</span></span><br><span class="line">                                                }</span><br><span class="line">                                        },</span><br><span class="line">                                        {</span><br><span class="line">                                                <span class="string">"query"</span> : {</span><br><span class="line">                                                        <span class="string">"<span class="variable">$eq</span>"</span> : {</span><br><span class="line">                                                                <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                        <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000,</span><br><span class="line">                                                                        <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                                },</span><br><span class="line">                                                                <span class="string">"content_type_id"</span> : <span class="string">"28"</span></span><br><span class="line">                                                        }</span><br><span class="line">                                                }</span><br><span class="line">                                        }</span><br><span class="line">                                ]</span><br><span class="line">                        },</span><br><span class="line">                        <span class="string">"direction"</span> : <span class="string">"forward"</span></span><br><span class="line">                },</span><br><span class="line">                <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">        },</span><br><span class="line">        <span class="string">"serverInfo"</span> : {</span><br><span class="line">                <span class="string">"host"</span> : <span class="string">"public-ops-mongodb2.wj.babytree-ops.org"</span>,</span><br><span class="line">                <span class="string">"port"</span> : 29001,</span><br><span class="line">                <span class="string">"version"</span> : <span class="string">"3.4.2"</span>,</span><br><span class="line">                <span class="string">"gitVersion"</span> : <span class="string">"3f76e40c105fc223b3e5aac3e20dcd026b83b38b"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="string">"ok"</span> : 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>于是很鲁莽的添加了索引操作<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.content_medium_hismatch.ensureIndex({update_time: 1, content_type_id: 1})</span><br></pre></td></tr></tbody></table></figure><p></p><p>发现时间很长，于是就crtl+c中断操作，在执行登录MongoDB shell 发现操作都堵塞。执行<code>tail -f /data/repset/log/mongod.log</code>发现<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2019-04-04T16:54:54.984+0800 I INDEX [conn2744778] build index on: feeds.content_medium_hismatch properties: { v: 2, key: { update_time: 1.0, content_type_id: 1.0 }, name: <span class="string">"update_time_1_content_type_id_1"</span>, ns: <span class="string">"feeds.content_medium_hismatch"</span> }</span><br><span class="line"></span><br><span class="line">Index Build: 33461300/138238312 0%</span><br><span class="line">……</span><br><span class="line">Index Build: 33461300/138238312 99%</span><br><span class="line"></span><br><span class="line">Index: (2/3) BTree Bottom Up Progress: 99135500/138238312 1%</span><br><span class="line">……</span><br><span class="line">Index: (2/3) BTree Bottom Up Progress: 99135500/138238312 71%</span><br><span class="line"></span><br><span class="line">2019-04-04T18:22:05.817+0800 I INDEX [conn2744778] build index <span class="keyword">done</span>. scanned 138238312 total records. 5230 secs</span><br></pre></td></tr></tbody></table></figure><p></p><p>还在执行创建索引操作。经过排查发现。MongoDB 不是和MySQL一样。中断了就不执行了。而且MongoDB 在前台创建索引操作。会把整个服务阻塞。直到索引创建成功，才会放开阻塞。这样操作直接造成了业务不可用状态，时间整整87分钟。鲁莽惹的祸。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当系统已有大量数据时，创建索引就是个非常耗时的活，我们可以在后台执行，只需指定”backgroud: true”即可。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.content_medium_hismatch.ensureIndex({update_time: 1, content_type_id: 1}, {backgroud: <span class="literal">true</span>})</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>最后在看一下如此之大的代价创建的索引之后使用的情况<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">repset:PRIMARY> db.content_medium_hismatch.find({ update_time: { <span class="variable">$gte</span>: 1384099200000, <span class="variable">$lt</span>: 1384185600000 }, content_type_id: <span class="string">"28"</span> }).explain()</span><br><span class="line">{</span><br><span class="line">        <span class="string">"queryPlanner"</span> : {</span><br><span class="line">                <span class="string">"plannerVersion"</span> : 1,</span><br><span class="line">                <span class="string">"namespace"</span> : <span class="string">"feeds.content_medium_hismatch"</span>,</span><br><span class="line">                <span class="string">"indexFilterSet"</span> : <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"parsedQuery"</span> : {</span><br><span class="line">                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"28"</span></span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                {</span><br><span class="line">                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        ]</span><br><span class="line">                },</span><br><span class="line">                <span class="string">"winningPlan"</span> : {</span><br><span class="line">                        <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                        <span class="string">"inputStage"</span> : {</span><br><span class="line">                                <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                                <span class="string">"keyPattern"</span> : {</span><br><span class="line">                                        <span class="string">"update_time"</span> : 1,</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : 1</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"indexName"</span> : <span class="string">"update_time_1_content_type_id_1"</span>,</span><br><span class="line">                                <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">"multiKeyPaths"</span> : {</span><br><span class="line">                                        <span class="string">"update_time"</span> : [ ],</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : [ ]</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"isUnique"</span> : <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">"indexVersion"</span> : 2,</span><br><span class="line">                                <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                                <span class="string">"indexBounds"</span> : {</span><br><span class="line">                                        <span class="string">"update_time"</span> : [</span><br><span class="line">                                                <span class="string">"[1384099200000.0, 1384185600000.0)"</span></span><br><span class="line">                                        ],</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : [</span><br><span class="line">                                                <span class="string">"[\"28\", \"28\"]"</span></span><br><span class="line">                                        ]</span><br><span class="line">                                }</span><br><span class="line">                        }</span><br><span class="line">                },</span><br><span class="line">                <span class="string">"rejectedPlans"</span> : [</span><br><span class="line">                        {</span><br><span class="line">                                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                                <span class="string">"filter"</span> : {</span><br><span class="line">                                        <span class="string">"content_type_id"</span> : {</span><br><span class="line">                                                <span class="string">"<span class="variable">$eq</span>"</span> : <span class="string">"28"</span></span><br><span class="line">                                        }</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"inputStage"</span> : {</span><br><span class="line">                                        <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                                        <span class="string">"keyPattern"</span> : {</span><br><span class="line">                                                <span class="string">"update_time"</span> : 1</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"indexName"</span> : <span class="string">"update_time_1"</span>,</span><br><span class="line">                                        <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"multiKeyPaths"</span> : {</span><br><span class="line">                                                <span class="string">"update_time"</span> : [ ]</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"isUnique"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"indexVersion"</span> : 2,</span><br><span class="line">                                        <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                                        <span class="string">"indexBounds"</span> : {</span><br><span class="line">                                                <span class="string">"update_time"</span> : [</span><br><span class="line">                                                        <span class="string">"[1384099200000.0, 1384185600000.0)"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        },</span><br><span class="line">                        {</span><br><span class="line">                                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                                <span class="string">"filter"</span> : {</span><br><span class="line">                                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                                {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                        }</span><br><span class="line">                                                },</span><br><span class="line">                                                {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000</span><br><span class="line">                                                        }</span><br><span class="line">                                                }</span><br><span class="line">                                        ]</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"inputStage"</span> : {</span><br><span class="line">                                        <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                                        <span class="string">"keyPattern"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : 1</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"indexName"</span> : <span class="string">"content_type_id_1"</span>,</span><br><span class="line">                                        <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"multiKeyPaths"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : [ ]</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"isUnique"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"indexVersion"</span> : 2,</span><br><span class="line">                                        <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                                        <span class="string">"indexBounds"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : [</span><br><span class="line">                                                        <span class="string">"[\"28\", \"28\"]"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        },</span><br><span class="line">                        {</span><br><span class="line">                                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                                <span class="string">"filter"</span> : {</span><br><span class="line">                                        <span class="string">"<span class="variable">$and</span>"</span> : [</span><br><span class="line">                                                {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$lt</span>"</span> : 1384185600000</span><br><span class="line">                                                        }</span><br><span class="line">                                                },</span><br><span class="line">                                                {</span><br><span class="line">                                                        <span class="string">"update_time"</span> : {</span><br><span class="line">                                                                <span class="string">"<span class="variable">$gte</span>"</span> : 1384099200000</span><br><span class="line">                                                        }</span><br><span class="line">                                                }</span><br><span class="line">                                        ]</span><br><span class="line">                                },</span><br><span class="line">                                <span class="string">"inputStage"</span> : {</span><br><span class="line">                                        <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                                        <span class="string">"keyPattern"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : 1,</span><br><span class="line">                                                <span class="string">"content_id"</span> : 1</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"indexName"</span> : <span class="string">"content_type_id_1_content_id_1"</span>,</span><br><span class="line">                                        <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"multiKeyPaths"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : [ ],</span><br><span class="line">                                                <span class="string">"content_id"</span> : [ ]</span><br><span class="line">                                        },</span><br><span class="line">                                        <span class="string">"isUnique"</span> : <span class="literal">true</span>,</span><br><span class="line">                                        <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">"indexVersion"</span> : 2,</span><br><span class="line">                                        <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                                        <span class="string">"indexBounds"</span> : {</span><br><span class="line">                                                <span class="string">"content_type_id"</span> : [</span><br><span class="line">                                                        <span class="string">"[\"28\", \"28\"]"</span></span><br><span class="line">                                                ],</span><br><span class="line">                                                <span class="string">"content_id"</span> : [</span><br><span class="line">                                                        <span class="string">"[MinKey, MaxKey]"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                        }</span><br><span class="line">                                }</span><br><span class="line">                        }</span><br><span class="line">                ]</span><br><span class="line">        },</span><br><span class="line">        <span class="string">"serverInfo"</span> : {</span><br><span class="line">                <span class="string">"host"</span> : <span class="string">"public-ops-mongodb2.wj.babytree-ops.org"</span>,</span><br><span class="line">                <span class="string">"port"</span> : 29001,</span><br><span class="line">                <span class="string">"version"</span> : <span class="string">"3.4.2"</span>,</span><br><span class="line">                <span class="string">"gitVersion"</span> : <span class="string">"3f76e40c105fc223b3e5aac3e20dcd026b83b38b"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="string">"ok"</span> : 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>发现正常走了索引。总算没有白做。可是代价太大了。这个教训告诉我，在不熟悉的数据库操作一定要慎重。针对线上操作，一定要再三慎重。引以为戒！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 实现 MySQL 的 INSERT INTO SELECT</title>
      <link href="/2019/04/15/mongodb-inset-into-select/"/>
      <url>/2019/04/15/mongodb-inset-into-select/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>说金钱是罪恶，都在捞；说美女是祸水，都想要；说高处不胜寒，都在爬；说烟酒伤身体，都不戒；说天堂最美好，都不去！</strong></p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>公司业务有要将一个集合需要更改名称，需要DBA做配合</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li>停止入库</li><li>确认已经把库入数据审完</li><li>重命名collections</li><li>创建新集合索引<br><code>db.antispam_resource.renameCollection("antispam_resource_20190415");</code><br><code>db.createCollection("antispam_resource");</code><br><code>db.antispam_resource.ensureIndex({createTs: 1, groupId: 1});</code><br><code>db.antispam_resource.ensureIndex({handleTs: 1, opUserId: 1});</code><br><code>db.antispam_resource.getIndexes();</code></li><li>新数据入库</li><li>看审核后台是否有新数据入库并审核</li><li>把最近1个月数据(antispam_resource_20190415)导入到antispam_resource</li><li>完毕</li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>查看一下原集合数据量<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_resource.find().count();</span><br></pre></td></tr></tbody></table></figure><p></p><p>进行更改名称操作<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_resource.renameCollection(<span class="string">"antispam_resource_20190415"</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><p>进行创建索引<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.antispam_resource.ensureIndex({createTs: 1, groupId: 1});</span><br><span class="line">db.antispam_resource.ensureIndex({handleTs: 1, opUserId: 1});</span><br><span class="line">db.antispam_resource.getIndexes();</span><br></pre></td></tr></tbody></table></figure><p></p><p>进行操作 MongoDB 版本的 INSERT INTO SELECT<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">db.antispam_resource.find().forEach(<span class="keyword">function</span>(doc){</span><br><span class="line"> <span class="built_in">print</span>(doc._id);</span><br><span class="line">    db.antispam_resource.insert(doc)}</span><br><span class="line">  );</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="操作详细步骤"><a href="#操作详细步骤" class="headerlink" title="操作详细步骤"></a>操作详细步骤</h2><p>查看原集合大于4月1号的数据<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mgset-11469021:PRIMARY> db.antispam_resource_20190415.find({createTs: { <span class="variable">$gte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">2726271</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource_20190415.find({createTs: { <span class="variable">$lte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">22264682</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find().count()</span><br><span class="line">27824</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find({ createTs: { <span class="variable">$gte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">27861</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find({ createTs: { <span class="variable">$lte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">0</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find({ createTs: { <span class="variable">$gte</span>: NumberLong(1554048000) }}).count()</span><br><span class="line">28074</span><br></pre></td></tr></tbody></table></figure><p></p><p>进行操作<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mgset-11469021:PRIMARY> var docs = db.antispam_resource_20190415.find({createTs: { <span class="variable">$gte</span>: NumberLong(1554048000) }});</span><br><span class="line">mgset-11469021:PRIMARY> docs.forEach( <span class="keyword">function</span>(d){ db.antispam_resource.insert(d) });</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/04/15/mongodb-inset-into-select/inset_into_select.png" title="inset_into_select"><p>数据在慢慢插入到新的集合中</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mgset-11469021:PRIMARY> db.antispam_resource_20190415.find({createTs: { <span class="variable">$gte</span>:1554048000, <span class="variable">$lte</span>:1555311600}}).count()</span><br><span class="line">2726271</span><br><span class="line">mgset-11469021:PRIMARY> db.antispam_resource.find({createTs: { <span class="variable">$gte</span>:1554048000, <span class="variable">$lte</span>:1555311600}}).count()</span><br><span class="line">2726271</span><br></pre></td></tr></tbody></table></figure><p>终于导完</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL BINLOG Server</title>
      <link href="/2019/04/03/mysql-binlog-server/"/>
      <url>/2019/04/03/mysql-binlog-server/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>雷锋做了好事不留名，但是每一件事情都记到日记里面。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL Binlog Server: 它使用 <code>mysqlbinlog</code> 命令以 <code>daemon</code> 进程的方式模拟一个 <code>slave</code> 的 <code>IO</code> 线程与主库连接，可以很方便地即时同步主库的 <code>binlog</code>，以便弥补定时备份策略中最近一次备份到下一次备份完成之前这段时间内的数据容易丢失的问题。</p><p>做好 MySQL 日志的备份，是数据安全的一个重要保证。以前通过写程序来实现，从 MySQL 5.6 出现以后，可以使用 <code>mysqlbinlog</code> 命令实现，不用写程序了。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>创建复制账号<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">'repl'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'repl'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql 5.7</span><br><span class="line">CREATE USER <span class="string">'repl'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'repl'</span>;</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">'repl'</span>@<span class="string">'%'</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure><h2 id="创建BINLOG-SERVER"><a href="#创建BINLOG-SERVER" class="headerlink" title="创建BINLOG SERVER"></a>创建BINLOG SERVER</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqlbinlog -R --raw --host='192.168.199.230' --port=3306 --user='repl' --password='unixfbi' --stop-never --stop-never-slave-server-id=2313306 mysql-bin.000001 --result-file=/data/mysql/mysql3306/logs/ &</span></span><br></pre></td></tr></tbody></table></figure><p>命令参数介绍：</p><ul><li><strong>-R –read-from-remote-server</strong> :表示从远程机器上读取 binlog,要确保远程 mysql 存储，需要提供–host, –user, –password 参数; 使用该选项时，mysqlbinlog 会伪装成一个 slave，连接读取，请求指定的 binlog file，主库获取接收到这个请求之后就创建一个 binlog dump 线程推送 binlog 给 mysqlbinlog server。</li><li><strong>–raw</strong>: 以 binlog 格式存储日志，方便后期使用;</li><li><strong>–host</strong>: 远程库的主机 IP 或者主机名;</li><li><strong>–port</strong>: 远端库的端口号;</li><li><strong>–user</strong>: 远程库上用于复制的账号;</li><li><strong>–password</strong>: 远端库上复制账号的密码;</li><li><strong>–stop-never</strong>: 一直连接到远程的 server 上读取 binlog 日志，直接到远程的 server 关闭后才会退出。或是被 pkill 掉;</li><li><strong>–stop-never-slave-server-id</strong>: 如果需要启动多个 binlog server ，需要给 binlog server 指定 server-id 。如果需要启动多个 binlog server,需要给 binlog server 指定 server-id(默认是 65535)，可以利用 –stop-never-slave-server-id 变更;</li><li><strong>mysql-bin.0000001</strong> 这个日志名表示从那个日志开始读取;</li><li><strong>–result-file</strong>: 指定存储到本地的目录，注意后缀需要加上/，否则 mysqlbinlog 命令会认为是保存文件的前缀。若指定了–raw 参数，-r 的值指定 binlog 的存放目录和文件名前缀；若没有指定–raw 参数，-r 的值指定文本存放的目录和文件名。</li></ul><blockquote><p>注意：<br>  使用–raw 连接 master 时，以 4k 为单位写入磁盘。并不能实时写入磁盘。那么不够 4k 时，binlog server 什么时候才会把日志写入磁盘呢？</p></blockquote><blockquote><p>有两种情况：</p></blockquote><blockquote><pre><code>第一：binlog server 和主库断开时，第二：master 执行 flush logs 都会实时把日志写入磁盘。</code></pre><p>mysqlbinlog raw 有一个 4k 的 Buffer ，够 4k 就发车。</p></blockquote><h2 id="设置-mysqlbinlog-为守护进程"><a href="#设置-mysqlbinlog-为守护进程" class="headerlink" title="设置 mysqlbinlog 为守护进程"></a>设置 mysqlbinlog 为守护进程</h2><p>如果 master 重启的话，binlog server 上的 mysqlbinlog 进程就会退出，所以我们写个脚本把 mysqlbinlog 设置为守护进程方式运行<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">BACKUP_BIN=/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog</span><br><span class="line">LOCAL_BACKUP_DIR=/data/mysql/mysql3306/logs/</span><br><span class="line">BACKUP_LOG=/tmp/backup.log</span><br><span class="line">REMOTE_HOST=192.168.199.230</span><br><span class="line">REMOTE_PORT=3306</span><br><span class="line">REMOTE_USER=repl</span><br><span class="line">REMOTE_PASS=unixfbi</span><br><span class="line">FIRST_BINLOG=mysql-bin.000001</span><br><span class="line">SLAVE_SERVER_ID=2313306</span><br><span class="line"><span class="comment"># wait for 10s</span></span><br><span class="line">SLEEP_SECONDS=10</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">${LOCAL_BACKUP_DIR}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ `ls -A <span class="string">"<span class="variable">${LOCAL_BACKUP_DIR}</span>"</span> |wc -l` -eq 0 ];<span class="keyword">then</span></span><br><span class="line">     LAST_FILE=<span class="variable">${FIRST_BINLOG}</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     LAST_FILE=`ls -l <span class="variable">${LOCAL_BACKUP_DIR}</span> |tail -n 1 |awk <span class="string">'{print $NF}'</span>`</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="variable">${BACKUP_BIN}</span> --raw -R --stop-never --host=<span class="variable">${REMOTE_HOST}</span> --port=<span class="variable">${REMOTE_PORT}</span> --user=<span class="variable">${REMOTE_USER}</span> --password=<span class="variable">${REMOTE_PASS}</span>  --stop-never --stop-never-slave-server-id=<span class="variable">${SLAVE_SERVER_ID}</span> <span class="variable">${LAST_FILE}</span> --result-file=<span class="variable">${LOCAL_BACKUP_DIR}</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"`date +"</span>%Y/%m/%d %H:%M:%S<span class="string">"` mysqlbinlog is stoped,return code: $?"</span> | tee -a <span class="variable">${BACKUP_LOG}</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">${SLEEP_SECONDS}</span>s will continue !"</span> | tee -a <span class="variable">${BACKUP_LOG}</span>  </span><br><span class="line">  sleep <span class="variable">${SLEEP_SECONDS}</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>执行脚本<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nohup binlog_cp.sh &</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.unixfbi.com/291.html" target="_blank" rel="noopener">UnixFBI 运维特工</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Innodb表空间传输</title>
      <link href="/2019/04/03/innodb-tablespace-copying/"/>
      <url>/2019/04/03/innodb-tablespace-copying/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>不吃饱哪有力气减肥啊。</strong></p></blockquote><p>innodb表空间传输，是MySQL5.6开始加入的新特性，支持普通表空间拷贝到其他实例下，MySQL5.7支持分区表的表空间传输，使innodb表的拷贝变得更加简单容易。</p><p>方便是方便了，但也要需要注意:</p><ul><li>innodb表空间传输不要用来做主从复制，否则会出现数据不一致的问题;</li><li>使用之前，要确认使用了innodb_file_per_table即独立表空间;</li><li>在表空间导出的过程中，事务不能进行写操作, 应该注意选择操作时间, 应该选择业务低峰期操作;</li><li>默认不支持导出有外键的表, 可以通过set foreign_key_checks=0强制忽略, 但仅限于普通表, 而分区表暂时不支持这样操作。</li></ul><p>我们知道了innodb表空间传输的特点和使用注意事项, 现在考虑一下应用场景。因为不做主从复制，就只能做一些离线方面的使用，比如把线上某个生产表拿到离线环境做统计分析等等。</p><p>下面介绍innodb普通表空间传输和分区表空间传输的操作过程<br>1.innodb普通表空间传输</p><p>1.1目标库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> create table t2(id int auto_increment, name varchar(20), primary key(id));</span><br><span class="line">mysql> insert into t2(name) values(<span class="string">'aa'</span>),(<span class="string">'bb'</span>),(<span class="string">'cc'</span>);</span><br><span class="line">mysql> alter table t2 discard tablespace;</span><br></pre></td></tr></tbody></table></figure><p></p><p>1.2 源库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql> flush tables t2 <span class="keyword">for</span> <span class="built_in">export</span>;</span><br><span class="line"></span><br><span class="line">shell> scp -P2222 /data/mysql/mysql_3306/data/db1/t2.{cfg,ibd} 172.16.123.103:/data/mysql/mysql_3306/data/<span class="built_in">test</span>/</span><br><span class="line"></span><br><span class="line">mysql> unlock tables;</span><br></pre></td></tr></tbody></table></figure><p></p><p>1.3 目标库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell> chown mysql.mysql /data/mysql/mysql_3306/data/<span class="built_in">test</span>/t2.*</span><br><span class="line"></span><br><span class="line">mysql> alter table t2 import tablespace;</span><br></pre></td></tr></tbody></table></figure><p></p><p>2.innodb分区表空间传输<br>测试分区表结构<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> create table t3(id int auto_increment, name varchar(20), primary key(id)) partition by key(id) partitions 4;</span><br></pre></td></tr></tbody></table></figure><p></p><p>2.1 目标库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> create table t3(id int auto_increment, name varchar(20), primary key(id)) partition by key(id) partitions 4;</span><br></pre></td></tr></tbody></table></figure><p></p><p>插入测试数据(省略)<br>2.2 源库<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql> flush tables t3 <span class="keyword">for</span> <span class="built_in">export</span>; <span class="comment">#导出整个分区表</span></span><br><span class="line"></span><br><span class="line">shell> cp -a /data/mysql/mysql_3306/data/db1/t3* /var/tmp/</span><br><span class="line"></span><br><span class="line">mysql> unlock tables;</span><br></pre></td></tr></tbody></table></figure><p></p><p>2.3 目标库</p><p>2.3.1 导入全数分区<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标库</span><br><span class="line">mysql> alter table t3 discard tablespace;</span><br><span class="line">或</span><br><span class="line">mysql> alter table t3 discard partition all tablespace;</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">源库</span><br><span class="line">shell> scp -P2222 -r t3* 172.16.123.103:/data/mysql/mysql_3306/data/<span class="built_in">test</span>/</span><br><span class="line">shell> chown mysql.mysql /data/mysql/mysql_3306/data/<span class="built_in">test</span>/ -R</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标库</span><br><span class="line">mysql> alter table t3 import tablespace;</span><br></pre></td></tr></tbody></table></figure><p>2.3.2 导入指定分区<br>只导p1分区<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标库</span><br><span class="line">mysql> alter table t3 discard partition p1 tablespace;</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">源库</span><br><span class="line">shell> scp -P2222 -r t3p1 172.16.123.103:/data/mysql/mysql_3306/data/<span class="built_in">test</span>/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标库</span><br><span class="line">mysql> alter table t3 import partition p1 tablespace;</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>源库上<br><code>flush tables tbname for export;</code>—><code>拷贝文件</code>–><code>unlock tables;</code></p><p>目标库上<br><code>alter table tbname discard [partition partition_names | ALL] tablespace;</code>–><code>拷贝文件过来,改权限</code>–><code>alter table tbname IMPORT [PARTITION partition_names | ALL] TABLESPACE;</code></p><p>再次提醒</p><p>做<code>flush tables xx discard tablespace</code>之前，<strong><em>务必三思</em></strong>, 一定要搞清楚在哪个库操作, 万一在生产库上操作，这就悲剧了!</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://hzkeung.com/2017/06/07/innodb-tablespace-copying" target="_blank" rel="noopener">Huang Jinqiang</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从MySQL源码学习运维Innodb buffer命中率计算</title>
      <link href="/2019/04/03/mysql-innodb-buffer-pool-hit/"/>
      <url>/2019/04/03/mysql-innodb-buffer-pool-hit/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>天没降大任于我，照样苦我心智，劳我筋骨。</strong></p></blockquote><h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p>按官方手册推荐<code>Innodb buffer Hit Ratios</code>的计算是:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100-((iReads / iReadRequests)*100)</span><br><span class="line">iReads : mysql->status->Innodb_buffer_pool_reads</span><br><span class="line">iReadRequests: mysql->status->Innodb_buffer_pool_read_requests</span><br></pre></td></tr></tbody></table></figure><p></p><p>mysqlsqlreport中关于<code>buffer</code>命中计算是:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ib_bp_hit=100-(Innodb_buffer_pool_reads/Innodb_buffer_pool_read_requests)*100</span><br></pre></td></tr></tbody></table></figure><p></p><p>另外我们知道查看<code>Innodb Buffer Hit Ratios</code>的地方是:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br><span class="line">Buffer pool hit rate : XXXX/1000;</span><br></pre></td></tr></tbody></table></figure><p></p><p>那个XXX/1000即是<code>buffer pool hit ratios</code>的命中.</p><p><code>innodb buffer hit Ratios</code>的命中计算需要本次取的值和上次值做一个减法公式应该为<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ib_bp_hit=1000 – (t2.iReads – t1.iReads)/(t2.iReadRequest – t1.iReadRequest)*1000</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>t(n): 时间点 两个时间间隔最少是30秒以上,在小意义不大.</li><li>iReads: Innodb_buffer_pool_reads</li><li>iReadRequest: Innodb_buffer_pool_read_requests</li></ul><p>思考:<br>对于innodb_buffer_pool_read_requests, innodb_buffer_pool_reads这种累加值,当很大时进行: innodb_buffer_pool_reads/innodb_buffer_pool_read_requests 相来讲只能得到从开始到现在的命中率的表现了. 如果想得到现在近五分钟,近一分钟或是8点到9点每分钟的命中率情况,如果还是按着innodb_buffer_pool_reads/innodb_buffer_pool_read_requests 进行计算,只能得到mysqld开起累计在8点-9点的每分钟的累计平均命中情况.</p><p>所以如果想到每(五)分钟的命中情况,就需要本次取得的值和一(五)分钟前的值进行相减,然后进行运算.这样才能得到一个当下的bp命中情况.</p><p>两种方法没实质的对错的问题,但相对于源码中的那种计算方式更容让发现数据库的抖动问题.</p><p>能解决的问题:</p><p>偶而的数据库性能抖动能直观的反应出来.</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="http://wubx.net/mysql_innodb_buffer_pool_hit/" target="_blank" rel="noopener">吴 炳锡(数据库架构师):从MySQL源码学习运维Innodb buffer命中率计算</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中SHELL内置getopts命令获取命令行参数</title>
      <link href="/2019/04/03/shell-getopts/"/>
      <url>/2019/04/03/shell-getopts/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>做人如果没有梦想，那和咸鱼有何区别？</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写程序的时候经常要处理命令行参数，本文描述在Bash下的命令行处理方式。</p><p>选项与参数:</p><p>如下一个命令行:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/test.sh -f config.conf -v --prefix=/home</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们称-f为选项，它需要一个参数，即config.conf, -v 也是一个选项，但它不需要参数。</p><p>–prefix我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home可以直接写在–prefix后面，即–prefix/home,更多的限制后面具体会讲到。</p><p>在bash中，可以用以下三种方式来处理命令行参数，每种方式都有自己的应用场景。</p><ul><li>手工处理方式</li><li>getopts</li><li>getopt</li></ul><p>由于shell命令行的灵活性，自己编写代码判断时，复杂度会比较高。使用内部命令 getopts 可以很方便地处理命令行参数。一般格式为：</p><p><strong>调用格式：</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> options variable</span><br></pre></td></tr></tbody></table></figure><p></p><p>getopts 的设计目标是在循环中运行，每次执行循环，getopts 就检查下一个命令行参数，并判断它是否合法。即检查参数是否以 - 开头，后面跟一个包含在 options 中的字母。如果是，就把匹配的选项字母存在指定的变量 variable 中，并返回退出状态0；如果 - 后面的字母没有包含在 options 中，就在 variable 中存入一个 ？，并返回退出状态0；如果命令行中已经没有参数，或者下一个参数不以 - 开头，就返回不为0的退出状态。</p><p><strong>参数说明：</strong></p><ul><li>option_string 选项名称 </li><li>variable 选项的值 </li></ul><blockquote><p>选项之间使用<strong>冒号:</strong>分隔，也可以直接连接， <strong>:</strong> 表示选项后面有传值。<br>  当getopts命令发现冒号后，会从命令行该选项后读取该值。如该值存在，将保存在特殊的变量OPTARG中。</p></blockquote><p>当option_string用<strong>:</strong>开头，getopts会区分invalid option错误和miss option argument错误。</p><p>invalid option时, varname会被设成? </p><p>miss option argument时，varname会被设成:</p><p>如果option_string不用:开头，invalid option错误和miss option argument错误都会使varname被设成?。</p><p><strong>getopts包含两个内置变量，OPTARG和OPTIND</strong></p><ul><li>OPTARG 保存选项后的参数值 </li><li>OPTIND 表示命令行下一个选项或参数的索引 </li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>例子1: 使用getopts命令获取参数<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> a:b:c:d opts; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$opts</span> <span class="keyword">in</span></span><br><span class="line">        a) a=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        b) b=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        c) c=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        d) d=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        ?) ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a=<span class="variable">$a</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"b=<span class="variable">$b</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"c=<span class="variable">$c</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"d=<span class="variable">$d</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行输出<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -a 1 -b 2 -c 3 -d 4</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>option_string a<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f171.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f171.png?v8">🅱</span>c:d </p></blockquote><blockquote><p>a,b,c后都有:</p></blockquote><blockquote><p>d后没有: </p></blockquote><blockquote><p>所以可以获取到a,b,c的值 </p></blockquote><p>例子2: option_string前加:<br>上例中，如果a,b,c任意一个没有传值，将会提示出错。例如 -c 不传值。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -a 1 -b 2 -c</span><br><span class="line">./test.sh: option requires an argument -- c</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们在option_string前加上:，则可以屏蔽这个错误<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :a:b:c:d opts; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$opts</span> <span class="keyword">in</span></span><br><span class="line">        a) a=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        b) b=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        c) c=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        d) d=<span class="variable">$OPTARG</span> ;;</span><br><span class="line">        ?) ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a=<span class="variable">$a</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"b=<span class="variable">$b</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"c=<span class="variable">$c</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"d=<span class="variable">$d</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行输出<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -a 1 -b 2 -c</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>在option_string前加上:，可以屏蔽缺失传值的错误，但如果缺失的是前面选项的值，那么获取到的值将会错误。</strong></p><p>例如缺失a的传值，命令会把-a后的-b作为了-a的值，导致错误。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -a -b 2 -c 3</span><br><span class="line">a=-b</span><br><span class="line">b=</span><br><span class="line">c=</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><p>因此使用getopts命令时，对于没有传值的选项，选项名称也不要加入命令行中。<br>例如a不传值，则-a不要加入命令行。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh -b 2 -c 3</span><br><span class="line">a=</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br><span class="line">d=</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="SHELL-代码"><a href="#SHELL-代码" class="headerlink" title="SHELL 代码"></a>SHELL 代码</h2><p>以上是示例，下面贴上我写的脚本代码：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author: Created by jiemin.wang</span></span><br><span class="line"><span class="comment"># QQ: 278667010</span></span><br><span class="line"><span class="comment"># E-mail: 278661010@qq.com or wangjiemin880228@gmail.com</span></span><br><span class="line"><span class="comment"># Created Time: Wed Apr  3 14:15:12 CST 2019</span></span><br><span class="line"><span class="comment"># function: This is tcpdump grabs SQL executed by MySQL</span></span><br><span class="line"><span class="comment"># version: 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>(){</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Usage:"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" <span class="variable">$(basename $0)</span> [OPTION]:"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-n net"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-P port"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq <span class="string">"0"</span> ];<span class="keyword">then</span></span><br><span class="line">usage</span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :n:P: arg</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$arg</span> <span class="keyword">in</span></span><br><span class="line">n)</span><br><span class="line">net=<span class="variable">$OPTARG</span></span><br><span class="line">;;</span><br><span class="line">P)</span><br><span class="line">port=<span class="variable">$OPTARG</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tcpdump -i "$net" -s 0 -l -w - dst port "$port" | strings | perl -e '</span></span><br><span class="line">tcpdump -i <span class="string">"<span class="variable">$net</span>"</span> -s 0 -l -w file dst port <span class="string">"<span class="variable">$port</span>"</span> | strings | perl -e <span class="string">'</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">while(<>) { chomp; next if /^[^ ]+[ ]*$/;</span></span><br><span class="line"><span class="string">if(/^(SELECT|UPDATE|DELETE|INSERT|SET|COMMIT|ROLLBACK|CREATE|DROP|ALTER|CALL)/i) {</span></span><br><span class="line"><span class="string">if (defined $q) { print "$q\n"; }</span></span><br><span class="line"><span class="string">$q=$_;</span></span><br><span class="line"><span class="string">} else {</span></span><br><span class="line"><span class="string">$_ =~ s/^[ \t]+//; $q.=" $_";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}'</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h2><p>在网上找了一个示例,贴上来,仅供参考<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">QUIET=</span><br><span class="line">VERBOSE=</span><br><span class="line">DEVICE=</span><br><span class="line">LOGFILE=/tmp/default</span><br><span class="line"></span><br><span class="line">usage()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: `basename <span class="variable">$0</span>` [-qv] [-l LOGFILE] -d DEVICE input_file [input_file2...]"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">[ <span class="variable">$#</span> -eq 0 ] && usage</span><br><span class="line"></span><br><span class="line"><span class="comment">#option_string以冒号开头表示屏蔽脚本的系统提示错误，自己处理错误提示。</span></span><br><span class="line"><span class="comment">#后面接合法的单字母选项，选项后若有冒号，则表示该选项必须接具体的参数</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :qvd:l: OPTION</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$OPTION</span> <span class="keyword">in</span></span><br><span class="line">        q)</span><br><span class="line">            QUIET=y</span><br><span class="line">            ;;</span><br><span class="line">        v)</span><br><span class="line">            VERBOSE=y</span><br><span class="line">            ;;</span><br><span class="line">        d)</span><br><span class="line">            DEVICE=<span class="variable">$OPTARG</span>        <span class="comment">#$OPTARG为特殊变量，表示选项的具体参数</span></span><br><span class="line">            ;;</span><br><span class="line">        l)</span><br><span class="line">            LOGFILE=<span class="variable">$OPTARG</span></span><br><span class="line">            ;;</span><br><span class="line">        \?)                       <span class="comment">#如果出现错误，则解析为?</span></span><br><span class="line">            usage</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#$OPTIND为特殊变量，表示第几个选项，初始值为1</span></span><br><span class="line"><span class="built_in">shift</span> $((<span class="variable">$OPTIND</span> - 1))      <span class="comment">#除了选项之外，该脚本必须接至少一个参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    usage</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$DEVICE</span>"</span> ]; <span class="keyword">then</span>   <span class="comment">#该脚本必须提供-d选项</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"You must specify DEVICE with -d option"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"you chose the following options.."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Quiet=<span class="variable">$QUIET</span> VERBOSE=<span class="variable">$VERBOSE</span> DEVICE=<span class="variable">$DEVICE</span> LOGFILE=<span class="variable">$LOGFILE</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$@</span>          <span class="comment">#依次处理剩余的参数</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Processing <span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 技巧：使用 screen 管理你的远程会话</title>
      <link href="/2019/04/02/linux-screen/"/>
      <url>/2019/04/02/linux-screen/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>有本事，你来顺着网线爬过来，你来咬我呀</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是不是经常需要 SSH 或者 telent 远程登录到 Linux 服务器？你是不是经常为一些长时间运行的任务而头疼，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p><h4 id="元凶：SIGHUP-信号"><a href="#元凶：SIGHUP-信号" class="headerlink" title="元凶：SIGHUP 信号"></a>元凶：SIGHUP 信号</h4><p>让我们来看看为什么关掉窗口/断开连接会使得正在运行的程序死掉。</p><p>在Linux/Unix中，有这样几个概念:</p><ul><li>进程组（process group）：一个或多个进程的集合，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。</li><li>会话期（session）：一个或多个进程组的集合，有唯一一个会话期首进程（session leader）。会话期ID为首进程的ID。</li><li>会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组。其余进程组称为后台进程组。</li></ul><p>根据POSIX.1定义:</p><ul><li>挂断信号（SIGHUP）默认的动作是终止程序。</li><li>当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。</li><li>如果会话期首进程终止，则该信号发送到该会话期前台进程组。</li><li>一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。</li></ul><p>因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。</p><p>我们来看一个例子。打开两个SSH终端窗口，在其中一个运行top命令。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># top</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>在另一个终端窗口，找到top的进程ID为15371，其父进程ID为10034，即登录shell。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># ps -ef|grep top</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root         5     2  0 Apr01 ?        00:00:00 [stopper/0]</span><br><span class="line">root         8     2  0 Apr01 ?        00:00:00 [stopper/1]</span><br><span class="line">root     15371 10034  0 18:37 pts/1    00:00:00 top</span><br><span class="line">root     15380 15352  0 18:37 pts/2    00:00:00 grep --colour=auto top</span><br><span class="line">test_dbs2 ~ <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>使用pstree命令可以更清楚地看到这个关系：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># pstree -H 15371|grep top    </span></span><br><span class="line">     |      |-sshd---sshd---bash---sudo---bash---sudo---bash---top</span><br><span class="line">test_dbs2 ~ <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>使用ps-xj命令可以看到，登录shell（PID 15371）和top在同一个会话期，shell为会话期首进程，所在进程组PGID为15371，top所在进程组PGID为9410，为前台进程组。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># ps -xj|grep 15371</span></span><br><span class="line">Warning: bad syntax, perhaps a bogus <span class="string">'-'</span>? See /usr/share/doc/procps-3.2.8/FAQ</span><br><span class="line"> 9410 10020 10020  9410 pts/1    15371 S        0   0:00 sudo bash</span><br><span class="line">10020 10021 10021  9410 pts/1    15371 S        0   0:00 bash</span><br><span class="line">10021 10033 10033  9410 pts/1    15371 S        0   0:00 sudo bash</span><br><span class="line">10033 10034 10034  9410 pts/1    15371 S        0   0:00 bash</span><br><span class="line">10034 15371 15371  9410 pts/1    15371 S+       0   0:00 top</span><br><span class="line">15352 15485 15484 15327 pts/2    15484 R+       0   0:00 grep --colour=auto 15371</span><br></pre></td></tr></tbody></table></figure><p></p><p>关闭第一个SSH窗口，在另一个窗口中可以看到top也被杀掉了。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># ps -ef|grep 15371</span></span><br><span class="line">root     15511 15352  0 18:42 pts/2    00:00:00 grep --colour=auto 15371</span><br><span class="line">test_dbs2 ~ <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>如果我们可以忽略SIGHUP信号，关掉窗口应该就不会影响程序的运行了。nohup命令可以达到这个目的，如果程序的标准输出/标准错误是终端，nohup默认将其重定向到nohup.out文件。值得注意的是nohup命令只是使得程序忽略SIGHUP信号，还需要使用标记&把它放在后台运行。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup <<span class="built_in">command</span>> [argument…] &</span><br></pre></td></tr></tbody></table></figure><p></p><p>虽然nohup很容易使用，但还是比较“简陋”的，对于简单的命令能够应付过来，对于复杂的需要人机交互的任务就麻烦了。</p><p>其实我们可以使用一个更为强大的实用程序screen。流行的Linux发行版（例如Red Hat Enterprise Linux ）</p><p>通常会自带screen实用程序，如果没有的话，可以从<a href="https://www.gnu.org/software/screen/" target="_blank" rel="noopener">GNU screen的官方网站</a>下载。</p><h2 id="开始使用Screen"><a href="#开始使用Screen" class="headerlink" title="开始使用Screen"></a>开始使用Screen</h2><p>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。在screen中创建一个新的窗口有这样几种方式：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># yum install -y screen</span></span><br><span class="line">test_dbs2 ~ <span class="comment"># </span></span><br><span class="line">test_dbs2 ~ <span class="comment"># screen --help</span></span><br><span class="line">Use: screen [-opts] [cmd [args]]</span><br><span class="line"> or: screen -r [host.tty]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-4            Use IPv4.</span><br><span class="line">-6            Use IPv6.</span><br><span class="line">-a            Force all capabilities into each window<span class="string">'s termcap.</span></span><br><span class="line"><span class="string">-A -[r|R]     Adapt all windows to the new display width & height.</span></span><br><span class="line"><span class="string">-c file       Read configuration file instead of '</span>.screenrc<span class="string">'.</span></span><br><span class="line"><span class="string">-d (-r)       Detach the elsewhere running screen (and reattach here).</span></span><br><span class="line"><span class="string">-dmS name     Start as daemon: Screen session in detached mode.</span></span><br><span class="line"><span class="string">-D (-r)       Detach and logout remote (and reattach here).</span></span><br><span class="line"><span class="string">-D -RR        Do whatever is needed to get a screen session.</span></span><br><span class="line"><span class="string">-e xy         Change command characters.</span></span><br><span class="line"><span class="string">-f            Flow control on, -fn = off, -fa = auto.</span></span><br><span class="line"><span class="string">-h lines      Set the size of the scrollback history buffer.</span></span><br><span class="line"><span class="string">-i            Interrupt output sooner when flow control is on.</span></span><br><span class="line"><span class="string">-l            Login mode on (update /var/run/utmp), -ln = off.</span></span><br><span class="line"><span class="string">-list         or -ls. Do nothing, just list our SockDir.</span></span><br><span class="line"><span class="string">-L            Turn on output logging.</span></span><br><span class="line"><span class="string">-m            ignore $STY variable, do create a new screen session.</span></span><br><span class="line"><span class="string">-O            Choose optimal output rather than exact vt100 emulation.</span></span><br><span class="line"><span class="string">-p window     Preselect the named window if it exists.</span></span><br><span class="line"><span class="string">-q            Quiet startup. Exits with non-zero return code if unsuccessful.</span></span><br><span class="line"><span class="string">-r            Reattach to a detached screen process.</span></span><br><span class="line"><span class="string">-R            Reattach if possible, otherwise start a new session.</span></span><br><span class="line"><span class="string">-s shell      Shell to execute rather than $SHELL.</span></span><br><span class="line"><span class="string">-S sockname   Name this session <pid>.sockname instead of <pid>.<tty>.<host>.</span></span><br><span class="line"><span class="string">-t title      Set title. (window'</span>s name).</span><br><span class="line">-T term       Use term as <span class="variable">$TERM</span> <span class="keyword">for</span> windows, rather than <span class="string">"screen"</span>.</span><br><span class="line">-U            Tell screen to use UTF-8 encoding.</span><br><span class="line">-v            Print <span class="string">"Screen version 4.00.03 (FAU) 23-Oct-06"</span>.</span><br><span class="line">-wipe         Do nothing, just clean up SockDir.</span><br><span class="line">-x            Attach to a not detached screen. (Multi display mode).</span><br><span class="line">-X            Execute <cmd> as a screen <span class="built_in">command</span> <span class="keyword">in</span> the specified session.</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="直接在命令行键入screen命令"><a href="#直接在命令行键入screen命令" class="headerlink" title="直接在命令行键入screen命令"></a>直接在命令行键入screen命令</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># screen</span></span><br></pre></td></tr></tbody></table></figure><p>或者添加一个名称为mysqldump<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># screen -S mysqldump</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入C-a d，Screen会给出detached提示：</p><p>暂时中断会话</p><p>半个小时之后回来了，找到该screen会话：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># screen -ls</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>重新连接会话：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># screen -r -S mysqldump</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">test_dbs2 ~ <span class="comment"># screen -r 16582</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>看看出现什么了，太棒了，一切都在。继续干吧。</p><p>你可能注意到给screen发送命令使用了特殊的键组合C-a。这是因为我们在键盘上键入的信息是直接发送给当前screen窗口，必须用其他方式向screen窗口管理器发出命令，默认情况下，screen接收以C-a开始的命令。这种命令形式在screen中叫做键绑定（key binding），C-a叫做命令字符（command character）。</p><p>可以通过C-a ?来查看所有的键绑定，常用的键绑定有：</p><table><thead><tr><th style="text-align:center">C-a ?</th><th style="text-align:center">显示所有键绑定信息</th></tr></thead><tbody><tr><td style="text-align:center">C-a w</td><td style="text-align:center">显示所有窗口列表</td></tr><tr><td style="text-align:center">C-a C-a</td><td style="text-align:center">切换到之前显示的窗口</td></tr><tr><td style="text-align:center">C-a c</td><td style="text-align:center">创建一个新的运行shell的窗口并切换到该窗口</td></tr><tr><td style="text-align:center">C-a n</td><td style="text-align:center">切换到下一个窗口</td></tr><tr><td style="text-align:center">C-a p</td><td style="text-align:center">切换到前一个窗口(与C-a n相对)</td></tr><tr><td style="text-align:center">C-a 0..9</td><td style="text-align:center">切换到窗口0..9</td></tr><tr><td style="text-align:center">C-a a</td><td style="text-align:center">发送 C-a到当前窗口</td></tr><tr><td style="text-align:center">C-a d</td><td style="text-align:center">暂时断开screen会话</td></tr><tr><td style="text-align:center">C-a k</td><td style="text-align:center">杀掉当前窗口</td></tr><tr><td style="text-align:center">C-a [</td><td style="text-align:center">进入拷贝/回滚模式</td></tr></tbody></table><p>使用键绑定C-a ?命令可以看到, 默认的命令字符（Command key）为C-a，转义C-a（literal ^a）的字符为a：</p><p>如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dbs2 ~ <span class="comment"># kill -9 8462</span></span><br><span class="line">test_dbs2 ~ <span class="comment"># screen -wipe</span></span><br><span class="line">test_dbs2 ~ <span class="comment"># screen -ls</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 优化原理(三)</title>
      <link href="/2019/03/29/mysql-optimization-principle-3/"/>
      <url>/2019/03/29/mysql-optimization-principle-3/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>戴上它。都几十岁的人了，你看你多贱，你没尊严啊？我不想看见你，快点戴上，然后去看医生。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>聊聊 MySQL 配置。</p><p>大多数开发者可能不太会关注 MySQL 的配置，毕竟在基本配置没有问题的情况下，把更多的精力放在 schema 设计、索引优化和 SQL 优化上，是非常务实的策略。这时，如果再花力气去优化配置项，获得的收益通常都比较小。更多的时候，基于安全因素的考量，普通开发者很少能够接触到生产环境的 MySQL 配置。正是这样，导致开发者（包括我）对 MySQL 的配置不甚了解，希望本文能帮你更好的了解 MySQL 配置。</p><p>如果让你在某种环境上安装配置 MySQL，你会怎么做？安装后，直接 copy 修改示例配置文件，应该是大多数人的做法。但强烈建议不要怎么做，首先，示例配置文件有非常多注释掉的配置项，它可能会诱使你打开一个你并不了解的配置，而且这些注释还不一定准确。其次，MySQL 的一些配置对于现代化的硬件和工作负载来说，有点过时了。</p><p>MySQL 有非常多的配置项可以修改，但大多数情况下，你都不应该随便修改它，因为错误或者没用的配置导致的潜在风险非常大，而且还很难定位问题。确保基本配置正确，然后小心诊断问题，确认问题恰好可以通过某个配置项解决，紧接着再修改这个配置吧。</p><p>其实，创建一个好的配置，最快方法不是从学习配置项开始，也不是问哪个配置项应该怎么设置或者怎么修改开始，更不是从检查服务器行为和询问哪个配置项可以提升性能开始。最好是从理解 MySQL 内核和行为开始，然后利用这些知识来指导你配置 MySQL。</p><p>就从理解 MySQL 配置的工作原理开始吧。</p><h2 id="MySQL-配置的工作原理"><a href="#MySQL-配置的工作原理" class="headerlink" title="MySQL 配置的工作原理"></a>MySQL 配置的工作原理</h2><p>MySQL 从哪儿获得配置信息：命令行参数和配置文件。类 Unix 系统中，配置文件一般位于 /etc/my.cnf 或者 /etc/mysql/my.cnf。在启动时，可以通过命令行参数指定配置文件的位置，当然命令行中也可以指定其它参数，服务器会读取配置文件的内容，删除所有注释和换行，然后和命令行选项一起处理。</p><p>任何打算长期使用的配置项都应该写入配置文件，而不是在命令行中指定。一定要清楚的知道 MySQL 使用的配置文件位置，在修改时不能想当然，比如，修改了 /etc/my.cnf 的配置项，但 MySQL 实际并未使用这个配置文件。如果你不知道当前使用的配置文件路径，可以尝试：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> mysqld</span><br><span class="line">/usr/sbin/mysqld</span><br><span class="line">$ /usr/sbin/mysqld --verbose --<span class="built_in">help</span> |grep -A 1 <span class="string">'Default options'</span></span><br><span class="line">Default options are <span class="built_in">read</span> from the following files <span class="keyword">in</span> the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf</span><br></pre></td></tr></tbody></table></figure><p></p><p>一个典型的配置文件包含多个部分，每个部分的开头是一个方括号括起来的分段名称。MySQL 程序通常读取跟它同名的分段部分，比如，许多客户端程序读取[client]部分。服务器通常读取[mysqld]这一段，一定要确认配置项放在了文件正确的分段中，否则配置是不会生效的。</p><p>MySQL 每一个配置项均使用小写，单词之间用下划线或者横线隔开，虽然我们常用的分隔符是下划线，但如果在命令行或者配置文件中见到如下配置，你要知道，它们其实是等价的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">max_connections=5000</span><br><span class="line">max-connections=5000</span><br><span class="line"><span class="comment"># 命令行</span></span><br><span class="line">/usr/sbin/mysqld --max_connections=5000</span><br><span class="line">/usr/sbin/mysqld --max-connections=5000</span><br></pre></td></tr></tbody></table></figure><p></p><p>配置项可以有多个作用域：全局作用域、会话作用域 (每个连接作用不同)、对象作用域。很多会话级配置项跟全局配置相等，可以认为是默认值，如果改变会话级配置项，它只影响改动的当前连接，当连接关闭时，所有的参数变更都会失效。下面有几个示例配置项：</p><ul><li><code>query-cache-size</code> 全局配置项</li><li><code>sort-buffer-size</code> 默认全局相同，但每个线程里也可以设置</li><li><code>join-buffer-size</code> 默认全局，且每个线程也可以设置。但若一个查询中关联多张表，可以为每个关联分配一个关联缓存 (join-buffer)，所以一个查询可能有多个关联缓冲。</li></ul><p>配置文件中的变量 (配置项) 有很多 (但不是所有) 可以在服务器运行时修改，MySQL 把这些归为动态配置变量：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 设置全局变量，GLOBAL和@@global作用是一样的</span><br><span class="line"><span class="built_in">set</span>   GLOBAL   sort-buffer-size  = <value></span><br><span class="line"><span class="built_in">set</span>   @@global.sort-buffer-size := <value></span><br><span class="line"></span><br><span class="line">-- 设置会话级变量，下面6种方式作用是一样的</span><br><span class="line">-- 即：没有修饰符、SESSION、LOCAL等修饰符作用是一致的</span><br><span class="line"><span class="built_in">set</span>  SESSION   sort-buffer-size  = <value></span><br><span class="line"><span class="built_in">set</span>  @@session.sort-buffer-size := <value></span><br><span class="line"><span class="built_in">set</span>          @@sort-buffer-size  = <value></span><br><span class="line"><span class="built_in">set</span>  LOCAL     sort-buffer-size  = <value></span><br><span class="line"><span class="built_in">set</span>     @@ocal.sort-buffer-size := <value></span><br><span class="line"><span class="built_in">set</span>            sort-buffer-size  = <value></span><br><span class="line"></span><br><span class="line">-- <span class="built_in">set</span>命令可以同时设置多个变量，但其中只要有一个变量设置失败，所有的变量都未生效</span><br><span class="line">SET GLOBAL sort-buffer-size = 100, SESSION sort-buffer-size = 1000;</span><br><span class="line">SET GLOBAL max-connections = 1000, sort-buffer-size = 1000000;</span><br></pre></td></tr></tbody></table></figure><p></p><p>动态的设置变量，MySQL 关闭时这些变量都会失效。如果在服务器运行时修改了变量的全局值，这个值对当前会话和其他任何已经存在的会话都不起效果，这是因为会话的变量值是在连接创建时从全局值初始化而来的。注意，在配置修改后，需要确认是否修改成功。</p><p>你可能注意到，上面的示例中，有些使用 ‘=’，有些使用 ‘:=’。对于 set 命令本身来说，两种赋值运算符没有任何区别，在命令行中使用任一运算符符，均可以生效。而在其他语句中，赋值运算符必须是 ‘:=’，因为在非 set 语句中 ‘=’ 被视为比较运算符。具体可以参考如下示例：</p><p>详细示例可以参考：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- @exp 表示用户变量，上面的示例均是系统变量</span><br><span class="line">-- 错误</span><br><span class="line"><span class="built_in">set</span> @user = 123456;</span><br><span class="line"><span class="built_in">set</span> @group = select GROUP from USER <span class="built_in">where</span> User = @user;</span><br><span class="line">select * from USER <span class="built_in">where</span> GROUP = @group;</span><br><span class="line"></span><br><span class="line">-- 正确</span><br><span class="line">SET @user := 123456;</span><br><span class="line">SELECT @group := `group` FROM user WHERE user = @user;</span><br><span class="line">SELECT * FROM user WHERE `group` = @group;</span><br></pre></td></tr></tbody></table></figure><p></p><p>有一些配置使用了不同的单位，比如table-cache变量指定表可以被缓存的数量，而不是表可以被缓存的字节数。而<code>key-buffer-size</code>则是以字节为单位。</p><p>还有一些配置可以指定后缀单位，比如1M=1024<em>1024字节，但需要注意的是，这只能在配置文件或者作为命令行参数时有效。当使用 SQL 的 SET 命令时，必须使用数字值 1048576 或者 1024</em>1024 这样的表达式，但在配置文件中不能使用表达式。</p><p><strong>小心翼翼的配置 MySQL</strong><br>我们常常动态的修改配置，但请务必小心，因为它们可能导致数据库做大量耗时的工作，从而影响数据库的整体性能。比如从缓存中刷新脏块，不同的刷新方式对 I/O 的影响差别很大 (后文会具体说明)。最好把一些好的习惯作为规范合并到工作流程中去，就比如：</p><p><strong>好习惯 1：不要通过配置项的名称来推断一个变量的作用</strong></p><p>不要通过配置项的名称来推断一个变量的作用，因为它可能跟你想象的完全不一样。比如：</p><ul><li><code>read-buffer-size</code>：当 MySQL 需要顺序读取数据时，如无法使用索引，其将进行全表扫描或者全索引扫描。这时，MySQL 按照数据的存储顺序依次读取数据块，每次读取的数据块首先会暂存在缓存中，当缓存空间被写满或者全部数据读取结束后，再将缓存中的数据返回给上层调用者，以提高效率。</li><li><code>read-rnd-buffer-size</code>：和顺序读取相对应，当 MySQL 进行非顺序读取（随机读取）数据块的时候，会利用这个缓冲区暂存读取的数据。比如：根据索引信息读取表数据、根据排序后的结果集与表进行 Join 等等。总的来说，就是当数据块的读取需要满足一定的顺序的情况下，MySQL 就需要产生随机读取，进而使用到read-rnd-buffer-size参数所设置的内存缓冲区。</li></ul><p>这两个配置都是在扫描 MyISAM 表时有效，且 MySQL 会为每个线程分配内存。对于前者，MySQL 只会在查询需要使用时才会为该缓存分配内存，并且一次性分配该参数指定大小的全部内存，而后者同样是需要时才分配内存，但只分配需要的内存大小而不是参数指定的数值，max-read-rnd-buffer-size(实际上没有这个配置项) 这个名字更能表达这个变量的实际含义。</p><p><strong>好习惯 2：不要轻易在全局修改会话级别的配置</strong></p><p>对于某些会话级别的设置，不要轻易的在全局增加它们的值，除非你确认这样做是对的。比如：<code>sort-buffer-size</code>，该参数控制排序操作的缓存大小，MySQL 只会在查询需要做排序操作时才会为该缓冲分配内存，一旦需要排序，就会一次性分配指定大小的内存，即使是非常小的排序操作。因此在配置文件中应该配置的小一些，然后在某些查询需要排序时，再在连接中把它调大。比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET @@seession.sort-buffer-size := <value></span><br><span class="line">-- 执行查询的sql</span><br><span class="line">SET @@seession.sort-buffer-size := DEFAULT -- 恢复默认值</span><br><span class="line">-- 可以将类似的代码封装在函数中方便使用。</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>好习惯 3：配置变量时，并不是值越大越好</strong><br>配置变量时，并不是值越大越好，而且如果设置的值太高，可能更容易导致内存问题。在修改完成后，应该通过监控来确认变量的修改对服务器整体性能的影响。</p><p><strong>好习惯 4：规范注释，版本控制</strong><br>在配置文件中写好注释，可能会节省自己和同事大量的工作，一个更好的习惯是把配置文件置于版本控制之下。</p><p>说完了好习惯，再来说说不好的习惯。</p><p><strong>坏习惯 1：根据一些 “比率” 来调优</strong><br>一个经典的按 “比率” 调优的经验法则是，缓存的命中率应该高于某个百分比，如果命中率过低，则应该增加缓存的大小。这是非常错误的意见，大家可以仔细思考一下：缓存的命中率跟缓存大小有必然联系吗？(分母变大，值就变大了？) 除非确实是缓存太小了。关于 MyISAM 键缓冲命中率，下文会详细说明。</p><p><strong>坏习惯 2：随便使用调优脚本</strong><br>尽量不要使用调优脚本！不同的业务场景、不同的硬件环境对 MySQL 的性能要求是不一样的。比如有些业务对数据的完整性要求较高，那么就一定要保证数据不丢失，出现故障后可恢复数据，而有些业务却对数据的完整性要求没那么高，但对性能要求更高。因此，即使是同一个变量，在这两个不同场景下，其配置的值也应该是不同的。那你还能放心的使用网上找到的脚本吗 ？</p><blockquote><p>本小节示例的几个配置项，仅用于举例说明，并不代表它们有多么重要，请根据实际应用场景配置它们。就比如<code>sort-buffer-size</code>，你真的需要 100M 内存来缓存 10 行数据？</p></blockquote><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>MySQL 配置文件的格式为集中式，通常会分成好几部分，可以为多个程序提供配置，如<code>[client]</code>、<code>[mysqld]</code>、<code>[mysql]</code>等等。MySQL 程序通常是读取与它同名的分段部分。</p><ul><li><code>[client]</code>客户端默认设置内容</li><li><code>[mysql]</code>使用 mysql 命令登录 MySQL 数据库时的默认设置</li><li><code>[mysqld]</code>数据库本身的默认设置</li></ul><p>例如服务器 mysqld 通常读取<code>[mysqld]</code>分段下的相关配置项。如果配置项位置不正确，该配置是不会生效的。</p><h4 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h4><p>首先创建一个用户 mysql 来运行 mysqld 进程，请确保这个用户拥有操作数据目录的权限。设置默认端口为 3306，有时为了安全，可能会修改一下。默认选择 Innodb 存储引擎，在大多数情况下是最好的选择。但如果默认是 InnoDB，却需要使用 MyISAM 存储引擎，请显式地进行配置。许多用户认为其数据库使用了某种存储引擎但实际上却使用的是另外一种，就是因为默认配置的问题。</p><p>接着设置数据文件的位置，这里把 pid 文件和 socket 文件放到相同的位置，当然也可以选择其它位置，但要注意的是不要将 socket 文件和 pid 文件放到 MySQL 编译的默认位置，因为不同版本的 MySQL，这两个文件的默认路径可能会不一致，最好明确地设置这些文件的位置，以免版本升级时出现问题。</p><blockquote><p>在类 UNIX 系统下本地连接 MySQL 可以采用 UNIX 域套接字方式，这种方式需要一个套接字（socket）文件，即配置中的mysql.sock文件。</p></blockquote><blockquote><p>当 MySQL 实例启动时，会将自己的进程 ID 写入一个文件中——该文件即为 pid 文件。该文件可由参数pid-file控制，默认位于数据库目录下，文件名为主机名.pid。</p></blockquote><h4 id="DATA-STORAGE"><a href="#DATA-STORAGE" class="headerlink" title="DATA STORAGE"></a>DATA STORAGE</h4><p>datadir用于配置数据文件的存储位置，没有什么好说的。</p><p><strong>为缓存分配内存</strong><br>接下来有许多涉及到缓存的配置项，缓存设置多大，最直接的因素肯定是服务器内存的大小。如果服务器只运行 MySQL，所有不需要为 OS 以及查询处理保留的内存都可以用在 MySQL 缓存。为 MySQL 缓存分配更多内存，可以有效的避免磁盘访问，提升数据库性能。大部分情况来说最为重要的缓存：</p><ul><li>InnoDB 缓冲池</li><li>InnoDB 日志文件和 MyISAM 数据的操作系统缓存 (MyISAM 依赖于 OS 缓存数据)</li><li>MyISAM 键缓存</li><li>查询缓存</li><li>无法配置的缓存，比如：bin-log 或者表定义文件的 OS 缓存</li></ul><p>还有一些其他缓存，但它们通常不会使用太多内存。关于查询缓存，前面文章 (参考本系列的第一篇) 已有介绍，大多数情况下我们不建议开启查询缓存，因此上文的配置中query-cache-type=0表示禁用了查询缓存，相应的查询缓存大小query-cache-size=0。除开查询缓存，剩下关于 InnoDB 和 MyISAM 的相关缓存，在接下来会做详细介绍。</p><p>如果只使用单一存储引擎，配置服务器就会简单许多。如果只使用 MyISAM 表，就可以完全关闭 InnoDB，而如果只使用 InnoDB，就只需要分配最少的资源给 MyISAM（MySQL 内部系统表使用 MyISAM 引擎）。但如果是混合使用各种存储引擎，就很难在他们之间找到恰当的平衡，因此只能根据业务做一个猜测，然后在运行中观察服务器运行状况后做出调整。</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p><strong>key-buffer-size</strong></p><p><code>key-buffer-size</code>用于配置 <code>MyISAM</code>键缓存大小，默认只有一个键缓存，但是可以创建多个。MyISAM 自身只缓存索引，不缓存数据 (依赖 OS 缓存数据)。如果大部分表都是 <code>MyISAM</code>，那么应该为键缓存设置较多的内存。但如何确定该设置多大？<br>假设整个数据库中表的索引大小为 X，肯定不需要把缓存设置得比 X 还大，所以当前的索引大小就成为这个配置项的重要依据。可以通过下面两种方式来查询当前索引的大小：</p><p>1.通过 SQL 语句查询<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(INDEX_LENGTH) FROM INFORMATION_SCHEMA.TABLES WHERE ENGINE = <span class="string">'MYISAM'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>2.统计索引文件的大小<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ du -sch `find /path/to/mysql/data/directory/ -name <span class="string">"*.MYI"</span>`</span><br><span class="line">比如：</span><br><span class="line">root@dev-msc3:<span class="comment"># du -sch `find /var/lib/mysql -name "*.MYI"`</span></span><br><span class="line">72K        /var/lib/mysql/static/t_global_region.MYI</span><br><span class="line">40K        /var/lib/mysql/mysql/db.MYI</span><br><span class="line">12K        /var/lib/mysql/mysql/proxies_priv.MYI</span><br><span class="line">12K        /var/lib/mysql/mysql/tables_priv.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/func.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/columns_priv.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/proc.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/event.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/user.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/procs_priv.MYI</span><br><span class="line">4.0K       /var/lib/mysql/mysql/ndb_binlog_index.MYI</span><br><span class="line">164K       total</span><br></pre></td></tr></tbody></table></figure><p></p><p>你可能会问，刚创建好的数据库，根本就没什么数据，索引文件大小为 0，那如何配置键缓存大小？这时候只能根据经验值：不超过为操作系统缓存保留内存的 25% ~ 50%。设置一个基本值，等运行一段时间后，根据运行情况来调整键缓存大小。总结来说，索引大小与 OS 缓存的 25%~50% 两者间取小者。当然还可以计算键缓存的使用情况，如果一段时间后还是没有使用完所有的键缓存，就可以把缓冲区调小一点，计算缓存区的使用率可以通过以下公式：<br><strong>(key_blocks_unused * key_cache_block_size) / key_buffer_size</strong></p><blockquote><p>说明：</p></blockquote><blockquote><p>key_blocks_unused 的值可以通过 SHOW STATUS 获取</p></blockquote><blockquote><p>key_cache_block_size 的值可以通过 SHOW VARIABLES 获取</p></blockquote><p>键缓存块大小是一个比较重要的值，因为它影响 MyISAM、OS 缓存以及文件系统之间的交互。如果缓存块太小，可能会碰到写时读取 (OS 在写数据之前必须先从磁盘上读取一些数据)，关于写时读取的相关知识，大家可以自行查阅。</p><p>关于缓存命中率，这里再说一点。缓存命中率有什么意义？其实这个数字没太大的作用。比如 99% 和 99.9% 之间看起来差距很小，但实际上代表了 10 倍的差距。缓存命中率的实际意义与应用也有很大关系，有些应用可以在命中率 99% 下良好的工作，有些 I/O 密集型应用，可能需要 99.99%。所以从经验上来说，每秒未命中次数这个指标实际上会更有用一些。比如每秒 5 次未命中可能不会导致 IO 繁忙，但每秒 100 次缓存未命中则可能出现问题。</p><p>MyISAM 键缓存的每秒未命中次数可以通过如下命令监控：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每隔10s缓存未命中次数的增量</span></span><br><span class="line"><span class="comment"># 使用此命令时请带上用户和密码参数：mysqladmin -uroot -pxxx extended-status -r -i 10 | grep Key_reads</span></span><br><span class="line">$ mysqladmin extended-status -r -i 10 | grep Key_reads</span><br></pre></td></tr></tbody></table></figure><p></p><p>最后，即使没有使用任何 MyISAM 表，依然需要将key-buffer-size设置为较小值，比如 32M，因为 MySQL 内部会使用 MyISAM 表，比如 GROUP BY 语句可能会创建 MyISAM 临时表。</p><h4 id="myisam-recover"><a href="#myisam-recover" class="headerlink" title="myisam-recover"></a>myisam-recover</h4><p>myisam-recover选项用于配置 MyISAM 怎样寻找和修复错误。打开这个选项会通知 MySQL 在打开表时，检查表是否损坏，并在找到问题时进行修复，它可以设置如下值：    </p><ul><li>DEFAULT：表示不设置，会尝试修复崩溃或者未完全关闭的表，但在恢复数据时不会执行其它动作</li><li>BACKUP：将数据文件备份到. bak 文件，以便随后进行检查</li><li>FORCE：即使. myd 文件中丢失的数据超过 1 行，也让恢复动作继续执行</li><li>QUICK：除非有删除块，否则跳过恢复</li></ul><p>可以设置多个值，每个值用逗号隔开，比如配置文件中的BACKUP,FORCE会强制恢复并且创建备份，这样配置在只有一些小的 MyISAM 表时有用，因为服务器运行着一些损坏的 MyISAM 表是非常危险的，它们有时可能会导致更多数据损坏，甚至服务器崩溃。然而如果有很大的表，它会导致服务器打开所有的 MyISAM 表时都检查和修复，大表的检查和修复可能会耗费大量时间，且在这段时间里，MySQL 会阻止这个连接做其它任何操作，这显然是不切实际的。</p><p>因此，在默认使用 InnoDB 存储引擎时，数据库中只有非常小的 MyISAM 表时，只需要配置key-buffe-size于一个很小的值 (32M) 以及myisam-recover=BACKUP,FORCE。当数据库中大部分表为 MyISAM 表时，请根据上文的公式合理配置key-buffer-size，而myisam-recover则可以关闭，在启动后使用CHECK TABLES和REPAIR TABLES命令来做检查和修复，这样对服务器的影响比较小。</p><h4 id="SAFETY"><a href="#SAFETY" class="headerlink" title="SAFETY"></a>SAFETY</h4><p>基本配置设置到位后，MySQL 已经比较安全了，这里仅仅列出两个需要注意的配置项，如果需要启用一些使服务器更安全和可靠的设置，可以参考 MySQL 官方手册，但需要注意的是，它们其中的一些选项可能会影响性能，毕竟保证安全和可靠需要付出一些代价。</p><p><strong>max-allowed-packet</strong><br><code>max-allowed-packet</code>防止服务器发送太大的数据包，也控制服务器可以接收多大的包。默认值 4M，可能会比较小。如果设置太小，有时复制上会出问题，表现为从库不能接收主库发过来的复制数据。如果表中有 Blob 或者 Text 字段，且数据量较大的话，要小心，如果数据量超过这个变量的大小，它们可能被截断或者置为 NULL，这里建议设置为 16M。</p><p><strong>max-connect-errors</strong><br>这个变量是一个 MySQL 中与安全相关的计数器值，它主要防止客户端暴力破解密码。如果某一个客户端尝试连接 MySQL 服务器失败超过 n 次，则 MySQL 会无条件强制阻止此客户端连接，直到再次刷新主机缓存或者重启 MySQL 服务器。</p><p>这个值默认为 10，太小了，有时候网络抽风或者应用配置出现错误导致短时间内不断尝试重连服务器，客户端就会被列入黑名单，导致无法连接。如果在内网环境，可以确认没有安全问题可以把这个值设置的大一点，默认值太容易导致问题。</p><h4 id="LOGGING"><a href="#LOGGING" class="headerlink" title="LOGGING"></a>LOGGING</h4><p>接下来看下日志的配置，对于 MySQL 来说，慢日志和 bin-log 是非常重要的两种日志，前者可以帮助应用程序监控性能问题，后者在数据同步、备份等方面发挥着非常重要的作用。</p><p>关于 bin-log 的 3 个配置，log-bin用于配置文件存放路径，expire_logs_days让服务器在指定天数之后清理旧的日志，即配置保留最近多少天的日志。除非有运维手动备份清理 bin-log，否则强烈建议打开此配置，如果不启用，服务器空间最终将会被耗尽，导致服务器卡住或者崩溃。</p><h4 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync-binlog"></a>sync-binlog</h4><p><code>sync-binlog</code>控制当事务提交之后，MySQL 是否将 bin-log 刷新到磁盘。如果其值等于 0 或者大于 1 时，当事务提交之后，MySQL 不会将 bin-log 刷新到磁盘，其性能最高，但存在的风险也是最大的，因为一旦系统崩溃，bin-log 将会丢失。而当其值等于 1 时，是最安全的，这时候即使系统崩溃，最多也就丢失本次未完成的事务，对实际的数据没有实质性的影响，但性能较差。</p><p>需要注意的是，在 5.7.7 之前的版本，这个选择的默认值为 0，而之后的版本默认值为 1，也就是最安全的策略。对于高并发的性能，需要关注这一点，防止版本升级后出现性能问题。</p><p>剩下的 4 个配置项就没太多要说的。</p><ul><li>log-error：用于配置错误日志的存放目录</li><li>slow-query-log：打开慢日志，默认关闭</li><li>slow-query-log-file：配置慢日志的存放目录</li><li>log-queries-not-using-indexes：如果该 sql 没有使用索引，会将其写入到慢日志，但是否真的执行很慢，需要区分，默认关闭。</li></ul><h4 id="CACHES-AND-LIMITS"><a href="#CACHES-AND-LIMITS" class="headerlink" title="CACHES AND LIMITS"></a>CACHES AND LIMITS</h4><p><strong>tmp-table-size && max-heap-table-size</strong><br>这两个配置控制使用 Memory 引擎的内存临时表可以使用多大的内存。如果隐式内存临时表的大小超过这两个值，将会被转为磁盘 MyISAM 表 (隐式临时表由服务器创建，用户保存执行中的查询的中间结果)。</p><p>如果查询语句没有创建庞大的临时表 (通过合理的索引和查询设计来避免)，可以把这个值设大一点，以免需要把内存临时表转换为磁盘临时表。但要谨防这个值设置得过大，如果查询确实会创建很大的临时表，那么还是使用磁盘比较好，毕竟并发数一起来，所需要的内存就会急剧增长。</p><p>应该简单的把这两个变量设为同样的值，这里选择了 32M，可以通过仔细检查created-tmp-disk-tables和created-tmp-tables两个变量来指导你设置，这两个变量的值将展示临时表的创建有多频繁。</p><p><strong>max-connections</strong></p><p>用于设置用户的最大连接数，保证服务器不会应为应用程序激增的连接而不堪重负。如果应用程序有问题，或者服务器遇到连接延迟问题，会创建很多新连接。但如果这些连接不能执行查询，那打开一个连接没什么好处，所以被 “太多的连接” 错误拒绝是一种快速而且代价小的失败方式。</p><p>在服务器资源允许的情况下，可以把<code>max-connections</code>设置的足够大，以容纳正常可能达到的负载。若认为正常情况将有 <code>300</code> 或者更多连接，可以设置为 <code>500</code> 或者更多 (应对高峰期)。默认值是 <code>100</code>，太小了，这里设置为 <code>500</code>，但并不意味着其是一个合理的值，应该监控应用有多少连接，然后根据监控值 (观察<code>max_used_connections</code>随时间的变化) 来设置。</p><p><strong>thread-cache-size</strong></p><p>线程缓存保存那些当前没有与连接关联但是准备为后面新连接服务的线程。当一个新的连接创建时，如果缓存中有线程存在，MySQL 则从缓存中删除一个线程，并且把它分配给这个新连接。当连接关闭时，如果线程缓存还有空间的话，MySQL 又会把线程放回缓存。如果没有空间的话，MySQL 会销毁这个线程。只要 MySQL 在缓存里还有空闲的线程，它就可以迅速响应连接请求，因为这样就不用为每个连接创建新线程。<code>thread-cache-size</code>指定 MySQL 可以保存在缓存中的线程数量。如果服务器没有很多的连接请求，一般不需要配置这个值。</p><p>如何判断这个值该设置多大？</p><p>观察threads-connected变量，如果threads-connected在 100-120，那么thread-cache-size设置为 20。如果它保持在 500-700，200 的线程缓存应该足够大了。可以这么理解：当同时有 700 个连接时，可能缓存中没有线程。在 500 个连接时，有 200 个缓存的线程准备为负载再次增加到 700 个连接时使用。</p><p><strong>open-files-limit</strong></p><p>在类 Uinux 系统上我们把它设置得尽可能大。现代 OS 中打开句柄开销都很小，如果此参数设置过小，可能会遇到 “打开的文件太多 (too many open files)” 错误。</p><p><strong>table_cache_size</strong></p><p>表缓存跟线程缓存类似，但存储的对象是表，其包含表. frm 文件的解析结果和一些其他数据。准确的说，缓存的数据依赖于存储引擎，比如，对于 MyISAM，缓存表的数据和索引的文件描述符。表缓存对 InnoDB 的存储引擎来说，重要性会小很多，因为 InnoDB 不依赖它来做那么多的事。</p><p>从 5.1 版本及以后，表缓存就被分为两个部分：打开表缓存和定义表缓存，分别通过table-open-cache-size和table-definition-cache-size变量来配置。通常可以把table-definition-cache-size设置得足够高，以缓存所有的表定义，因为大部分存储引擎都能从table-definition-cache获益。</p><p><strong>InnoDB</strong></p><p>InnoDB 应该是使用最广发的存储引擎，最重要的配置选项是下面这两个：innodb-buffer-pool-size与innodb-log-file-size，解决这两个配置基本上就解决了真实场景下的大部分配置问题。</p><p><strong>innodb-buffer-pool-size</strong></p><p>如果大部分是 InnoDB 表，那么 InnoDB 缓冲池或许比其他任何东西都更需要内存，InnoDB 缓冲池缓冲的数据：索引、行数据、自适应哈希索引、插入缓冲、锁以及其他内部数据结构。InnoDB 还使用缓冲池来帮助延迟写入，这样就可以合并多个写入操作，然后一起顺序写入，提升性能。总之，InnoDB 严重依赖缓冲池，必须为其分配足够的内存。</p><p>当然，如果数据量不大且不会快速增长，就没有必要为缓冲池分配过多的内存，把缓冲池配置得比需要缓存的表和索引还要大很多，实际上也没有什么意义。很大的缓冲池也会带来一些挑战，例如，预热和关闭都会花费很长的时间。如果有很多脏页在缓冲池里，InnoDB 关闭时可能会花很长时间来把脏页写回数据文件。虽然可以快速关闭，但是在启动时需要做更多的恢复工作，也就是说我们无法同时加速关闭和重启两个操作。当有一个很大的缓冲池，重启服务需要花费很长时间（几小时或者几天）来预热，尤其是磁盘很慢的时候，如果想加快预热时间，可以在重启后立刻进行全表扫描或者索引扫描，把索引载入缓冲池。</p><p>可以看到示例的配置文件中把这个值配置为 12G，这不是一个标准配置，需要根据具体的硬件来估算。那如何估算？</p><p>前面的小节，我们说到，MySQL 中最重要的缓存有 5 种，可以简单的使用下面的公式计算：</p><p><em><strong>InnoDB 缓冲池 = 服务器总内存 - OS 预留 - 服务器上的其他应用占用内存 - MySQL 自身需要的内存 - InnoDB 日志文件占用内存 - 其它内存 (MyISAM 键缓存、查询缓存等)</strong></em></p><p>具体来看，至少需要为 OS 保留 1~2G 内存，如果机器内存大的话可以预留多一些，建议 2GB 和总内存的 5% 为基准，以较大者为准，如果机器上还运行着一些内存密集型任务，比如，备份任务，那么可以为 OS 再预留多一些内存。不要为 OS 缓存增加任何内存，因为 OS 通常会利用所有剩下的内存来做文件缓存。</p><p>一般来说，运行 MySQL 的服务器很少会运行其他应用程序，但如果有的话，请为这些应用程序预留足够多的内存。</p><p>MySQL 自身运行还需要一些内存，但通常都不会太大。需要考虑 MySQL 每个连接需要的内存，虽然每个连接需要的内存都很少，但它还要求一个基本量的内存来执行任何给定的查询，而且查询过程中还需要为排序、GROUP BY 等操作分配临时表内存，因此需要为高峰期执行大量的查询预留足够的内存。这个内存有多大？只能在运行过程中监控。</p><p>如果大部分表都是 InnoDB，MyISAM 键缓存配置一个很小值足矣，查询缓存也建议关闭。</p><p>公式中就剩下 InnoDB 日志文件了，这就是我们接下来要说的。</p><p><strong>innodb-log-file-size && innodb-log-files-in-group</strong></p><p>如果对 InnoDB 数据表有大量的写入操作，那么选择合适的innodb-log-file-size值对提升 MySQL 性能很重要。InnoDB 使用日志来减少提交事务时的开销。日志中记录了事务，就无须在每个事务提交时把缓冲池的脏块 (缓存中与磁盘上数据不一致的页) 刷新到磁盘。事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 I/O。一旦日志安全的写入磁盘，事务就持久化了，即使变更还没有写到数据文件，在一些意外情况发生时 (比如断电了)，InnoDB 可以重放日志并且恢复已经提交的事务。</p><p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。实际上，事务日志把数据文件的随机 I/O 转换为几乎顺序地日志文件和数据文件 I/O，让刷新操作在后台可以更快的完成，并且缓存 I/O 压力。</p><p>整体的日志文件大小受控于<code>innodb-log-file-size</code>和<code>innodb-log-files-in-group</code>两个参数，这对写性能非常重要。日志文件的总大小是每个文件的大小之和。默认情况下，只有两个 5M 的文件，总共 10M，对高性能工作来说太小了，至少需要几百 M 或者上 G 的日志文件。这里要注意<code>innodb-log-files-in-group</code>这个参数，它控制日志文件的数量，从名字上看好似配置一个日志组有几个文件，实际上，log group表示一个重做日志的文件集合，没有参数也没有必要配置有多少个日志组。</p><p>修改日志文件的大小，需要完全关闭 MySQL，然后将旧的日志文件迁移到其他地方，重新配置参数，然后重启。重启时需要将旧的日志迁移回来，然后等待 MySQL 恢复数据后，再删除旧的日志文件，请一定要查看错误日志，确认 MySQL 重启成功后再删除旧的日志文件。</p><p>想要确定理想的日志文件大小，需要权衡正常数据变更的开销，以及崩溃时恢复需要的时间。如果日志太小，InnoDB 将必须要做更多的检查点，导致更多的日志写，在极个别情况下，写语句还会被拖累，在日志没有空间继续写入前，必须等待变更被刷新到数据文件。另一方面，如果日志太大，在崩溃时恢复就得做大量的工作，这可能增大恢复时间。InnoDB 会采用 checkpoint 机制来刷新和恢复数据，这会加快恢复数据的时间，具体可以参考：</p><ul><li><a href="http://www.cnblogs.com/cuisi/p/6590281.html" target="_blank" rel="noopener">MySQL-checkpoint 技术</a></li><li><a href="https://www.xaprb.com/blog/2011/01/29/how-innodb-performs-a-checkpoint/" target="_blank" rel="noopener">How InnoDB performs a checkpoint</a></li></ul><p><strong>innodb-flush-log-at-trx-commit</strong></p><p>前面讨论了很多缓存，InnoDB 日志也是有缓存的。当 InnoDB 变更任何数据时，会写一条变更记录到日志缓存区。在缓冲慢的时候、事务提交的时候，或者每一秒钟，InnoDB 都会将缓冲区的日志刷新到磁盘的日志文件。如果有大事务，增加日志缓冲区大小可以帮助减少 I/O，变量innodb-log-buffer-size可以控制日志缓冲区的大小。通常不需要把日志缓冲区设置的非常大，毕竟上述 3 个条件，任一条件先触发都会把缓冲区的内容刷新到磁盘，所以缓冲区的数据肯定不会太多，出入你的数据中有很多相当大的 BLOB 记录。通常来说，配置 1M~8M 即可。</p><p>既然存在缓冲区，怎样刷新日志缓冲就是我们需要关注的问题。日志缓冲必须刷新到磁盘，以确保提交的事务完全被持久化。如果和持久化相比，更在乎性能，可以修改 innodb-flush-log-at-trx-commit 变量来控制日志缓冲刷新的频率。</p><ul><li>0：每 1 秒钟将日志缓冲写到日志文件并刷新到磁盘，事务提交时不做任何处理</li><li>1：每次事务提交时，将日志缓冲写到日志文件并刷新到磁盘</li><li>2：每次事务提交时，将日志缓冲写到日志文件，然后每秒刷新一次到磁盘</li></ul><blockquote><p>1  是最安全的设置，保证不会丢失任何已经提交的事务，这也是默认的设置。</p></blockquote><blockquote><p>0 和 2 最主要的区别是，如果 MySQL 挂了，2 不会丢失事务，但 0 有可能，</p></blockquote><blockquote><p>2 在每次事务提交时，至少将日志缓冲刷新到操作系统的缓存，而 0 则不会。如果整个服务器挂了或者断电了，则还是可能会丢失一些事务。</p></blockquote><p><strong>innodb-flush-method</strong></p><p>前面都在讨论使用什么样的策略刷新、以及何时刷新日志或者数据，那 InnoDB 具体是怎样刷新数据的？使用innodb-flush-method选项可以配置 InnoDB 如何跟文件系统相互作用。从名字上看，会以为只能影响 InnoDB 怎么写数据，实际上还影响了 InnoDB Windows 和非 Windows 操作系统下这个选项的值是互斥的，也就是说有些值只能 Windows 下使用，有些只能在非 Windows 下使用，其中 Windows 下可取值：async_unbuffered、unbuffered、normal、Nosync与littlesync，非 Windows 取值：fdatasync、0_DIRECT、 0_DSYNC。</p><p>这个选项既会影响日志文件，也会影响数据文件，而且有时候对不同类型的文件的处理也不一样，导致这个选项有些难以理解。如果有一个选项来配置日志文件，一个选项来配置数据文件，应该会更好，但实际上它们混合在同一个配置项中。这里只介绍类 Unix 操作系统下的选项。</p><p><strong>fdatasync</strong></p><p>InnoDB 调用fsync()和fdatasync()函数来刷新数据和日志文件，其中fdatasync()只刷文件的数据，但不包含元数据 (比如：访问权限、文件拥有者、最后修改时间等描述文件特征的系统数据)，因此fsync()相比fdatasync()会产生更多的 I/O，但在某些场景下fdatasync()会导致数据损坏，因此 InnoDB 开发者决定用fsync()来代替fdatasync()。</p><p>fsync()的缺点是操作系统会在自己的缓存中缓冲一些数据，理论上双重缓冲是浪费的，因为 InnoDB 自己会管理缓冲，而且比操作系统更加智能。但如果文件系统能有更智能的 I/O 调度和批量操作，双重缓冲也并不一定是坏事：</p><ul><li>有的文件系统和 os 可以累积写操作后合并执行，通过对 I/O 的重排序来提升效率、或者并发写入多个设备</li><li>有的还可以做预读优化，比如连续请求几个顺序的块，它会通知硬盘预读下一个块</li></ul><p>这些优化在特定的场景下才会起作用，fdatasync为innodb-flush-method的默认值。</p><p><strong>0_DIRCET</strong></p><p>这个设置不影响日志文件并且不是所有的类 Unix 系统都有效，但至少在 Linux、FreeBSD 以及 Solaris 是支持的。这个设置依然使用 fsync 来刷新文件到磁盘，但是它完全关闭了操作系统缓存，并且是所有的读和写都直接通过存储设置，避免了双重缓冲。如果存储设备支持写缓冲或预读，那么这个选项并不会影响到设备的设置，比如 RAID 卡。</p><p><strong>0_DSYNC</strong></p><p>这个选项使得所有的写同步，即只有数据写到磁盘后写操作才返回，但它只影响日志文件，而不影响数据文件。</p><p>说完了每个配置的作用，最后是一些建议：如果使用类 Unix 操作系统并且 RAID 控制器带有电池保护的写缓存，建议使用 0_DIRECT，如果不是，默认值或者 0_DIRECT 都可能是最好的选择。</p><p><strong>innodb-file-per-table</strong></p><p>最后一个配置，说说 InnoDB 表空间，InnoDB 把数据保存在表空间内，它本质上是一个由一个或者多个磁盘文件组成的虚拟文件系统。InnoDB 表空间并不只是存储表和索引，它还保存了回滚日志、插入缓冲、双写缓冲以及其他内部数据结构，除此之外，表空间还实现了很多其它的功能。可以通过 innodb-data-file-path 配置项定制表空间文件，innodb-data-home-dir配置表空间文件存放的位置，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb-data-home-dir = /var/lib/mysql</span><br><span class="line">innodb-data-file-path = ibdata1:1G;ibdata2:1G;ibdata3:1G</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里在 3 个文件中创建了 3G 表空间，为了允许表空间在超过了分配的空间时还能增长，可以像这样配置最后一个文件自动扩展<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb-data-file-path = ibdata1:1G;ibdata2:1G;ibdata3:1G:autoextend</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>innodb-file-per-table</code>选项让 InnoDB 为每张表使用一个文件，这使得在删除一张表时回收空间容易很多，而且特别容易管理，并且可以通过查看文件大小来确定表大小，所以这里建议打开这个配置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MySQL 有太多的配置项，这里没有办法一一列举，重要的是了解每个配置的工作原理，从一个基础配置文件开始，设置符合服务器软硬件环境与工作负载的基本选项。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>高性能 MySQL(第 3 版)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 优化原理(二)</title>
      <link href="/2019/03/29/mysql-optimization-principle-2/"/>
      <url>/2019/03/29/mysql-optimization-principle-2/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="img.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>我打你应该，不打你悲哀~</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果有同学看完<a href="https://jiemin.wang/2019/03/29/mysql-optimization-principle-1/">上一篇关于 MySQL 文章</a>，文末留有两个很开放的问题，如有兴趣可以在脑袋里想想。本文也会试着回答这两个问题，希望能给你一些参考。现在可以思考一个问题，如果数据量非常大的情况下，您根据业务选择了合适的字段，精心设计了表和索引，还仔细的检查了所有的 SQL，并确认已经没什么问题，但性能仍然不能满足您的要求，该怎么办呢？还有其他优化策略吗？答案是肯定的。接下来继续和您讨论一些常用的 MySQL 高级特性以及其背后的工作原理。</p><h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><p>合理的使用索引可以极大提升 MySQL 的查询性能，但如果单表数据量达到一定的程度，索引就无法起作用，因为在数据量超大的情况下，除非覆盖索引，因回表查询会产生大量的随机 I/O，数据库的响应时间可能会达到不可接受的程度。而且索引维护（磁盘空间、I/O 操作）的代价也会非常大。</p><p>因此，当单表数据量达到一定程度时（在 MySQL4.x 时代，MyISAM 存储引擎业内公认的性能拐点是 500W 行，MySQL5.x 时代的性能拐点则为 1KW ~ 2KW 行级别，具体需根据实际情况测试），为了提升性能，最为常用的方法就是分表。分表的策略可以是垂直拆分（比如：不同订单状态的订单拆分到不同的表），也可以是水平拆分（比如：按月将订单拆分到不同表）。但总的来说，分表可以看作是从业务角度来解决大数据量问题，它在一定程度上可以提升性能，但也大大提升了编码的复杂度，有过这种经历的同学可能深有体会。</p><p>在业务层分表大大增加了编码的复杂程度，而且处理数据库的相关代码会大量散落在应用各处，维护困难。那是否可以将分表的逻辑抽象出来，统一处理，这样业务层就不用关心底层是否分表，只需要专注在业务即可。答案当然是肯定的，目前有非常多的数据库中间件都可以屏蔽分表后的细节，让业务层像查询单表一样查询分表后的数据。如果再将抽象的逻辑下移到数据库的服务层，就是我们今天要讲的分区表。</p><p>分区可以看作是从技术层面解决大数据问题的有效方法，简单的理解，可以认为是 MySQL 底层帮我们实现分表，分区表是一个独立的逻辑表，底层由多个物理子表组成。存储引擎管理分区的各个底层表和管理普通表一样（所有底层表必须使用相同的存储引擎），分区表的索引也是在各个底层表上各自加上一个完全相同的索引。从存储引擎的角度来看，底层表和普通表没有任何不同，存储引擎也无须知道。在执行查询时，优化器会根据分区的定义过滤那些没有我们需要数据的分区，这样查询就无需扫描所有分区，只需要查找包含需要数据的分区就可以了。</p><p>更好的理解分区表，我们从一个示例入手：一张订单表，数据量大概有 10TB，如何设计才能使性能达到最优？</p><p>首先可以肯定的是，因为数据量巨大，肯定不能走全表扫描。使用索引的话，你会发现数据并不是按照想要的方式聚集，而且会产生大量的碎片，最终会导致一个查询产生成千上万的随机 I/O，应用随之僵死。所以需要选择一些更粗粒度并且消耗更少的方式来检索数据。比如先根据索引找到一大块数据，然后再在这块数据上顺序扫描。</p><p>这正是分区要做的事情，理解分区时还可以将其当作索引的最初形态，以代价非常小的方式定位到需要的数据在哪一片 “区域”，在这片 “区域” 中，你可以顺序扫描，可以建索引，还可以将数据都缓存在内存中。因为分区无须额外的数据结构记录每个分区有哪些数据，所以其代价非常低。只需要一个简单的表达式就可以表达每个分区存放的是什么数据。</p><p>对表分区，可以在创建表时，使用如下语句：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sales {</span><br><span class="line">    order_date DATETIME NOT NULL</span><br><span class="line">    -- other columns</span><br><span class="line">} ENGINE=InnoDB PARTITION BY RANGE(YEAR(order_date)) (</span><br><span class="line">    PARTITION p_2014 VALUES LESS THAN (2014),</span><br><span class="line">    PARTITION p_2015 VALUES LESS THAN (2015)</span><br><span class="line">    PARTITION p_2016 VALUES LESS THAN (2016)</span><br><span class="line">    PARTITION p_2017 VALUES LESS THAN (2017)</span><br><span class="line">    PARTITION p_catchall VALUES LESS THAN MAXVALUE</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>分区子句中可以使用各种函数，但表达式的返回值必须是一个确定的整数，且不能是一个常数。MySQL 还支持一些其他分区，比如键值、哈希、列表分区，但在生产环境中很少见到。在 MySQL5.5 以后可以使用 RANGE COLUMNS 类型分区，这样即使是基于时间分区，也无需再将其转化成一个整数。</p><p>接下来简单看下分区表上的各种操作逻辑：</p><ul><li><code>SELECT</code>：当查询一个分区表时，分区层<strong>先打开并锁住所有的底层表</strong>，优化器先判断是否可以过滤部分分区，然后在调用对应的存储引擎接口访问各个分区的数据</li><li><code>INSERT</code>：当插入一条记录时，分区层<strong>先打开并锁住所有的底层表</strong>，然后确定哪个分区接收这条记录，再将记录写入对应的底层表，DELETE操作与其类似</li><li><code>UPDATE</code>：当更新一条数据时，分区层<strong>先打开并锁住所有的底层表</strong>，然后确定数据对应的分区，然后取出数据并更新，再判断更新后的数据应该存放到哪个分区，最后对底层表进行写入操作，并对原数据所在的底层表进行删除操作</li></ul><p>有些操作是支持条件过滤的。例如，当删除一条记录时，MySQL 需要先找到这条记录，如果WHERE条件恰好和分区表达式匹配，就可以将所有不包含这条记录的分区都过滤掉，这对UPDATE语句同样有效。如果是INSERT操作，本身就只命中一个分区，其他分区都会被过滤。</p><p>虽然每个操作都会 “先打开并锁住所有的底层表”，但这并不是说分区表在处理过程中是锁住全表的。如果存储引擎能够自己实现行级锁，例如 InnoDB，则会在分区层释放对应表锁。这个加锁和解锁的操作过程与普通 InnoDB 上的查询类似。</p><p>在使用分区表时，为了保证大数据量的可扩展性，一般有两个策略：</p><ul><li>全量扫描数据，不用索引。即只要能够根据 WHERE 条件将需要查询的数据限制在少数分区中，效率是不错的</li><li>索引数据，分离热点。如果数据有明显的 “热点”，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独存放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的利用缓存。</li></ul><p>分区表的优点是优化器可以根据分区函数来过滤一些分区，但很重要的一点是要在WHERE条件中带入分区列，有时候即使看似多余的也要带上，这样就可以让优化器能够过滤掉无须访问的分区，如果没有这些条件，MySQL 就需要让对应的存储引擎访问这个表的所有分区，如果表非常大的话，就可能会非常慢。</p><p>上面两个分区策略基于两个非常重要的前提：查询都能够过滤掉很多额外的分区，分区本身并不会带来很多额外的代价。而这两个前提在某些场景下是有问题的，比如：</p><p><strong>1、NULL 值会使分区过滤无效</strong></p><p>假设按照<code>PARTITION BY RANGE YEAR(order_date)</code>分区，那么所有<code>order_date</code>为 <code>NULL</code> 或者非法值时，记录都会被存放到第一个分区。所以<code>WHERE order_date BETWEEN '2017-05-01' AND '2017-05-31'</code>，这个查询会检查两个分区，而不是我们认为的 2017 年这个分区（会额外的检查第一个分区），是因为YEAR()在接收非法值时会返回 <code>NULL</code>。如果第一个分区的数据量非常大，而且使用全表扫描的策略时，代价会非常大。为了解决这个问题，我们可以创建一个无用的分区，比如：<code>PARTITION p_null values less than (0)</code>。如果插入的数据都是有效的话，第一个分区就是空的。</p><blockquote><p>在 MySQL5.5 以后就不需要这个技巧了，因为可以直接使用列本身而不是基于列的函数进行分区：PARTITION BY RANGE COLUMNS(order_date)。直接使用这个语法可避免这个问题。</p></blockquote><p><strong>2、分区列和索引列不匹配</strong></p><p>当分区列和索引列不匹配时，可能会导致查询无法进行分区过滤，除非每个查询条件中都包含分区列。假设在列 a 上定义了索引，而在列 b 上进行分区。因为每个分区都有其独立的索引，所以在扫描列 b 上的索引就需要扫描每一个分区内对应的索引，当然这种速度不会太慢，但是能够跳过不匹配的分区肯定会更好。这个问题看起来很容易避免，但需要注意一种情况就是，关联查询。如果分区表是关联顺序的第 2 张表，并且关联使用的索引与分区条件并不匹配，那么关联时对第一张表中符合条件的每一行都需要访问并搜索第二张表的所有分区（关联查询原理，请参考前一篇文章）</p><p><strong>3、选择分区的成本可能很高</strong></p><p>分区有很多种类型，不同类型的分区实现方式也不同，所以它们的性能也不尽相同，尤其是范围分区，在确认这一行属于哪个分区时会扫描所有的分区定义，这样的线性扫描效率并不高，所以随着分区数的增长，成本会越来越高。特别是在批量插入数据时，由于每条记录在插入前，都需要确认其属于哪一个分区，如果分区数太大，会造成插入性能的急剧下降。因此有必要限制分区数量，但也不用太过担心，对于大多数系统，100 个左右的分区是没有问题的。</p><p><strong>4、打开并锁住所有底层表的成本在某些时候会很高</strong></p><p>前面说过，打开并锁住所有底层表并不会对性能有太大的影响，但在某些情况下，比如只需要查询主键，那么锁住的成本相对于主键的查询来说，成本就略高。</p><p><strong>5、维护分区的成本可能会很高</strong></p><p>新增和删除分区的速度都很快，但是修改分区会造成数据的复制，这与ALTER TABLE的原理类似，需要先创建一个历史分区，然后将数据复制到其中，最后删除原分区。因此，设计数据库时，考虑业务的增长需要，合理的创建分区表是一个非常好的习惯。在 MySQL5.6 以后的版本可以使用ALTER TABLE EXCHAGE PARTITION语句来修改分区，其性能会有很大提升。</p><p>分区表还有一些其他限制，比如所有的底层表必须使用相同的存储引擎，某些存储引擎也不支持分区。分区一般应用于一台服务器上，但一台服务器的物理资源总是有限的，当数据达到这个极限时，即使分区，性能也可能会很低，所以这个时候分库是必须的。但不管是分区、分库还是分表，它们的思想都是一样的，大家可以好好体会下。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>对于一些关联表的复杂查询，使用视图有时候会大大简化问题，因此在许多场合下都可以看到视图的身影，但视图真如我们所想那样简单吗？它和直接使用JOIN的 SQL 语句有何区别？视图背后的原理又了解多少？</p><p>视图本身是一个虚拟表，不存放任何数据，查询视图的数据集由其他表生成。MySQL 底层通过两种算法来实现视图：临时表算法（TEMPTABLE）和合并算法（MERGE）。所谓临时表算法就是将 SELECT 语句的结果存放到临时表中，当需要访问视图的时候，直接访问这个临时表即可。而合并算法则是重写包含视图的查询，将视图定义的 SQL 直接包含进查询 SQL 中。通过两个简单的示例来体会两个算法的差异，创建如下视图：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 视图的作用是查询未支付订单</span><br><span class="line">CREATE VIEW unpay_order AS</span><br><span class="line">SELECT * FROM sales WHERE status = <span class="string">'new'</span></span><br><span class="line">WITH CHECK OPTION;   -- 其作用下文会讲</span><br></pre></td></tr></tbody></table></figure><p></p><p>现要从未支付订单中查询购买者为csc的订单，可以使用如下查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询购买者为csc且未支付的订单</span><br><span class="line">SELECT order_id,order_amount,buyer FROM unpay_order WHERE buyer = <span class="string">'csc'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用临时表来模拟视图：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE tmp_order_unpay AS SELECT * FROM sales WHERE status = <span class="string">'new'</span>;</span><br><span class="line">SELECT order_id,order_amount,buyer FROM tmp_order_unpay WHERE buyer = <span class="string">'csc'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用合并算法将视图定义的 SQL 合并进查询 SQL 后的样子：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_id,order_amount,buyer FROM sales WHERE status = <span class="string">'new'</span> AND buyer = <span class="string">'csc'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>MySQL 可以嵌套定义视图，即在一个视图上在定义另一个视图，可以在EXPLAIN EXTENDED之后使用SHOW WARNINGS来查看使用视图的查询重写后的结果。如果采用临时表算法实现的视图，EXPLAIN中会显示为派生表（DERIVED），注意EXPLAIN时需要实际执行并产生临时表，所以有可能会很慢。</p><p>明显地，临时表上没有任何索引，而且优化器也很难优化临时表上的查询，因此，如有可能，尽量使用合并算法会有更好的性能。那么问题来了：合并算法（类似于直接查询）有更好的性能，为什么还要使用视图？</p><p>首先视图可以简化应用上层的操作，让应用更专注于其所关心的数据。其次，视图能够对敏感数据提供安全保护，比如：对不同的用户定义不同的视图，可以使敏感数据不出现在不应该看到这些数据的用户视图上；也可以使用视图实现基于列的权限控制，而不需要真正的在数据库中创建列权限。再者，视图可以方便系统运维，比如：在重构 schema 的时候使用视图，使得在修改视图底层表结构的时候，应用代码还可以继续运行不报错。</p><p>基于此，使用视图其实更多的是基于业务或者维护成本上的考虑，其本身并不会对性能提升有多大作用（注意：此处只是基于 MySQL 考虑，其他关系性数据库中视图可能会有更好的性能，比如ORACLE和MS SQL SERVER都支持物化视图，它们都比 MySQL 视图有更好的性能）。而且使用临时表算法实现的视图，在某些时候性能可能会非常糟糕，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 视图的作用是统计每日支出金额，DATE(<span class="string">'2017-06-15 12:00:23'</span>) = 2017-06-15</span><br><span class="line">CREATE VIEW cost_per_day AS</span><br><span class="line">SELECT DATE(create_time) AS date,SUM(cost) AS cost FROM costs GROUP BY date;</span><br></pre></td></tr></tbody></table></figure><p></p><p>现要统计每日的收入与支出，有类似于上面的收入表，可以使用如下 SQL：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.date,c.cost,s.amount</span><br><span class="line">FROM cost_per_day AS c</span><br><span class="line">JOIN sale_per_day AS s USING(date)</span><br><span class="line">WHERE date BETWEEN <span class="string">'2017-06-01'</span> AND <span class="string">'2017-06-30'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>这个查询中，MySQL 先执行视图的 SQL，生成临时表，然后再将sale_per_day表和临时表进行关联。这里WHERE字句中的BETWEEN条件并不能下推到视图中，因而视图在创建时，会将所有的数据放到临时表中，而不是一个月数据，并且这个临时表也不会有索引。</p><p>当然这个示例中的临时表数据不会太大，毕竟日期的数量不会太多，但仍然要考虑生成临时表的性能（如果 costs 表数据过大，GROUP BY有可能会比较慢）。而且本示例中索引也不是问题，通过上一篇我们知道，如果 MySQL 将临时表作为关联顺序中的第一张表，仍然可以使用sale_per_day中的索引。但如果是对两个视图做关联的话，优化器就没有任何索引可以使用，这时就需要严格测试应用的性能是否满足需求。</p><p>我们很少会在实际业务场景中去更新视图，因此印象中，视图是不能更新的。但实际上，在某些情况下，视图是可以更新的。可更新视图是指通过更新这个视图来更新视图涉及的相关表，只要指定了合适的条件，就可以更新、删除甚至是向视图中插入数据。通过上文的了解，不难推断出：更新视图的实质就是更新视图关联的表，将创建视图的WHERE子句转化为UPDATE语句的WHERE子句，只有使用合并算法的视图才能更新，并且更新的列必须来自同一个表中。回顾上文创建视图的 SQL 语句，其中有一句：WITH CHECK OPTION，其作用就是表示通过视图更新的行，都必须符合视图本身的WHERE条件定义，不能更新视图定义列以外的列，否则就会抛出check option failed错误。</p><p>视图还有一个容易造成误解的地方：“对于一些简单的查询，视图会使用合并算法，而对于一些比较复杂的查询，视图就会使用临时表算法”。但实际上，视图的实现算法是视图本身的属性决定的，跟作用在视图上的 SQL 没有任何关系。那什么时候视图采用临时表算法，什么时候采用合并算法呢？一般来说，只要原表记录和视图中的记录无法建立一一映射的关系时，MySQL 都将使用临时表算法来实现视图。比如创建视图的 SQL 中包含GROUP BY、DISTINCT、UNION、聚合函数、子查询的时候，视图都将采用临时表算法（这些规则在以后的版本中，可能会发生改变，具体请参考官方手册）。</p><p>相比于其它关系型数据库的视图，MySQL 的视图在功能上会弱很多，比如ORACLE和MS SQL SERVER都支持物化视图。物化视图是指将视图结果数据存放在一个可以查询的表中，并定期从原始表中刷新数据到这张表中，这张表和普通物理表一样，可以创建索引、主键约束等等，性能相比于临时表会有质的提升。但遗憾的是 MySQL 目前并不支持物化视图，当然 MySQL 也不支持在视图中创建索引。</p><h4 id="存储过程与触发器"><a href="#存储过程与触发器" class="headerlink" title="存储过程与触发器"></a>存储过程与触发器</h4><p>回到第二个问题，有非常多的人在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</p><p>如果有深入了解过存储过程，就会发现存储过程并没有大家描述的那么不堪。我曾经经历过一些重度使用存储过程的产品，依赖到什么程度呢？就这么说吧，上层的应用基本上只处理交互与动效的逻辑，所有的业务逻辑，甚至是参数的校验均在存储过程中实现。曾经有出现过一个超大的存储过程，其文件大小达到惊人的 80K，可想而知，其业务逻辑有多么复杂。在大多数人眼中，这样的技术架构简直有点不可理喻，但实际上这款产品非常成功。</p><p>其成功的原因在一定程度上得益于存储过程的优点，由于业务层代码没有任何侵入业务的代码，在不改变前端展示效果的同时，可以非常快速的修复 BUG、开发新功能。由于这款产品需要部署在客户的私有环境上，快速响应客户的需求就变得尤为重要，正是得益于这种架构，可以在客户出现问题或者提出新需求时，快速响应，极端情况下，我们可以在 1 小时内修复客户遇到的问题。正是这种快速响应机制，让我们获得大量的客户。</p><p>当然存储过程还有其他的优点，比如，可以非常方便的加密存储过程代码，而不用担心应用部署到私有环境造成源代码泄露、可以像调试其他应用程序一样调试存储过程、可以设定存储过程的使用权限来保证数据安全等等。一切都非常美好，但我们的产品是基于MS SQL SERVER实现的，其可以通过T-SQL非常方便的实现复杂的业务逻辑。你可以把T-SQL看做是一门编程语言，其包含SQL的所有功能，还具备流程控制、批处理、定时任务等能力，你甚至可以用其来解析 XML 数据。关于T-SQL的更多信息可以参考MSDN，主流的关系型数据库目前只有MS SQL SERVER支持T-SQL，因此，MySQL 并不具备上文描述的一些能力，比如，MySQL 的存储过程调试非常不方便（当然可以通过付费软件来获得很好的支持）。</p><p>除此之外，MySQL 存储过程还有一些其他的限制：</p><ul><li>优化器无法评估存储过程的执行成本</li><li>每个连接都有独立的存储过程执行计划缓存，如果有多个连接需要调用同一个存储过程，将会浪费缓存空间来缓存相同的执行计划</li></ul><p>因此，在 MySQL 中使用存储过程并不是一个太好策略，特别是在一些大数据、高并发的场景下，将复杂的逻辑交给上层应用实现，可以非常方便的扩展已有资源以便获得更高的计算能力。而且对于熟悉的编程语言，其可读性会比存储过程更好一些，也更加灵活。不过，在某些场景下，如果存储过程比其他实现会快很多，并且是一些较小的操作，可以适当考虑使用存储过程。</p><p>和存储过程类似的，还有触发器，触发器可以让你在执行INSERT、UPDATE和DELETE时，执行一些特定的操作。在 MySQL 中可以选择在 SQL 执行之前触发还是在 SQL 执行后触发。触发器一般用于实现一些强制的限制，这些限制如果在应用程序中实现会让业务代码变得非常复杂，而且它也可以减少客户端与服务器之间的通信。MySQL 触发器的实现非常简单，所以功能非常有限，如果你在其他数据库产品中已经重度依赖触发器，那么在使用 MySQL 触发器时候需要注意，因为 MySQL 触发器的表现和预想的不一致。</p><p>首先对一张表的每一个事件，最多只能定义一个触发器，而且它只支持 “基于行的触发”，也就是触发器始终是针对一条记录的，而不是针对整个 SQL 语句。如果是批量更新的话，效率可能会很低。其次，触发器可以掩盖服务器本质工作，一个简单的 SQL 语句背后，因为触发器，可能包含了很多看不见的工作。再者，触发器出现问题时很难排查。最后，触发器并不一定能保证原子性，比如MyISAM引擎下触发器执行失败了，也不能回滚。在InnoDB表上的触发器是在同一个事务中执行完成的，所以他们的执行是原子的，原操作和触发器操作会同时失败或者成功。</p><p>虽然触发器有这么多限制，但它仍有适用的场景，比如，当你需要记录 MySQL 数据的变更日志，这时触发器就非常方便了。</p><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>目前在大多数互联网项目，特别是在大数据的场景下，已经不建议使用外键了，主要是考虑到外键的使用成本：</p><ul><li>外键通常要求每次修改数据时都要在另外一张表中执行一次查找操作。在 InnoDB 存储引擎中会强制外键使用索引，但在大数据的情况下，仍然不能忽略外键检查带来的开销，特别是当外键的选择性很低时，会导致一个非常大且选择性低的索引。</li><li>如果向子表中插入一条记录，外键约束会让 InnoDB 检查对应的父表的记录，也就需要对父表对应记录进行加锁操作，来确保这条记录不会在这个事务完成之时就被删除了。这会导致额外的锁等待，甚至会导致一些死锁。</li><li>高并发场景下，数据库很容易成为性能瓶颈，自然而然的就希望数据库可以水平扩展，这时就需要把数据的一致性控制放到应用层，也就是让应用服务器可以承担压力，这种情况下，数据库层面就不能使用外键。</li></ul><p>因此，当不用过多考虑数据库的性能问题时，比如一些内部项目或传统行业项目（其使用人数有限，而且数据量一般不会太大），使用外键是一个不错的选择，毕竟想要确保相关表始终有一致的数据，使用外键要比在应用程序中检查一致性方便简单许多，此外，外键在相关数据的删除和更新操作上也会比在应用中要高效。</p><h4 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h4><p>可能大家看到 “绑定变量” 这个词时，会有一点陌生，换个说法可能会熟悉一些：prepared statement。绑定变量的 SQL，使用问号标记可以接收参数的位置，当真正需要执行具体查询的时候，则使用具体的数值代替这些问号，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_no, order_amount FROM sales WHERE order_status = ? and buyer = ?</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">为什么要使用绑定变量？总所周知的原因是可以预先编译，减少 SQL 注入的风险，除了这些呢？</span><br><span class="line"></span><br><span class="line">当创建一个绑定变量 SQL 时，客户端向服务器发送了一个 SQL 语句原型，服务器收到这个 SQL 语句的框架后，解析并存储这个 SQL 语句的部分执行计划，返回给客户端一个 SQL 语句处理句柄，从此以后，客户端通过向服务器发送各个问号的取值和这个句柄来执行一个具体查询，这样就可以更高效地执行大量重复语句，因为：</span><br><span class="line">* 服务器只需要解析一次 SQL 语句</span><br><span class="line">* 服务器某些优化器的优化工作也只需要做一次，因为 MySQL 会缓存部分执行计划</span><br><span class="line">* 通信中仅仅发送的是参数，而不是整个语句，网络开销也会更小，而且以二进制发送参数和句柄要比发送 ASCII 文本的效率更高</span><br><span class="line"></span><br><span class="line">需要注意的是，MySQL 并不是总能缓存执行计划，如果某些执行计划需要根据参入的参数来计算时，MySQL 就无法缓存这部分执行计划。比如：</span><br><span class="line">```bash</span><br><span class="line">-- 这里假装有一个例子，大家可以自己思考一下</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用绑定变量的最大陷阱是：你知道其原理，但不知道它是如何实现的。有时候，很难解释如下 3 种绑定变量类型之间的区别：</p><ol><li>客户端模拟的绑定变量：客户端的驱动程序接收一个带参数的 SQL，再将参数的值带入其中，最后将完整的查询发送到服务器。</li><li>服务器绑定变量：客户端使用特殊的二进制协议将带参数的 SQL 语句发送到服务器端，然后使用二进制协议将具体的参数值发送给服务器并执行。</li><li>SQL 接口的绑定变量：客户端先发送一个带参数的 SQL 语句到服务器端，这类似于使用prepared的 SQL 语句，然后发送设置的参数，最后在发送execute指令来执行 SQL，所有这些都是用普通的文本传输协议。</li></ol><p>比如某些不支持预编译的 JDBC 驱动，在调用<code>connection.prepareStatement(sql)</code>时，并不会把 <code>SQL</code> 语句发送给数据库做预处理，而是等到调用<code>executeQuery</code>方法时才把整个语句发送到服务器，这种方式就类似于第 1 种情况。因此，在程序中使用绑定变量时，理解你使用的驱动通过哪种方式来实现就显得很有必要。延伸开来说，对于自己使用的框架、开源工具，不应仅仅停留在会使用这个层面，有时间可以深入了解其原理和实现，不然有可能被骗了都不知道哦。</p><h4 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h4><p>MySQL 本身内置了非常多的函数，比如SUM、COUNT、AVG等等，可实际应用中，我们常常需要更多。大多数情况下，更强大的功能都是在应用层面实现，但实际上 MySQL 也提供了机会让我们可以去扩展 MySQL 函数，这就是用户自定义函数 (user-defined function)，也称为：UDF。需要注意UDF与存储过程和通过 SQL 创建函数的区别，存储过程只能使用 SQL 来编写，而UDF没有这个限制，可以使用支持 C 语言调用约定的任何编程语言来实现。</p><p>UDF必须事先编译好并动态链接到服务器上，这种平台相关性使得UDF在很多方面都很强大，UDF速度非常快，而且可以访问大量操作系统功能，还可以使用大量库函数。如果需要一个 MySQL 不支持的统计聚合函数，并且无法使用存储过程来实现，而且还想不同的语言都可以调用，那么UDF是不错的选择，至少不需要每种语言都来实现相同的逻辑。</p><p>所谓能力越大，责任也就越大，UDF中的一个错误可能直接让服务器崩溃，甚至扰乱服务器的内存和数据，因此，使用时需要注意其潜在的风险。在 MySQL 版本升级时也需要注意，因为你可能需要重新编译或者修改这些UDF，以便让它们能在新版本中工作。</p><p>这里有一个简单的示例来展示如何创建UDF：将结果集转化为 JSON，具体的代码请参考：lib_mysqludf_json。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-- 1、首先使用c语言实现功能</span><br><span class="line">-- 2、编译</span><br><span class="line">-- 这里省略第1、2步，实现并编译成.so</span><br><span class="line">-- 3、使用SQL创建函数</span><br><span class="line">DROP FUNCTION json_array;</span><br><span class="line">CREATE FUNCTION json_array RETURNS string soname <span class="string">'lib_mysqludf_json.so'</span>;</span><br><span class="line">-- 4、使用函数</span><br><span class="line">SELECT</span><br><span class="line">  json_array(</span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    last_update</span><br><span class="line">  ) as customer</span><br><span class="line">FROM</span><br><span class="line">  customer</span><br><span class="line">WHERE</span><br><span class="line">  customer_id = 1;</span><br><span class="line">/*</span><br><span class="line">5、得到的结果如下：</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| customer                                 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| [1,<span class="string">"MARY"</span>,<span class="string">"SMITH"</span>,<span class="string">"2006-02-15 04:57:20"</span>] |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p></p><p>其大致的实现流程：使用 C 语言实现逻辑 -> 编译成.so文件 -> 创建函数 -> 使用函数。UDF在实际工作中可能很少使用，但作为开发者的我们，了解这么一款强大的工具，在解决棘手问题时，也让我们有了更多的选择。</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>最后说说字符集。</p><p>关于字符集大多数人的第一印象可能就是：数据库字符集尽量使用<code>UTF8</code>，因为<code>UTF8</code>字符集是目前最适合于实现多种不同字符集之间的转换的字符集，可以最大程度上避免乱码问题，也可以方便以后的数据迁移。But why？</p><p>字符集是指一种从<strong>二进制编码到某类字符符号</strong>的映射，可以参考如何使用一个字节来表示英文字母。校对规则是指一组<strong>用于某个字符集的排序规则</strong>，即采用何种规则对某类字符进行排序。MySQL 每一类编码字符都有其对应的字符集和校对规则。MySQL 对各种字符集的支持都非常完善，但同时也带来一些复杂性，某些场景下甚至会有一些性能牺牲。</p><p>一种字符集可能对应多种校对规则，且都有一个默认校对规则，那在 MySQL 中是如何使用字符集的？在 MySQL 中可以通过两种方式设置字符集：创建对象时设置默认值、客户端与服务器通信时显式设置。</p><p>MySQL 采用 “阶梯” 式的方式来设定字符集默认值，每个数据库，每张表都有自己的默认值，它们逐层继承，最终最靠底层的默认设置将影响你创建的对象。比如，创建数据库时，将根据服务器上的character_set_server来设置数据库的默认字符集，同样的道理，根据database的字符集来指定库中所有表的字符集…… 不管是对数据库，还是表和列，只有当它们没有显式指定字符集时，默认字符集才会起作用。</p><p>当客户端与服务器通信时，它们可以使用不同的字符集，这时候服务器将进行必要的转换工作。当客户端向服务器发送请求时，数据以character_set_client设置的字符集进行编码；而当服务器收到客户端的 SQL 或者数据时，会按照character_set_connection设置的字符集进行转换；当服务器将要进行增删改查等操作前会再次将数据转换成character_set_database(数据库采用的字符集，没有单独配置即使用默认配置，具体参考上文)，最后当服务器返回数据或者错误信息时，则将数据按character_set_result设置的字符集进行编码。服务器端可以使用SET CHARACTER SET来改变上面的配置，客户端也可以根据对应的 API 来改变字符集配置。客户端和服务器端都使用正确的字符集才能避免在通信中出现问题。</p><h4 id="那如何选择字符集"><a href="#那如何选择字符集" class="headerlink" title="那如何选择字符集"></a>那如何选择字符集</h4><p>在考虑使用何种字符集时，最主要的衡量因素是存储的内容，在能够满足存储内容的前提下，尽量使用较小的字符集。因为更小的字符集意味着更少空间占用、以及更高的网络传输效率，也间接提高了系统的性能。如果存储的内容是英文字符等拉丁语系字符的话，那么使用默认的latin1字符集完全没有问题（MySQL 8 默认utf8mb4），如果需要存储汉字、俄文、阿拉伯语等非拉丁语系字符，则建议使用UTF8字符集。当然不同字符在使用UTF8字符集所占用的空间是不同的，比如英文字符在UTF8字符集中只使用一个字节，而一个汉字则占用 3 个字节。</p><p>除了字符集，校对规则也是我们需要考虑的问题。对于校对规则，一般来说只需要考虑是否以大小写敏感的方式比较字符串或者是否用字符串编码的二进制来比较大小，其对应的校对规则的后缀分别是_cs、_ci和_bin。大小写敏感和二进制校对规则的不同之处在于，二进制校对规则直接使用字符的字节进行比较，而大小写敏感的校对规则在多字节字符集时，如德语，有更复杂的比较规则。举个简单的例子，UTF8字符集对应校对规则有三种：</p><ul><li>utf8_bin将字符串中的每一个字符用二进制数据存储，区分大小写</li><li>utf8_general_ci不区分大小写，ci为case insensitive的缩写，即大小写不敏感</li><li>utf8_general_cs区分大小写，cs为case sensitive的缩写，即大小写敏感</li></ul><p>比如，创建一张表，使用UTF8编码，且大小写敏感时，可以使用如下语句：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sales (</span><br><span class="line">    order_no VARCHAR(32) NOT NULL PRIMARY KEY,</span><br><span class="line">    order_amount INT NOT NULL DEFAULT 0,</span><br><span class="line">    ......</span><br><span class="line">) ENGINE=InnoDB COLLATE=utf8_general_cs;</span><br></pre></td></tr></tbody></table></figure><p></p><p>因此，在项目中直接使用UTF8字符集是完全没有问题的，但需要记住的是不要在一个数据库中使用多个不同的字符集，不同字符集之间的不兼容问题很难缠。有时候，看起来一切正常，但是当某个特殊字符出现时，一切操作都会出错，而且你很难发现错误的原因。</p><h4 id="字符集对数据库的性能有影响吗"><a href="#字符集对数据库的性能有影响吗" class="headerlink" title="字符集对数据库的性能有影响吗"></a>字符集对数据库的性能有影响吗</h4><p>某些字符集和校对规则可能会需要多个的 CPU 操作，可能会消耗更多的内存和存储空间，这点在前文已经说过。特别是在同一个数据库中使用不同的字符集，造成的影响可能会更大。</p><p>不同字符集和校对规则之间的转换可能会带来额外的系统开销，比如，数据表sales在buyer字段上有索引，则可以加速下面的ORDER BY操作：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_no,order_amount FROM sales ORDER BY buyer;</span><br></pre></td></tr></tbody></table></figure><p></p><p>只有当 SQL 查询中排序要求的字符集与服务器数据的字符集相同时，才能使用索引进行排序。你可能会说，这不是废话吗？其实不然，MySQL 是可以单独指定排序时使用的校对规则的，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 你说，这不是吃饱了撑的吗？我觉得也是，也许会有其适用的场景吧</span><br><span class="line">-- 这时候就不能使用索引排序呢，只能使用文件排序</span><br><span class="line">SELECT order_no,order_amount FROM sales ORDER BY buyer COLLATE utf8_bin;</span><br></pre></td></tr></tbody></table></figure><p></p><p>当使用两个字符集不同的列来关联两张表时，MySQL 会尝试转换其中一个列的字符集。这和在数据列外面封装一个函数一样，会让 MySQL 无法使用这个列上的索引。关于 MySQL 字符集还有一些坑，但在实际应用场景中遇到的字符集问题，其实不是特别的多，所以就此打住。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>MySQL 还有一些其他高级特性，但在大多数场景下我们很少会使用，因此这里也没有讨论，但多了解一些总是好的，至少在需要的时候，你知道有这样一个东西。我们非常多的人，<strong>总是会认为自己所学的知识就像碎片一样不成体系，又找不到解决办法，那你有没有想过也许是碎片不够多的缘故？点太少，自然不能连接成线，线太少，自然不能结成网</strong>。因而，没有其他办法，<strong>保持好奇心、多学习、多积累，量变总有一天会质变</strong>。</p><p>前面我写的一些文章里面会有提到过，架构设计是一种平衡的艺术，其实质应该是一种妥协，是对现有资源的一种妥协。有时候我们会不自觉的陷入某一个点，比如，为了追求数据的扩展性，很多人一上来就开始分库分表，然后把应用搞得非常复杂，到最后表里还没有装满数据，项目就已经死了。所以在资源有限或者未来还不可知的情况下，尽量使用数据库、语言本身的特性来完成相应的工作，是不是会更好一点。解决大数据问题，也不只是分库分表，你还应该还可以想到分区；有些业务即使在分布式环境下也不一定非要在业务层完成，合理使用存储过程和触发器或者使用自己根据分表分库规则的小工具也许会让你更轻松……</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>高性能 MySQL(第 3 版)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 优化原理(一)</title>
      <link href="/2019/03/29/mysql-optimization-principle-1/"/>
      <url>/2019/03/29/mysql-optimization-principle-1/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>扫地只不过是我di表面工作，我真正di身份是一位研究——僧。</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起 MySQL 的查询优化，相信大家收藏了一堆奇技淫巧：不能使用SELECT *、不使用 NULL 字段、合理创建索引、为字段选择合适的数据类型…… 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。</p><h4 id="MySQL-逻辑架构"><a href="#MySQL-逻辑架构" class="headerlink" title="MySQL 逻辑架构"></a>MySQL 逻辑架构</h4><p>如果能在头脑中构建一幅 MySQL 各组件之间如何协同工作的架构图，有助于深入理解 MySQL 服务器。下图展示了 MySQL 的逻辑架构图。<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="img.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p><p>MySQL 逻辑架构整体分为三层，最上层为客户端层，并非 MySQL 所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p><p>MySQL 大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数 (比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p><p>最下层为存储引擎，其负责 MySQL 中的数据存储和提取。和 Linux 下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过 API 与存储引擎通信，这些 API 接口屏蔽了不同存储引擎间的差异。</p><h4 id="MySQL-查询过程"><a href="#MySQL-查询过程" class="headerlink" title="MySQL 查询过程"></a>MySQL 查询过程</h4><p>我们总是希望 MySQL 能够获得更高的查询性能，最好的办法是弄清楚 MySQL 是如何优化和执行查询的。一旦理解了这一点，就会发现：<strong>很多的查询优化工作实际上就是遵循一些原则让 MySQL 的优化器能够按照预想的合理方式运行而已</strong>。</p><p>当向 MySQL 发送一个请求的时候，MySQL 到底做了些什么呢？<br><img src="/2019/03/29/mysql-optimization-principle-1/SQLluoji.jpg" title="SQLluoji"></p><h4 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端 / 服务端通信协议"></a>客户端 / 服务端通信协议</h4><p>MySQL 客户端 / 服务端通信协议是 “半双工” 的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p><p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置<code>max_allowed_packet</code>参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p><p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用<code>SELECT *</code>以及加上<code>LIMIT</code>限制的原因之一。</p><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>在解析一个查询语句前，如果查询缓存是打开的，那么 MySQL 会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p><p>MySQL 将缓存存放在一个引用表（不要理解成<code>table</code>，可以认为是类似于<code>HashMap</code>的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p><p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果都不会被缓存。比如函数<code>NOW()</code>或者<code>CURRENT_DATE()</code>会因为不同的查询时间，返回不同的查询结果，再比如包含<code>CURRENT_USER</code>或者<code>CONNECION_ID()</code>的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p><p>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL 的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL 必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p><ul><li>任何的查询语句在开始之前都必须经过检查，即使这条 SQL 语句永远不会命中缓存</li><li>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li></ul><p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p><ol><li>用多个小表代替一个大表，注意不要过度设计</li><li>批量插入代替循环单条插入</li><li>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</li><li>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</li></ol><p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将<code>query_cache_type</code>设置为<code>DEMAND</code>，这时只有加入<code>SQL_CACHE</code>的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p><p>当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。</p><h4 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h4><p>MySQL 通过关键字将 SQL 语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如 SQL 中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据 MySQL 规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。</p><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p><p>MySQL 使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在 MySQL 可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql> select * from t_message <span class="built_in">limit</span> 10;</span><br><span class="line">...省略结果集</span><br><span class="line"></span><br><span class="line">mysql> show status like <span class="string">'last_query_cost'</span>;</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Last_query_cost | 6391.799000 |</span><br><span class="line">+-----------------+-------------+</span><br></pre></td></tr></tbody></table></figure><p></p><p>示例中的结果表示优化器认为大概需要做 6391 个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</p><p>有非常多的原因会导致 MySQL 选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL 认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但 MySQL 只选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p><p>MySQL 的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p><ul><li>重新定义表的关联顺序（多张表关联查询时，并不一定按照 SQL 中指定的顺序进行，但有一些技巧可以指定关联顺序）</li><li>优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找 B+Tree 索引最左端，反之则可以找到最大值，具体原理见下文）</li><li>提前终止查询（比如：使用 Limit 时，查找到满足数量的结果集后会立即终止查询）</li><li>优化排序（在老版本 MySQL 会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于 I/O 密集型应用，效率会高很多）</li></ul><p>随着 MySQL 的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p><h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>在完成解析和优化阶段以后，MySQL 会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为<code>handler API</code>。查询过程中的每一张表由一个<code>handler</code>实例表示。实际上，MySQL 在查询优化阶段就为每一张表创建了一个<code>handler</code>实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p><h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL 仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。</p><p>如果查询缓存被打开且这个查询可以被缓存，MySQL 也会将结果存放到缓存中。</p><p>结果集返回客户端是一个增量且逐步返回的过程。有可能 MySQL 在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足 ① 中所描述的通信协议的数据包发送，再通过 TCP 协议进行传输，在传输过程中，可能对 MySQL 的数据包进行缓存然后批量发送。</p><p>回头总结一下 MySQL 整个查询执行过程，总的来说分为 5 个步骤：</p><ol><li>客户端向 MySQL 服务器发送一条查询请求</li><li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li><li>服务器进行 SQL 解析、预处理、再由优化器生成对应的执行计划</li><li>MySQL 根据执行计划，调用存储引擎的 API 来执行查询</li><li>将结果返回给客户端，同时缓存查询结果</li></ol><h4 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h4><p>看了这么多，你可能会期待给出一些优化手段，是的，下面会从 3 个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：不要听信你看到的关于优化的 “绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设。</p><p><strong>Scheme 设计与数据类型优化</strong></p><p>选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的 CPU 周期也更少。越简单的数据类型在计算时需要更少的 CPU 周期，比如，整型就比字符操作代价低，因而会使用整型来存储 IP 地址，使用DATETIME来存储时间，而不是使用字符串。</p><p>这里总结几个可能容易理解错误的技巧：</p><ol><li>通常来说把可为<code>NULL</code>的列改为<code>NOT NULL</code>不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为<code>NOT NULL</code>。</li><li>对整数类型指定宽度，比如<code>INT(11)</code>，没有任何卵用。<code>INT</code>使用 <code>32</code> 位（<code>4</code> 个字节）存储空间，那么它的表示范围已经确定，所以<code>INT(1)</code>和<code>INT(20)</code>对于存储和计算是相同的。</li><li><code>UNSIGNED</code>表示不允许负值，大致可以使正数的上限提高一倍。比如<code>TINYINT</code>存储范围是 <code>-128 ~ 127</code>，而<code>UNSIGNED TINYINT</code>存储的范围却是 <code>0 - 255</code>。</li><li>通常来讲，没有太大的必要使用<code>DECIMAL</code>数据类型。即使是在需要存储财务数据时，仍然可以使用<code>BIGINT</code>。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用<code>BIGINT</code>存储。这样可以避免浮点数计算不准确和<code>DECIMAL</code>精确计算代价高的问题。</li><li><code>TIMESTAMP</code>使用 4 个字节存储空间，<code>DATETIME</code>使用 <code>8</code> 个字节存储空间。因而，<code>TIMESTAMP</code>只能表示 <code>1970 - 2038</code> 年，比<code>DATETIME</code>表示的范围小得多，而且<code>TIMESTAMP</code>的值因时区不同而不同。</li><li>大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用<code>ALTER TABLE</code>（如果只只是在列表末尾追加元素，不需要重建表）。</li><li><code>schema</code> 的列不要太多。原因是存储引擎的 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致 <code>CPU</code> 占用过高。</li><li>大表<code>ALTER TABLE</code>非常耗时，MySQL 执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。</li></ol><p><strong>创建高性能索引</strong><br>索引是提高 MySQL 查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的 SQL 才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p><p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p><p><strong>索引相关的数据结构和算法</strong></p><p>通常我们所说的索引是指<code>B-Tree</code>索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用<code>B-Tree</code>这个术语，是因为 MySQL 在<code>CREATE TABLE</code>或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 就是使用的是它的变种B+Tree。</p><p><code>B+Tree</code>中的 B 是指<code>balance</code>，意为平衡。需要注意的是，B + 树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p><p>在介绍<code>B+Tree</code>前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图 ①。如果要在这课树中查找值为 5 的记录，其大致流程：先找到根，其值为 6，大于 5，所以查找左子树，找到 3，而 5 大于 3，接着找 3 的右子树，总共找了 3 次。同样的方法，如果查找值为 8 的记录，也需要查找 3 次。所以二叉查找树的平均查找次数为 (3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3 次，而顺序查找的话，查找值为 2 的记录，仅需要 1 次，但查找值为 8 的记录则需要 6 次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3 次，因此大多数情况下二叉查找树的平均查找速度比顺序查找要快。</p><p>由于二叉查找树可以任意构造，同样的值，可以构造出如图 ② 的二叉查找树，显然这棵二叉树的查询效率和顺序查找差不多。若想二叉查找数的查询性能最高，需要这棵二叉查找树是平衡的，也即平衡二叉树（AVL 树）。<br><img src="/2019/03/29/mysql-optimization-principle-1/shu.jpg" title="shu"></p><p>平衡二叉树首先需要符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度差不能大于 1。显然图 ② 不满足平衡二叉树的定义，而图 ① 是一课平衡二叉树。平衡二叉树的查找性能是比较高的（性能最好的是最优二叉树），查询性能越好，维护的成本就越大。比如图 ① 的平衡二叉树，当用户需要插入一个新的值 9 的节点时，就需要做出如下变动。<br><img src="/2019/03/29/mysql-optimization-principle-1/ershu.jpg" title="ershu"></p><p>通过一次左旋操作就将插入后的树重新变为平衡二叉树是最简单的情况了，实际应用场景中可能需要旋转多次。至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么 MySQL 索引不直接使用平衡二叉树？</p><p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I/O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I/O 存取次数？</p><p>一种行之有效的解决方法是减少树的深度，将二叉树变为 m 叉树（多路搜索树），而B+Tree就是一种多路搜索树。理解B+Tree时，只需要理解其最重要的两个特征即可：第一，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。其次，所有的叶子节点由指针连接。如下图为高度为 2 的简化了的B+Tree。<br><img src="/2019/03/29/mysql-optimization-principle-1/erbtree.jpg" title="erbtree"></p><p>怎么理解这两个特征？MySQL 将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。所有的叶子节点使用指针链接的好处是可以进行区间访问，比如上图中，如果查找大于 20 而小于 30 的记录，只需要找到节点 20，就可以遍历指针依次找到 25、30。如果没有链接指针的话，就无法进行区间查找。这也是 MySQL 使用B+Tree作为索引存储结构的重要原因。</p><p>MySQL 为何将节点大小设置为页的整数倍，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页的整数倍。</p><blockquote><p>页是计算机管理存储器的逻辑块，硬件及 OS 往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多 OS 中，页的大小通常为 4K）。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后一起返回，程序继续运行。</p></blockquote><p>MySQL 巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了读取一个节点只需一次 I/O。假设B+Tree的高度为 h，一次检索最多需要h-1次 I/O（根节点常驻内存），复杂度 O(h) = O(logmN)。实际应用场景中，M 通常较大，常常超过 100，因此树的高度一般都比较小，通常不超过 3。</p><p>最后简单了解下B+Tree节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费很大的代价，因此合理的创建索引也就尤为重要。</p><p>仍以上面的树为例，我们假设每个节点只能存储 4 个内节点。首先要插入第一个节点 28，如下图所示。<br><img src="/2019/03/29/mysql-optimization-principle-1/chazhao.jpg" title="chazhao"></p><p>接着插入下一个节点 70，在 Index Page 中查询后得知应该插入到 50 - 70 之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的操作，当前的叶子节点起点为 50，所以根据中间值来拆分叶子节点，如下图所示。<br><img src="/2019/03/29/mysql-optimization-principle-1/pagechazhao.jpg" title="pagechazhao"></p><p>最后插入一个节点 95，这时候 Index Page 和 Leaf Page 都满了，就需要做两次拆分，如下图所示。<br><img src="/2019/03/29/mysql-optimization-principle-1/zhaodao.jpg" title="zhaodao"></p><p>Leaf Page 与 Index Page 拆分后最终形成了这样一颗树。<br><img src="/2019/03/29/mysql-optimization-principle-1/leaf.jpg" title="leaf"></p><p>B+Tree为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的拆分需要 I/O 操作，为了尽可能的减少页的拆分操作，B+Tree也提供了类似于平衡二叉树的旋转功能。当 Leaf Page 已满但其左右兄弟节点没有满的情况下，B+Tree并不急于去做拆分操作，而是将记录移到当前所在页的兄弟节点上。通常情况下，左兄弟会被先检查用来做旋转操作。就比如上面第二个示例，当插入 70 的时候，并不会去做页拆分，而是左旋操作。<br><img src="/2019/03/29/mysql-optimization-principle-1/zuoxuan.jpg" title="zuoxuan"></p><p>通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的 I/O 操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类似，仍然需要旋转和拆分操作，这里就不再说明。</p><p><strong>高性能策略</strong><br>通过上文，相信你对B+Tree的数据结构已经有了大致的了解，但 MySQL 中索引是如何组织数据的存储呢？以一个简单的示例来说明，假如有如下数据表：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE People(</span><br><span class="line">    last_name varchar(50) not null,</span><br><span class="line">    first_name varchar(50) not null,</span><br><span class="line">    dob date not null,</span><br><span class="line">    gender enum(`m`,`f`) not null,</span><br><span class="line">    key(last_name,first_name,dob)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p></p><p>对于表中每一行数据，索引中包含了 last_name、first_name、dob 列的值，下图展示了索引是如何组织数据存储的。<br><img src="/2019/03/29/mysql-optimization-principle-1/IMG.png" title="IMG"></p><p>可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正是因为这个原因，才有了索引的 “最左原则”。</p><p><strong>MySQL 不会使用索引的情况：非独立的列</strong></p><p>“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from <span class="built_in">where</span> id + 1 = 5</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们很容易看出其等价于 id = 4，但是 MySQL 无法自动解析这个表达式，使用函数是同样的道理。</p><p><strong>前缀索引</strong><br>如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。</p><p><strong>多列索引和索引顺序</strong><br>在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL 不知道选择哪个索引的查询效率更好，所以在老版本，比如 MySQL5.0 之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略。举个简单的例子，在一张电影演员表中，在 actor_id 和 film_id 两个列上都建立了独立的索引，然后有如下查询：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select film_id,actor_id from film_actor <span class="built_in">where</span> actor_id = 1 or film_id = 1</span><br></pre></td></tr></tbody></table></figure><p>老版本的 MySQL 会随机选择一个索引，但新版本做如下的优化：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select film_id,actor_id from film_actor <span class="built_in">where</span> actor_id = 1</span><br><span class="line">union all</span><br><span class="line">select film_id,actor_id from film_actor <span class="built_in">where</span> film_id = 1 and actor_id <> 1</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>当出现多个索引做相交操作时（多个 AND 条件），通常来说一个包含所有相关列的索引要优于多个独立索引。</li><li>当出现多个索引做联合操作时（多个 OR 条件），对结果集的合并、排序等操作需要耗费大量的 CPU 和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。</li></ul><p>因此explain时如果发现有索引合并（Extra 字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。</p><p>前面我们提到过索引如何组织数据存储的，从图中可以看到多列索引时，索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</p><blockquote><p>索引选择性是指不重复的索引值和数据表的总记录数的比值，选择性越高查询效率越高，因为选择性越高的索引可以让 MySQL 在查询时过滤掉更多的行。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p></blockquote><p>理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM payment <span class="built_in">where</span> staff_id = 2 and customer_id = 584</span><br></pre></td></tr></tbody></table></figure><p></p><p>是应该创建<code>(staff_id,customer_id)</code>的索引还是应该颠倒一下顺序？执行下面的查询，哪个字段的选择性更接近 1 就把哪个字段索引前面就好。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct staff_id)/count(*) as staff_id_selectivity,</span><br><span class="line">       count(distinct customer_id)/count(*) as customer_id_selectivity,</span><br><span class="line">       count(*) from payment</span><br></pre></td></tr></tbody></table></figure><p></p><p>多数情况下使用这个原则没有任何问题，但仍然注意你的数据中是否存在一些特殊情况。举个简单的例子，比如要查询某个用户组下有过交易的用户信息：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from trade <span class="built_in">where</span> user_group_id = 1 and trade_amount > 0</span><br></pre></td></tr></tbody></table></figure><p></p><p>MySQL 为这个查询选择了索引<code>(user_group_id,trade_amount)</code>，如果不考虑特殊情况，这看起来没有任何问题，但实际情况是这张表的大多数数据都是从老系统中迁移过来的，由于新老系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过索引扫描的行数跟全表扫描基本没什么区别，索引也就起不到任何作用。</p><p>推广开来说，经验法则和推论在多数情况下是有用的，可以指导我们开发和设计，但实际情况往往会更复杂，实际业务场景下的某些特殊情况可能会摧毁你的整个设计。</p><p><strong>避免多个范围条件</strong></p><p>实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登录过的用户：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user.* from user <span class="built_in">where</span> login_time > <span class="string">'2017-04-01'</span> and age between 18 and 30;</span><br></pre></td></tr></tbody></table></figure><p></p><p>这个查询有一个问题：它有两个范围条件，login_time 列和 age 列，MySQL 可以使用 login_time 列的索引或者 age 列的索引，但无法同时使用它们。</p><p><strong>覆盖索引</strong></p><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：</p><ul><li>索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量</li><li>索引是有按照列值顺序存储的，对于 I/O 密集型的范围查询要比随机从磁盘读取每一行数据的 IO 要少的多</li></ul><p><strong>使用索引扫描来排序</strong></p><p>MySQL 有两种方式可以生产有序的结果集，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。如果 explain 的结果中type列的值为index表示使用了索引扫描来做排序。</p><p>扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。但如果索引本身不能覆盖所有需要查询的列，那么就不得不每扫描一条索引记录就回表查询一次对应的行。这个读取操作基本上是随机 I/O，因此按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢。</p><p>在设计索引时，如果一个索引既能够满足排序，又满足查询，是最好的。</p><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其他情况下都需要执行排序操作，而无法利用索引排序。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 最左列为常数，索引：(date,staff_id,customer_id)</span><br><span class="line">select  staff_id,customer_id from demo <span class="built_in">where</span> date = <span class="string">'2015-06-01'</span> order by staff_id,customer_id</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>冗余和重复索引</strong></p><p>冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引<code>(A,B)</code>，再创建索引<code>(A)</code>就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引<code>(A,B)</code>，但这个索引不是扩展已有的索引<code>(A)</code>。</p><p>大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</p><p><strong>删除长期未使用的索引</strong></p><p>定期删除一些长时间未使用过的索引是一个非常好的习惯。</p><p>关于索引这个话题打算就此打住，最后要说一句，索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，简单的全表扫描更高效。对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，<strong>explain后再提测是一种美德</strong>。</p><p><strong>特定类型查询优化</strong></p><p><strong>优化 COUNT() 查询</strong></p><p><code>COUNT()</code>可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，它不会统计 NULL。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用<code>COUNT(*)</code>时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。</p><p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用<code>COUNT(*)</code>，意义清晰，且性能更好。</p><p>有时候某些业务场景并不需要完全精确的<code>COUNT</code>值，可以用近似值来代替，<code>EXPLAIN</code> 出来的行数就是一个不错的近似值，而且执行 <code>EXPLAIN</code> 并不需要真正地去执行查询，所以成本非常低。通常来说，执行<code>COUNT()</code>都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL 层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用 <code>redis</code> 这样的外部缓存系统。</p><p><strong>优化关联查询</strong></p><p>在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能。如果确实需要使用关联查询的情况下，需要特别注意的是：</p><ul><li>确保<code>ON</code>和<code>USING</code>字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表 <code>A</code> 和表 <code>B</code> 用列 <code>c</code> 关联的时候，如果优化器关联的顺序是 <code>A</code>、<code>B</code>，那么就不需要在 <code>A</code> 表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。</li><li>确保任何的<code>GROUP BY</code>和<code>ORDER BY</code>中的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引来优化。</li></ul><p>要理解优化关联查询的第一个技巧，就需要理解 MySQL 是如何执行关联查询的。当前 MySQL 关联执行的策略非常简单，它对任何的关联都<strong>执行嵌套循环关联操作</strong>，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p><p>太抽象了？以上面的示例来说明，比如有这样的一个查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.xx,B.yy FROM A INNER JOIN B USING(c) WHERE A.xx IN (5,6)</span><br></pre></td></tr></tbody></table></figure><p></p><p>假设 MySQL 按照查询中的关联顺序 A、B 来进行关联操作，那么可以用下面的伪代码表示 MySQL 如何完成这个查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer_iterator = SELECT A.xx,A.c FROM A WHERE A.xx IN (5,6);</span><br><span class="line">outer_row = outer_iterator.next;</span><br><span class="line"><span class="keyword">while</span>(outer_row) {</span><br><span class="line">    inner_iterator = SELECT B.yy FROM B WHERE B.c = outer_row.c;</span><br><span class="line">    inner_row = inner_iterator.next;</span><br><span class="line">    <span class="keyword">while</span>(inner_row) {</span><br><span class="line">        output[inner_row.yy,outer_row.xx];</span><br><span class="line">        inner_row = inner_iterator.next;</span><br><span class="line">    }</span><br><span class="line">    outer_row = outer_iterator.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到，最外层的查询是根据A.xx列来查询的，A.c上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显B.c上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p><p><strong>优化 LIMIT 分页</strong></p><p>当需要分页操作时，通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY字句。如果有对应的索引，通常效率会不错，否则，MySQL 需要做大量的文件排序操作。</p><p>一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL 需要查询 10020 条记录然后只返回 20 条记录，前面的 10000 条都将被抛弃，这样的代价非常高。</p><p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果这张表非常大，那么这个查询最好改成下面的样子：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT film.film_id,film.description</span><br><span class="line">FROM film INNER JOIN (</span><br><span class="line">    SELECT film_id FROM film ORDER BY title LIMIT 50,5</span><br><span class="line">) AS tmp USING(film_id);</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里的延迟关联将大大提升查询效率，让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p><p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET，比如下面的查询：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM t LIMIT 10000, 10;</span><br><span class="line">-- 改为：</span><br><span class="line">SELECT id FROM t WHERE id > 10000 LIMIT 10;</span><br></pre></td></tr></tbody></table></figure><p></p><p>其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p><p><strong>优化 UNION</strong><br>MySQL 处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句 “下推” 到各个子查询中，以便优化器可以充分利用这些条件先优化。</p><p>除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL 会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用 ALL 关键字，MySQL 总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>理解查询是如何执行以及时间都消耗在哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解 MySQL，理解常见优化技巧背后的原理。希望本文中的原理、示例能够帮助大家更好的将理论和实践联系起来，更多的将理论知识运用到实践中。</p><p>其他也没啥说的了，给大家留两个思考题吧，可以在脑袋里想想答案，这也是大家经常挂在嘴边的，但很少有人会思考为什么？</p><ol><li>有非常多的程序员在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</li><li>JOIN本身也挺方便的，直接查询就好了，为什么还需要视图呢？</li></ol><p>参考资料</p><ul><li><a href="https://segmentfault.com/a/1190000004690721" target="_blank" rel="noopener">由 B-/B+树看 MySQL索引结构</a></li><li>MySQL 技术内幕：InnoDB 存储引擎(第 2 版)</li><li>高性能 MySQL(第 3 版)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 优化之 Covering Index</title>
      <link href="/2019/03/29/CoveringIndex/"/>
      <url>/2019/03/29/CoveringIndex/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="hehe.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p><strong>为什么我老爸不是李嘉诚，为什么我长的这么帅，但是要掉头发呢，你们长这么丑，却不掉头发呢？</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在网上随便搜搜，就能找到大把的关于 MySQL 优化的文章，不过里面很多都不准确，说个常见的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a FROM ... WHERE b = ...</span><br></pre></td></tr></tbody></table></figure><p></p><p>一般来说，很多文章会告诫你类似这样的查询，不要在 “a” 字段上建立索引，而应该在 “b” 上建立索引。这样做确实不错，但是很多时候这并不是最佳结果。为什么这样说？这还得先从索引来说起。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>在 MySQL 中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文讨论的主要是 InnoDB 的 B+Tree 索引，它又可以分为两类：</p><ul><li>聚簇索引</li><li>非聚簇索引</li></ul><p>聚簇索引又称为聚集索引或主键索引，它并不是一种单独的索引类型，而是一种数据存储方式。在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶子节点称为 leaf page，其 data 域保存了完整的数据记录。也即我们所说的数据行即索引，索引即数据。<br><img src="/2019/03/29/CoveringIndex/Primary_key.jpg" title="Primary_key"></p><p>非聚簇索引是相对于聚簇索引来说的，我们又称为辅助索引或二级索引。 InnoDB 的二级索引 data 域存储的是相应记录主键的值而不是物理位置的指针。<br><img src="/2019/03/29/CoveringIndex/Secoudary_key.jpg" title="Secoudary_key"></p><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>了解了 InnoDB 索引的实现方式，我们就很容易理解 “回表” 这个概念了。</p><p>聚簇索引这种实现方式使得按主键的搜索十分高效，但是二级索引搜索需要检索两遍索引：首先检索二级索引获得主键，然后用主键到主索引中检索获得记录。</p><p>让我们回到开头说的那个例子：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a FROM ... WHERE b = ...</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们先来分析一下查询的处理过程：在执行查询时，系统会查询 “b” 索引进行定位，然后回表查询需要的数据 “a”，也就是说，在这个过程中存在两次查询，一次是查询索引，另一次是查询表。</p><p>那有没有办法用一次查询搞定问题呢？有，就是 Covering Index！</p><blockquote><p>说到这里你可能会想起来 MySQL5.6 中引入的 MRR（Multi-Range Read，多范围读），它是专门来优化二级索引的范围扫描并且需要回表的情况。它的原理是，将多个需要回表的二级索引根据主键进行排序，然后一起回表，将原来的回表时进行的随机 IO，转变成顺序 IO。MRR 的优势是将多个随机 IO 转换成较少数量的顺序 IO，所以对于 SSD 来说价值还是有的，但是相比机械磁盘来说意义小一些。</p></blockquote><h2 id="Covering-Index"><a href="#Covering-Index" class="headerlink" title="Covering Index"></a>Covering Index</h2><p>所谓 Covering Index，就是说不必查询表文件，单靠查询索引文件即可完成。使用覆盖索引的好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的 IO 操作。</p><p>具体到上边的例子中就是建立一个复合索引 (b, a)，当查询进行时，通过复合索引的 “b” 部分去定位，至于需要的数据 “a”，立刻就可以在索引里得到，从而省略了表查询的过程。</p><p>如果你想利用 Covering Index，那么就要注意 SELECT 方式，只 SELECT 必要的字段，千万别SELECT * FROM …，因为我们不太可能把所有的字段一起做索引，虽然可以那样做，但那样会让索引文件过大，结果反倒会弄巧成拙。</p><p>如何才能确认查询使用了 Covering Index 呢？很简单，使用 EXPLAIN 即可！只要在 Extra 里出现Using index就说明使用的是 Covering Index。</p><p>这里再举两个栗子，让大家印象深点。</p><p>例子一</p><p>在文章系统里统计总数的时候，一般的查询是这样的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM article WHERE category_id = ...</span><br></pre></td></tr></tbody></table></figure><p></p><p>当我们在<code>category_id</code>建立索引后，这个查询使用的就是 Covering Index。</p><blockquote><p>参考文档：<a href="https://www.percona.com/blog/2007/04/10/count-vs-countcol/" target="_blank" rel="noopener">COUNT(*) vs COUNT(col)</a></p></blockquote><p>例子二<br>在文章系统里分页显示的时候，一般的查询是这样的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, title, content FROM article ORDER BY created DESC LIMIT 10000, 10;</span><br></pre></td></tr></tbody></table></figure><p></p><p>通常这样的查询会把索引建在created字段（其中id是主键），不过当LIMIT偏移很大时，查询效率仍然很低，这时这个查询最好改成下面的样子：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, title, content FROM article</span><br><span class="line">INNER JOIN (</span><br><span class="line">    SELECT id FROM article ORDER BY created DESC LIMIT 10000, 10</span><br><span class="line">) AS page USING(id);</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时，就可以在子查询里利用上 Covering Index，快速定位 id，查询效率嗷嗷的。</p><p>基于我的测试数据，这两条语句的查询耗时分别是 “0.08 秒” 和“0.01 秒以内”，8 倍的差距啊！不由又想起了地精的经典语录<br></p><blockquote class="blockquote-center"><p>时间就是金钱，我的朋友！</p></blockquote><p></p><blockquote><p>补充：InnoDB 引擎层是会对二级索引做自动扩展，优化器能识别出扩展的主键。详情可以参考<a href="https://blog.51cto.com/huanghualiang/1607496" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><p>我们再来看看这两条语句分别对应的执行计划<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql> EXPLAIN SELECT SQL_NO_CACHE id, title, content FROM article ORDER BY created DESC LIMIT 10000, 10;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">| id | select_type | table   | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | article | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 99210 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span>, 2 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql> EXPLAIN SELECT SQL_NO_CACHE id, title, content FROM article INNER JOIN ( SELECT id FROM article ORDER BY created DESC LIMIT 10000, 10 ) AS page USING(id);</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+-------------+---------+---------+-------+----------+----------------------------------+</span><br><span class="line">| id | select_type | table      | partitions | <span class="built_in">type</span>   | possible_keys | key         | key_len | ref     | rows  | filtered | Extra                            |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+-------------+---------+---------+-------+----------+----------------------------------+</span><br><span class="line">|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL          | NULL        | NULL    | NULL    | 10010 |   100.00 | NULL                             |</span><br><span class="line">|  1 | PRIMARY     | article    | NULL       | eq_ref | PRIMARY       | PRIMARY     | 4       | page.id |     1 |   100.00 | NULL                             |</span><br><span class="line">|  2 | DERIVED     | article    | NULL       | index  | NULL          | idx_created | 5       | NULL    | 10010 |   100.00 | Backward index scan; Using index |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+-------------+---------+---------+-------+----------+----------------------------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span>, 2 warnings (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><p></p><p>通过 EXPLAIN 我们可以很明显的看出，第一个查询没有用到索引，Extra 里是 “Using filesort”，这是我们应该尽量避免的情况。而第二个的 Extra 是 “Using index”，所以这两者间效率上的差距就显而易见了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Covering Index 并不是什么很难的概念，但是有些人还不了解它或忽视它的价值，希望本文能给你提个醒。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://yq.aliyun.com/articles/62419" target="_blank" rel="noopener">MySQL 覆盖索引</a></li><li><a href="https://www.jianshu.com/p/fa24238d84a9" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li><li><a href="https://segmentfault.com/a/1190000010264071" target="_blank" rel="noopener">MySQL 认识索引</a></li><li><a href="https://huoding.com/2018/02/27/656" target="_blank" rel="noopener">谈谈 SQL 查询中回表对性能的影响</a></li><li><a href="http://www.cnblogs.com/digdeep/p/4995039.html" target="_blank" rel="noopener">MySQL 优化之 MRR (Multi-Range Read: 二级索引合并回表)</a></li><li><a href="https://blog.51cto.com/huanghualiang/1607496" target="_blank" rel="noopener">关于 MySQL InnoDB 表的二级索引是否加入主键列的问题解释</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsync 命令详解</title>
      <link href="/2019/03/29/rsync/"/>
      <url>/2019/03/29/rsync/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Rsync"><a href="#什么是-Rsync" class="headerlink" title="什么是 Rsync"></a>什么是 Rsync</h2><p>Rsync（remote synchronize）是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件。Rsync 使用所谓的 “Rsync 算法” 来使本地和远 程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。</p><p>Rsync 本来是用于替代 rcp 的一个工具，目前由 <a href="https://rsync.samba.org/" target="_blank" rel="noopener">samba</a> 维护，所以 rsync.conf 文件的格式类似于 Samba 的 主配置文件。Rsync 可以通过 rsh 或 ssh 使用，也能以 daemon 模式去运行，在以 daemon 方式运行时 Rsync server 会打开一个 873 端口，等待客户端去连接。连接时，Rsync server 会检查口令是否相符，若通过口令查核，则可以开始进行文件传输。第一次连通完成时，会把整份文件传输一次，以后则就只需进行增量备份。</p><p>Rsync 支持大多数的类 Unix 系统，无论是 Linux、Solaris 还是 BSD 上都经过了良好的测试。此外，它在 windows 平台下也有相应的版本，如 cwRsync 和 Sync2NAS 等工具。</p><p>Rsync 的基本特点如下：</p><ol><li>可以镜像保存整个目录树和文件系统；</li><li>可以很容易做到保持原来文件的权限、时间、软硬链接等；</li><li>无须特殊权限即可安装；</li><li>优化的流程，文件传输效率高；</li><li>可以使用 rsh、ssh 等方式来传输文件，当然也可以通过直接的 socket 连接；</li><li>支持匿名传输。</li></ol><h2 id="Rsync-同步算法"><a href="#Rsync-同步算法" class="headerlink" title="Rsync 同步算法"></a>Rsync 同步算法</h2><p>Rsync 只所以同步文件的速度相当快，是因为 “Rsync 同步算法” 能在很短的时间内计算出需要备份的数据，关于 Rsync 的同步算法描述如下：</p><p>假定在 1 号和 2 号两台计算机之间同步相似的文件 A 与 B，其中 1 号对文件 A 拥有访问权，2 号对文件 B 拥有访问权。并且假定主机 1 号与 2 号之间的网络带宽很小。那么 rsync 算法将通过下面的五个步骤来完成：</p><ol><li>2 号将文件 B 分割成一组不重叠的固定大小为 S 字节的数据块，最后一块可能会比 S 小。</li><li>2 号对每一个分割好的数据块执行两种校验：一种是 32 位的滚动弱校验，另一种是 128 位的 MD4 强校验</li><li>2 号将这些校验结果发给 1 号。</li><li>1 号通过搜索文件 A 的所有大小为 S 的数据块 (偏移量可以任选，不一定非要是 S 的倍数)，来寻找与文件 B 的某一块有着相同的弱校验码和强校验码的数据块。这项工作可以借助滚动校验的特性很快完成。</li><li>1 号发给 2 号一串指令来生成文件 A 在 2 号上的备份。这里的每一条指令要么是对文件 B 经拥有某一个数据块而不须重传的证明，要么是一个数据块，这个数据块肯定是没有与文件 B 的任何一个数据块匹配上的。</li></ol><h2 id="Rsync-参数说明"><a href="#Rsync-参数说明" class="headerlink" title="Rsync 参数说明"></a>Rsync 参数说明</h2><p>配置文件：<code>rsyncd.conf</code></p><h4 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h4><p>在文件中，<code>[module]</code>之前的所有参数都是全局参数，当然也可以在全局参数部分定义模块参数，这时候该参数的值就是所有模块的默认值。</p><p><code>port</code>指定后台程序使用的端口号，默认为 <code>873</code>。</p><p><code>motd file</code>用来指定一个消息文件，当客户连接服务器时该文件的内容显示给客户，默认是没有 <code>motd</code> 文件的。</p><p><code>log file</code>指定 <code>rsync</code> 的日志文件，而不将日志发送给 <code>syslog</code>。比如可指定为 <code>/var/log/rsyncd.log</code>。</p><p><code>pid file</code>指定 <code>rsync</code> 的 <code>pid</code> 文件，通常指定为 <code>/var/run/rsyncd.pid</code>。</p><p><code>syslog facility</code>指定 <code>rsync</code> 发送日志消息给 <code>syslog</code> 时的消息级别，常见的消息级别是：</p><ul><li>daemon 默认值</li><li>uth</li><li>authpriv</li><li>cron</li><li>daemon</li><li>ftp</li><li>kern</li><li>lpr</li><li>mail</li><li>news</li><li>security</li><li>sys-log</li><li>user</li><li>uucp</li><li>local0</li><li>local1</li><li>local2</li><li>local3</li><li>local4</li><li>local5</li><li>local6</li><li>local7</li></ul><h4 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h4><p>主要是定义服务器哪个目录要被同步。其格式必须为<code>“[module]”</code>形式，这个名字就是在 <code>rsync</code> 客户端看到的名字，其实有点象 <code>Samba</code> 服务器提供的共享名。而服务器真正同步的数据是通过 <code>path</code> 来指定的。我们可以根据自己的需要，来指定多个模块，模块中可以定义以下参数：</p><p><code>comment</code>给模块指定一个描述，该描述连同模块名在客户连接得到模块列表时显示给客户。默认没有描述定义。</p><p><code>path</code>指定该模块的供备份的目录树路径，该参数是必须指定的。</p><p><code>use chroot</code>如果指定为 <code>true</code>，那么 <code>rsync</code> 在传输文件以前首先 <code>chroot</code> 到 <code>path</code> 参数所指定的目录下。这样做的原因是实现额外的安全防护，但是缺点是需要以 <code>root</code> 权限，并且不能备份指向外部的符号连接所指向的目录文件。默认值为 <code>true</code>。</p><p><code>uid</code>指定当该模块传输文件时守护进程应该具有的 <code>uid</code>，配合 <code>gid</code>选项使用可以确定哪些可以访问怎么样的文件权限，默认值是<code>”nobody”</code>。</p><p><code>gid</code>指定当该模块传输文件时守护进程应该具有的 <code>gid</code>。默认值为<code>”nobody”</code>。</p><p><code>max connections</code>指定该模块的最大并发连接数量以保护服务器，超过限制的连接请求将被告知随后再试。默认值是 <code>0</code>，也就是没有限制。</p><p><code>list</code>该选项设定当客户请求可以使用的模块列表时，该模块是否应该被列出。如果设置该选项为 <code>false</code>，可以创建隐藏的模块。默认值是 <code>true</code>。</p><p><code>read only</code>设定是否允许客户上载文件。如果为 <code>true</code> 那么任何上载请求都会失败，如果为 <code>false</code> 并且服务器目录读写权限允许那么上载是允许的。默认值为 <code>true</code>。</p><p><code>exclude</code>用来指定多个由空格隔开的多个文件或目录 (相对路径)，并将其添加到 <code>exclude</code> 列表中。这等同于在客户端命令中使用<code>--exclude</code>来指定 模式，一个模块只能指定一个 <code>exclude</code> 选项。但是需要注意的一点是该选项有一定的安全性问题，客户很有可能绕过 <code>exclude</code> 列表，如果希望确保特定 的文件不能被访问，那就最好结合 <code>uid/gid</code> 选项一起使用。</p><p><code>exclude from</code>指定一个包含 <code>exclude</code> 模式的定义的文件名，服务器从该文件中读取 <code>exclude</code> 列表定义。</p><p><code>include</code>用来指定不排除符合要求的文件或目录。这等同于在客户端命令中使用<code>–include</code> 来指定模式，结合 <code>include</code> 和 <code>exclude</code> 可以定义复杂的 <code>exclude/include</code> 规则。</p><p><code>include from</code>指定一个包含 <code>include</code> 模式的定义的文件名，服务器从该文件中读取 <code>include</code> 列表定义。</p><p><code>auth users</code>指定由空格或逗号分隔的用户名列表，只有这些用户才允许连接该模块。这里的用户和系统用户没有任何关系。如果”auth users” 被设置，那么客户端发出对该模块的连接请求以后会被 <code>rsync</code> 请求 <code>challenged</code> 进行验证身份这里使用的 <code>challenge/response</code> 认证协议。用户的名和密码以明文方式存放在<code>”secrets file”</code> 选项指定的文件中。默认情况下无需密码就可以连接模块 (也就是匿名方式)。</p><p><code>secrets file</code>指定一个包含定义用户名: 密码对的文件。只有在<code>”auth users”</code> 被定义时，该文件才有作用。文件每行包含一个 <code>username:passwd</code> 对。一般来说密码最好不要超过 <code>8</code> 个字符。没有默认的 <code>secures file</code>，需要限式指定一个 (例如：<code>/etc/rsyncd.passwd</code>)。注意：该文件的权限一定要是 <code>600</code>，否则客户端将不能连接服务器。</p><p><code>strict modes</code>指定是否监测密码文件的权限，如果该选项值为 <code>true</code> 那么密码文件只能被 <code>rsync</code> 服务器运行身份的用户访问，其他任何用户不可以访问该文件。默认值为 <code>true</code>。</p><p><code>hosts allow</code>指定哪些 <code>IP</code> 的客户允许连接该模块。客户模式定义可以是以下形式：</p><ul><li>单个 IP 地址，例如：192.167.0.1</li><li>整个网段，例如：192.168.0.0/24，也可以是 192.168.0.0/255.255.255.0</li><li>多个 IP 或网段需要用空格隔开，<code>“*”</code> 则表示所有，默认是允许所有主机连接。</li></ul><p><code>hosts deny</code>指定不允许连接 <code>rsync</code> 服务器的机器，可以使用 <code>hosts allow</code> 的定义方式来进行定义。默认是没有 <code>hosts deny</code> 定义。</p><p><code>ignore errors</code>指定 <code>rsyncd</code> 在判断是否运行传输时的删除操作时忽略 <code>server</code> 上的 <code>IO</code> 错误，一般来说 <code>rsync</code> 在出现 <code>IO</code> 错误时将将跳过<code>--delete</code>操作，以防止因为暂时的资源不足或其它 <code>IO</code> 错误导致的严重问题。</p><p><code>ignore nonreadable</code>指定 <code>rysnc</code> 服务器完全忽略那些用户没有访问权限的文件。这对于在需要备份的目录中有些文件是不应该被备份者得到的情况是有意义的。</p><p><code>lock file</code>指定支持 <code>max connections</code> 参数的锁文件，默认值是 <code>/var/run/rsyncd.lock</code>。</p><p><code>transfer logging</code>使 <code>rsync</code> 服务器使用 <code>ftp</code> 格式的文件来记录下载和上载操作在自己单独的日志中。</p><p><code>log format</code>通过该选项用户在使用 <code>transfer logging</code> 可以自己定制日志文件的字段。其格式是一个包含格式定义符的字符串，可以使用的格式定义符如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%h 远程主机名</span><br><span class="line">%a 远程IP地址</span><br><span class="line">%l 文件长度字符数</span><br><span class="line">%p 该次rsync会话的进程id</span><br><span class="line">%o 操作类型：<span class="string">"send"</span>或<span class="string">"recv"</span></span><br><span class="line">%f 文件名</span><br><span class="line">%P 模块路径</span><br><span class="line">%m 模块名</span><br><span class="line">%t 当前时间</span><br><span class="line">%u 认证的用户名(匿名时是null)</span><br><span class="line">%b 实际传输的字节数</span><br><span class="line">%c 当发送文件时，该字段记录该文件的校验码</span><br><span class="line">默认<span class="built_in">log</span>格式为：`%o %h [%a] %m (%u) %f %l`，一般来说,在每行的头上会添加`%t [%p]`。在源代码中同时发布有一个叫rsyncstats的perl脚本程序来统计这种格式的日志文件。</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>timeout</code>通过该选项可以覆盖客户指定的 <code>IP</code> 超时时间。通过该选项可以确保 <code>rsync</code> 服务器不会永远等待一个崩溃的客户端。超时单位为秒钟，<code>0</code> 表示没有超时定义，这也是默认值。对于匿名 <code>rsync</code> 服务器来说，一个理想的数字是 <code>600</code>。</p><p><code>refuse options</code>通过该选项可以定义一些不允许客户对该模块使用的命令参数列表。这里必须使用命令全名，而不能是简称。但发生拒绝某个命令的情况时服务器将报告错误信息然后退出。如果要防止使用压缩，应该是：<code>dont compress = *</code>。</p><p><code>dont compress</code>用来指定那些不进行压缩处理再传输的文件，默认值是 <code>*.gz</code> <code>*.tgz</code> <code>*.zip</code> <code>*.z</code> <code>*.rpm</code> <code>*.deb</code> <code>*.iso</code> <code>*.bz2</code> <code>*.tbz</code></p><h2 id="Rsync-命令"><a href="#Rsync-命令" class="headerlink" title="Rsync 命令"></a>Rsync 命令</h2><p>在对 rsync 服务器配置结束以后，下一步就需要在客户端发出 rsync 命令来实现将服务器端的文件备份到客户端来。rsync 是一个功能非常强大的工具，其命令也有很多功能特色选项，下面就对它的选项一一进行分析说明。<br>Rsync 的命令格式可以为以下六种：</p><ol><li><code>rsync [OPTION]... SRC DEST</code></li><li><code>rsync [OPTION]... SRC [USER@]HOST:DEST</code></li><li><code>rsync [OPTION]... [USER@]HOST:SRC DEST</code></li><li><code>rsync [OPTION]... [USER@]HOST::SRC DEST</code></li><li><code>rsync [OPTION]... SRC [USER@]HOST::DEST</code></li><li><code>rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</code></li></ol><p>对应于以上六种命令格式，rsync 有六种不同的工作模式：</p><ol><li>拷贝本地文件。当 SRC 和 DES 路径信息都不包含有单个冒号”:” 分隔符时就启动这种工作模式。如：rsync -a /data /backup</li><li>使用一个远程 shell 程序 (如 rsh、ssh) 来实现将本地机器的内容拷贝到远程机器。当 DST 路径地址包含单个冒号”:”分隔符时启动该模式。如：rsync -avz *.c foo:src</li><li>使用一个远程 shell 程序 (如 rsh、ssh) 来实现将远程机器的内容拷贝到本地机器。当 SRC 地址路径包含单个冒号”:”分隔符时启动该模式。如：rsync -avz foo:src/bar /data</li><li>从远程 rsync 服务器中拷贝文件到本地机。当 SRC 路径信息包含”::” 分隔符时启动该模式。如：rsync -av <a href="mailto:root@172.16.78.192" target="_blank" rel="noopener">root@172.16.78.192</a>::www /databack</li><li>从本地机器拷贝文件到远程 rsync 服务器中。当 DST 路径信息包含”::” 分隔符时启动该模式。如：rsync -av /databack <a href="mailto:root@172.16.78.192" target="_blank" rel="noopener">root@172.16.78.192</a>::www</li><li>列远程机的文件列表。这类似于 rsync 传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://172.16.78.192/www</li></ol><p>rsync 参数的具体解释如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-v, --verbose 详细模式输出</span><br><span class="line">-q, --quiet 精简输出模式</span><br><span class="line">-c, --checksum 打开校验开关，强制对文件传输进行校验</span><br><span class="line">-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</span><br><span class="line">-r, --recursive 对子目录以递归模式处理</span><br><span class="line">-R, --relative 使用相对路径信息</span><br><span class="line">-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">--backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">-suffix=SUFFIX 定义备份文件前缀</span><br><span class="line">-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)</span><br><span class="line">-l, --links 保留软链结</span><br><span class="line">-L, --copy-links 想对待常规文件一样处理软链结</span><br><span class="line">--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结</span><br><span class="line">--safe-links 忽略指向SRC路径目录树以外的链结</span><br><span class="line">-H, --hard-links 保留硬链结</span><br><span class="line">-p, --perms 保持文件权限</span><br><span class="line">-o, --owner 保持文件属主信息</span><br><span class="line">-g, --group 保持文件属组信息</span><br><span class="line">-D, --devices 保持设备文件信息</span><br><span class="line">-t, --<span class="built_in">times</span> 保持文件时间信息</span><br><span class="line">-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间</span><br><span class="line">-n, --dry-run现实哪些文件将被传输</span><br><span class="line">-W, --whole-file 拷贝文件，不进行增量检测</span><br><span class="line">-x, --one-file-system 不要跨越文件系统边界</span><br><span class="line">-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节</span><br><span class="line">-e, --rsh=COMMAND 指定使用rsh、ssh方式进行数据同步</span><br><span class="line">--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息</span><br><span class="line">-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件</span><br><span class="line">--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件</span><br><span class="line">--delete 删除那些DST中SRC没有的文件</span><br><span class="line">--delete-excluded 同样删除接收端那些被该选项指定排除的文件</span><br><span class="line">--delete-after 传输结束以后再删除</span><br><span class="line">--ignore-errors 及时出现IO错误也进行删除</span><br><span class="line">--max-delete=NUM 最多删除NUM个文件</span><br><span class="line">--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输</span><br><span class="line">--force 强制删除目录，即使不为空</span><br><span class="line">--numeric-ids 不将数字的用户和组ID匹配为用户名和组名</span><br><span class="line">--timeout=TIME IP超时时间，单位为秒</span><br><span class="line">-I, --ignore-times 不跳过那些有同样的时间和长度的文件</span><br><span class="line">--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间</span><br><span class="line">--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0</span><br><span class="line">-T --temp-dir=DIR 在DIR中创建临时文件</span><br><span class="line">--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份</span><br><span class="line">-P 等同于 --partial</span><br><span class="line">--progress 显示备份过程</span><br><span class="line">-z, --compress 对备份的文件在传输时进行压缩处理</span><br><span class="line">--exclude=PATTERN 指定排除不需要传输的文件模式</span><br><span class="line">--include=PATTERN 指定不排除而需要传输的文件模式</span><br><span class="line">--exclude-from=FILE 排除FILE中指定模式的文件</span><br><span class="line">--include-from=FILE 不排除FILE指定模式匹配的文件</span><br><span class="line">--version 打印版本信息</span><br><span class="line">--address 绑定到特定的地址</span><br><span class="line">--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件</span><br><span class="line">--port=PORT 指定其他的rsync服务端口</span><br><span class="line">--blocking-io 对远程shell使用阻塞IO</span><br><span class="line">-stats 给出某些文件的传输状态</span><br><span class="line">--progress 在传输时现实传输过程</span><br><span class="line">--<span class="built_in">log</span>-format=formAT 指定日志文件格式</span><br><span class="line">--password-file=FILE 从FILE中得到密码</span><br><span class="line">--bwlimit=KBPS 限制I/O带宽，KBytes per second</span><br><span class="line">-h, --<span class="built_in">help</span> 显示帮助信息</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Rsync-使用实例"><a href="#Rsync-使用实例" class="headerlink" title="Rsync 使用实例"></a>Rsync 使用实例</h2><h4 id="SSH-方式"><a href="#SSH-方式" class="headerlink" title="SSH 方式"></a>SSH 方式</h4><p>在服务端启动 ssh 服务<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service sshd start</span><br><span class="line">启动 sshd： [确定]</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用 rsync 进行同步</p><p>接下来就可以在客户端使用 rsync 命令来备份服务端上的数据了，SSH 方式是通过系统用户来进行备份的，如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -vzrtopg --progress -e ssh --delete work@172.16.78.192:/www/* /databack/experiment/rsync</span><br><span class="line">work@172.16.78.192<span class="string">'s password:</span></span><br><span class="line"><span class="string">receiving file list ...</span></span><br><span class="line"><span class="string">5 files to consider</span></span><br><span class="line"><span class="string">test/</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">0 100% 0.00kB/s 527:35:41 (1, 20.0% of 5)</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">67 100% 65.43kB/s 0:00:00 (2, 40.0% of 5)</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">0 100% 0.00kB/s 527:35:41 (3, 60.0% of 5)</span></span><br><span class="line"><span class="string">dd</span></span><br><span class="line"><span class="string">100663296 100% 42.22MB/s 0:00:02 (4, 80.0% of 5)</span></span><br><span class="line"><span class="string">sent 96 bytes received 98190 bytes 11563.06 bytes/sec</span></span><br><span class="line"><span class="string">total size is 100663363 speedup is 1024.19</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>上面的信息描述了整个的备份过程，以及总共备份数据的大小。</p><h4 id="后台服务方式"><a href="#后台服务方式" class="headerlink" title="后台服务方式"></a>后台服务方式</h4><p><strong>启动 rsync 服务</strong></p><p>编辑 / etc/xinetd.d/rsync 文件，将其中的 disable=yes 改为 disable=no，并重启 xinetd 服务，如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># default: off</span></span><br><span class="line"><span class="comment"># description: The rsync server is a good addition to an ftp server, as it \</span></span><br><span class="line"><span class="comment"># allows crc checksumming etc.</span></span><br><span class="line">service rsync</span><br><span class="line">{</span><br><span class="line"><span class="built_in">disable</span> = no</span><br><span class="line">socket_type = stream</span><br><span class="line"><span class="built_in">wait</span> = no</span><br><span class="line">user = root</span><br><span class="line">server = /usr/bin/rsync</span><br><span class="line">server_args = --daemon</span><br><span class="line">log_on_failure += USERID</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/xinetd restart</span><br><span class="line">停止 xinetd： [确定]</span><br><span class="line">启动 xinetd： [确定]</span><br></pre></td></tr></tbody></table></figure><p>或者自己手动启动并添加自启动：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/rsync --daemon --config=/etc/rsyncd.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/bin/rsync --daemon --config=/etc/rsyncd.conf"</span> >> /etc/rc.local</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>创建配置文件</strong></p><p>默认安装好 rsync 程序后，并不会自动创建 rsync 的主配置文件，需要手工来创建，其主配置文件为 “/etc/rsyncd.conf”，创建该文件并插入如下内容：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Minimal configuration file for rsync daemon</span></span><br><span class="line"><span class="comment"># See rsync(1) and rsyncd.conf(5) man pages for help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################ 以下是公共参数配置 ############################</span></span><br><span class="line"><span class="comment"># This line is required by the /etc/init.d/rsyncd script</span></span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line"><span class="comment"># 服务的端口</span></span><br><span class="line">port = 873</span><br><span class="line"><span class="comment"># 服务的IP</span></span><br><span class="line">address = 10.44.201.202</span><br><span class="line"><span class="comment"># 运行的宿主账户，这里为简单就root了</span></span><br><span class="line">uid = root</span><br><span class="line">gid = root</span><br><span class="line"><span class="comment"># 打开（yes）后有个功能是让符号链接可以同步过去（不通过符号链接对应的实际文件）</span></span><br><span class="line">use chroot = no</span><br><span class="line"><span class="comment"># 客户端只读</span></span><br><span class="line"><span class="built_in">read</span> only = yes</span><br><span class="line"><span class="comment">#limit access to private LANs</span></span><br><span class="line">hosts allow=10.51.56.165/255.255.255.0</span><br><span class="line"><span class="comment"># hosts deny=*</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line">max connections = 5</span><br><span class="line"><span class="comment"># 欢迎信息对应的文件</span></span><br><span class="line"><span class="comment"># motd file = /etc/rsyncd.motd</span></span><br><span class="line"><span class="comment"># 客户端链接的超时时间</span></span><br><span class="line">timeout = 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是日志相关配置，可选使用独立日志文件和系统日志</span></span><br><span class="line"><span class="comment"># This will give you a separate log file</span></span><br><span class="line"><span class="comment"># log file = /var/log/rsync.log</span></span><br><span class="line"><span class="comment"># This will log every file transferred - up to 85,000+ per user, per sync</span></span><br><span class="line"><span class="comment"># transfer logging = yes</span></span><br><span class="line"><span class="comment"># log format = %t %a %m %f %b</span></span><br><span class="line"><span class="comment"># syslog facility = local3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# 同步模块配置 ################################</span></span><br><span class="line">[thrift]</span><br><span class="line"><span class="comment"># 需要同步的路径</span></span><br><span class="line">path = /data/JiemoLucenes</span><br><span class="line"><span class="comment"># 客户端可以使用list命令列表显示</span></span><br><span class="line">list=yes</span><br><span class="line"><span class="comment"># 忽略错误</span></span><br><span class="line">ignore errors</span><br><span class="line"><span class="comment"># 认证用户</span></span><br><span class="line">auth users = root</span><br><span class="line"><span class="comment"># 认证使用的账户密码文件</span></span><br><span class="line">secrets file = /etc/rsyncd.secrets</span><br><span class="line"><span class="comment"># 备注信息</span></span><br><span class="line">comment = This is nexus data</span><br><span class="line"><span class="comment"># 如果有忽略的子目录，可以通过exclude定义</span></span><br><span class="line"><span class="comment"># exclude = easylife/  samba/</span></span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>创建密码文件</strong><br>采用这种方式不能使用系统用户对客户端进行认证，所以需要创建一个密码文件，其格式为 “username:password”，用户名可以和密码可以随便定义，最好不要和系统帐户一致，同时要把创建的密码文件权限设置为 600，这在前面的模块参数做了详细介绍。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"work:abc123"</span> > /etc/rsyncd.passwd</span><br><span class="line">chmod 600 /etc/rsyncd.passwd</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>备份</strong><br>完成以上工作，现在就可以对数据进行备份了，如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -avz --progress --delete work@172.16.78.192::www /databack/experiment/rsync</span><br><span class="line">Password:</span><br><span class="line">receiving file list ...</span><br><span class="line">6 files to consider</span><br><span class="line">./ files...</span><br><span class="line">a</span><br><span class="line">0 100% 0.00kB/s 528:20:41 (1, 50.0% of 6)</span><br><span class="line">b</span><br><span class="line">67 100% 65.43kB/s 0:00:00 (2, 66.7% of 6)</span><br><span class="line">c</span><br><span class="line">0 100% 0.00kB/s 528:20:41 (3, 83.3% of 6)</span><br><span class="line">dd</span><br><span class="line">100663296 100% 37.49MB/s 0:00:02 (4, 100.0% of 6)</span><br><span class="line">sent 172 bytes received 98276 bytes 17899.64 bytes/sec</span><br><span class="line">total size is 150995011 speedup is 1533.75</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>恢复</strong><br>当服务器的数据出现问题时，那么这时就需要通过客户端的数据对服务端进行恢复，但前提是服务端允许客户端有写入权限，否则也不能在客户端直接对服务端进行恢复，使用 rsync 对数据进行恢复的方法如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -avz --progress /databack/experiment/rsync/ work@172.16.78.192::www</span><br><span class="line">Password:</span><br><span class="line">building file list ...</span><br><span class="line">6 files to consider</span><br><span class="line">./</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">67 100% 0.00kB/s 0:00:00 (2, 66.7% of 6)</span><br><span class="line">c</span><br><span class="line">sent 258 bytes received 76 bytes 95.43 bytes/sec</span><br><span class="line">total size is 150995011 speedup is 452080.87</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>示例脚本</strong><br>这里这些脚本都是 rsync 网站上的例子：<br>1、每隔七天将数据往中心服务器做增量备份<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This script does personal backups to a rsync backup server. You will end up</span></span><br><span class="line"><span class="comment"># with a 7 day rotating incremental backup. The incrementals will go</span></span><br><span class="line"><span class="comment"># into subdirectories named after the day of the week, and the current</span></span><br><span class="line"><span class="comment"># full backup goes into a directory called "current"</span></span><br><span class="line"><span class="comment"># tridge@linuxcare.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># directory to backup</span></span><br><span class="line">BDIR=/home/<span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># excludes file - this contains a wildcard pattern per line of files to exclude</span></span><br><span class="line">EXCLUDES=<span class="variable">$HOME</span>/cron/excludes</span><br><span class="line"></span><br><span class="line"><span class="comment"># the name of the backup machine</span></span><br><span class="line">BSERVER=owl</span><br><span class="line"></span><br><span class="line"><span class="comment"># your password on the backup server</span></span><br><span class="line"><span class="built_in">export</span> RSYNC_PASSWORD=XXXXXX</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line"></span><br><span class="line">BACKUPDIR=`date +%A`</span><br><span class="line">OPTS=<span class="string">"--force --ignore-errors --delete-excluded --exclude-from=<span class="variable">$EXCLUDES</span></span></span><br><span class="line"><span class="string">--delete --backup --backup-dir=/<span class="variable">$BACKUPDIR</span> -a"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/bin:/usr/bin:/usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># the following line clears the last weeks incremental directory</span></span><br><span class="line">[ -d <span class="variable">$HOME</span>/emptydir ] || mkdir <span class="variable">$HOME</span>/emptydir</span><br><span class="line">rsync --delete -a <span class="variable">$HOME</span>/emptydir/ <span class="variable">$BSERVER</span>::<span class="variable">$USER</span>/<span class="variable">$BACKUPDIR</span>/</span><br><span class="line">rmdir <span class="variable">$HOME</span>/emptydir</span><br><span class="line"></span><br><span class="line"><span class="comment"># now the actual transfer</span></span><br><span class="line">rsync <span class="variable">$OPTS</span> <span class="variable">$BDIR</span> <span class="variable">$BSERVER</span>::<span class="variable">$USER</span>/current</span><br></pre></td></tr></tbody></table></figure><p></p><p>2、备份至一个空闲的硬盘<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin</span><br><span class="line"></span><br><span class="line">LIST=<span class="string">"rootfs usr data data2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> <span class="variable">$LIST</span>; <span class="keyword">do</span></span><br><span class="line">mount /backup/<span class="variable">$d</span></span><br><span class="line">rsync -ax --exclude fstab --delete /<span class="variable">$d</span>/ /backup/<span class="variable">$d</span>/</span><br><span class="line">umount /backup/<span class="variable">$d</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">DAY=`date <span class="string">"+%A"</span>`</span><br><span class="line"></span><br><span class="line">rsync -a --delete /usr/<span class="built_in">local</span>/apache /data2/backups/<span class="variable">$DAY</span></span><br><span class="line">rsync -a --delete /data/solid /data2/backups/<span class="variable">$DAY</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>3、对 vger.rutgers.edu 的 cvs 树进行镜像<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/www/cvs/vger/</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/usr/freeware/bin:/usr/bin:/bin</span><br><span class="line"></span><br><span class="line">RUN=`lps x | grep rsync | grep -v grep | wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$RUN</span>"</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> already running</span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">rsync -az vger.rutgers.edu::cvs/CVSROOT/ChangeLog <span class="variable">$HOME</span>/ChangeLog</span><br><span class="line"></span><br><span class="line">sum1=`sum <span class="variable">$HOME</span>/ChangeLog`</span><br><span class="line">sum2=`sum /var/www/cvs/vger/CVSROOT/ChangeLog`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$sum1</span>"</span> = <span class="string">"<span class="variable">$sum2</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> nothing to <span class="keyword">do</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">rsync -az --delete --force vger.rutgers.edu::cvs/ /var/www/cvs/vger/</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q：如何通过 ssh 进行 rsync，而且无须输入密码？</p><p>A：可以通过以下几个步骤</p><pre><code>* 通过 ssh-keygen 在 server A 上建立 SSH keys，不要指定密码，你会在~/.ssh 下看到 identity 和 identity.pub 文件* 在 server B 上的 home 目录建立子目录. ssh* 将 A 的 identity.pub 拷贝到 server B 上* 将 identity.pub 加到`~[user b]/.ssh/authorized_keys`* 于是 server A 上的 A 用户，可通过下面命令以用户 B ssh 到 server B 上了 e.g.`ssh -l userB serverB`* 这样就使 server A 上的用户 A 就可以 ssh 以用户 B 的身份无需密码登陆到 server B 上了。</code></pre><p>Q：如何通过在不危害安全的情况下通过防火墙使用 rsync?</p><p>A：解答如下：</p><p>这通常有两种情况，一种是服务器在防火墙内，一种是服务器在防火墙外。无论哪种情况，通常还是使用 ssh，这时最好新建一个备份用户，并且配置 sshd 仅允许这个用户通过 RSA 认证方式进入。如果服务器在防火墙内，则最好限定客户端的 IP 地址，拒绝其它所有连接。如果客户机在防火墙内，则可以简 单允许防火墙打开 TCP 端口 22 的 ssh 外发连接就 ok 了。</p><p>Q：我能将更改过或者删除的文件也备份上来吗？</p><p>A：当然可以：</p><p>你可以使用如：<code>rsync -other -options -backupdir = ./backup-2000-2-13 ...</code>这样的命令来实现。<br>这样如果源文件:/path/to/some/file.c 改变了，那么旧的文件就会被移到./backup-2000-2-13/path/to/some/file.c，<br>这里这个目录需要自己手工建立起来</p><p>Q：我需要在防火墙上开放哪些端口以适应 rsync？</p><p>A：视情况而定</p><p>rsync 可以直接通过 873 端口的 tcp 连接传文件，也可以通过 22 端口的 ssh 来进行文件传递，但你也可以通过下列命令改变它的端口：<br><code>rsync --port 8730 otherhost::</code><br>或者<br><code>rsync -e 'ssh -p 2002' otherhost:</code></p><p>Q：我如何通过 rsync 只复制目录结构，忽略掉文件呢？</p><p>A：<code>rsync -av --include '*/' --exclude '*' source-dir dest-dir</code></p><p>Q：为什么我总会出现 “Read-only file system” 的错误呢？</p><p>A：看看是否忘了设 “read only = no” 了</p><p>Q：为什么我会出现‘@ERROR: invalid gid’的错误呢？</p><p>A：rsync 使用时默认是用 uid=nobody;gid=nobody 来运行的，如果你的系统不存在 nobody 组的话，就会出现这样的错误，可以试试 gid = nogroup 或者其它</p><p>Q：绑定端口 873 失败是怎么回事？</p><p>A：如果你不是以 root 权限运行这一守护进程的话，因为 1024 端口以下是特权端口，会出现这样的错误。你可以用–port 参数来改变。</p><p>Q：为什么我认证失败？</p><p>A：从你的命令行看来：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -a 144.16.251.213::<span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line">Password:</span><br><span class="line">@ERROR: auth failed on module <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>应该是没有以你的用户名登陆导致的问题，试试<code>rsync -a max@144.16.251.213::test test</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modules 初试 -- Go 包管理解决之道</title>
      <link href="/2019/03/29/goModules/"/>
      <url>/2019/03/29/goModules/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 的包管理是一直是为人诟病之处，从 Go 1.5 引入的 vendor 机制，到准官方工具 dep，目前为止还没一个简便的解决方案</p><p>不过现在 go modules 随着 golang1.11 的发布而和我们见面了，这是官方提倡的新的包管理，乃至项目管理机制，可以不再需要 GOPATH 的存在。<br><img src="/2019/03/29/goModules/go-module.jpg" title="go-module"></p><p>欣喜之余，赶紧上手来试一下吧~</p><p><strong>Go modules 的前世今生</strong></p><p>说起 Go 的包依赖管理，作为 Google 脑残粉的我也是连连叹气。。。</p><p>如果说 Java(Maven) 是坨 shit 的话，那 Go 真是连 Java 都不如。</p><p>自 2007 年 “三巨头”（<a href="https://github.com/griesemer" target="_blank" rel="noopener">Robert Griesemer</a>, <a href="https://en.wikipedia.org/wiki/Rob_Pike" target="_blank" rel="noopener">Rob Pike</a>, <a href="https://en.wikipedia.org/wiki/Ken_Thompson" target="_blank" rel="noopener">Ken Thompson</a>）提出设计和实现 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>以来，这门语言已经发展和演化了十余年了。</p><p>但是自从 Go 语言诞生以来吧，大佬们就认为<code>go get</code> 已经挺好了，没必要再额外造一个轮子了——包管理器。</p><p>也许是大佬们都不需要团队开发吧，但是大佬毕竟是少数，于是，各种各样的社区解决方案就出现了，可谓是百家争鸣。</p><ul><li><a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a></li><li><a href="https://github.com/kovetskiy/manul" target="_blank" rel="noopener">manul</a> - Vendor packages using git submodules.</li><li><a href="https://github.com/tools/godep" target="_blank" rel="noopener">Godep</a></li><li><a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">Govendor</a></li><li><a href="https://github.com/hectorj/godm" target="_blank" rel="noopener">godm</a></li><li><a href="https://github.com/govend/govend" target="_blank" rel="noopener">govend</a> - Manage dependencies like <code>go get</code> but for <code>/vendor</code>.</li><li><a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener">Glide</a> - Manage packages like composer, npm, bundler, or other languages.</li></ul><p>当初看到这个列表的时候，我不禁感慨：“这么多的解决方案，可真是挑花了朕的眼睛呀。”</p><p>Go 官方说：“莫急，这份<a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="noopener">官方对比</a>拿好不谢。”</p><p>Go 在构建设计方面深受 Google 内部开发实践的影响，比如 go get 的设计就深受 <a href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/pdf" target="_blank" rel="noopener">Google 内部单一代码仓库 (single monorepo) 和基于主干 (trunk/mainline based) 的开发模型</a>的影响：只获取 Trunk/mainline 代码和版本无感知。<br><img src="/2019/03/29/goModules/google-trunk-based-and-release-branch-dev-model.png" title="google-trunk-based-and-release-branch-dev-model"></p><blockquote><p>Google 内部基于主干的开发模型：</p><ul><li>所有开发人员基于主干 trunk/mainline 开发：提交到 trunk 或从 trunk 获取最新的代码（同步到本地 workspace）</li><li>版本发布时，建立 Release branch，release branch 实质上就是某一个时刻主干代码的快照</li><li>必须同步到 release branch 上的 bug fix 和增强改进代码也通常是先在 trunk 上提交 (commit)，然后再 cherry-pick 到 release branch 上</li></ul></blockquote><p>我们知道 go get 获取的代码会放在 $GOPATH/src 下面，而 go build 会在 $GOROOT/src 和 \$GOPATH/src 下面按照 import path 去搜索 package，由于 go get 获取的都是各个 package repo 的 trunk/mainline 的代码，因此，Go 1.5 之前的 Go compiler 都是基于目标 Go 程序依赖包的 trunk/mainline 代码去编译的。这样的机制带来的问题是显而易见的，至少包括：</p><ul><li>因依赖包的 trunk 的变化，导致不同人获取和编译你的包 / 程序时得到的结果实质是不同的，即不能实现 reproduceable build</li><li>因依赖包的 trunk 的变化，引入不兼容的实现，导致你的包 / 程序无法通过编译</li><li>因依赖包演进而无法通过编译，导致你的包 / 程序无法通过编译</li></ul><p>为了实现 reporduceable build，Go 1.5 引入了 Vendor 机制，Go 编译器会优先在 vendor 下搜索依赖的第三方包，这样如果开发者将特定版本的依赖包存放在 vendor 下面并提交到 code repo，那么所有人理论上都会得到同样的编译结果，从而实现 reporduceable build。</p><p>在 Go 1.5 发布后的若干年，gopher 们把注意力都集中在如何利用 vendor 解决包依赖问题，从手工添加依赖到 vendor、手工更新依赖，到一众包依赖管理工具的诞生，比如：<a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">Govendor</a>、<a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener">glide</a> 以及号称准官方工具的 <a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a>，努力地尝试着按照当今主流思路解决着诸如 “钻石型依赖” 等难题。</p><p>正当 gopher 认为 dep 将 “顺理成章” 地升级为 go toolchain 一部分的时候，今年年初，Go 核心 Team 的技术 leader，也是 Go Team 最早期成员之一的 <a href="https://research.swtch.com/" target="_blank" rel="noopener">Russ Cox</a> 在<a href="https://research.swtch.com/" target="_blank" rel="noopener">个人博客</a>上连续发表了<a href="https://research.swtch.com/vgo" target="_blank" rel="noopener">七篇文章</a>，系统阐述了 Go team 解决” 包依赖管理” 的技术方案: <a href="https://github.com/golang/vgo" target="_blank" rel="noopener">vgo</a> —— modules 的前身。</p><p>vgo 的主要思路包括：<a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">Semantic Import Versioning</a>、<a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">Minimal Version Selection</a>、<a href="https://research.swtch.com/vgo-module" target="_blank" rel="noopener">引入 Go module</a> 等。这七篇文章的发布引发了 Go 社区激烈地争论，尤其是 MVS(最小版本选择) 与目前主流的依赖版本选择方法的相悖让很多传统 Go 包管理工具的维护者” 不满”，尤其是” 准官方工具”：dep。vgo 方案的提出也意味着 dep 项目的生命周期即将进入尾声。</p><p>5 月份，Russ Cox 的 <a href="https://github.com/golang/go/issues/24301" target="_blank" rel="noopener">Proposal “cmd/go: add package version support to Go toolchain” </a>被 accepted，这周五早些时候 Russ Cox <a href="https://github.com/golang/go/commit/f7248f05946c1804b5519d0b3eb0db054dc9c5d6" target="_blank" rel="noopener">将 vgo 的代码 merge 到 Go 主干</a>，并将这套机制正式命名为”go modules”。由于 vgo 项目本身就是一个实验原型，merge 到主干后，vgo 这个术语以及 vgo 项目的使命也就就此结束了。后续 Go modules 机制将直接在 Go 主干上继续演化。</p><p>Go modules 是 Go team 在解决包依赖管理方面的一次勇敢尝试，无论如何，对 Go 语言来说都是一个好事。</p><h2 id="Go-modules-上手"><a href="#Go-modules-上手" class="headerlink" title="Go modules 上手"></a>Go modules 上手</h2><p>这里就用 Gin 框架来实现两个 RESTful API 作示例吧，目录结构如下，两个 handler 分别属于 <code>main</code> 和 <code>pkg/api/data</code> 这两个 package<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mytest</span><br><span class="line">├── main.<span class="keyword">go</span></span><br><span class="line">└── pkg</span><br><span class="line">    └── api</span><br><span class="line">        └── data</span><br><span class="line">            └── api.<span class="keyword">go</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>进入 myproj 目录，然后使用 <code>go mod</code> 建立 modules<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod init github.com/wangjiemin/mytest</span><br><span class="line"><span class="keyword">go</span>: creating <span class="built_in">new</span> <span class="keyword">go</span>.mod: module github.com/wangjiemin/mytest</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时会自动产生一个 go.mod 文件，打开看到里边内容只有一行<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module github.com/wangjiemin/mytest</span><br></pre></td></tr></tbody></table></figure><p></p><p>现在开始写我们的两个 handler<br>1.pkg/api/data/api.go<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDataAPIHealthHandler GET /health-dataapi to expose heathy check result of data API</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDataAPIHealthHandler</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">    <span class="comment">// do something to check heathy of data API</span></span><br><span class="line">    c.JSON(http.StatusOK, gin.H{</span><br><span class="line">        <span class="string">"code"</span>:    <span class="number">0</span>,</span><br><span class="line">        <span class="string">"message"</span>: <span class="string">"Data API is alive"</span>,</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>2.main.go<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    dataapi <span class="string">"github.com/wangjiemin/mytest/pkg/api/data"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.GET(<span class="string">"/health"</span>, GetHealthHandler)</span><br><span class="line">    router.GET(<span class="string">"/health-dataapi"</span>, dataapi.GetDataAPIHealthHandler)</span><br><span class="line"></span><br><span class="line">    s := &http.Server{</span><br><span class="line">        Addr:    <span class="string">":8000"</span>,</span><br><span class="line">        Handler: router,</span><br><span class="line">    }</span><br><span class="line">    s.ListenAndServe()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetHealthHandler - GET /health to expose service health</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHealthHandler</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">    c.JSON(http.StatusOK, gin.H{</span><br><span class="line">        <span class="string">"code"</span>:    <span class="number">0</span>,</span><br><span class="line">        <span class="string">"message"</span>: <span class="string">"Service is alive!"</span>,</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>然后用我们的老朋友 <code>go build</code> 创建可执行文件<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build -o bin/main main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span>: finding github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: finding github.com/gin-contrib/sse latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/ugorji/<span class="keyword">go</span>/codec latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/golang/protobuf/proto latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="keyword">go</span>: finding gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line"><span class="keyword">go</span>: finding gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170109093832</span><span class="number">-22d</span>885f9ecc7</span><br><span class="line"><span class="keyword">go</span>: downloading github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/ugorji/<span class="keyword">go</span>/codec v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20181022190402</span>-e5e69e061d4f</span><br><span class="line"><span class="keyword">go</span>: finding github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: downloading gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line"><span class="keyword">go</span>: downloading gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: finding gopkg.in/check.v1 v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20161208181325</span><span class="number">-20d</span>25e280405</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到 go compiler 主动下载了相关 package。</p><p>那么这些 package 被下载到了哪里呢，你打开 $GOPATH/pkg/mod 就可以看到了，另外 modules 是允许同 package 多种版本并存的。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="keyword">go</span>/pkg/mod</span><br><span class="line">├── cache</span><br><span class="line">│   ├── download</span><br><span class="line">│   │   ├── github.com</span><br><span class="line">│   │   └── gopkg.in</span><br><span class="line">│   └── vcs</span><br><span class="line">│       ├── <span class="number">37981</span>a5904034a62f98c21341f5422b08cc21ccf1bea734e2aafc91119af6c9b</span><br><span class="line">│       ├── <span class="number">37981</span>a5904034a62f98c21341f5422b08cc21ccf1bea734e2aafc91119af6c9b.info</span><br><span class="line">│       ├── <span class="number">3</span>cef6ea433a84771f272e076cd77b94bd94828b89b4ccd04fa8622bf2d5d3a3f</span><br><span class="line">│       ├── <span class="number">3</span>cef6ea433a84771f272e076cd77b94bd94828b89b4ccd04fa8622bf2d5d3a3f.info</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们看看执行 <code>go build</code> 后 go.mod 文件的内容：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module github.com/wangjiemin/mytest</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">  github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170109093832</span><span class="number">-22d</span>885f9ecc7 <span class="comment">// indirect</span></span><br><span class="line">  github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">  github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">  github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span> <span class="comment">// indirect</span></span><br><span class="line">  github.com/ugorji/<span class="keyword">go</span>/codec v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20181022190402</span>-e5e69e061d4f <span class="comment">// indirect</span></span><br><span class="line">  gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span> <span class="comment">// indirect</span></span><br><span class="line">  gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们看到 go modules 分析出了 mytest 的依赖，并将其放入 go.mod 的 require 区域。</p><blockquote><p>go modules 拉取 package 的原则是先拉取最新的 release tag，若无 tag 则拉最新 commit 并以 Pseudo-versions 的形式记录。<br>因为我们的 module 只直接依赖了 gin，其他的都是非直接依赖的，所以它们后边都被以注释形式标记了 indirect，即传递依赖。<br>go.mod 文件一旦创建后，它的内容将会被 go toolchain 全面掌控。go toolchain 会在各类命令执行时，比如 go get、go build、go mod 等修改和维护 go.mod 文件。</p></blockquote><p>同时发现目录下多了一个文件 go.sum<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170109093832</span><span class="number">-22d</span>885f9ecc7 h1:AzN37oI0cOS+cougNAV9szl6CVoj2RYwzS3DpUQNtlY=</span><br><span class="line">github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170109093832</span><span class="number">-22d</span>885f9ecc7/<span class="keyword">go</span>.mod h1:VJ0WA2NBN22VlZ2dKZQPAPnyWw5XTlK1KymzLKsr59s=</span><br><span class="line">github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span> h1:kCmZyPklC0gVdL728E6Aj20uYBJV93nj/TkwBTKhFbs=</span><br><span class="line">github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:<span class="number">7</span>cKuhb5qV2ggCFctp2fJQ+ErvciLZrIeoOSOm6mUr7Y=</span><br><span class="line">github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span> h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=</span><br><span class="line">github.com/golang/protobuf v1<span class="number">.2</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:<span class="number">6l</span>Qm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=</span><br><span class="line">github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span> h1:bnP0vzxcAdeI1zdubAl5PjU6zsERjGZb7raWodagDYs=</span><br><span class="line">github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.4</span>/<span class="keyword">go</span>.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=</span><br><span class="line">github.com/ugorji/<span class="keyword">go</span>/codec v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20181022190402</span>-e5e69e061d4f h1:y3Vj7GoDdcBkxFa2RUUFKM25TrBbWVDnjRDI0u975zQ=</span><br><span class="line">github.com/ugorji/<span class="keyword">go</span>/codec v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20181022190402</span>-e5e69e061d4f/<span class="keyword">go</span>.mod h1:VFNgLljTbGfSG7qAOspJ7OScBnGdDN/yBr0sguwnwf0=</span><br><span class="line">gopkg.in/check.v1 v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20161208181325</span><span class="number">-20d</span>25e280405/<span class="keyword">go</span>.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=</span><br><span class="line">gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span> h1:lFB4DoMU6B626w8ny76MV7VX6W2VHct2GVOI3xgiMrQ=</span><br><span class="line">gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span>/<span class="keyword">go</span>.mod h1:RX2a/<span class="number">7</span>Ha8BgOhfk7j780h4/u/RRjR0eouCJSH80/M2Y=</span><br><span class="line">gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span> h1:mUhvW9EsL+naU5Q3cakzfE91YhliOondGd6ZrsDBHQE=</span><br><span class="line">gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+<span class="number">5</span>A1VGuI=</span><br></pre></td></tr></tbody></table></figure><p></p><p>写过 node 的人应该会发现， <code>go.mod/go.sum</code> 的关系跟 <code>package.json/package-lock.json</code> 类似，前者定义 dependency root，后者将关系展开。</p><p>最后执行 <code>bin/main</code> 可以看到 Gin 很贴心的列出了 handler 所属的 package<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/main</span><br><span class="line">[GIN-debug] [WARNING] Now Gin requires Go <span class="number">1.6</span> or later and Go <span class="number">1.7</span> will be required soon.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running in <span class="string">"debug"</span> mode. Switch to <span class="string">"release"</span> mode in production.</span><br><span class="line"> - using env: export GIN_MODE=release</span><br><span class="line"> - using code: gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /health                   --> main.GetHealthHandler (<span class="number">3</span> handlers)</span><br><span class="line">[GIN-debug] GET    /health-dataapi           --> github.com/wangjiemin/mytest/pkg/api/data.GetDataAPIHealthHandler (<span class="number">3</span> handlers)</span><br></pre></td></tr></tbody></table></figure><p></p><p>到这里，一个 go modules 就完成了。</p><h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h4><p>Modules 是作为 experiment feature 加入到不久前正式发布的 Go 1.11 中的。</p><p>按照 Go 的惯例，在新的 experiment feature 首次加入时，都会有一个特性开关，go modules 也不例外，<code>GO111MODULE</code> 这个临时的环境变量就是 go modules 特性的 experiment 开关。</p><ul><li>off: go modules experiment feature 关闭，go compiler 会始终使用 GOPATH mode，即无论要构建的源码目录是否在 GOPATH 路径下，go compiler 都会在传统的 GOPATH 和 vendor 目录 (仅支持在 GOPATH 目录下的 package) 下搜索目标程序依赖的 go package；</li><li>on: 始终使用 module-aware mode，只根据 go.mod 下载 dependency 而完全忽略 GOPATH 以及 vendor 目录</li></ul><ul><li>auto: Golang 1.11 预设值，使用 GOPATH mode 还是 module-aware mode，取决于要构建的源码目录所在位置以及是否包含 go.mod 文件。满足任一条件时才使用 module-aware mode:<ul><li>当前目录位于 GOPATH/src 之外并且包含 go.mod 文件</li><li>当前目录位于包含 go.mod 文件的目录下    </li></ul></li></ul><p><code>go mod</code> 命令<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">download    download modules to local cache (下载依赖的 modules 到本地 cache)</span><br><span class="line">edit        edit <span class="keyword">go</span>.mod from tools or scripts (编辑 <span class="keyword">go</span>.mod 文件)</span><br><span class="line">graph       <span class="built_in">print</span> module requirement graph (打印模块依赖图)</span><br><span class="line">init        initialize <span class="built_in">new</span> module in current directory (再当前文件夹下初始化一个新的 module, 创建 <span class="keyword">go</span>.mod 文件)</span><br><span class="line">tidy        add missing and remove unused modules (增加丢失的 modules，去掉未用的 modules)</span><br><span class="line">vendor      <span class="built_in">make</span> vendored <span class="built_in">copy</span> of dependencies (将依赖复制到 vendor 下)</span><br><span class="line">verify      verify dependencies have expected content (校验依赖)</span><br><span class="line">why         explain why packages or modules are needed (解释为什么需要依赖)</span><br></pre></td></tr></tbody></table></figure><p></p><p>看这些命令的帮助已经比较容易了解命令的功能。</p><h4 id="既有项目"><a href="#既有项目" class="headerlink" title="既有项目"></a>既有项目</h4><p>假设你已经有了一个 go 项目， 比如在<code>$GOPATH/github.com/wangjiemim/mytest</code>下， 你可以使用<code>go mod init github.com/wangjiemim/mytest</code>在这个文件夹下创建一个空的 go.mod (只有第一行 <code>module github.com/wangjiemim/mytest</code>)。</p><p>然后你可以通过 <code>go get ./...</code>让它查找依赖，并记录在 go.mod 文件中 (你还可以指定 <code>-tags</code>, 这样可以把 tags 的依赖都查找到)。</p><p>通过<code>go mod tidy</code>也可以用来为 go.mod 增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理<code>tags</code>。</p><p>执行上面的命令会把 go.mod 的<code>latest</code>版本换成实际的最新的版本，并且会生成一个go.sum记录每个依赖库的版本和哈希值。</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>在国内访问<code>golang.org/x</code>的各个包都需要梯子，你可以在 go.mod 中使用<code>replace</code>替换成 github 上对应的库。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">  golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614d</span>502a4dac => github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614d</span>502a4dac</span><br><span class="line">  golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180821023952</span><span class="number">-922f</span>4815f713 => github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180826012351</span><span class="number">-8</span>a410e7b638d</span><br><span class="line">  golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> => github.com/golang/text v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p><p>依赖库中的<code>replac</code>e对你的主 go.mod 不起作用，比如<code>github.com/wangjiemin/mytest</code>的 go.mod 已经增加了<code>replace</code>, 但是你的 go.mod 虽然<code>require</code>了<code>rpcx</code>的库，但是没有设置<code>replace</code>的话， <code>go get</code>还是会访问<code>golang.org/x</code>。</p><p>所以如果想编译那个项目，就在哪个项目中增加<code>replace</code>。</p><h4 id="包的版本控制"><a href="#包的版本控制" class="headerlink" title="包的版本控制"></a>包的版本控制</h4><p>下面的版本都是合法的：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gopkg.in/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20141024135613</span>-dd632973f1e7</span><br><span class="line">gopkg.in/vmihailenco/msgpack.v2 v2<span class="number">.9</span><span class="number">.1</span></span><br><span class="line">gopkg.in/yaml.v2 <=v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line">github.com/tatsushid/<span class="keyword">go</span>-fastping v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20160109021039</span>-d7bb493dee3e</span><br><span class="line">latest</span><br></pre></td></tr></tbody></table></figure><p></p><p>版本号遵循如下规律：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vX.Y.Z-pre<span class="number">.0</span>.yyyymmddhhmmss-abcdefabcdef</span><br><span class="line">vX<span class="number">.0</span><span class="number">.0</span>-yyyymmddhhmmss-abcdefabcdef</span><br><span class="line">vX.Y.(Z+<span class="number">1</span>)<span class="number">-0.</span>yyyymmddhhmmss-abcdefabcdef</span><br><span class="line">vX.Y.Z</span><br></pre></td></tr></tbody></table></figure><p></p><p>也就是版本号 + 时间戳 + hash，我们自己指定版本时只需要制定版本号即可，没有版本 tag 的则需要找到对应 commit 的时间和 hash 值。</p><p>另外版本号是支持 query 表达式的，其求值算法是 “选择最接近于比较目标的版本 (tagged version)”，即上文中的 gopkg.in/yaml.v2 会找不高于 v2.2.1 的最高版本。</p><p>对于复杂的包依赖场景，可以参考 Russ Cox 在 <a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">“Minimal Version Selection”</a> 一文中给出的形象的算法解释 (注意：这个算法仅是便于人类理解，但是性能低下，真正的实现并非按照这个算法实现)。</p><h4 id="go-get-升级"><a href="#go-get-升级" class="headerlink" title="go get 升级"></a>go get 升级</h4><ul><li>运行 <code>go get -u</code> 将会升级到最新的次要版本或者修订版本 (x.y.z，z 是修订版本号， y 是次要版本号)</li><li>运行 <code>go get -u=patch</code> 将会升级到最新的修订版本</li><li>运行 <code>go get package@version</code> 将会升级到指定的版本号<code>version</code></li></ul><h4 id="go-modules-与-vendor"><a href="#go-modules-与-vendor" class="headerlink" title="go modules 与 vendor"></a>go modules 与 vendor</h4><p>在最初的设计中，Russ Cox 是想彻底废除掉 vendor 的，但在社区的反馈下，vendor 得以保留，这也是为了兼容 Go 1.11 之前的版本。</p><p>Go modules 支持通过<code>go mod vendor</code>命令将某个 module 的所有依赖保存一份 copy 到 root module dir 的 vendor 下，然后在构建的使用<code>go build -mod=vendor</code>即可忽略 cache 里的包而只使用 vendor 目录里的版本。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本 2.0.0 | Semantic Versioning</a></li><li><a href="https://golang.google.cn/cmd/go/#hdr-Module_maintenance" target="_blank" rel="noopener">go - The Go Programming Language</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Modules · golang/go Wiki · GitHub</a></li><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules – Roberto Selbach</a></li><li><a href="https://tonybai.com/2018/07/15/hello-go-module/" target="_blank" rel="noopener">初窥 Go module | Tony Bai</a></li><li><a href="https://www.lightblue.asia/golang-1-11-new-festures-modules/" target="_blank" rel="noopener">Golang 1.11 新功能介紹 - Modules - LightBlue Essay</a></li><li><a href="https://gocn.vip/article/957" target="_blank" rel="noopener">Golang modules 初探 - Go 中国技术社区 - golang</a></li><li><a href="https://colobu.com/2018/08/27/learn-go-module/" target="_blank" rel="noopener">跳出 Go module 的泥潭 | 鸟窝</a></li><li><a href="https://windmt.com/2018/11/08/first-look-go-modules/" target="_blank" rel="noopener">Go 包管理解决之道 —— Modules 初试</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>masterha-master-switch 参数详解</title>
      <link href="/2019/03/28/masterha-master-switch/"/>
      <url>/2019/03/28/masterha-master-switch/</url>
      
        <content type="html"><![CDATA[<h4 id="MHA-命令-masterha-master-switch"><a href="#MHA-命令-masterha-master-switch" class="headerlink" title="MHA 命令 masterha_master_switch"></a>MHA 命令 <a href="https://github.com/yoshinorim/mha4mysql-manager/wiki/masterha_master_switch" target="_blank" rel="noopener">masterha_master_switch</a></h4><p>常用参数介绍<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">--master_state=dead</span><br><span class="line">    强制的参数，参数值为<span class="string">"dead"</span> 或者 <span class="string">"alive"</span> . 如果 设置为 alive 模式，masterha_master_switch 开始在线主库切换操作。</span><br><span class="line"> </span><br><span class="line">--dead_master_host=(hostname)</span><br><span class="line">    强制参数，宕机的主库所在的主机名称。--dead_master_ip 和 --dead_master_port 是可选参数，如果这些参数没有设置，--dead_master_ip 就是 --dead_master_host 解析的IP地址。--dead_master_port 为 3306</span><br><span class="line"> </span><br><span class="line">--new_master_host=(hostname)</span><br><span class="line">    新主机地址，可选参数，这个参数在你明确新的主库的主机，非常有用。(这就意味着你不需要让MHA来决定新的主库)。如果不设置此参数，MHA 将会利用自动failover的规则来选择新的主库。如果设置--new_master_host，MHA选择此主机为新的主库，如果不能成为主库，MHA将会退出</span><br><span class="line"> </span><br><span class="line">--interactive=(0|1)</span><br><span class="line">    如果设置为0，在masterha_master_switch，它自动执行故障转移(非交互式)。这实际上是和masterha_manager的内部运行机制一样，这种非交互式故障转移是有用的，如果你已经证实了master死了,但你想尽快做故障转移。非交互式故障转移也是有用的,如果你使用其他现有的主监控软件和要调用的非交互式故障转移命令软件。典型的例子是masterha_master_switch调用从集群软件像起搏器。</span><br><span class="line"> </span><br><span class="line">--ssh_reachable=(0|1|2)</span><br><span class="line">    指定master 经过SSH是否可达。0:不可达、1:可达、2:未知(默认值)。 如果设置为了2，此命令内部将会检测通过SSH 是否可达master，并且跟新SSH 状态。如果可达，且设置master_ip_failover_script 或者 shutdown_script .将会执行<span class="string">"--command=stopssh"</span>。否则，执行 <span class="string">"--command=stop"</span>。另外，如果宕机的master通过SSH可达，failover脚本试图从宕机的master机器上拷贝没有没有发送的binlog。</span><br><span class="line"> </span><br><span class="line">--skip_change_master</span><br><span class="line">    如果设置此参数，当发生failover的时候，MAH 在应用完不同的relay <span class="built_in">log</span>退出，忽略CHANGE MASTER 和 START SLAVE 操作。所以 slaves 不会指向 新的master. 开启此参数，有利于手动的二次检查slave 恢复是否成功</span><br><span class="line"> </span><br><span class="line">--skip_disable_read_only</span><br><span class="line">    设置此参数，MHA 将不会在新的主库上执行 SET GLOBAL read_only =0 操作，有利于手动操作</span><br><span class="line"> </span><br><span class="line">--last_failover_minute=(minutes)</span><br><span class="line">    参考master_manager </span><br><span class="line"> </span><br><span class="line">--ignore_last_failover</span><br><span class="line">    参考master_manager</span><br><span class="line"> </span><br><span class="line">--wait_on_failover_error=(seconds)</span><br><span class="line">    类似于master_manager, 此参数只用于自动的/非交互式的failover。如果没有设置--interval=0，wait_on_failover_error 将会被忽略，在发生错误的时候不会sleep。</span><br><span class="line"> </span><br><span class="line">--remove_dead_master_conf</span><br><span class="line">    参考masterha_manager</span><br><span class="line"> </span><br><span class="line">--wait_until_gtid_in_sync(0|1)</span><br><span class="line">    此参数从0.56版本开始可用，如果设置成1，当基于GITD的failover时,MHA 会等待所有的从库追上新主库的GITD</span><br><span class="line"> </span><br><span class="line">--skip_change_master</span><br><span class="line">    此参数从0.56版本开始可用，如果开启此选项，MHA 跳过 CHANGE MASTER 的操作</span><br><span class="line"> </span><br><span class="line">--skip_disable_read_only</span><br><span class="line">    此参数从0.56版本开始可用，如果开启此选项，MHA 将会在新的master 跳过 SET GLOBAL read_only = 0;</span><br><span class="line"> </span><br><span class="line">--ignore_binlog_server_error</span><br><span class="line">    此参数从0.56版本开始可用，如果开启此选项，当执行failover的时，MHA忽略binlog server上任何错误</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="主在线切换时相关参数"><a href="#主在线切换时相关参数" class="headerlink" title="主在线切换时相关参数"></a>主在线切换时相关参数</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--new_master_host=(hostname)</span><br><span class="line">    新主机地址，可选参数，这个参数在你明确新的主库的主机，非常有用。(这就意味着你不需要让MHA来决定新的主库)。如果不设置此参数，MHA 将会利用自动failover的规则来选择新的主库。如果设置--new_master_host，MHA选择此主机为新的主库，如果不能成为主库，MHA将会退出</span><br><span class="line"> </span><br><span class="line">--orig_master_is_new_slave</span><br><span class="line">    当完成主库切换后，原先的主库将作为现在主库的slave运行。默认:不开启(原先的主库不会加入到新的复制环境中)。如果开启此选项，需要在配置文件中设置repl_password参数，由于当期的Master并不知道新的Master的replication的密码</span><br><span class="line"> </span><br><span class="line">--remove_orig_master_conf</span><br><span class="line">    如果设置此参数，当成功failover后，MHA manager将会自动删除配置文件中关于dead master的配置选项。</span><br><span class="line"> </span><br><span class="line">--skip_lock_all_tables</span><br><span class="line">    当在做主库切换的时候，MHA会在原先的主库上执行FLUSH TABLES WITH READ LOCK 操作，确保没有跟新操作，但是FLUSH TABLES WITH READ LOCK 操作是非常耗费资源的，并且你可以在原先的主库确定没有跟新操作(通过master_ip_online_change_script 中<span class="built_in">kill</span> all clients操作等)。可以利用此选项避免锁表。</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MHA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MHA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MHA 故障切换演练 --- masterha_master_switch</title>
      <link href="/2019/03/28/mha-switch/"/>
      <url>/2019/03/28/mha-switch/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天公司要进行线上MHA高可用集群故障切换演练。由于我刚入职公司。公司还没有做过太多的灾难级别的故障演练。</p><h5 id="我写了一些步骤："><a href="#我写了一些步骤：" class="headerlink" title="我写了一些步骤："></a>我写了一些步骤：</h5><h6 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h6><ol><li>查看主从延迟状态</li><li>登录MHA中控机，查看演练切换的数据库MHA log文件，使用tail -f 命令来获取切换的log日志信息</li><li>登录master机器，执行 /etc/init.d/mysql stop</li><li>查看MHA中控机日志信息。</li><li>切换成功，登录到 new_master 中查看vip是否已经绑定到网卡上</li><li>登录slave，查看 show slave status 是否已经change master to new_master ip上，查看slave正常与否</li><li>在 MHA 中控机启动 masterha_manager 进程，查看MHA集群启动是否正常。(两节点)<br>结构图：<br>new_master: (master)<br>—> slave: (slave)</li></ol><h6 id="master-数据库恢复"><a href="#master-数据库恢复" class="headerlink" title="master 数据库恢复"></a>master 数据库恢复</h6><ol><li>登录到old_master 机器上执行 /etc/init.d/mysql start 是否正常启动服务</li><li>在MHA中控机中获取切换的log 日志信息找出 change master to new_master 信息语句</li><li>在old_master 中执行change master to 语句，变为 new_master的slave</li><li>show slave status 查看 old_master 是否正常变为 new_master 的slave</li><li>在MHA 中控机节点，执行 masterha_stop 命令结束 masterha_manager进程。</li><li>在MHA 中控机启动 masterha_manager 进程，查看恢复好的old_master是否正常加入到MHA节点 (三节点）<br>结构图：<br>new_master: (master)<br>—> old_master: (slave)<br>—> slave: (slave)</li></ol><h6 id="恢复-old-master为-master-角色"><a href="#恢复-old-master为-master-角色" class="headerlink" title="恢复 old_master为 master 角色"></a>恢复 old_master为 master 角色</h6><ol><li>查看主从延迟状态</li><li>登录MHA中控机，查看演练切换的数据库MHA log文件，使用tail -f 命令来获取切换的log日志信息</li><li>登录new_master机器，执行 /etc/init.d/mysql stop</li><li>查看MHA中控机日志信息。</li><li>切换成功，登录到 old_master 中查看vip是否已经绑定到网卡上</li><li>登录slave，查看 show slave status 是否已经change master to old_master ip上，查看slave正常与否</li><li>在 MHA 中控机启动 masterha_manager 进程，查看MHA集群启动是否正常。(两节点)<br>结构图：<br>master(old_master): (master)<br>—> slave(new_master): (slave)<br>—> slave: (slave)</li></ol><h5 id="但是这么操作虽然能更贴近真实灾难-暂时没有把主从数据延迟考虑进入-，需要的时间会更多。领导建议手动操作MHA-failover测试能不能切换。"><a href="#但是这么操作虽然能更贴近真实灾难-暂时没有把主从数据延迟考虑进入-，需要的时间会更多。领导建议手动操作MHA-failover测试能不能切换。" class="headerlink" title="但是这么操作虽然能更贴近真实灾难(暂时没有把主从数据延迟考虑进入)，需要的时间会更多。领导建议手动操作MHA failover测试能不能切换。"></a>但是这么操作虽然能更贴近真实灾难(暂时没有把主从数据延迟考虑进入)，需要的时间会更多。领导建议手动操作MHA failover测试能不能切换。</h5><h2 id="服务器架构"><a href="#服务器架构" class="headerlink" title="服务器架构"></a>服务器架构</h2><table><thead><tr><th style="text-align:center">server</th><th style="text-align:center">role</th></tr></thead><tbody><tr><td style="text-align:center">master</td><td style="text-align:center">old_master</td></tr><tr><td style="text-align:center">slave</td><td style="text-align:center">new_master</td></tr><tr><td style="text-align:center">slave</td><td style="text-align:center">slave</td></tr></tbody></table><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>在MHA 中控机中执行命令<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># masterha_check_repl --conf=/root/dba/mha/conf/babybi_#1.conf</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Wed Mar 27 23:28:28 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Reading application default configuration from /root/dba/mha/conf/babybi_<span class="comment">#1.conf..</span></span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Reading server configuration from /root/dba/mha/conf/babybi_<span class="comment">#1.conf..</span></span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] MHA::MasterMonitor version 0.56.</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] GTID failover mode = 0</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Dead Servers:</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Alive Servers:</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.67(10.25.1.67:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.68(10.25.1.68:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Alive Slaves:</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.67(10.25.1.67:3306)  Version=5.6.29-76.2-log (oldest major version between slaves) <span class="built_in">log</span>-bin:enabled</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]     Replicating from 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]     Primary candidate <span class="keyword">for</span> the new Master (candidate_master is <span class="built_in">set</span>)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]   10.25.1.68(10.25.1.68:3306)  Version=5.6.29-76.2-log (oldest major version between slaves) <span class="built_in">log</span>-bin:enabled</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]     Replicating from 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Current Alive Master: 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Checking slave configurations..</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [warning]  relay_log_purge=0 is not <span class="built_in">set</span> on slave 10.25.1.67(10.25.1.67:3306).</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [warning]  relay_log_purge=0 is not <span class="built_in">set</span> on slave 10.25.1.68(10.25.1.68:3306).</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Checking replication filtering settings..</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]  binlog_do_db= , binlog_ignore_db= </span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info]  Replication filtering check ok.</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] GTID (with auto-pos) is not supported</span><br><span class="line">Wed Mar 27 23:28:28 2019 - [info] Starting SSH connection tests..</span><br><span class="line">Wed Mar 27 23:28:29 2019 - [info] All SSH connection tests passed successfully.</span><br><span class="line">Wed Mar 27 23:28:29 2019 - [info] Checking MHA Node version..</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info]  Version check ok.</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info] Checking SSH publickey authentication settings on the current master..</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info] HealthCheck: SSH to 10.25.1.66 is reachable.</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info] Master MHA Node version is 0.56.</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info] Checking recovery script configurations on 10.25.1.66(10.25.1.66:3306)..</span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info]   Executing <span class="built_in">command</span>: save_binary_logs --<span class="built_in">command</span>=<span class="built_in">test</span> --start_pos=4 --binlog_dir=/<span class="built_in">log</span>/mysql/binlog/ --output_file=/var/tmp/save_binary_logs_test --manager_version=0.56 --start_file=mysql-bin.004691 </span><br><span class="line">Wed Mar 27 23:28:30 2019 - [info]   Connecting to root@10.25.1.66(10.25.1.66:22).. </span><br><span class="line">  Creating /var/tmp <span class="keyword">if</span> not exists..    ok.</span><br><span class="line">  Checking output directory is accessible or not..</span><br><span class="line">   ok.</span><br><span class="line">  Binlog found at /<span class="built_in">log</span>/mysql/binlog/, up to mysql-bin.004691</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Binlog setting check <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   Executing <span class="built_in">command</span> : apply_diff_relay_logs --<span class="built_in">command</span>=<span class="built_in">test</span> --slave_user=<span class="string">'mha'</span> --slave_host=10.25.1.67 --slave_ip=10.25.1.67 --slave_port=3306 --workdir=/var/tmp --target_version=5.6.29-76.2-log --manager_version=0.56 --relay_log_info=/my/data/percona/relay-log.info  --relay_dir=/my/data/percona/  --slave_pass=xxx</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   Connecting to root@10.25.1.67(10.25.1.67:22).. </span><br><span class="line">  Checking slave recovery environment settings..</span><br><span class="line">    Opening /my/data/percona/relay-log.info ... ok.</span><br><span class="line">    Relay <span class="built_in">log</span> found at /<span class="built_in">log</span>/mysql/relaylog, up to relay-log.014072</span><br><span class="line">    Temporary relay <span class="built_in">log</span> file is /<span class="built_in">log</span>/mysql/relaylog/relay-log.014072</span><br><span class="line">    Testing mysql connection and privileges..Warning: Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line"> <span class="keyword">done</span>.</span><br><span class="line">    Testing mysqlbinlog output.. <span class="keyword">done</span>.</span><br><span class="line">    Cleaning up <span class="built_in">test</span> file(s).. <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   Executing <span class="built_in">command</span> : apply_diff_relay_logs --<span class="built_in">command</span>=<span class="built_in">test</span> --slave_user=<span class="string">'mha'</span> --slave_host=10.25.1.68 --slave_ip=10.25.1.68 --slave_port=3306 --workdir=/var/tmp --target_version=5.6.29-76.2-log --manager_version=0.56 --relay_log_info=/my/data/percona/relay-log.info  --relay_dir=/my/data/percona/  --slave_pass=xxx</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   Connecting to root@10.25.1.68(10.25.1.68:22).. </span><br><span class="line">  Checking slave recovery environment settings..</span><br><span class="line">    Opening /my/data/percona/relay-log.info ... ok.</span><br><span class="line">    Relay <span class="built_in">log</span> found at /<span class="built_in">log</span>/mysql/relaylog, up to relay-log.014072</span><br><span class="line">    Temporary relay <span class="built_in">log</span> file is /<span class="built_in">log</span>/mysql/relaylog/relay-log.014072</span><br><span class="line">    Testing mysql connection and privileges..Warning: Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line"> <span class="keyword">done</span>.</span><br><span class="line">    Testing mysqlbinlog output.. <span class="keyword">done</span>.</span><br><span class="line">    Cleaning up <span class="built_in">test</span> file(s).. <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Slaves settings check <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] </span><br><span class="line">10.25.1.66(10.25.1.66:3306) (current master)</span><br><span class="line"> +--10.25.1.67(10.25.1.67:3306)</span><br><span class="line"> +--10.25.1.68(10.25.1.68:3306)</span><br><span class="line"></span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Checking replication health on 10.25.1.67..</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Checking replication health on 10.25.1.68..</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Checking master_ip_failover_script status:</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]   /root/dba/mha/script/master_ip_failover.sh --<span class="built_in">command</span>=status --ssh_user=root --orig_master_host=10.25.1.66 --orig_master_ip=10.25.1.66 --orig_master_port=3306 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IN SCRIPT TEST====/etc/init.d/keepalived stop==/etc/init.d/keepalived start===</span><br><span class="line"></span><br><span class="line">Checking the Status of the script.. OK </span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info]  OK.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [warning] shutdown_script is not defined.</span><br><span class="line">Wed Mar 27 23:28:31 2019 - [info] Got <span class="built_in">exit</span> code 0 (Not master dead).</span><br><span class="line"></span><br><span class="line">MySQL Replication Health is OK.</span><br></pre></td></tr></tbody></table></figure><p>执行 masterha_master_switch 命令<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># masterha_master_switch --conf=/root/dba/mha/conf/babybi_#1.conf --master_state=alive --new_master_host=10.25.1.67 --new_master_port=3306 --orig_master_is_new_slave --running_updates_limit=10000</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">Wed Mar 27 23:34:27 2019 - [info] MHA::MasterRotate version 0.56.</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Starting online master switch..</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] </span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] * Phase 1: Configuration Check Phase..</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] </span><br><span class="line">Wed Mar 27 23:34:27 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Reading application default configuration from /root/dba/mha/conf/babybi_<span class="comment">#1.conf..</span></span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Reading server configuration from /root/dba/mha/conf/babybi_<span class="comment">#1.conf..</span></span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] GTID failover mode = 0</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Current Alive Master: 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info] Alive Slaves:</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]   10.25.1.67(10.25.1.67:3306)  Version=5.6.29-76.2-log (oldest major version between slaves) <span class="built_in">log</span>-bin:enabled</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]     Replicating from 10.25.1.66(10.25.1.66:3306)</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]     Primary candidate <span class="keyword">for</span> the new Master (candidate_master is <span class="built_in">set</span>)</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]   10.25.1.68(10.25.1.68:3306)  Version=5.6.29-76.2-log (oldest major version between slaves) <span class="built_in">log</span>-bin:enabled</span><br><span class="line">Wed Mar 27 23:34:27 2019 - [info]     Replicating from 10.25.1.66(10.25.1.66:3306)</span><br><span class="line"></span><br><span class="line">It is better to execute FLUSH NO_WRITE_TO_BINLOG TABLES on the master before switching. Is it ok to execute on 10.25.1.66(10.25.1.66:3306)? (YES/no): ---> 输入: yes</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] Executing FLUSH NO_WRITE_TO_BINLOG TABLES. This may take long time..</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] Checking MHA is not monitoring or doing failover..</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] Checking replication health on 10.25.1.67..</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] Checking replication health on 10.25.1.68..</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] 10.25.1.67 can be new master.</span><br><span class="line">Wed Mar 27 23:34:34 2019 - [info] </span><br><span class="line">From:</span><br><span class="line">10.25.1.66(10.25.1.66:3306) (current master)</span><br><span class="line"> +--10.25.1.67(10.25.1.67:3306)</span><br><span class="line"> +--10.25.1.68(10.25.1.68:3306)</span><br><span class="line"></span><br><span class="line">To:</span><br><span class="line">10.25.1.67(10.25.1.67:3306) (new master)</span><br><span class="line"> +--10.25.1.68(10.25.1.68:3306)</span><br><span class="line"> +--10.25.1.66(10.25.1.66:3306)</span><br><span class="line"></span><br><span class="line">Starting master switch from 10.25.1.66(10.25.1.66:3306) to 10.25.1.67(10.25.1.67:3306)? (yes/NO): ---> 输入: yes</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] Checking whether 10.25.1.67(10.25.1.67:3306) is ok <span class="keyword">for</span> the new master..</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] 10.25.1.66(10.25.1.66:3306): SHOW SLAVE STATUS returned empty result. To check replication filtering rules, temporarily executing CHANGE MASTER to a dummy host.</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] 10.25.1.66(10.25.1.66:3306): Resetting slave pointing to the dummy host.</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] ** Phase 1: Configuration Check Phase completed.</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] </span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] * Phase 2: Rejecting updates Phase..</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] </span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info] Executing master ip online change script to <span class="built_in">disable</span> write on the current master:</span><br><span class="line">Wed Mar 27 23:34:37 2019 - [info]   /root/dba/mha/script/master_ip_online_change.sh --<span class="built_in">command</span>=stop --orig_master_host=10.25.1.66 --orig_master_ip=10.25.1.66 --orig_master_port=3306 --orig_master_user=<span class="string">'mha'</span> --orig_master_password=<span class="string">'mhapassword'</span> --new_master_host=10.25.1.67 --new_master_ip=10.25.1.67 --new_master_port=3306 --new_master_user=<span class="string">'mha'</span> --new_master_password=<span class="string">'mhapassword'</span> --orig_master_ssh_user=root --new_master_ssh_user=root   --orig_master_is_new_slave</span><br><span class="line">2019-03-27 23:34:38 set_mysql_read_only successful!</span><br><span class="line">Stopping keepalived: [  OK  ]</span><br><span class="line">2019-03-27 23:34:38 stop_keepalived successful!</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info] Locking all tables on the orig master to reject updates from everybody (including root):</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info] Executing FLUSH TABLES WITH READ LOCK..</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]  ok.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info] Orig master binlog:pos is mysql-bin.004691:854373586.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]  Waiting to execute all relay logs on 10.25.1.67(10.25.1.67:3306)..</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]  master_pos_wait(mysql-bin.004691:854373586) completed on 10.25.1.67(10.25.1.67:3306). Executed 0 events.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info]   <span class="keyword">done</span>.</span><br><span class="line">Wed Mar 27 23:34:38 2019 - [info] Getting new master<span class="string">'s binlog name and position..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  mysql-bin.000001:120</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  All other slaves should start replication from here. Statement should be: CHANGE MASTER TO MASTER_HOST='</span>10.25.1.67<span class="string">', MASTER_PORT=3306, MASTER_LOG_FILE='</span>mysql-bin.000001<span class="string">', MASTER_LOG_POS=120, MASTER_USER='</span>repl<span class="string">', MASTER_PASSWORD='</span>xxx<span class="string">';</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] Executing master ip online change script to allow write on the new master:</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]   /root/dba/mha/script/master_ip_online_change.sh --command=start --orig_master_host=10.25.1.66 --orig_master_ip=10.25.1.66 --orig_master_port=3306 --orig_master_user='</span>mha<span class="string">' --orig_master_password='</span>mhapassword<span class="string">' --new_master_host=10.25.1.67 --new_master_ip=10.25.1.67 --new_master_port=3306 --new_master_user='</span>mha<span class="string">' --new_master_password='</span>mhapassword<span class="string">' --orig_master_ssh_user=root --new_master_ssh_user=root   --orig_master_is_new_slave</span></span><br><span class="line"><span class="string">Starting keepalived: [  OK  ]</span></span><br><span class="line"><span class="string">2019-03-27 23:34:38 start_keepalived successful!</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  ok.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] Setting read_only=0 on 10.25.1.67(10.25.1.67:3306)..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  ok.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] * Switching slaves in parallel..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] -- Slave switch on host 10.25.1.68(10.25.1.68:3306) started, pid: 20673</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info] Log messages from 10.25.1.68 ...</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  Waiting to execute all relay logs on 10.25.1.68(10.25.1.68:3306)..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  master_pos_wait(mysql-bin.004691:854373586) completed on 10.25.1.68(10.25.1.68:3306). Executed 0 events.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]   done.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  Resetting slave 10.25.1.68(10.25.1.68:3306) and starting replication from the new master 10.25.1.67(10.25.1.67:3306)..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  Executed CHANGE MASTER.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:38 2019 - [info]  Slave started.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] End of log messages from 10.25.1.68 ...</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] -- Slave switch on host 10.25.1.68(10.25.1.68:3306) succeeded.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] Unlocking all tables on the orig master:</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] Executing UNLOCK TABLES..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  ok.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] Starting orig master as a new slave..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  Resetting slave 10.25.1.66(10.25.1.66:3306) and starting replication from the new master 10.25.1.67(10.25.1.67:3306)..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  Executed CHANGE MASTER.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  Slave started.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] All new slave servers switched successfully.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] * Phase 5: New master cleanup phase..</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] </span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info]  10.25.1.67: Resetting slave info succeeded.</span></span><br><span class="line"><span class="string">Wed Mar 27 23:34:39 2019 - [info] Switching master to 10.25.1.67(10.25.1.67:3306) completed successfully.</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -ef|grep babybi_#1.conf</span></span><br><span class="line">root      3578     1  0 Jan08 ?        00:42:35 perl /usr/bin/masterha_manager --conf=/root/dba/mha/conf/babybi_<span class="comment">#1.conf --ignore_last_failover</span></span><br><span class="line">root     21082 17518  0 23:35 pts/0    00:00:00 grep --colour=auto babybi_<span class="comment">#1.conf</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>到new_master机器中查看VIP有没有绑定过来到网卡上<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip a</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: em1: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc mq master bond0 state UP qlen 1000</span><br><span class="line">    link/ether 24:6e:96:13:61:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: em2: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc mq master bond0 state UP qlen 1000</span><br><span class="line">    link/ether 24:6e:96:13:61:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: em3: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether 24:6e:96:13:61:34 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: em4: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether 24:6e:96:13:61:35 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: bond0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP </span><br><span class="line">    link/ether 24:6e:96:13:61:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.25.1.67/24 brd 10.25.1.255 scope global bond0</span><br><span class="line">    inet 10.25.1.203/32 scope global bond0</span><br><span class="line">    inet6 fe80::266e:96ff:fe13:6130/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></tbody></table></figure><p>登录到slave机器上<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">mysql> show slave status\G</span><br><span class="line">ERROR 2006 (HY000): MySQL server has gone away</span><br><span class="line">No connection. Trying to reconnect...</span><br><span class="line">Connection id:    2049252955</span><br><span class="line">Current database: *** NONE ***</span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">                  Master_Host: 10.25.1.67</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 62528</span><br><span class="line">               Relay_Log_File: relay-log.000002</span><br><span class="line">                Relay_Log_Pos: 62691</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 62528</span><br><span class="line">              Relay_Log_Space: 62858</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1673306</span><br><span class="line">                  Master_UUID: ca479c32-fa0d-11e8-bc0f-246e96136130</span><br><span class="line">             Master_Info_File: /my/data/percona/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has <span class="built_in">read</span> all relay <span class="built_in">log</span>; waiting <span class="keyword">for</span> the slave I/O thread to update it</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql></span><br></pre></td></tr></tbody></table></figure><p></p><p>正常 CHANGE MASTER TO NEW_MASTER </p><p>登录到old_master中查看<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql> show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">                  Master_Host: 10.25.1.67</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 66875</span><br><span class="line">               Relay_Log_File: relay-log.000002</span><br><span class="line">                Relay_Log_Pos: 67038</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 66875</span><br><span class="line">              Relay_Log_Space: 67205</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1673306</span><br><span class="line">                  Master_UUID: ca479c32-fa0d-11e8-bc0f-246e96136130</span><br><span class="line">             Master_Info_File: /my/data/percona/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has <span class="built_in">read</span> all relay <span class="built_in">log</span>; waiting <span class="keyword">for</span> the slave I/O thread to update it</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql></span><br></pre></td></tr></tbody></table></figure><p></p><p>到new_master上查看<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep keepalived</span><br><span class="line">root     37477     1  0 23:41 ?        00:00:00 /usr/sbin/keepalived -D</span><br><span class="line">root     37478 37477  0 23:41 ?        00:00:00 /usr/sbin/keepalived -D</span><br><span class="line">root     37479 37477  0 23:41 ?        00:00:00 /usr/sbin/keepalived -D</span><br><span class="line">dbctl    38747 35598  0 23:49 pts/0    00:00:00 grep --colour=auto keepalived</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="在切换回来到old-master提成为master"><a href="#在切换回来到old-master提成为master" class="headerlink" title="在切换回来到old_master提成为master"></a>在切换回来到old_master提成为master</h5><p>步骤按照上面操作，就不重复搬砖了。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>MHA 高可用集群切换成功，虽然是手动MHA failover测试，并不能代表MHA的高可用。以后还会按照上面缩写的步骤在加上一定的主从数据同步延迟来进行演练。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MHA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MHA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS Install git Source</title>
      <link href="/2019/03/25/git-install/"/>
      <url>/2019/03/25/git-install/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://git-scm.com" target="_blank" rel="noopener">Git</a></p><p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">官方文档</a></p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许上千个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>git 源码安装。<a href="https://github.com/git/git/archive/v2.21.0.zip" target="_blank" rel="noopener">下载源码</a><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://github.com/git/git/archive/v2.21.0.zip</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>解压缩<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tar zxvf v2.21.0.zip</span></span><br><span class="line"><span class="comment"># cd git-2.20.1</span></span><br><span class="line"></span><br><span class="line">编译命令如下</span><br><span class="line"><span class="comment"># # make prefix=/usr/local/git all</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>如果遇到该错误</p><img src="/2019/03/25/git-install/giterror.jpg" title="giterror"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.h:6:23: warning: curl/curl.h: No such file or directory</span><br><span class="line">http.h:7:23: warning: curl/easy.h: No such file or directory</span><br><span class="line">……</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行命令</span><br><span class="line"><span class="comment"># yum install -y curl curl-devel</span></span><br></pre></td></tr></tbody></table></figure><p>重新执行编译命令</p><p>发现编译报错</p><img src="/2019/03/25/git-install/giterror2.jpg" title="giterror2"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    CC http.o</span><br><span class="line">    CC http-walker.o</span><br><span class="line">    CC http-fetch.o</span><br><span class="line">    LINK git-http-fetch</span><br><span class="line">    CC http-push.o</span><br><span class="line">http-push.c:22:19: warning: expat.h: No such file or directory</span><br><span class="line">http-push.c:830: warning: <span class="built_in">type</span> defaults to ‘int’ <span class="keyword">in</span> declaration of ‘XML_Char’</span><br><span class="line">http-push.c:830: error: expected ‘;’, ‘,’ or ‘)’ before ‘*’ token</span><br><span class="line">http-push.c: In <span class="keyword">function</span> ‘lock_remote’:</span><br><span class="line">http-push.c:900: error: ‘XML_Parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:900: error: (Each undeclared identifier is reported only once</span><br><span class="line">http-push.c:900: error: <span class="keyword">for</span> each <span class="keyword">function</span> it appears <span class="keyword">in</span>.)</span><br><span class="line">http-push.c:900: error: expected ‘;’ before ‘parser’</span><br><span class="line">http-push.c:907: warning: implicit declaration of <span class="keyword">function</span> ‘XML_SetUserData’</span><br><span class="line">http-push.c:907: error: ‘parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:908: warning: implicit declaration of <span class="keyword">function</span> ‘XML_SetElementHandler’</span><br><span class="line">http-push.c:910: warning: implicit declaration of <span class="keyword">function</span> ‘XML_SetCharacterDataHandler’</span><br><span class="line">http-push.c:910: error: ‘xml_cdata’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:911: warning: implicit declaration of <span class="keyword">function</span> ‘XML_Parse’</span><br><span class="line">http-push.c:916: warning: implicit declaration of <span class="keyword">function</span> ‘XML_ErrorString’</span><br><span class="line">http-push.c:917: warning: implicit declaration of <span class="keyword">function</span> ‘XML_GetErrorCode’</span><br><span class="line">http-push.c:920: warning: implicit declaration of <span class="keyword">function</span> ‘XML_ParserFree’</span><br><span class="line">http-push.c: In <span class="keyword">function</span> ‘remote_ls’:</span><br><span class="line">http-push.c:1154: error: ‘XML_Parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:1154: error: expected ‘;’ before ‘parser’</span><br><span class="line">http-push.c:1161: error: ‘parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:1164: error: ‘xml_cdata’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c: In <span class="keyword">function</span> ‘locking_available’:</span><br><span class="line">http-push.c:1228: error: ‘XML_Parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">http-push.c:1228: error: expected ‘;’ before ‘parser’</span><br><span class="line">http-push.c:1235: error: ‘parser’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>)</span><br><span class="line">make: *** [http-push.o] Error 1</span><br></pre></td></tr></tbody></table></figure><p>执行命令解决这个问题<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y expat-devel</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>再次重新执行编译命令</p><p>发现再次报错</p><img src="/2019/03/25/git-install/giterror3.jpg" title="giterror3"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GITGUI_VERSION = 0.21.GITGUI</span><br><span class="line">    * new locations or Tcl/Tk interpreter</span><br><span class="line">    GEN git-gui</span><br><span class="line">    INDEX lib/</span><br><span class="line">    * tclsh failed; using unoptimized loading</span><br><span class="line">    MSGFMT    po/bg.msg make[1]: *** [po/bg.msg] Error 127</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></tbody></table></figure><p>执行命令解决<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y tcl build-essential tk gettext</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>再次重新执行编译命令</p><p>git源码编译成功执行执行命令<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make prefix=/usr/local/git install</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /usr/local/git/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">bin  libexec  share</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd bin/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">git  git-cvsserver  gitk  git-receive-pack  git-shell  git-upload-archive  git-upload-pack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./git --version</span></span><br><span class="line">git version 2.20.1</span><br></pre></td></tr></tbody></table></figure><p>安装完成。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Netcat 命令 - 网络中的瑞士军刀</title>
      <link href="/2019/03/25/nc/"/>
      <url>/2019/03/25/nc/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://netcat.sourceforge.net/" target="_blank" rel="noopener">netcat</a>是网络工具中的瑞士军刀，它能通过TCP和UDP在网络中读写数据。通过与其他工具结合和重定向，你可以在脚本中以多种方式使用它。使用netcat命令所能完成的事情令人惊讶。它的<a href="http://netcat.sourceforge.net/download.php" target="_blank" rel="noopener">下载地址</a></p><p>netcat所做的就是在两台电脑之间建立链接并返回两个数据流，在这之后所能做的事就看你的想像力了。你能建立一个服务器，传输文件，与朋友聊天，传输流媒体或者用它作为其它协议的独立客户端。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ nc -h</span><br><span class="line">usage: nc [-46DdhklnrStUuvzC] [-i interval] [-p source_port]</span><br><span class="line">          [-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_version]</span><br><span class="line">          [-x proxy_address[:port]] [hostname] [port[s]]</span><br><span class="line">        Command Summary:</span><br><span class="line">                -4              Use IPv4</span><br><span class="line">                -6              Use IPv6</span><br><span class="line">                -D              Enable the debug socket option</span><br><span class="line">                -d              Detach from stdin</span><br><span class="line">                -h              This <span class="built_in">help</span> text</span><br><span class="line">                -i secs         Delay interval <span class="keyword">for</span> lines sent, ports scanned</span><br><span class="line">                -k              Keep inbound sockets open <span class="keyword">for</span> multiple connects</span><br><span class="line">                -l              Listen mode, <span class="keyword">for</span> inbound connects</span><br><span class="line">                -n              Suppress name/port resolutions</span><br><span class="line">                -p port         Specify <span class="built_in">local</span> port <span class="keyword">for</span> remote connects</span><br><span class="line">                -r              Randomize remote ports</span><br><span class="line">                -S              Enable the TCP MD5 signature option</span><br><span class="line">                -s addr         Local <span class="built_in">source</span> address</span><br><span class="line">                -T ToS          Set IP Type of Service</span><br><span class="line">                -C              Send CRLF as line-ending</span><br><span class="line">                -t              Answer TELNET negotiation</span><br><span class="line">                -U              Use UNIX domain socket</span><br><span class="line">                -u              UDP mode</span><br><span class="line">                -v              Verbose</span><br><span class="line">                -w secs         Timeout <span class="keyword">for</span> connects and final net reads</span><br><span class="line">                -X proto        Proxy protocol: <span class="string">"4"</span>, <span class="string">"5"</span> (SOCKS) or <span class="string">"connect"</span></span><br><span class="line">                -x addr[:port]  Specify proxy address and port</span><br><span class="line">                -z              Zero-I/O mode [used <span class="keyword">for</span> scanning]</span><br><span class="line">        Port numbers can be individual or ranges: lo-hi [inclusive]</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nc</span><br><span class="line">usage: nc [-46DdhklnrStUuvzC] [-i interval] [-p source_port]</span><br><span class="line">          [-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_version]</span><br><span class="line">          [-x proxy_address[:port]] [hostname] [port[s]]</span><br></pre></td></tr></tbody></table></figure><p>nc 的基本功能如下：</p><ul><li>telnet / 获取系统 banner 信息</li><li>传输文本信息</li><li>传输文件和目录</li><li>加密传输文件</li><li>端口扫描</li><li>远程控制 / 正方向 shell</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p>端口扫描经常被系统管理员和黑客用来发现在一些机器上开放的端口，帮助他们识别系统中的漏洞<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -z -v -n 192.168.10.10 10-100</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以运行在TCP或者UDP模式，默认是TCP，-u参数调整为udp.</p><ul><li>z 参数告诉netcat使用0 IO,连接成功后立即关闭连接， 不进行数据交换</li><li>v 参数指使用冗余选项（译者注：即详细输出）</li><li>n 参数告诉netcat 不要使用DNS反向查询IP地址的域名</li></ul><p>这个命令会打印21到25 所有开放的端口。Banner是一个文本，Banner是一个你连接的服务发送给你的文本信息。当你试图鉴别漏洞或者服务的类型和版本的时候，Banner信息是非常有用的。但是，并不是所有的服务都会发送banner。</p><p>一旦你发现开放的端口，你可以容易的使用netcat 连接服务抓取他们的banner。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -v 192.168.10.10 22</span><br></pre></td></tr></tbody></table></figure><p>netcat 命令会连接开放端口21并且打印运行在这个端口上服务的banner信息。</p><h4 id="C-S-Chat-Server-聊天"><a href="#C-S-Chat-Server-聊天" class="headerlink" title="C S(Chat Server) 聊天"></a>C S(Chat Server) 聊天</h4><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>netcat 命令在1567端口启动了一个tcp 服务器，所有的标准输出和输入会输出到该端口。输出和输入都在此shell中展示。</p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc 192.168.10.10 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>不管你在机器B上键入什么都会出现在机器A上。</p><h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><p>大部分时间中，我们都在试图通过网络或者其他工具传输文件。有很多种方法，比如FTP,SCP,SMB等等，但是当你只是需要临时或者一次传输文件，真的值得浪费时间来安装配置一个软件到你的机器上嘛。假设，你想要传一个文件testfile.txt 从A 到B。A或者B都可以作为服务器或者客户端，以下，让A作为服务器，B为客户端。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010 > testfile.txt</span><br></pre></td></tr></tbody></table></figure><p></p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -n 192.168.10.10 10010 < testfile.txt</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里我们创建了一个服务器在A上并且重定向netcat的输入为文件testfile.txt，那么当任何成功连接到该端口，netcat会发送file的文件内容。<br>在客户端我们重定向输出到testfile.txt，当B连接到A，A发送文件内容，B保存文件内容到testfile.txt.</p><p>没有必要创建文件源作为Server，我们也可以相反的方法使用。像下面的我们发送文件从B到A，但是服务器创建在A上，这次我们仅需要重定向netcat的输出并且重定向B的输入文件。</p><h4 id="目录传输"><a href="#目录传输" class="headerlink" title="目录传输"></a>目录传输</h4><p>发送一个文件很简单，但是如果我们想要发送多个文件，或者整个目录，一样很简单，只需要使用压缩工具tar，压缩后发送压缩包。</p><p>如果你想要通过网络传输一个目录从A到B。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf - dir_name | nc -n 192.168.10.10 10010</span><br><span class="line">$ tar -cvf - dir_name | nc 192.168.10.10 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010 | tar -xvf -</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里在A服务器上，我们创建一个tar归档包并且通过-在控制台重定向它，然后使用管道，重定向给netcat，netcat可以通过网络发送它。</p><p>在客户端我们下载该压缩包通过netcat 管道然后打开文件。</p><p>如果想要节省带宽传输压缩包，我们可以使用<strong>bzip2</strong>或者其他工具压缩。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf - dir_name| bzip2 -z | nc -n 192.168.10.10 10010</span><br><span class="line">$ tar -cvf - dir_name| bzip2 -z | nc 192.168.10.10 10010</span><br><span class="line"><span class="comment">#使用 bzip2 压缩</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010 | bzip2 -d | tar -xvf -</span><br><span class="line"><span class="comment">#使用 bzip2 解压缩</span></span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="加密通过网络发送的数据"><a href="#加密通过网络发送的数据" class="headerlink" title="加密通过网络发送的数据"></a>加密通过网络发送的数据</h4><p>如果你担心你在网络上发送数据的安全，你可以在发送你的数据之前用如 <strong>mcrypt</strong> 的工具加密。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc localhost 10010 | mcrypt -flush -bare -F -q -d -m ecb > testfile.txt</span><br><span class="line"><span class="comment">#使用mcrypt工具加密数据</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mcrypt -flush -bare -F -q -m ecb < testfile.txt | nc -l 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用mcrypt工具解密数据。</p><p>以上两个命令会提示需要密码，确保两端使用相同的密码。</p><p>这里我们是使用mcrypt用来加密，使用其它任意加密工具都可以。</p><h4 id="反向-SHELL"><a href="#反向-SHELL" class="headerlink" title="反向 SHELL"></a>反向 SHELL</h4><p>反向shell是指在客户端打开的shell。反向shell这样命名是因为不同于其他配置，这里服务器使用的是由客户提供的服务。</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>在客户端，简单地告诉netcat在连接完成后，执行shell</p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc 192.168.10.10 10010 -e /bin/bash</span><br></pre></td></tr></tbody></table></figure><p></p><p>现在，什么是反向shell的特别之处呢 </p><p>反向shell经常被用来绕过防火墙的限制，如阻止入站连接。例如，我有一个专用IP地址为192.168.10.10，我使用代理服务器连接到外部网络。如果我想从网络外部访问 这台机器如10.1.1.10的shell，那么我会用反向外壳用于这一目的。 </p><h4 id="克隆设备"><a href="#克隆设备" class="headerlink" title="克隆设备"></a>克隆设备</h4><p>如果你已经安装配置一台Linux机器并且需要重复同样的操作对其他的机器，而你不想在重复配置一遍。不在需要重复配置安装的过程，只启动另一台机器的一些引导可以随身碟和克隆你的机器。</p><p>克隆Linux PC很简单，假如你的系统在磁盘/dev/sda上</p><p>Server<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/sda | nc -l 10010</span><br></pre></td></tr></tbody></table></figure><p></p><p>在客户端，简单地告诉netcat在连接完成后，执行shell</p><p>Client<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -n 192.168.10.10 10010 | dd of=/dev/sda</span><br></pre></td></tr></tbody></table></figure><p></p><p>dd是一个从磁盘读取原始数据的工具，我通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果我们已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防止 rm -rf 误删带来的灾难</title>
      <link href="/2019/03/20/trash-cli/"/>
      <url>/2019/03/20/trash-cli/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm-rf-这种操作，太危险了。为什么不学学Ubuntu-MacOS等系统有一个回收站，删除了可以去回收站里面找。经过折腾一番，终于找到了一个工具-trash-cli。"><a href="#搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm-rf-这种操作，太危险了。为什么不学学Ubuntu-MacOS等系统有一个回收站，删除了可以去回收站里面找。经过折腾一番，终于找到了一个工具-trash-cli。" class="headerlink" title="搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm -rf 这种操作，太危险了。为什么不学学Ubuntu/MacOS等系统有一个回收站，删除了可以去回收站里面找。经过折腾一番，终于找到了一个工具 trash-cli。"></a>搞过运维想过行业的淫们都有过rm之伤，造成血的教训。为了避免以后才出现类似的情况，强烈建议生产环境中千万不要使用rm -rf 这种操作，太危险了。为什么不学学Ubuntu/MacOS等系统有一个回收站，删除了可以去回收站里面找。经过折腾一番，终于找到了一个工具 trash-cli。</h4><h4 id="trash-cli是一个使用-python-开发的软件包，trash-cli-trashes记录原始路径，删除日期和权限的文件。它使用KDE，GNOME和XFCE使用的相同垃圾桶，但您可以从命令行（和脚本）调用它。包含"><a href="#trash-cli是一个使用-python-开发的软件包，trash-cli-trashes记录原始路径，删除日期和权限的文件。它使用KDE，GNOME和XFCE使用的相同垃圾桶，但您可以从命令行（和脚本）调用它。包含" class="headerlink" title="trash-cli是一个使用 python 开发的软件包，trash-cli trashes记录原始路径，删除日期和权限的文件。它使用KDE，GNOME和XFCE使用的相同垃圾桶，但您可以从命令行（和脚本）调用它。包含:"></a><a href="https://github.com/andreafrancia/trash-cli" target="_blank" rel="noopener">trash-cli</a>是一个使用 python 开发的软件包，trash-cli trashes记录原始路径，删除日期和权限的文件。它使用KDE，GNOME和XFCE使用的相同垃圾桶，但您可以从命令行（和脚本）调用它。包含:</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* trash-put           trash files and directories.</span><br><span class="line">* trash-empty         empty the trashcan(s).</span><br><span class="line">* trash-list          list trashed files.</span><br><span class="line">* trash-restore       restore a trashed file.</span><br><span class="line">* trash-rm            remove individual files from the trashcan.</span><br></pre></td></tr></tbody></table></figure><h2 id="trash-cli-安装"><a href="#trash-cli-安装" class="headerlink" title="trash-cli 安装"></a>trash-cli 安装</h2><h4 id="The-easy-way"><a href="#The-easy-way" class="headerlink" title="The easy way"></a>The easy way</h4><h5 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements:"></a>Requirements:</h5><blockquote><p>Python 2.7 or Python 3<br>  setuptools (use apt-get install python-setuptools on Debian)</p></blockquote><p>Installation command:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install trash-cli</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="From-sources"><a href="#From-sources" class="headerlink" title="From sources"></a>From sources</h4><h5 id="System-wide-installation"><a href="#System-wide-installation" class="headerlink" title="System-wide installation:"></a>System-wide installation:</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/andreafrancia/trash-cli.git</span><br><span class="line"><span class="built_in">cd</span> trash-cli</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></tbody></table></figure><h5 id="User-only-installation"><a href="#User-only-installation" class="headerlink" title="User-only installation:"></a>User-only installation:</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/andreafrancia/trash-cli.git</span><br><span class="line"><span class="built_in">cd</span> trash-cli</span><br><span class="line">python setup.py install --user</span><br></pre></td></tr></tbody></table></figure><h2 id="trash-cli-命令"><a href="#trash-cli-命令" class="headerlink" title="trash-cli 命令"></a>trash-cli 命令</h2><h4 id="查看安装成功之后的命令"><a href="#查看安装成功之后的命令" class="headerlink" title="查看安装成功之后的命令"></a>查看安装成功之后的命令</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ll /usr/bin/ | grep trash</span></span><br><span class="line">-rwxr-xr-x    1 root root         123 Feb  2 17:43 trash</span><br><span class="line">-rwxr-xr-x    1 root root         125 Feb  2 17:43 trash-empty</span><br><span class="line">-rwxr-xr-x    1 root root         124 Feb  2 17:43 trash-list</span><br><span class="line">-rwxr-xr-x    1 root root         123 Feb  2 17:43 trash-put</span><br><span class="line">-rwxr-xr-x    1 root root         127 Feb  2 17:43 trash-restore</span><br><span class="line">-rwxr-xr-x    1 root root         122 Feb  2 17:43 trash-rm</span><br></pre></td></tr></tbody></table></figure><h6 id="功能说明："><a href="#功能说明：" class="headerlink" title="功能说明："></a>功能说明：</h6><ul><li>trash-put     将文件或目录移入回收站</li><li>trash-empty   清空回收站</li><li>trash-list    列出回收站中的文件</li><li>trash-restore 还原回收站中的文件</li><li>trash-rm      删除回首站中的单个文件</li></ul><h6 id="用它替代-rm命令"><a href="#用它替代-rm命令" class="headerlink" title="用它替代 rm命令"></a>用它替代 rm命令</h6><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim .bashrc </span></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"><span class="comment">#alias rm='rm -i'</span></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">'trash-put'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h2><h4 id="删除测试："><a href="#删除测试：" class="headerlink" title="删除测试："></a>删除测试：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm -rf dump.sql</span></span><br><span class="line"><span class="comment"># ll ~/.local/share/Trash/files </span></span><br><span class="line">-rw-r--r-- 1 root root 123 Jul 17  2018 dump.sql</span><br><span class="line"> </span><br><span class="line"><span class="comment"># trash-list</span></span><br><span class="line">2019-02-02 18:02:33 /root/dump.sql</span><br></pre></td></tr></tbody></table></figure><h4 id="还原删除的文件"><a href="#还原删除的文件" class="headerlink" title="还原删除的文件"></a>还原删除的文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trash-restore /root/dump.rdb</span></span><br><span class="line">   0 2019-02-02 18:01:08 /root/dump.sql.bak</span><br><span class="line">   1 2019-02-02 18:02:33 /root/dump.sql</span><br><span class="line">What file to restore [0..1]: 1</span><br><span class="line"></span><br><span class="line">还原成功</span><br><span class="line"><span class="comment"># ll /root/dump.rdb </span></span><br><span class="line">-rw-r--r-- 1 root root 123 Jul 17  2018 /root/dump.sql</span><br></pre></td></tr></tbody></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><h4 id="trash-put命令会把我们想要删除的文件移动到-local-share-Trash-files-中。相关信息记录在-local-share-Trash-info中。"><a href="#trash-put命令会把我们想要删除的文件移动到-local-share-Trash-files-中。相关信息记录在-local-share-Trash-info中。" class="headerlink" title="trash-put命令会把我们想要删除的文件移动到~/.local/share/Trash/files 中。相关信息记录在~/.local/share/Trash/info中。"></a>trash-put命令会把我们想要删除的文件移动到~/.local/share/Trash/files 中。相关信息记录在~/.local/share/Trash/info中。</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClickHouse-sync-to-MySQLDate</title>
      <link href="/2019/03/20/ClickHouse-sync-to-MySQLDate/"/>
      <url>/2019/03/20/ClickHouse-sync-to-MySQLDate/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>ClickHouse 这款产品大家都听说过很快，但是到底有多恐怖？</li><li>ClickHouse 到底是什么？</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ClickHouse最初是为 Yandex.Metrica 世界第二大Web分析平台 而开发的。多年来一直作为该系统的核心组件被该系统持续使用着。目前为止，该系统在ClickHouse中有超过13万亿条记录，并且每天超过200多亿个事件被处理。它允许直接从原始数据中动态查询并生成报告。本文简要介绍了ClickHouse在其早期发展阶段的目标。</p><p>Yandex.Metrica基于用户定义的字段，对实时访问、连接会话，生成实时的统计报表。这种需求往往需要复杂聚合方式，比如对访问用户进行去重。构建报表的数据，是实时接收存储的新数据。</p><p>截至2014年4月，Yandex.Metrica每天跟踪大约120亿个事件（用户的点击和浏览）。为了可以创建自定义的报表，我们必须存储全部这些事件。同时，这些查询可能需要在几百毫秒内扫描数百万行的数据，或在几秒内扫描数亿行的数据。</p><h4 id="什么是ClickHouse"><a href="#什么是ClickHouse" class="headerlink" title="什么是ClickHouse ?"></a><strong>什么是ClickHouse ?</strong></h4><p>ClickHouse 是面向 OLAP 的分布式列式 DBMS.</p><h4 id="ClickHouse的显著特性"><a href="#ClickHouse的显著特性" class="headerlink" title="ClickHouse的显著特性"></a>ClickHouse的显著特性</h4><ul><li>真正的面向列的DBMS</li><li>数据高效压缩</li><li>磁盘存储的数据</li><li>多核并行处理</li></ul><ul><li>在多个服务器上分布式处理<ul><li>SQL语法支持</li></ul></li></ul><ul><li>向量化引擎</li><li>实时数据更新</li><li>索引</li><li>适合在线查询</li><li>支持近似预估计算</li><li>支持嵌套的数据结构</li><li>支持数组作为数据类型</li><li>支持限制查询复杂性以及配额</li><li>复制数据复制和对数据完整性的支持</li></ul><h4 id="OLAP场景的关键特征"><a href="#OLAP场景的关键特征" class="headerlink" title="OLAP场景的关键特征"></a>OLAP场景的关键特征</h4><ul><li>大多数是读请求</li><li>数据总是以相当大的批(> 1000 rows)进行写入</li><li>不修改已添加的数据</li><li>每次查询都从数据库中读取大量的行，但是同时又仅需要少量的列</li><li>宽表，即每个表包含着大量的列</li><li>较少的查询(通常每台服务器每秒数百个查询或更少)</li><li>对于简单查询，允许延迟大约50毫秒</li><li>列中的数据相对较小： 数字和短字符串(例如，每个URL 60个字节)</li><li>处理单个查询时需要高吞吐量（每个服务器每秒高达数十亿行）</li><li>事务不是必须的</li><li>对数据一致性要求低</li><li>每一个查询除了一个大表外都很小</li><li>查询结果明显小于源数据，换句话说，数据被过滤或聚合后能够被盛放在单台服务器的内存中</li></ul><h4 id="列式数据库更适合OLAP场景的原因"><a href="#列式数据库更适合OLAP场景的原因" class="headerlink" title="列式数据库更适合OLAP场景的原因"></a>列式数据库更适合OLAP场景的原因</h4><p>列式数据库更适合于OLAP场景(对于大多数查询而言，处理速度至少提高了100倍)，下面详细解释了原因(通过图片更有利于直观理解)：<br>行式<br><img src="/2019/03/20/ClickHouse-sync-to-MySQLDate/row_oriented.gif" title="row_oriented"><br>列式<br><img src="/2019/03/20/ClickHouse-sync-to-MySQLDate/column_oriented.gif" title="column_oriented"><br>看到差别了么？下面将详细介绍为什么会发生这种情况。<br>1.针对分析类查询，通常只需要读取表的一小部分列。在列式数据库中你可以只读取你需要的数据。例如，如果只需要读取100列中的5列，这将帮助你最少减少20倍的I/O消耗。<br>2.由于数据总是打包成批量读取的，所以压缩是非常容易的。同时数据按列分别存储这也更容易压缩。这进一步降低了I/O的体积。<br>3.由于I/O的降低，这将帮助更多的数据被系统缓存。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ clickhouse-client</span><br><span class="line">ClickHouse client version 0.0.52053.</span><br><span class="line">Connecting to localhost:9000.</span><br><span class="line">Connected to ClickHouse server version 0.0.52053.</span><br><span class="line"></span><br><span class="line">:) SELECT CounterID, count() FROM hits GROUP BY CounterID ORDER BY count() DESC LIMIT 20</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">    CounterID,</span><br><span class="line">    count()</span><br><span class="line">FROM hits</span><br><span class="line">GROUP BY CounterID</span><br><span class="line">ORDER BY count() DESC</span><br><span class="line">LIMIT 20</span><br><span class="line"></span><br><span class="line">┌─CounterID─┬──count()─┐</span><br><span class="line">│    114208 │ 56057344 │</span><br><span class="line">│    115080 │ 51619590 │</span><br><span class="line">│      3228 │ 44658301 │</span><br><span class="line">│     38230 │ 42045932 │</span><br><span class="line">│    145263 │ 42042158 │</span><br><span class="line">│     91244 │ 38297270 │</span><br><span class="line">│    154139 │ 26647572 │</span><br><span class="line">│    150748 │ 24112755 │</span><br><span class="line">│    242232 │ 21302571 │</span><br><span class="line">│    338158 │ 13507087 │</span><br><span class="line">│     62180 │ 12229491 │</span><br><span class="line">│     82264 │ 12187441 │</span><br><span class="line">│    232261 │ 12148031 │</span><br><span class="line">│    146272 │ 11438516 │</span><br><span class="line">│    168777 │ 11403636 │</span><br><span class="line">│   4120072 │ 11227824 │</span><br><span class="line">│  10938808 │ 10519739 │</span><br><span class="line">│     74088 │  9047015 │</span><br><span class="line">│    115079 │  8837972 │</span><br><span class="line">│    337234 │  8205961 │</span><br><span class="line">└───────────┴──────────┘</span><br><span class="line"></span><br><span class="line">20 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.153 sec. Processed 1.00 billion rows, 4.00 GB (6.53 billion rows/s., 26.10 GB/s.)</span><br><span class="line"></span><br><span class="line">:)</span><br></pre></td></tr></tbody></table></figure><h4 id="ClickHouse-SQL"><a href="#ClickHouse-SQL" class="headerlink" title="ClickHouse SQL"></a>ClickHouse SQL</h4><p>Creating a Table<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]</span><br><span class="line">(</span><br><span class="line">    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],</span><br><span class="line">    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],</span><br><span class="line">    ...</span><br><span class="line">    INDEX index_name1 expr1 TYPE type1(...) GRANULARITY value1,</span><br><span class="line">    INDEX index_name2 expr2 TYPE type2(...) GRANULARITY value2</span><br><span class="line">) ENGINE = MergeTree()</span><br><span class="line">[PARTITION BY expr]</span><br><span class="line">[ORDER BY expr]</span><br><span class="line">[PRIMARY KEY expr]</span><br><span class="line">[SAMPLE BY expr]</span><br><span class="line">[SETTINGS name=value, ...]</span><br></pre></td></tr></tbody></table></figure><p></p><p>Example of sections setting<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE MergeTree() PARTITION BY toYYYYMM(EventDate) ORDER BY (CounterID, EventDate, intHash32(UserID)) SAMPLE BY intHash32(UserID) SETTINGS index_granularity=8192</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="MySQL-数据导入测试"><a href="#MySQL-数据导入测试" class="headerlink" title="MySQL 数据导入测试"></a>MySQL 数据导入测试</h2><h4 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># du出的表大小</span></span><br><span class="line">5.5G    test_1.ibd</span><br><span class="line"><span class="comment"># ClickHouse操作语句</span></span><br><span class="line">CREATE TABLE test_1</span><br><span class="line">ENGINE = MergeTree</span><br><span class="line">ORDER BY id AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM mysql(<span class="string">'host:port'</span>, <span class="string">'dbtest'</span>, <span class="string">'test_1'</span>, <span class="string">'user'</span>, <span class="string">'password'</span>) </span><br><span class="line"><span class="comment"># 耗时和平均速度</span></span><br><span class="line">0 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 137.251 sec. Processed 18.59 million rows, 7.34 GB (135.43 thousand rows/s., 53.48 MB/s.)</span><br></pre></td></tr></tbody></table></figure><h4 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另一个表</span></span><br><span class="line">20G     test_2.ibd</span><br><span class="line">CREATE TABLE test_2</span><br><span class="line">ENGINE = MergeTree</span><br><span class="line">ORDER BY id AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM mysql(<span class="string">'host:port'</span>, <span class="string">'dbtest'</span>, <span class="string">'test_2'</span>, <span class="string">'user'</span>, <span class="string">'password'</span>) </span><br><span class="line"><span class="comment"># 不知道为啥这表这么快就导入了 貌似是行少，但是表的总大小大啊</span></span><br><span class="line">0 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 44.389 sec. Processed 13.03 million rows, 1.44 GB (293.44 thousand rows/s., 32.35 MB/s.)</span><br></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://clickhouse.yandex/docs/zh/" target="_blank" rel="noopener">ClickHouse 官方资料</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ClickHouse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ClickHouse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>disk cache policy in RAID</title>
      <link href="/2019/03/11/disk-cache-policy-in-RAID/"/>
      <url>/2019/03/11/disk-cache-policy-in-RAID/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h4 id="这篇文章背后，字字都是血泪。曾经因为EXT4-fs-error，从夜里10点抢救数据到凌晨7点，-睡一个小时候之后，吃饭，见客户，告诉客户数据恢复回来了。"><a href="#这篇文章背后，字字都是血泪。曾经因为EXT4-fs-error，从夜里10点抢救数据到凌晨7点，-睡一个小时候之后，吃饭，见客户，告诉客户数据恢复回来了。" class="headerlink" title="这篇文章背后，字字都是血泪。曾经因为EXT4-fs error，从夜里10点抢救数据到凌晨7点， 睡一个小时候之后，吃饭，见客户，告诉客户数据恢复回来了。"></a>这篇文章背后，字字都是血泪。曾经因为EXT4-fs error，从夜里10点抢救数据到凌晨7点， 睡一个小时候之后，吃饭，见客户，告诉客户数据恢复回来了。</h4><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h4 id="首先，RAID的write-policy分成两种："><a href="#首先，RAID的write-policy分成两种：" class="headerlink" title="首先，RAID的write policy分成两种："></a>首先，RAID的write policy分成两种：</h4><ul><li>write back</li><li>write through</li></ul><p>一种模式是write back会有更好的性能。因为在write back模式下，数据写入Controller Cache，就认为Write IO结束了，而不需要等待写入Hard driver。这种模式很明显存在安全隐患，异常掉电情况下，很容易引起数据丢失。</p><p>另一种模式是write through，这种模式比较谨慎，它压根不使用Raid Cache来加速写操作，因此这种模式的性能要比write back 低不少。</p><p>但是write back的不安全也是有办法解决的：</p><ul><li>第一个方案是UPS–Uninterruptible Power Supply，这个按下不提</li><li>第二个方案是BBU–Backup Battery Unit，有了BBU，就可以安心地采用write-back模式了</li></ul><p>对BBU不太了解的，可以阅读[Barriers, Caches, Filesystems]，介绍的非常好</p><p>讲完了这个write policy，还有一个东东叫disk cache policy，这个东西用来决定磁盘一级的cache是否enable。 一定要注意这个东西，无数血泪都是这个东西引起的。</p><p>如果选择write through模式，即不使用RAID cache，这种情况下disk cache对性能的提升是很大的。但是尽管如此，也不要enable disk cache，因为，会有数据丢失的风险。如果可能异常掉电，那么一定不要enable disk cache。</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h4 id="查看write-policy-和-disk-cache-policy的命令如下："><a href="#查看write-policy-和-disk-cache-policy的命令如下：" class="headerlink" title="查看write policy 和 disk cache policy的命令如下："></a>查看write policy 和 disk cache policy的命令如下：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64 -LDInfo -Lall -aAll</span><br></pre></td></tr></tbody></table></figure><p>输出如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Virtual Drive: 1 (Target Id: 1)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-5, Secondary-0, RAID Level Qualifier-3</span><br><span class="line">Size                : 25.466 TB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Parity Size         : 3.637 TB</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 128 KB</span><br><span class="line">Number Of Drives    : 8</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteBack, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Current Cache Policy: WriteBack, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disk<span class="string">'s Default</span></span><br><span class="line"><span class="string">Encryption Type     : None</span></span><br><span class="line"><span class="string">PI type: No PI</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Is VD Cached: No</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到Disk Cache Policy 是 Disk’s Default 。这个default值可以分成以下情况：</p><ul><li>For virtual disks containing SATA disks ， Enabled</li><li>For virtual disks containing SAS disks ， Disabled</li></ul><p>可以通过如下命令将Disk Cache Policy的值改成 Disable<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64 -LDSetProp -DisDskCache -Immediate -Lall -aAll</span><br></pre></td></tr></tbody></table></figure><p></p><p>输出如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set Disk Cache Policy to Disabled on Adapter 0, VD 0 (target id: 0) success</span><br><span class="line">Set Disk Cache Policy to Disabled on Adapter 0, VD 1 (target id: 1) success</span><br><span class="line">Set Disk Cache Policy to Disabled on Adapter 0, VD 2 (target id: 2) success</span><br><span class="line">Set Disk Cache Policy to Disabled on Adapter 0, VD 3 (target id: 3) success</span><br><span class="line">Set Disk Cache Policy to Disabled on Adapter 0, VD 4 (target id: 4) success</span><br><span class="line">Set Disk Cache Policy to Disabled on Adapter 0, VD 5 (target id: 5) success</span><br><span class="line">Set Disk Cache Policy to Disabled on Adapter 0, VD 6 (target id: 6) success</span><br><span class="line"></span><br><span class="line">Exit Code: 0x00</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时再次查看输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Virtual Drive: 1 (Target Id: 1)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-5, Secondary-0, RAID Level Qualifier-3</span><br><span class="line">Size                : 25.466 TB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Parity Size         : 3.637 TB</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 128 KB</span><br><span class="line">Number Of Drives    : 8</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteBack, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Current Cache Policy: WriteBack, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disabled</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="推荐设置"><a href="#推荐设置" class="headerlink" title="推荐设置"></a>推荐设置</h2><p>1.商用环境，RAID一定要有BBU<br>2.write policy 采用 write back<br>3.disk cache policy 一定要为disable</p><p>这个推荐设置，和Intel给出的 <a href="http://download.intel.com/support/motherboards/server/sb/configuring_raid_for_optimal_perfromance_11.pdf" target="_blank" rel="noopener">Configuring RAID For Optimal Performance</a> 是一致的，除此以外，<a href="https://www.thomas-krenn.com/en/wiki/RAID_Controller_and_Hard_Disk_Cache_Settings" target="_blank" rel="noopener">RAID Controller and Hard Disk Cache Settings</a>也给出了类似的结论。这些都是不错的参考文献。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check e2fsck progress realtime</title>
      <link href="/2019/03/11/check-e2fsck-progress-realtime/"/>
      <url>/2019/03/11/check-e2fsck-progress-realtime/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="对于e2fsck-而言，有两个特点，如果文件系统是健康的，可以很快完成，3秒之内解决战斗，但是确实存在error的情况下，可能耗时非常久，这种情况下，进度汇报是非常重要的，如果一个文件系统需要修复几个小时，又没有进度汇报，人会抓狂的。"><a href="#对于e2fsck-而言，有两个特点，如果文件系统是健康的，可以很快完成，3秒之内解决战斗，但是确实存在error的情况下，可能耗时非常久，这种情况下，进度汇报是非常重要的，如果一个文件系统需要修复几个小时，又没有进度汇报，人会抓狂的。" class="headerlink" title="对于e2fsck 而言，有两个特点，如果文件系统是健康的，可以很快完成，3秒之内解决战斗，但是确实存在error的情况下，可能耗时非常久，这种情况下，进度汇报是非常重要的，如果一个文件系统需要修复几个小时，又没有进度汇报，人会抓狂的。"></a>对于e2fsck 而言，有两个特点，如果文件系统是健康的，可以很快完成，3秒之内解决战斗，但是确实存在error的情况下，可能耗时非常久，这种情况下，进度汇报是非常重要的，如果一个文件系统需要修复几个小时，又没有进度汇报，人会抓狂的。</h4><h2 id="实时检查-e2fsck-进度的方法"><a href="#实时检查-e2fsck-进度的方法" class="headerlink" title="实时检查 e2fsck 进度的方法"></a>实时检查 e2fsck 进度的方法</h2><p>在e2fsck 进行的时候，在另外一个终端向e2fsck 进程发送SIGUSR1信号。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 5 <span class="built_in">kill</span> -10 `pidof e2fsck`</span><br></pre></td></tr></tbody></table></figure><p></p><p>在e2fsck调用的终端上，就会每5秒钟显示一下实时的进度。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e2fsck 1.42 (29-Nov-2011)</span><br><span class="line">/dev/dm-19 contains a file system with errors, check forced.</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure                                           </span><br><span class="line">Pass 3: Checking directory connectivity                                        </span><br><span class="line">Pass 4: Checking reference counts                                              </span><br><span class="line">Pass 5: Checking group summary information                                     </span><br><span class="line">/dev/dm-19: |======================================================  \ 95.8%</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>并非只有e2fsck 这个工具会响应SIGUSR1信号，dd工具也有同样的特点。dd 拷贝大文件的时候，只有在拷贝结束的时候，才会汇报时间以及速度等信息，但是像我这种等待焦虑综合症的选手，一定是会抓狂的，同样道理，通过实时向dd进程发送 SIGUSR1信号，dd进程就会时时汇报速率信息，不妨试试，很有用。</p><p>对于开发各种工具的人来说，如果工具运行时间可能很久，可以通过注册SIGUSR1信号的处理函数，实时向用户汇报进度，这是一个不错的习惯。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iSCSI_command</title>
      <link href="/2019/03/11/iSCSI-command/"/>
      <url>/2019/03/11/iSCSI-command/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="iSCSI客户端常用命令总是忘记，在此处记录下。"><a href="#iSCSI客户端常用命令总是忘记，在此处记录下。" class="headerlink" title="iSCSI客户端常用命令总是忘记，在此处记录下。"></a>iSCSI客户端常用命令总是忘记，在此处记录下。</h4><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="查看当前session"><a href="#查看当前session" class="headerlink" title="查看当前session"></a>查看当前session</h4><h4 id="挂载之前，一般如下图所示："><a href="#挂载之前，一般如下图所示：" class="headerlink" title="挂载之前，一般如下图所示："></a>挂载之前，一般如下图所示：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># iscsiadm -m session </span></span><br><span class="line">iscsiadm: No active sessions.</span><br></pre></td></tr></tbody></table></figure><p>挂载之后<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">root@node-242:~<span class="comment"># iscsiadm -m session </span></span><br><span class="line">tcp: [2] 10.16.172.247:3260,1 iqn.2018-11.com:BEAN</span><br><span class="line"></span><br><span class="line">root@node-242:~<span class="comment"># iscsiadm -m session -P 3</span></span><br><span class="line">iSCSI Transport Class version 2.0-870</span><br><span class="line">version 2.0-871</span><br><span class="line">Target: iqn.2018-11.com:BEAN</span><br><span class="line">Current Portal: 10.16.172.247:3260,1</span><br><span class="line">Persistent Portal: 10.16.172.247:3260,1</span><br><span class="line">**********</span><br><span class="line">Interface:</span><br><span class="line">**********</span><br><span class="line">Iface Name: default</span><br><span class="line">Iface Transport: tcp</span><br><span class="line">Iface Initiatorname: iqn.1993-08.org.debian:01:c9c12dd76e</span><br><span class="line">Iface IPaddress: 10.16.172.242</span><br><span class="line">Iface HWaddress: (null)</span><br><span class="line">Iface Netdev: (null)</span><br><span class="line">SID: 2</span><br><span class="line">iSCSI Connection State: LOGGED IN</span><br><span class="line">iSCSI Session State: LOGGED_IN</span><br><span class="line">Internal iscsid Session State: NO CHANGE</span><br><span class="line">************************</span><br><span class="line">Negotiated iSCSI params:</span><br><span class="line">************************</span><br><span class="line">HeaderDigest: None</span><br><span class="line">DataDigest: None</span><br><span class="line">MaxRecvDataSegmentLength: 262144</span><br><span class="line">MaxXmitDataSegmentLength: 1048576</span><br><span class="line">FirstBurstLength: 262144</span><br><span class="line">MaxBurstLength: 1048576</span><br><span class="line">ImmediateData: Yes</span><br><span class="line">InitialR2T: No</span><br><span class="line">MaxOutstandingR2T: 1</span><br><span class="line">************************</span><br><span class="line">Attached SCSI devices:</span><br><span class="line">************************</span><br><span class="line">Host Number: 25State: running</span><br><span class="line">scsi25 Channel 00 Id 0 Lun: 0</span><br><span class="line">Attached scsi disk sdeState: running</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="根据IP-发现target"><a href="#根据IP-发现target" class="headerlink" title="根据IP 发现target"></a>根据IP 发现target</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m discovery -t st -p 10.16.172.246</span><br></pre></td></tr></tbody></table></figure><p>输出如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># iscsiadm -m discovery -t st -p 10.16.172.246</span></span><br><span class="line">10.16.172.246:3260,1 iqn.2018-11.com:BEAN</span><br><span class="line">10.16.172.247:3260,1 iqn.2018-11.com:BEAN</span><br><span class="line">10.16.172.248:3260,1 iqn.2018-11.com:BEAN</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="登录到指定target"><a href="#登录到指定target" class="headerlink" title="登录到指定target"></a>登录到指定target</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m node -T [target_name] -p [ip:3260] -l</span><br></pre></td></tr></tbody></table></figure><p>如下所示：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m node -T iqn.2018-11.com:BEAN -p 10.16.172.246:3260 -l</span><br></pre></td></tr></tbody></table></figure><p></p><p>输出如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># iscsiadm -m node -T iqn.2018-11.com:BEAN -p 10.16.172.246:3260 -l</span></span><br><span class="line">Logging <span class="keyword">in</span> to [iface: default, target: iqn.2018-11.com:BEAN, portal: 10.16.172.246,3260]</span><br><span class="line">Login to [iface: default, target: iqn.2018-11.com:BEAN, portal: 10.16.172.246,3260]: successful</span><br></pre></td></tr></tbody></table></figure><p></p><p>登录之后，可以用iscsiadm -m session查看。结果一般如下所示：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node-242:~<span class="comment"># iscsiadm -m session </span></span><br><span class="line">tcp: [3] 10.16.172.246:3260,1 iqn.2018-11.com:BEAN</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="登出指定target"><a href="#登出指定target" class="headerlink" title="登出指定target"></a>登出指定target</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m node -T [target_name] -p [ip:3260] -u</span><br></pre></td></tr></tbody></table></figure><p>具体指令如下所示：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># iscsiadm -m node -T iqn.2018-11.com:BEAN -p 10.16.172.246:3260 -u</span></span><br><span class="line">Logging out of session [sid: 3, target: iqn.2018-11.com:BEAN, portal: 10.16.172.246,3260]</span><br><span class="line">Logout of [sid: 3, target: iqn.2018-11.com:BEAN, portal: 10.16.172.246,3260]: successful</span><br></pre></td></tr></tbody></table></figure><p></p><p>登出之后，可以用iscsiadm -m session 检查效果。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node-242:~<span class="comment"># iscsiadm -m session </span></span><br><span class="line">iscsiadm: No active sessions.</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>一般来讲，登录target之后会新增一个盘符，登录之前，lsblk输出如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0    30G  0 disk </span><br><span class="line">├─sda1   8:1    0     7M  0 part </span><br><span class="line">├─sda2   8:2    0  22.2G  0 part /</span><br><span class="line">├─sda3   8:3    0   7.5G  0 part [SWAP]</span><br><span class="line">└─sda4   8:4    0   261M  0 part </span><br><span class="line">sdb      8:16   0   100G  0 disk </span><br><span class="line">├─sdb1   8:17   0     8G  0 part </span><br><span class="line">└─sdb2   8:18   0    92G  0 part /data/osd.2</span><br><span class="line">sdc      8:32   0     2T  0 disk </span><br><span class="line">sr0     11:0    1  1024M  0 rom</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行登录target之后：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># iscsiadm -m node -T iqn.2018-11.com:BEAN -p 10.16.172.246:3260 -l</span></span><br><span class="line">Logging <span class="keyword">in</span> to [iface: default, target: iqn.2018-11.com:BEAN, portal: 10.16.172.246,3260] (multiple)</span><br><span class="line">Login to [iface: default, target: iqn.2018-11.com:BEAN, portal: 10.16.172.246,3260] successful.</span><br><span class="line">root@node2:~<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0    30G  0 disk </span><br><span class="line">├─sda1   8:1    0     7M  0 part </span><br><span class="line">├─sda2   8:2    0  22.2G  0 part /</span><br><span class="line">├─sda3   8:3    0   7.5G  0 part [SWAP]</span><br><span class="line">└─sda4   8:4    0   261M  0 part </span><br><span class="line">sdb      8:16   0   100G  0 disk </span><br><span class="line">├─sdb1   8:17   0     8G  0 part </span><br><span class="line">└─sdb2   8:18   0    92G  0 part /data/osd.2</span><br><span class="line">sdc      8:32   0     2T  0 disk </span><br><span class="line">sr0     11:0    1  1024M  0 rom</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们可以看到新增了一个sdc。</p><p>如果确定sdc和iSCSI target的关系呢:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m session -P 3</span><br></pre></td></tr></tbody></table></figure><p></p><p>比如之前的输出, sde这块磁盘即iSCSI，来自 10.16.172.247:3260的Target: iqn.2018-11.com:BEAN<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># iscsiadm -m session -P 3</span></span><br><span class="line">iSCSI Transport Class version 2.0-870</span><br><span class="line">version 2.0-871</span><br><span class="line">Target: iqn.2018-11.com:BEAN</span><br><span class="line">Current Portal: 10.16.172.247:3260,1</span><br><span class="line">Persistent Portal: 10.16.172.247:3260,1</span><br><span class="line">**********</span><br><span class="line">Interface:</span><br><span class="line">**********</span><br><span class="line">Iface Name: default</span><br><span class="line">Iface Transport: tcp</span><br><span class="line">Iface Initiatorname: iqn.1993-08.org.debian:01:c9c12dd76e</span><br><span class="line">Iface IPaddress: 10.16.172.242</span><br><span class="line">Iface HWaddress: (null)</span><br><span class="line">Iface Netdev: (null)</span><br><span class="line">SID: 2</span><br><span class="line">iSCSI Connection State: LOGGED IN</span><br><span class="line">iSCSI Session State: LOGGED_IN</span><br><span class="line">Internal iscsid Session State: NO CHANGE</span><br><span class="line">************************</span><br><span class="line">Negotiated iSCSI params:</span><br><span class="line">************************</span><br><span class="line">HeaderDigest: None</span><br><span class="line">DataDigest: None</span><br><span class="line">MaxRecvDataSegmentLength: 262144</span><br><span class="line">MaxXmitDataSegmentLength: 1048576</span><br><span class="line">FirstBurstLength: 262144</span><br><span class="line">MaxBurstLength: 1048576</span><br><span class="line">ImmediateData: Yes</span><br><span class="line">InitialR2T: No</span><br><span class="line">MaxOutstandingR2T: 1</span><br><span class="line">************************</span><br><span class="line">Attached SCSI devices:</span><br><span class="line">************************</span><br><span class="line">Host Number: 25State: running</span><br><span class="line">scsi25 Channel 00 Id 0 Lun: 0</span><br><span class="line">        Attached scsi disk sdeState: running</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i通过ipmitool获取各元件的温度信息和检查电源模块状态</title>
      <link href="/2019/03/11/ipmitool/"/>
      <url>/2019/03/11/ipmitool/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="ipmitool可以获取各个元件的温度信息，如何判断各个组件的温度信息，各个组件的温度信息是否OK，有没有温度过高或者过低的元件需要告警？"><a href="#ipmitool可以获取各个元件的温度信息，如何判断各个组件的温度信息，各个组件的温度信息是否OK，有没有温度过高或者过低的元件需要告警？" class="headerlink" title="ipmitool可以获取各个元件的温度信息，如何判断各个组件的温度信息，各个组件的温度信息是否OK，有没有温度过高或者过低的元件需要告警？"></a>ipmitool可以获取各个元件的温度信息，如何判断各个组件的温度信息，各个组件的温度信息是否OK，有没有温度过高或者过低的元件需要告警？</h4><h2 id="获取各个元件温度的方法"><a href="#获取各个元件温度的方法" class="headerlink" title="获取各个元件温度的方法"></a>获取各个元件温度的方法</h2><h4 id="我们可以通过如下指令获取所有元件的温度信息和相关的状态"><a href="#我们可以通过如下指令获取所有元件的温度信息和相关的状态" class="headerlink" title="我们可以通过如下指令获取所有元件的温度信息和相关的状态"></a>我们可以通过如下指令获取所有元件的温度信息和相关的状态</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># ipmitool sensor list </span></span><br><span class="line">CPU1 Temp        | 29.000     | degrees C  | ok    | 0.000     | 0.000     | 0.000     | 85.000    | 90.000    | 90.000    </span><br><span class="line">CPU2 Temp        | 33.000     | degrees C  | nr    | 10.000    | 10.000    | 10.000    | 30.000    | 30.000    | 30.000    </span><br><span class="line">PCH Temp         | 32.000     | degrees C  | ok    | 0.000     | 5.000     | 16.000    | 90.000    | 95.000    | 100.000   </span><br><span class="line">System Temp      | 30.000     | degrees C  | ok    | -10.000   | -5.000    | 0.000     | 80.000    | 85.000    | 90.000    </span><br><span class="line">Peripheral Temp  | 34.000     | degrees C  | ok    | -10.000   | -5.000    | 0.000     | 80.000    | 85.000    | 90.000    </span><br><span class="line">Vcpu1VRM Temp    | 28.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 95.000    | 100.000   | 105.000   </span><br><span class="line">Vcpu2VRM Temp    | 34.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 95.000    | 100.000   | 105.000   </span><br><span class="line">VmemABVRM Temp   | 29.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 95.000    | 100.000   | 105.000   </span><br><span class="line">VmemCDVRM Temp   | 28.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 95.000    | 100.000   | 105.000   </span><br><span class="line">VmemEFVRM Temp   | 31.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 95.000    | 100.000   | 105.000   </span><br><span class="line">VmemGHVRM Temp   | 30.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 95.000    | 100.000   | 105.000   </span><br><span class="line">P1-DIMMA1 Temp   | 27.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 80.000    | 85.000    | 90.000    </span><br><span class="line">P1-DIMMA2 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P1-DIMMB1 Temp   | 27.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 80.000    | 85.000    | 90.000    </span><br><span class="line">P1-DIMMB2 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P1-DIMMC1 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P1-DIMMC2 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P1-DIMMD1 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P1-DIMMD2 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P2-DIMME1 Temp   | 29.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 80.000    | 85.000    | 90.000    </span><br><span class="line">P2-DIMME2 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P2-DIMMF1 Temp   | 30.000     | degrees C  | ok    | -5.000    | 0.000     | 5.000     | 80.000    | 85.000    | 90.000    </span><br><span class="line">P2-DIMMF2 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P2-DIMMG1 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P2-DIMMG2 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P2-DIMMH1 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">P2-DIMMH2 Temp   | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">FAN1             | 4400.000   | RPM        | ok    | 300.000   | 500.000   | 700.000   | 25300.000 | 25400.000 | 25500.000 </span><br><span class="line">FAN2             | 4300.000   | RPM        | ok    | 300.000   | 500.000   | 700.000   | 25300.000 | 25400.000 | 25500.000 </span><br><span class="line">FAN3             | 4400.000   | RPM        | ok    | 300.000   | 500.000   | 700.000   | 25300.000 | 25400.000 | 25500.000 </span><br><span class="line">FAN4             | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">FAN5             | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">FAN6             | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">FANA             | 4400.000   | RPM        | ok    | 300.000   | 500.000   | 700.000   | 25300.000 | 25400.000 | 25500.000 </span><br><span class="line">FANB             | na         |            | na    | na        | na        | na        | na        | na        | na        </span><br><span class="line">12V              | 12.315     | Volts      | ok    | 10.173    | 10.299    | 10.740    | 12.945    | 13.260    | 13.386    </span><br><span class="line">5VCC             | 5.000      | Volts      | ok    | 4.246     | 4.298     | 4.480     | 5.390     | 5.546     | 5.598     </span><br><span class="line">3.3VCC           | 3.316      | Volts      | ok    | 2.789     | 2.823     | 2.959     | 3.554     | 3.656     | 3.690     </span><br><span class="line">VBAT             | 3.104      | Volts      | ok    | 2.376     | 2.480     | 2.584     | 3.494     | 3.598     | 3.676     </span><br><span class="line">Vcpu1            | 1.800      | Volts      | ok    | 1.242     | 1.260     | 1.395     | 1.899     | 2.088     | 2.106     </span><br><span class="line">Vcpu2            | 1.809      | Volts      | ok    | 1.242     | 1.260     | 1.395     | 1.899     | 2.088     | 2.106     </span><br><span class="line">VDIMMAB          | 1.200      | Volts      | ok    | 0.948     | 0.975     | 1.047     | 1.344     | 1.425     | 1.443     </span><br><span class="line">VDIMMCD          | 1.209      | Volts      | ok    | 0.948     | 0.975     | 1.047     | 1.344     | 1.425     | 1.443     </span><br><span class="line">VDIMMEF          | 1.209      | Volts      | ok    | 0.948     | 0.975     | 1.047     | 1.344     | 1.425     | 1.443     </span><br><span class="line">VDIMMGH          | 1.209      | Volts      | ok    | 0.948     | 0.975     | 1.047     | 1.344     | 1.425     | 1.443     </span><br><span class="line">5VSB             | 4.974      | Volts      | ok    | 4.246     | 4.298     | 4.480     | 5.390     | 5.546     | 5.598     </span><br><span class="line">3.3VSB           | 3.316      | Volts      | ok    | 2.789     | 2.823     | 2.959     | 3.554     | 3.656     | 3.690     </span><br><span class="line">1.5V PCH         | 1.509      | Volts      | ok    | 1.320     | 1.347     | 1.401     | 1.644     | 1.671     | 1.698     </span><br><span class="line">1.2V BMC         | 1.209      | Volts      | ok    | 1.020     | 1.047     | 1.092     | 1.344     | 1.371     | 1.398     </span><br><span class="line">1.05V PCH        | 1.050      | Volts      | ok    | 0.870     | 0.897     | 0.942     | 1.194     | 1.221     | 1.248     </span><br><span class="line">Chassis Intru    | 0x0        | discrete   | 0x0000| na        | na        | na        | na        | na        | na        </span><br><span class="line">PS1 Status       | 0x1        | discrete   | 0x0100| na        | na        | na        | na        | na        | na        </span><br><span class="line">PS2 Status       | 0x1        | discrete   | 0x0100| na        | na        | na        | na        | na        | na        </span><br><span class="line">AOC_SAS Temp     | 60.000     | degrees C  | ok    | -11.000   | -8.000    | -5.000    | 100.000   | 105.000   | 110.000   </span><br><span class="line">HDD Temp         | 29.000     | degrees C  | ok    | -11.000   | -8.000    | -5.000    | 50.000    | 55.000    | 60.000    </span><br><span class="line">HDD Status       | 0x1        | discrete   | 0x01ff| na        | na        | na        | na        | na        | na</span><br></pre></td></tr></tbody></table></figure><p>一般来讲，第三列的值中有degree的，我们统计的是温度信息。</p><ul><li>第一列： 传感器的名称，比如CPU1 Temp，</li><li>第二列: 该元件的当前温度值，注意有时候会是na，即取不到。</li><li>第四列： 温度的状态信息，ok表示温度正常，有时候该状态值为nr，为non-recovery，不可恢复的意思</li></ul><p>一般来讲，常见的温度状态有以下5种：</p><ul><li>ok：温度正常</li><li>nc： non-critical，温度偏高（或者偏低），但是并不太严重</li><li>cr：critical，温度太高或者温度太低，很严重</li><li>nr： non-recovery，温度太高或者温度太低，造成不可恢复的损伤。</li><li>na：温度状态不明，比较少见。<blockquote><p>注意ok –> nc –> cr –> nr 从正常，到越来越严重的温度问题。</p></blockquote></li></ul><h2 id="如何触发温度告警"><a href="#如何触发温度告警" class="headerlink" title="如何触发温度告警"></a>如何触发温度告警</h2><p>介绍了nc cr 和nr三种状态，都说温度偏高或者温度偏低，那么</p><ul><li>温度到什么程度状态会变成nc，</li><li>温度到什么程度会变成cr</li><li>温度到什么程度会变成nr</li></ul><p>显然，各个元件的状态改变是有温度门限值的，我们可以通过如下方法查看：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># ipmitool sensor get "CPU1 Temp"</span></span><br><span class="line">Locating sensor record...</span><br><span class="line">Sensor ID              : CPU1 Temp (0x1)</span><br><span class="line"> Entity ID             : 3.1 (Processor)</span><br><span class="line"> Sensor Type (Threshold)  : Temperature (0x01)</span><br><span class="line"> Sensor Reading        : 29 (+/- 0) degrees C</span><br><span class="line"> Status                : ok</span><br><span class="line"> Nominal Reading       : 40.000</span><br><span class="line"> Normal Minimum        : -4.000</span><br><span class="line"> Normal Maximum        : 89.000</span><br><span class="line"> Upper non-recoverable : 90.000</span><br><span class="line"> Upper critical        : 90.000</span><br><span class="line"> Upper non-critical    : 85.000</span><br><span class="line"> Lower non-recoverable : 0.000</span><br><span class="line"> Lower critical        : 0.000</span><br><span class="line"> Lower non-critical    : 0.000</span><br><span class="line"> Positive Hysteresis   : 2.000</span><br><span class="line"> Negative Hysteresis   : 2.000</span><br><span class="line"> Minimum sensor range  : Unspecified</span><br><span class="line"> Maximum sensor range  : Unspecified</span><br><span class="line"> Event Message Control : Per-threshold</span><br><span class="line"> Readable Thresholds   : lnr lcr lnc unc ucr unr </span><br><span class="line"> Settable Thresholds   : lnr lcr lnc unc ucr unr </span><br><span class="line"> Threshold Read Mask   : lnr lcr lnc unc ucr unr </span><br><span class="line"> Assertion Events      : </span><br><span class="line"> Assertions Enabled    : ucr+ </span><br><span class="line"> Deassertions Enabled  : ucr+</span><br></pre></td></tr></tbody></table></figure><p></p><p>从上面的信息可以看出：</p><ul><li>Upper non-critical 85 度</li><li>Upper critical 90 度</li><li>Upper non-recovery 90 度</li><li>Lower non-critical 0 度</li><li>Lower critical 0 度</li><li>Lower non-recoverable</li></ul><p>有了门限值，是哪种状态就比较简单了。</p><ul><li>[0,85]之间是，状态ok</li><li>[85,90] 状态为nc</li><li>[90,] 状态为nr （因为cr的门限和nr的门限都是90，状态取nr）</li></ul><p>低温的情况也是类似。</p><p>如何让温度状态告警呢，即变成nc或者cr或者nr状态呢？</p><p>ipmitool提供了方法来设置各个状态的门限值。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipmitool -I open sensor thresh <span class="string">'CPU2 Temp'</span> upper 20 30 90</span><br></pre></td></tr></tbody></table></figure><p></p><p>上述指令的意思是将CPU2 Temp元件的告警门限中的温度上限告警门限设置为20 30 和90.</p><p>以为CPU的温度是33度左右，我们可以通过如下指令，将状态变为nc：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># ipmitool -I open sensor thresh 'CPU2 Temp' upper 20 40 90</span></span><br><span class="line">Locating sensor record <span class="string">'CPU2 Temp'</span>...</span><br><span class="line">Setting sensor <span class="string">"CPU2 Temp"</span> Upper Non-Critical threshold to 20.000</span><br><span class="line">Setting sensor <span class="string">"CPU2 Temp"</span> Upper Critical threshold to 40.000</span><br><span class="line">Setting sensor <span class="string">"CPU2 Temp"</span> Upper Non-Recoverable threshold to 90.000</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># ipmitool sensor list</span></span><br><span class="line">CPU2 Temp        | 33.000     | degrees C  | nc    | 10.000    | 10.000    | 10.000    | 20.000    | 40.000    | 90.000</span><br></pre></td></tr></tbody></table></figure><p>33摄氏度，超过了20度，但是没要超过40度，因此状态是nc，即non-critical。</p><p>同样道理，我们将告警门限设置为 20 30 90的话，就会发现状态为cr，即critical：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># ipmitool -I open sensor thresh 'CPU2 Temp' upper 20 30 90</span></span><br><span class="line">Locating sensor record <span class="string">'CPU2 Temp'</span>...</span><br><span class="line">Setting sensor <span class="string">"CPU2 Temp"</span> Upper Non-Critical threshold to 20.000</span><br><span class="line">Setting sensor <span class="string">"CPU2 Temp"</span> Upper Critical threshold to 30.000</span><br><span class="line">Setting sensor <span class="string">"CPU2 Temp"</span> Upper Non-Recoverable threshold to 90.000</span><br><span class="line"></span><br><span class="line">root@node:~<span class="comment"># ipmitool sensor list </span></span><br><span class="line">CPU1 Temp        | 30.000     | degrees C  | ok    | 0.000     | 0.000     | 0.000     | 85.000    | 90.000    | 90.000    </span><br><span class="line">CPU2 Temp        | 33.000     | degrees C  | cr    | 10.000    | 10.000    | 10.000    | 20.000    | 30.000    | 90.000</span><br></pre></td></tr></tbody></table></figure><p></p><p>同样道理，可以将状态变成nr，只需要设置门限为20 30 30 ，即可。</p><h2 id="检查电源模块状态"><a href="#检查电源模块状态" class="headerlink" title="检查电源模块状态"></a>检查电源模块状态</h2><p>我们知道IPMI很强大，如何利用ipmitool获取到电源的实施状态的。现代的服务器，基本上都有两个电源模块，作为冗余。如何查看电源的状态信息呢，是否所有的电源模块都已启用，电源是否都通电？</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><h4 id="通过如下指令可以获取到电源的状态信息："><a href="#通过如下指令可以获取到电源的状态信息：" class="headerlink" title="通过如下指令可以获取到电源的状态信息："></a>通过如下指令可以获取到电源的状态信息：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipmitool sdr <span class="built_in">type</span> <span class="string">"power supply"</span></span><br></pre></td></tr></tbody></table></figure><p>正常情况下电源的状态如下所示<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS1 Status       | C4h | ok  | 10.1 | Presence detected</span><br><span class="line">PS2 Status       | C5h | ok  | 10.2 | Presence detected</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果，我们将其中一个拔掉电源插头，状态就会如下所示：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS1 Status       | C4h | ok  | 10.1 | Presence detected</span><br><span class="line">PS2 Status       | C5h | ok  | 10.2 | Presence detected, Failure detected, Power Supply AC lost</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果我们将其中一个的电源模块(PSU, power supply unit)直接从服务器上拔出，状态就会如下所示：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS1 Status       | C4h | ok  | 10.1 | Presence detected</span><br><span class="line">PS2 Status       | C5h | ok  | 10.2 |</span><br></pre></td></tr></tbody></table></figure><p></p><p>事实上除了上面的几种，我们可以通过<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipmitool sensor get <span class="string">"PS1 Status"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>查看其他可能的值<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Sensor ID              : PS1 Status (0xc4)</span><br><span class="line">Entity ID             : 10.1 (Power Supply)</span><br><span class="line">Sensor Type (Discrete): Power Supply (0x08)</span><br><span class="line">Sensor Reading        : 1h                    <-------------这个值是方法2提到0x01 ，即正常状态</span><br><span class="line">Event Message Control : Per-threshold</span><br><span class="line">States Asserted       : Power Supply</span><br><span class="line">                        [Presence detected]</span><br><span class="line">Assertion Events      : Power Supply</span><br><span class="line">                        [Presence detected]</span><br><span class="line">Deassertion Events    : Power Supply</span><br><span class="line">                        [Failure detected]</span><br><span class="line">Assertions Enabled    : Power Supply</span><br><span class="line">                        [Failure detected]</span><br><span class="line">                        [Power Supply AC lost]</span><br><span class="line">                        [AC lost or out-of-range]</span><br><span class="line">                        [AC out-of-range, but present]</span><br><span class="line">                        [Config Error]</span><br><span class="line">Deassertions Enabled  : Power Supply</span><br><span class="line">                        [Failure detected]</span><br><span class="line">                        [Power Supply AC lost]</span><br><span class="line">                        [AC lost or out-of-range]</span><br><span class="line">                        [AC out-of-range, but present]</span><br><span class="line">                        [Config Error]</span><br><span class="line">OEM                   : 0</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><h4 id="从如下指令也可以获得电源模块的信息："><a href="#从如下指令也可以获得电源模块的信息：" class="headerlink" title="从如下指令也可以获得电源模块的信息："></a>从如下指令也可以获得电源模块的信息：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipmitool sensor list</span><br></pre></td></tr></tbody></table></figure><p>输出如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS1 Status       | 0x1        | discrete   | 0x0100| na        | na        | na        | na        | na        | na        </span><br><span class="line">PS2 Status       | 0x1        | discrete   | 0x0100| na        | na        | na        | na        | na        | na</span><br></pre></td></tr></tbody></table></figure><p></p><p>第二列的值很有意思</p><ul><li>0x01 status ok，最常见的状态</li><li>0x00 power supply unit not present ，即电源模块不存在，一般电源模块从服务器中拔出，状态是0x00</li><li>0x03 power supply off or failed，我没有遇到过这种状态，我猜是电源模块坏了的时候，会是这种状态</li><li>0x0b input out of range（ex. No AC input）这也是很常见的状态，把电源的插头拔掉，就会是这种状态。</li></ul><p>这种方法比较好，个人比较推荐这种方法。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://support.hpe.com/hpsc/doc/public/display?docId=emr_na-sg8039en_us&docLocale=en_US" target="_blank" rel="noopener">IPMItool Sometimes Fails to Detect Power Supply Failures on Rackable Nodes</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谁连了我的NFS目录</title>
      <link href="/2019/03/11/showmount/"/>
      <url>/2019/03/11/showmount/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有些时候，作为NFS Server，需要了解哪些client端连了我的NFS 目录，这时候，showmount命令就闪亮登场了。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>showmount -a 可以查看，当前到底有哪些client连接了本Server exports的目录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@node <span class="comment"># showmount -a </span></span><br><span class="line">All mount points on Storage-b3:</span><br><span class="line">10.1.226.105:/var/share/ezfs/shareroot/mgt</span><br><span class="line">10.1.227.1:/var/share/ezfs/shareroot/backup</span><br><span class="line">10.1.227.201:/var/share/ezfs/shareroot/mgt</span><br><span class="line">10.1.227.2:/var/share/ezfs/shareroot/backup</span><br><span class="line">10.1.227.3:/var/share/ezfs/shareroot/backup</span><br><span class="line">10.1.227.81:/var/share/ezfs/shareroot/mgt</span><br><span class="line">10.1.227.85:/var/share/ezfs/shareroot/mgt</span><br><span class="line">10.1.232.199:/var/share/ezfs/shareroot/mgt</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>showmount是一个比较综合的命令，还有很多其它的用法。可以通过man 查看。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解iostat</title>
      <link href="/2019/03/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iostat/"/>
      <url>/2019/03/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iostat/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="iostat算是比较重要的查看块设备运行状态的工具，相信大多数使用Linux的同学都用过这个工具，或者听说过这个工具。但是对于这个工具，引起的误解也是最多的，大多数人对这个工具处于朦朦胧胧的状态。现在我们由浅到深地介绍这个工具，它输出的含义什么，介绍它的能力边界，介绍关于这个工具的常见误解。"><a href="#iostat算是比较重要的查看块设备运行状态的工具，相信大多数使用Linux的同学都用过这个工具，或者听说过这个工具。但是对于这个工具，引起的误解也是最多的，大多数人对这个工具处于朦朦胧胧的状态。现在我们由浅到深地介绍这个工具，它输出的含义什么，介绍它的能力边界，介绍关于这个工具的常见误解。" class="headerlink" title="iostat算是比较重要的查看块设备运行状态的工具，相信大多数使用Linux的同学都用过这个工具，或者听说过这个工具。但是对于这个工具，引起的误解也是最多的，大多数人对这个工具处于朦朦胧胧的状态。现在我们由浅到深地介绍这个工具，它输出的含义什么，介绍它的能力边界，介绍关于这个工具的常见误解。"></a>iostat算是比较重要的查看块设备运行状态的工具，相信大多数使用Linux的同学都用过这个工具，或者听说过这个工具。但是对于这个工具，引起的误解也是最多的，大多数人对这个工具处于朦朦胧胧的状态。现在我们由浅到深地介绍这个工具，它输出的含义什么，介绍它的能力边界，介绍关于这个工具的常见误解。</h3><h2 id="基本用法和输出的基本含义"><a href="#基本用法和输出的基本含义" class="headerlink" title="基本用法和输出的基本含义"></a>基本用法和输出的基本含义</h2><h4 id="iostat的用法比较简单，一般来说用法如下："><a href="#iostat的用法比较简单，一般来说用法如下：" class="headerlink" title="iostat的用法比较简单，一般来说用法如下："></a>iostat的用法比较简单，一般来说用法如下：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -mtx 2</span><br></pre></td></tr></tbody></table></figure><h6 id="含义是说，每2秒钟采集一组数据："><a href="#含义是说，每2秒钟采集一组数据：" class="headerlink" title="含义是说，每2秒钟采集一组数据："></a>含义是说，每2秒钟采集一组数据：</h6><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-m     Display statistics <span class="keyword">in</span> megabytes per second.</span><br><span class="line">-t     Print the time <span class="keyword">for</span> each report displayed. The timestamp format may depend on the value of the S_TIME_FORMAT environment variable (see below).</span><br><span class="line">-x     Display extended statistics.</span><br></pre></td></tr></tbody></table></figure><h6 id="输出的结果如下所示："><a href="#输出的结果如下所示：" class="headerlink" title="输出的结果如下所示："></a>输出的结果如下所示：</h6><img src="/2019/03/11/深入理解iostat/single_disk_randw_4k_iops_5000_t.png" title="single_disk_randw_4k_iops_5000_t"><h6 id="注意，上图是在对sdc这块单盘（RAID卡上的单盘）做4KB的随机写入测试："><a href="#注意，上图是在对sdc这块单盘（RAID卡上的单盘）做4KB的随机写入测试：" class="headerlink" title="注意，上图是在对sdc这块单盘（RAID卡上的单盘）做4KB的随机写入测试："></a>注意，上图是在对sdc这块单盘（RAID卡上的单盘）做4KB的随机写入测试：</h6><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=randwrite --rw=randwrite --bs=4k --size=20G --runtime=1200 --ioengine=libaio --iodepth=64 --numjobs=1 --rate_iops=5000 --filename=/dev/sdf --direct=1 --group_reporting</span><br></pre></td></tr></tbody></table></figure><p>因此上图中只有sdc在忙。<br>如何阅读iostat的输出，各个参数都是什么含义，反映了磁盘的什么信息？<br>第一列Device比较容易理解，就是说这一行描述的是哪一个设备。</p><ul><li>rrqm/s :  每秒合并读操作的次数</li><li>wrqm/s:   每秒合并写操作的次数</li><li>r/s ：     每秒读操作的次数</li><li>w/s :     每秒写操作的次数</li><li>rMB/s :   每秒读取的MB字节数</li><li>wMB/s:    每秒写入的MB字节数</li><li>avgrq-sz：  每个IO的平均扇区数，即所有请求的平均大小，以扇区（512字节）为单位</li><li>avgqu-sz：   平均为完成的IO请求数量，即平均意义山的请求队列长度</li></ul><ul><li>await：      平均每个IO所需要的时间，包括在队列等待的时间，也包括磁盘控制器处理本次请求的有效时间。<ul><li>r_wait：     每个读操作平均所需要的时间，不仅包括硬盘设备读操作的时间，也包括在内核队列中的时间。</li><li>w_wait:      每个写操平均所需要的时间，不仅包括硬盘设备写操作的时间，也包括在队列中等待的时间。</li></ul></li></ul><ul><li>svctm：      表面看是每个IO请求的服务时间，不包括等待时间，但是实际上，这个指标已经废弃。实际上，iostat工具没有任何一输出项表示的是硬盘设备平均每次IO的时间。</li><li>%util：      工作时间或者繁忙时间占总时间的百分比</li></ul><h4 id="avgqu-sz-和繁忙程度"><a href="#avgqu-sz-和繁忙程度" class="headerlink" title="avgqu-sz    和繁忙程度"></a><strong>avgqu-sz    和繁忙程度</strong></h4><p>首先我们用超市购物来比对iostat的输出。我们在超市结账的时候，一般会有很多队可以排，队列的长度，在一定程度上反应了该收银柜台的繁忙程度。那么这个变量是avgqu-sz这个输出反应的，该值越大，表示排队等待处理的io越多。</p><p>我们搞4K的随机IO，但是iodepth=1 ，查看下fio的指令和iostat的输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=randwrite --rw=randwrite --bs=4k --size=20G --runtime=1200 --ioengine=libaio --iodepth=1 --numjobs=1 --filename=/dev/sdc --direct=1 --group_reporting</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/03/11/深入理解iostat/single_disk_randw_4k_iodepth_1.png" title="single_disk_randw_4k_iodepth_1"><p>同样是4K的随机IO，我们设置iodepth=16， 查看fio的指令和iostat的输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=randwrite --rw=randwrite --bs=4k --size=20G --runtime=1200 --ioengine=libaio --iodepth=16 --numjobs=1 --filename=/dev/sdc --direct=1 --group_reporting</span><br></pre></td></tr></tbody></table></figure><p></p><img src="/2019/03/11/深入理解iostat/single_disk_randw_4k_iodepth_16.png" title="single_disk_randw_4k_iodepth_16"><h6 id="注意-sdc的avgrq-sz这列的值，变成了256，即256-个扇区-256-512-Byte-128KB，等于我们fio测试时，下达的bs-128k。"><a href="#注意-sdc的avgrq-sz这列的值，变成了256，即256-个扇区-256-512-Byte-128KB，等于我们fio测试时，下达的bs-128k。" class="headerlink" title="注意 sdc的avgrq-sz这列的值，变成了256，即256 个扇区 = 256* 512 Byte = 128KB，等于我们fio测试时，下达的bs = 128k。"></a>注意 sdc的avgrq-sz这列的值，变成了256，即256 个扇区 = 256* 512 Byte = 128KB，等于我们fio测试时，下达的bs = 128k。</h6><h6 id="注意，这个值也不是为所欲为的，它受内核参数的控制："><a href="#注意，这个值也不是为所欲为的，它受内核参数的控制：" class="headerlink" title="注意，这个值也不是为所欲为的，它受内核参数的控制："></a>注意，这个值也不是为所欲为的，它受内核参数的控制：</h6><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@node1:~<span class="comment"># cat  /sys/block/sdc/queue/max_sectors_kb </span></span><br><span class="line">256</span><br><span class="line"><span class="comment">#这个值不是最大下发的IO是256KB，即512个扇区。当我们fio对sdc这块盘做测试的时候，如果bs=256k，iostat输出中的avgrq-sz 会变成 512 扇区，但是，如果继续增大bs，比如bs=512k，那么iostat输出中的avgrq-sz不会继续增大，仍然是512，表示512扇区。</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=randwrite --rw=randwrite --bs=512k --size=20G --runtime=1200 --ioengine=libaio --iodepth=1 --numjobs=1 --filename=/dev/sdc --direct=1 --group_reporting</span><br></pre></td></tr></tbody></table></figure><img src="/2019/03/11/深入理解iostat/single_disk_randw_512k_iodepth_1.png" title="single_disk_randw_512k_iodepth_1"><h6 id="注意，本来512KB等于1024个扇区，avgrq-sz应该为1204，但是由于内核的max-sectors-kb控制参数，决定了不可能："><a href="#注意，本来512KB等于1024个扇区，avgrq-sz应该为1204，但是由于内核的max-sectors-kb控制参数，决定了不可能：" class="headerlink" title="注意，本来512KB等于1024个扇区，avgrq-sz应该为1204，但是由于内核的max_sectors_kb控制参数，决定了不可能："></a>注意，本来512KB等于1024个扇区，avgrq-sz应该为1204，但是由于内核的max_sectors_kb控制参数，决定了不可能：</h6><p>另外一个需要注意也不难理解的现象是，io请求越大，需要消耗的时间就会越长。对于块设备而言，时间分成2个部分：</p><ul><li>寻道</li><li>读或写操作<br>注意此处的寻道不能简单地理解成磁盘磁头旋转到指定位置，因为后备块设备可能是RAID，可能是SSD，我们理解写入前的准备动作。准备工作完成之后，写入4K和写入128KB，明显写入128KB的工作量要更大一些，因此很容易理解随机写入128KB给块设备带来的负载要比随机写入4K给块设备带来的负载要高一些。</li></ul><p>对比生活中的例子，超时排队的时候，你会首先查看队列的长度来评估下时间，如果队列都差不多长的情况下，你就要关心前面顾客篮子里东西的多少了。如果前面顾客每人手里拿着一两件商品，另一队几乎每一个人都推这满满一车子的商品，你可能知道要排那一队。因为商品越多，处理单个顾客的时间就会越久。IO也是如此。</p><h4 id="rrqm-s-和wrqm-s"><a href="#rrqm-s-和wrqm-s" class="headerlink" title="rrqm/s 和wrqm/s"></a>rrqm/s 和wrqm/s</h4><p>块设备有相应的调度算法。如果两个IO发生在相邻的数据块时，他们可以合并成1个IO。</p><p>这个简单的可以理解为快递员要给一个18层的公司所有员工送快递，每一层都有一些包裹，对于快递员来说，最好的办法是同一楼层相近的位置的包裹一起投递，否则如果不采用这种算法，采用最原始的来一个送一个（即noop算法），那么这个快递员，可能先送了一个包括到18层，又不得不跑到2层送另一个包裹，然后有不得不跑到16层送第三个包裹，然后包到1层送第三个包裹，那么快递员的轨迹是杂乱无章的，也是非常低效的。</p><p>Linux常见的调度算法有:</p><ul><li>noop</li><li>deadline</li><li>cfq</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node:~<span class="comment"># cat /sys/block/sdc/queue/scheduler </span></span><br><span class="line">[noop] deadline cfq</span><br></pre></td></tr></tbody></table></figure><h4 id="类比总结"><a href="#类比总结" class="headerlink" title="类比总结"></a>类比总结</h4><p>我们还是以超时购物为例，比如一家三口去购物，各人买各人的东西，最终会汇总到收银台，你固然可以每人各自付各自的，但是也可以汇总一下，把所有购买的东西放在一起，由一个人来完成，也就说，三次收银事件merge成了一次。</p><p>至此，我们以超时购物收银为例，介绍了avgqu-sz 类比于队伍的长度，avgrq-sz 类比于每个人购物车里物品的多少，rrqm/s和wrqm/s 类比于将一家购得东西汇总一起，付费一次。还有svctm和%util两个没有介绍。</p><p>按照我们的剧情，我们自然而然地可以将svctm类比成收银服务员服务每个客户需要的平均时间，%util类比成收银服务员工作的繁忙程度。</p><p>注意这个类比是错误的，就是因为类似的类比，容易让人陷入误区不能自拔。不能简单地将svctm理解成单个IO被块设备处理的有效时间，同时不能理解成%util到了100% ，磁盘工作就饱和了，不能继续提升了，这是两个常见的误区。</p><p>svctm和%util是iostat最容易引起误解的两个输出。为了准确地评估块设备的能力，我们希望得到这样一个数值：即一个io从发给块设备层到完成这个io的时间，不包括其他在队列等待的时间。从表面看，svctm就是这个值。实际上并非如此。</p><p>Linux下iostat输出的svctm并不具备这方面的含义，这个指标应该非废弃。iostat和sar的man page都有这方面的警告：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svctm</span><br><span class="line">The average  service time (<span class="keyword">in</span> milliseconds) <span class="keyword">for</span> I/O requests that were issued to the device. Warning! Do not trust this field any more.  This field will be removed <span class="keyword">in</span> a future sysstat version.</span><br></pre></td></tr></tbody></table></figure><p></p><p>那么iostat输出中的svctm到底是怎么来的，%util又是怎么算出来的，进而iostat的输出的各个字段都是从哪里拿到的信息呢？</p><h2 id="iostat输出的数据来源diskstats"><a href="#iostat输出的数据来源diskstats" class="headerlink" title="iostat输出的数据来源diskstats"></a>iostat输出的数据来源diskstats</h2><h4 id="iostat数据的来源是-Linux-操作系统的-proc-diskstats"><a href="#iostat数据的来源是-Linux-操作系统的-proc-diskstats" class="headerlink" title="iostat数据的来源是 Linux 操作系统的 /proc/diskstats"></a>iostat数据的来源是 Linux 操作系统的 /proc/diskstats</h4><img src="/2019/03/11/深入理解iostat/proc_diskstats.png" title="proc_diskstats"><h6 id="注意，procfs中的前三个字段：主设备号、从设备号、设备名。"><a href="#注意，procfs中的前三个字段：主设备号、从设备号、设备名。" class="headerlink" title="注意，procfs中的前三个字段：主设备号、从设备号、设备名。"></a>注意，procfs中的前三个字段：主设备号、从设备号、设备名。</h6><h5 id="从第四个字段开始，介绍的是该设备的相关统计："><a href="#从第四个字段开始，介绍的是该设备的相关统计：" class="headerlink" title="从第四个字段开始，介绍的是该设备的相关统计："></a>从第四个字段开始，介绍的是该设备的相关统计：</h5><ul><li>(rd_ios) : 读操作的次数</li><li>(rd_merges):合并读操作的次数。如果两个读操作读取相邻的数据块，那么可以被合并成1个。</li><li>(rd_sectors): 读取的扇区数量</li><li>(rd_ticks):读操作消耗的时间（以毫秒为单位）。每个读操作从__make_request()开始计时，到end_that_request_last()为止，包括了在队列中等待的时间。</li><li>(wr_ios):写操作的次数</li><li>(wr_merges):合并写操作的次数</li><li>(wr_sectors): 写入的扇区数量</li><li>(wr_ticks): 写操作消耗的时间（以毫秒为单位）</li><li>(in_flight): 当前未完成的I/O数量。在I/O请求进入队列时该值加1，在I/O结束时该值减1。 注意：是I/O请求进入队列时，而不是提交给硬盘设备时</li><li>(io_ticks)该设备用于处理I/O的自然时间(wall-clock time)</li><li>(time_in_queue): 对字段#10(io_ticks)的加权值</li></ul><h5 id="这些字段大多来自内核的如下数据："><a href="#这些字段大多来自内核的如下数据：" class="headerlink" title="这些字段大多来自内核的如下数据："></a>这些字段大多来自内核的如下数据：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include/linux/genhd.h</span><br><span class="line">struct disk_stats {</span><br><span class="line">        unsigned long sectors[2];       /* READs and WRITEs */</span><br><span class="line">        unsigned long ios[2];</span><br><span class="line">        unsigned long merges[2];</span><br><span class="line">        unsigned long ticks[2];</span><br><span class="line">        unsigned long io_ticks;</span><br><span class="line">        unsigned long time_in_queue;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="除了in-flight来自："><a href="#除了in-flight来自：" class="headerlink" title="除了in_flight来自："></a>除了in_flight来自：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">part_in_flight(hd), </span><br><span class="line">static inline int part_in_flight(struct hd_struct *part)</span><br><span class="line">{</span><br><span class="line">        return atomic_read(&part->in_flight[0]) + atomic_read(&part->in_flight[1]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="内核相关的代码如下："><a href="#内核相关的代码如下：" class="headerlink" title="内核相关的代码如下："></a>内核相关的代码如下：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">while ((hd = disk_part_iter_next(&piter))) {</span><br><span class="line">  cpu = part_stat_lock();</span><br><span class="line">  part_round_stats(cpu, hd);</span><br><span class="line">  part_stat_unlock();</span><br><span class="line">  seq_printf(seqf, "%4d %7d %s %lu %lu %llu "</span><br><span class="line">         "%u %lu %lu %llu %u %u %u %u\n",</span><br><span class="line">         MAJOR(part_devt(hd)), MINOR(part_devt(hd)),</span><br><span class="line">         disk_name(gp, hd->partno, buf),</span><br><span class="line">         part_stat_read(hd, ios[READ]),</span><br><span class="line">         part_stat_read(hd, merges[READ]),</span><br><span class="line">         (unsigned long long)part_stat_read(hd, sectors[READ]),</span><br><span class="line">         jiffies_to_msecs(part_stat_read(hd, ticks[READ])),</span><br><span class="line">         part_stat_read(hd, ios[WRITE]),</span><br><span class="line">         part_stat_read(hd, merges[WRITE]),</span><br><span class="line">         (unsigned long long)part_stat_read(hd, sectors[WRITE]),</span><br><span class="line">         jiffies_to_msecs(part_stat_read(hd, ticks[WRITE])),</span><br><span class="line">         part_in_flight(hd),</span><br><span class="line">         jiffies_to_msecs(part_stat_read(hd, io_ticks)),</span><br><span class="line">         jiffies_to_msecs(part_stat_read(hd, time_in_queue))</span><br><span class="line">      );</span><br></pre></td></tr></tbody></table></figure><h2 id="io-ticks-and-time-in-queue"><a href="#io-ticks-and-time-in-queue" class="headerlink" title="io_ticks and time_in_queue"></a>io_ticks and time_in_queue</h2><p>这里面大部分字段都是很容易理解的，稍微难理解的在于io_ticks。初看之下，明明已经有了rd_ticks和wr_ticks 为什么还需一个io_ticks。注意rd_ticks和wr_ticks是把每一个IO消耗时间累加起来，但是硬盘设备一般可以并行处理多个IO，因此，rd_ticks和wr_ticks之和一般会比自然时间（wall-clock time）要大。而io_ticks 不关心队列中有多少个IO在排队，它只关心设备有IO的时间。即不考虑IO有多少，只考虑IO有没有。在实际运算中，in_flight不是0的时候保持计时，而in_flight 等于0的时候，时间不累加到io_ticks。</p><p>下一个比较难理解的是time_in_queue这个值，它的计算是当前IO数量（即in_flight的值）乘以自然时间间隔。表面看该变量的名字叫time_in_queue，但是实际上，并不只是在队列中等待的时间。</p><p>有人不理解time_in_queue，但是我相信读过小学 听过下面这句话的小朋友都会理解time_in_queue：</p><blockquote><p>因为你上课讲话， 让老师批评你5分钟，班里有50人，50个人你就浪费了全班250分钟。</p></blockquote><p>这段话非常形象地介绍了time_in_queue的计算法则，即自然时间只过去了5分钟，但是对于队列中的所有同学，哦不，所有IO来说，需要加权计算：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void part_round_stats_single(int cpu, struct hd_struct *part,</span><br><span class="line">                  unsigned long now)</span><br><span class="line">{</span><br><span class="line">  if (now == part->stamp)</span><br><span class="line">      return;</span><br><span class="line">   </span><br><span class="line">  /*如果队列不为空，存在in_flight io*/</span><br><span class="line">  if (part_in_flight(part)) {</span><br><span class="line">     </span><br><span class="line">      /*小学数学老师的算法，now-part->stamp 乘以班级人数，哦不，是乘以队列中等待的io请求个数*/</span><br><span class="line">      __part_stat_add(cpu, part, time_in_queue,</span><br><span class="line">              part_in_flight(part) * (now - part->stamp));</span><br><span class="line">     </span><br><span class="line">     /*如实的记录，因为批评调皮学生，浪费了5分钟。io不是空的时间增加now - part->stamp*/</span><br><span class="line">      __part_stat_add(cpu, part, io_ticks, (now - part->stamp));</span><br><span class="line">  }</span><br><span class="line">  part->stamp = now;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>这个计算的方法很简单：</p><ul><li>当请求队列为空的时候<ul><li>io_ticks不增加</li><li>time_in_queue不增加</li><li>part->stamp 更新为now</li></ul></li><li>当请求队列不是空的时候<ul><li>io_ticks增加， 增加量为 now - part->timestamp</li><li>time_in_queue增加，增加量为 在队列中IO的个数乘以 (now - part->stamp)</li><li>part->stamp 更新为now</li></ul></li><li>注意调用part_round_stats_single函数的时机在于<ul><li>在新IO请求插入队列（被merge的不算）</li><li>完成一个IO请求</li></ul></li></ul><p>空说太过抽象，但是我们还是给出一个例子来介绍io_ticks和time_in_queue的计算</p><table><thead><tr><th style="text-align:right">ID Time</th><th style="text-align:center">Ops</th><th style="text-align:center">in_flight</th><th style="text-align:center">stamp</th><th style="text-align:center">stamp_delta</th><th style="text-align:center">io_ticks</th><th style="text-align:center">time_in_queue</th></tr></thead><tbody><tr><td style="text-align:right">0</td><td style="text-align:center">100 新请求入队列</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">无需计算</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:right">1</td><td style="text-align:center">100.10 新请求入队列</td><td style="text-align:center">1</td><td style="text-align:center">100</td><td style="text-align:center">100.10-100 = 0.1</td><td style="text-align:center">0.1</td><td style="text-align:center">0.1</td></tr><tr><td style="text-align:right">2</td><td style="text-align:center">101.20 完成一个IO请求</td><td style="text-align:center">2</td><td style="text-align:center">100.10</td><td style="text-align:center">101.20-100.10 = 1.1</td><td style="text-align:center">1.2</td><td style="text-align:center">0.1+1.1*2 = 2.3</td></tr><tr><td style="text-align:right">3</td><td style="text-align:center">103.60 完成一个IO请求</td><td style="text-align:center">1</td><td style="text-align:center">101.20</td><td style="text-align:center">103.60-101.20 = 2.4</td><td style="text-align:center">3.6</td><td style="text-align:center">2.3+2.4*1=4.7</td></tr><tr><td style="text-align:right">4</td><td style="text-align:center">153.60 新请求入队列</td><td style="text-align:center">0</td><td style="text-align:center">103.60</td><td style="text-align:center">无需计算</td><td style="text-align:center">3.6</td><td style="text-align:center">4.7</td></tr><tr><td style="text-align:right">5</td><td style="text-align:center">153.90 完成一个IO请求</td><td style="text-align:center">1</td><td style="text-align:center">153.60</td><td style="text-align:center">153.90 - 153.60 = 0.3</td><td style="text-align:center">3.9</td><td style="text-align:center">4.7+0.3 * 1= 5</td></tr></tbody></table><h6 id="注意上面总时间是53-90时间内，有3-9秒的自然时间内是有IO的，即IO队列的非空时间为3-9秒。"><a href="#注意上面总时间是53-90时间内，有3-9秒的自然时间内是有IO的，即IO队列的非空时间为3-9秒。" class="headerlink" title="注意上面总时间是53.90时间内，有3.9秒的自然时间内是有IO的，即IO队列的非空时间为3.9秒。"></a>注意上面总时间是53.90时间内，有3.9秒的自然时间内是有IO的，即IO队列的非空时间为3.9秒。</h6><blockquote><p>注意，io_ticks这个字段被iostat用来计算%util，而time_in_queue这个字段被iostat用来计算avgqu-sz，即平均队列长度。</p></blockquote><p>其实不难理解了，队列中不为空的时候占总时间的比例即为 %util</p><h2 id="proc-diskstats中其他数据项的更新"><a href="#proc-diskstats中其他数据项的更新" class="headerlink" title="/proc/diskstats中其他数据项的更新"></a>/proc/diskstats中其他数据项的更新</h2><h4 id="既然我们介绍了io-ticks和time-in-queue，我们也简单介绍下其他字段的获取。"><a href="#既然我们介绍了io-ticks和time-in-queue，我们也简单介绍下其他字段的获取。" class="headerlink" title="既然我们介绍了io_ticks和time_in_queue，我们也简单介绍下其他字段的获取。"></a>既然我们介绍了io_ticks和time_in_queue，我们也简单介绍下其他字段的获取。</h4><h4 id="在每个IO结束后，都会调用blk-account-io-done函数，这个函数会负责更新rd-ios-wr-ios、rd-ticks-wr-ticks-包括会更新in-flight。"><a href="#在每个IO结束后，都会调用blk-account-io-done函数，这个函数会负责更新rd-ios-wr-ios、rd-ticks-wr-ticks-包括会更新in-flight。" class="headerlink" title="在每个IO结束后，都会调用blk_account_io_done函数，这个函数会负责更新rd_ios/wr_ios、rd_ticks/wr_ticks ,包括会更新in_flight。"></a>在每个IO结束后，都会调用blk_account_io_done函数，这个函数会负责更新rd_ios/wr_ios、rd_ticks/wr_ticks ,包括会更新in_flight。</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void blk_account_io_done(struct request *req)</span><br><span class="line">{</span><br><span class="line">        /*   </span><br><span class="line">         * Account IO completion.  flush_rq isn't accounted as a</span><br><span class="line">         * normal IO on queueing nor completion.  Accounting the</span><br><span class="line">         * containing request is enough.</span><br><span class="line">         */</span><br><span class="line">        if (blk_do_io_stat(req) && !(req->rq_flags & RQF_FLUSH_SEQ)) {</span><br><span class="line">                unsigned long duration = jiffies - req->start_time;</span><br><span class="line">                /*从req获取请求类型：R / W*/</span><br><span class="line">                const int rw = rq_data_dir(req);</span><br><span class="line">                struct hd_struct *part;</span><br><span class="line">                int cpu; </span><br><span class="line"></span><br><span class="line">                cpu = part_stat_lock();</span><br><span class="line">                part = req->part;</span><br><span class="line">               /*更新读或写次数，自加*/</span><br><span class="line">                part_stat_inc(cpu, part, ios[rw]);</span><br><span class="line">                /*将io的存活时间，更新到rd_ticks or wr_ticks*/</span><br><span class="line">                part_stat_add(cpu, part, ticks[rw], duration);</span><br><span class="line">                /*更新io_ticks和time_in_queue*/</span><br><span class="line">                part_round_stats(cpu, part);</span><br><span class="line">                /*对应infight 减 1 */</span><br><span class="line">                part_dec_in_flight(part, rw); </span><br><span class="line"></span><br><span class="line">                hd_struct_put(part);</span><br><span class="line">                part_stat_unlock();</span><br><span class="line">        }                                                                                                                                              </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 注意part_round_stats会调用上一小节介绍的part_round_stats_single函数：</span><br><span class="line">```cgo</span><br><span class="line">void part_round_stats(int cpu, struct hd_struct *part)</span><br><span class="line">{</span><br><span class="line">       /*既要更新分区的统计，也要更新整个块设备的统计*/</span><br><span class="line">        unsigned long now = jiffies;</span><br><span class="line">        if (part->partno)</span><br><span class="line">                part_round_stats_single(cpu, &part_to_disk(part)->part0, now);</span><br><span class="line">        part_round_stats_single(cpu, part, now);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="读写扇区的个数统计，是在blk-account-io-completion函数中实现的："><a href="#读写扇区的个数统计，是在blk-account-io-completion函数中实现的：" class="headerlink" title="读写扇区的个数统计，是在blk_account_io_completion函数中实现的："></a>读写扇区的个数统计，是在blk_account_io_completion函数中实现的：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void blk_account_io_completion(struct request *req, unsigned int bytes)                             {</span><br><span class="line">        if (blk_do_io_stat(req)) {</span><br><span class="line">                const int rw = rq_data_dir(req);</span><br><span class="line">                struct hd_struct *part;</span><br><span class="line">                int cpu; </span><br><span class="line"></span><br><span class="line">                cpu = part_stat_lock();</span><br><span class="line">                part = req->part;</span><br><span class="line">                /*右移9位，相当于除以512字节，即一个扇区的字节数*/</span><br><span class="line">                part_stat_add(cpu, part, sectors[rw], bytes >> 9);</span><br><span class="line">                part_stat_unlock();</span><br><span class="line">        }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于merge部分的统计，在blk_account_io_start函数中统计：<br><img src="/2019/03/11/深入理解iostat/diskstats_merge.png" title="diskstats_merge"><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void blk_account_io_start(struct request *rq, bool new_io)</span><br><span class="line">{</span><br><span class="line">        struct hd_struct *part;</span><br><span class="line">        int rw = rq_data_dir(rq);                                             </span><br><span class="line">        int cpu;</span><br><span class="line">        </span><br><span class="line">        if (!blk_do_io_stat(rq))</span><br><span class="line">                return;</span><br><span class="line">                </span><br><span class="line">        cpu = part_stat_lock();</span><br><span class="line">        </span><br><span class="line">        if (!new_io) {</span><br><span class="line">                /*注意，merge的IO就不会导致in_flight++*/</span><br><span class="line">                part = rq->part;</span><br><span class="line">                part_stat_inc(cpu, part, merges[rw]);</span><br><span class="line">        } else {</span><br><span class="line">                part = disk_map_sector_rcu(rq->rq_disk, blk_rq_pos(rq));</span><br><span class="line">                if (!hd_struct_try_get(part)) {</span><br><span class="line">                        part = &rq->rq_disk->part0;</span><br><span class="line">                        hd_struct_get(part);</span><br><span class="line">                }</span><br><span class="line">                /*新IO，更新io_ticks and time_in_queue*/</span><br><span class="line">                part_round_stats(cpu, part);</span><br><span class="line">                /*in_flight 加1*/</span><br><span class="line">                part_inc_in_flight(part, rw);</span><br><span class="line">                rq->part = part;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        part_stat_unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="iostat-输出的计算"><a href="#iostat-输出的计算" class="headerlink" title="iostat 输出的计算"></a>iostat 输出的计算</h2><h4 id="注意，-proc-diskstats-已经将所有的素材都准备好了，对于iostat程序来说，就是将处理这些数据，给客户展现出更友好，更有意义的数值。事实上，iostat的源码非常的短，它属于sysstat这个开源软件，整个文件大小1619行。"><a href="#注意，-proc-diskstats-已经将所有的素材都准备好了，对于iostat程序来说，就是将处理这些数据，给客户展现出更友好，更有意义的数值。事实上，iostat的源码非常的短，它属于sysstat这个开源软件，整个文件大小1619行。" class="headerlink" title="注意，/proc/diskstats 已经将所有的素材都准备好了，对于iostat程序来说，就是将处理这些数据，给客户展现出更友好，更有意义的数值。事实上，iostat的源码非常的短，它属于sysstat这个开源软件，整个文件大小1619行。"></a>注意，/proc/diskstats 已经将所有的素材都准备好了，对于iostat程序来说，就是将处理这些数据，给客户展现出更友好，更有意义的数值。事实上，iostat的源码非常的短，它属于sysstat这个开源软件，整个文件大小1619行。</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int read_sysfs_file_stat(int curr, char *filename, char *dev_name)</span><br><span class="line">{</span><br><span class="line">        FILE *fp; </span><br><span class="line">        struct io_stats sdev;</span><br><span class="line">        int i;</span><br><span class="line">        unsigned int ios_pgr, tot_ticks, rq_ticks, wr_ticks;</span><br><span class="line">        unsigned long rd_ios, rd_merges_or_rd_sec, wr_ios, wr_merges;</span><br><span class="line">        unsigned long rd_sec_or_wr_ios, wr_sec, rd_ticks_or_wr_sec;</span><br><span class="line"></span><br><span class="line">        /* Try to read given stat file */</span><br><span class="line">        if ((fp = fopen(filename, "r")) == NULL)</span><br><span class="line">                return 0;</span><br><span class="line"></span><br><span class="line">        i = fscanf(fp, "%lu %lu %lu %lu %lu %lu %lu %u %u %u %u",</span><br><span class="line">                   &rd_ios, &rd_merges_or_rd_sec, &rd_sec_or_wr_ios, &rd_ticks_or_wr_sec,</span><br><span class="line">                   &wr_ios, &wr_merges, &wr_sec, &wr_ticks, &ios_pgr, &tot_ticks, &rq_ticks);</span><br><span class="line"></span><br><span class="line">        if (i == 11) {</span><br><span class="line">                /* Device or partition */</span><br><span class="line">                sdev.rd_ios     = rd_ios;</span><br><span class="line">                sdev.rd_merges  = rd_merges_or_rd_sec;</span><br><span class="line">                sdev.rd_sectors = rd_sec_or_wr_ios;</span><br><span class="line">                sdev.rd_ticks   = (unsigned int) rd_ticks_or_wr_sec;</span><br><span class="line">                sdev.wr_ios     = wr_ios;</span><br><span class="line">                sdev.wr_merges  = wr_merges;                               </span><br><span class="line">                sdev.wr_sectors = wr_sec;</span><br><span class="line">                sdev.wr_ticks   = wr_ticks;</span><br><span class="line">                sdev.ios_pgr    = ios_pgr;</span><br><span class="line">                sdev.tot_ticks  = tot_ticks;</span><br><span class="line">                sdev.rq_ticks   = rq_ticks;</span><br><span class="line">        }</span><br><span class="line">        else if (i == 4) {</span><br><span class="line">                /* Partition without extended statistics */</span><br><span class="line">                sdev.rd_ios     = rd_ios;</span><br><span class="line">                sdev.rd_sectors = rd_merges_or_rd_sec;</span><br><span class="line">                sdev.wr_ios     = rd_sec_or_wr_ios;</span><br><span class="line">                sdev.wr_sectors = rd_ticks_or_wr_sec;</span><br><span class="line">        }</span><br><span class="line">        if ((i == 11) || !DISPLAY_EXTENDED(flags)) {</span><br><span class="line">                /*</span><br><span class="line">                 * In fact, we _don't_ save stats if it's a partition without</span><br><span class="line">                 * extended stats and yet we want to display ext stats.</span><br><span class="line">                 */</span><br><span class="line">                save_stats(dev_name, curr, &sdev, iodev_nr, st_hdr_iodev);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        fclose(fp);</span><br><span class="line">        </span><br><span class="line">        return 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="数据都采集到了，剩下就是计算了。其中下面几项的计算是非常简单的："><a href="#数据都采集到了，剩下就是计算了。其中下面几项的计算是非常简单的：" class="headerlink" title="数据都采集到了，剩下就是计算了。其中下面几项的计算是非常简单的："></a>数据都采集到了，剩下就是计算了。其中下面几项的计算是非常简单的：</h4><ul><li>rrqm/s</li><li>wrqm/s</li><li>r/s</li><li>w/s</li><li>rMB/s</li><li>wMB/s</li></ul><p>这几项的计算是非常简单的，就是采样两次，后一次的值减去前一次的值，然后除以时间间隔，得到平均值即可。因为这些/proc/diskstats中对应的值都是累加的，后一次减去前一次，即得到采样时间间隔内的新增量。不赘述。</p><h2 id="avgrq-sz的计算"><a href="#avgrq-sz的计算" class="headerlink" title="avgrq-sz的计算"></a>avgrq-sz的计算</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*       rrq/s wrq/s   r/s   w/s  rsec  wsec  rqsz  qusz await r_await w_await svctm %util */</span><br><span class="line">   cprintf_f(2, 8, 2,</span><br><span class="line">             S_VALUE(ioj->rd_merges, ioi->rd_merges, itv),</span><br><span class="line">             S_VALUE(ioj->wr_merges, ioi->wr_merges, itv));</span><br><span class="line">   cprintf_f(2, 7, 2,</span><br><span class="line">             S_VALUE(ioj->rd_ios, ioi->rd_ios, itv),</span><br><span class="line">             S_VALUE(ioj->wr_ios, ioi->wr_ios, itv));</span><br><span class="line">   cprintf_f(4, 8, 2,</span><br><span class="line">             S_VALUE(ioj->rd_sectors, ioi->rd_sectors, itv) / fctr,</span><br><span class="line">             S_VALUE(ioj->wr_sectors, ioi->wr_sectors, itv) / fctr,</span><br><span class="line">             xds.arqsz,  //此处是avgrq-sz</span><br><span class="line">             S_VALUE(ioj->rq_ticks, ioi->rq_ticks, itv) / 1000.0);//此处是avgqu-sz</span><br></pre></td></tr></tbody></table></figure><h5 id="注意avgrq-sz来自xds的argsz变量，该变量是通过该函数计算得到的："><a href="#注意avgrq-sz来自xds的argsz变量，该变量是通过该函数计算得到的：" class="headerlink" title="注意avgrq-sz来自xds的argsz变量，该变量是通过该函数计算得到的："></a>注意avgrq-sz来自xds的argsz变量，该变量是通过该函数计算得到的：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*注意sdc中的c指的是current，sdp中的p指的是previous*/</span><br><span class="line">void compute_ext_disk_stats(struct stats_disk *sdc, struct stats_disk *sdp,</span><br><span class="line">                            unsigned long long itv, struct ext_disk_stats *xds)</span><br><span class="line">{</span><br><span class="line">        double tput</span><br><span class="line">                = ((double) (sdc->nr_ios - sdp->nr_ios)) * HZ / itv;</span><br><span class="line"></span><br><span class="line">        xds->util  = S_VALUE(sdp->tot_ticks, sdc->tot_ticks, itv);</span><br><span class="line">        xds->svctm = tput ? xds->util / tput : 0.0;</span><br><span class="line">        xds->await = (sdc->nr_ios - sdp->nr_ios) ?</span><br><span class="line">                ((sdc->rd_ticks - sdp->rd_ticks) + (sdc->wr_ticks - sdp->wr_ticks)) /</span><br><span class="line">                ((double) (sdc->nr_ios - sdp->nr_ios)) : 0.0;</span><br><span class="line">        </span><br><span class="line">        xds->arqsz = (sdc->nr_ios - sdp->nr_ios) ?</span><br><span class="line">                ((sdc->rd_sect - sdp->rd_sect) + (sdc->wr_sect - sdp->wr_sect)) /</span><br><span class="line">                ((double) (sdc->nr_ios - sdp->nr_ios)) : 0.0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意nr_ios来自如下运算，即读IO和写IO的和</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sdc.nr_ios    = ioi->rd_ios + ioi->wr_ios;</span><br><span class="line">sdp.nr_ios    = ioj->rd_ios + ioj->wr_ios;</span><br></pre></td></tr></tbody></table></figure><h5 id="那么xds-gt-arqsz-的计算就是如下含义："><a href="#那么xds-gt-arqsz-的计算就是如下含义：" class="headerlink" title="那么xds->arqsz 的计算就是如下含义："></a>那么xds->arqsz 的计算就是如下含义：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xds->arqsz = (读扇区总数 + 写扇区总数)/(读IO次数+写IO次数)</span><br><span class="line">xds->arqsz = (sdc->nr_ios - sdp->nr_ios) ?</span><br><span class="line">          ((sdc->rd_sect - sdp->rd_sect) + (sdc->wr_sect - sdp->wr_sect)) /</span><br><span class="line">          ((double) (sdc->nr_ios - sdp->nr_ios)) : 0.0;</span><br></pre></td></tr></tbody></table></figure><h5 id="好吧。反正我是非常不理解这他妈的咋回事😂。"><a href="#好吧。反正我是非常不理解这他妈的咋回事😂。" class="headerlink" title="好吧。反正我是非常不理解这他妈的咋回事😂。"></a>好吧。反正我是非常不理解这他妈的咋回事😂。</h5><h2 id="avgqu-sz的计算"><a href="#avgqu-sz的计算" class="headerlink" title="avgqu-sz的计算"></a>avgqu-sz的计算</h2><h4 id="平均队列长度的计算，这个计算就用到了diskstats中time-in-queue这个值。"><a href="#平均队列长度的计算，这个计算就用到了diskstats中time-in-queue这个值。" class="headerlink" title="平均队列长度的计算，这个计算就用到了diskstats中time_in_queue这个值。"></a>平均队列长度的计算，这个计算就用到了diskstats中time_in_queue这个值。</h4><h4 id="这个值的计算来自这句话："><a href="#这个值的计算来自这句话：" class="headerlink" title="这个值的计算来自这句话："></a>这个值的计算来自这句话：</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_VALUE(ioj->rq_ticks, ioi->rq_ticks, itv) / 1000.0)</span><br></pre></td></tr></tbody></table></figure><p>其中rq_ticks即diskstats中的time_in_queue。</p><p>我们考虑如下的场景，如果IO请求有一个burst，同一时间来了250个IO请求，后续再也没有新的请求到来。这种情况下，每个请求处理时间都是4ms，那么所有IO的平均等待时间为：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均等待时间 = 单个请求处理时间*(1+2+3+4...+(请求总数-1))/请求总数</span><br></pre></td></tr></tbody></table></figure><p></p><p>对于我们这个例子而言，平均等待时间是4*125 = 500 ms</p><p>那么所有IO花费的总时间为250*500=125000毫秒，这个时间除以1000毫秒：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">125000/1000 = 125</span><br></pre></td></tr></tbody></table></figure><p></p><p>即平均下来，队列的长度是125 ，这个值很明显是符合直观的。排在队列最前端的IO认为，队列的长度是0，第2个IO认为队列的长度是1，第3个IO认为队列的长度是2，最后一个认为队列的长度是249。</p><p>我们换一种思路来考虑，即diskstats中time_in_queue的思路。</p><p>当第一个IO完成的时候，队列中250个IO，250个IO都等了4ms，即time_in_queue + = (250<em>4) ，当第二个IO完成的时候，time_in_queue += (249</em>4)，当所有IO都完成的时候，time_in_queue = 4*(250+249+248….+1)， …</p><p>根据time_in_queue/1000,殊途同归地获得了平均队列长度。</p><h2 id="await、r-wait及w-wait的计算"><a href="#await、r-wait及w-wait的计算" class="headerlink" title="await、r_wait及w_wait的计算"></a>await、r_wait及w_wait的计算</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void compute_ext_disk_stats(struct stats_disk *sdc, struct stats_disk *sdp,</span><br><span class="line">                            unsigned long long itv, struct ext_disk_stats *xds)</span><br><span class="line">{</span><br><span class="line">        ...</span><br><span class="line">        xds->await = (sdc->nr_ios - sdp->nr_ios) ?</span><br><span class="line">                ((sdc->rd_ticks - sdp->rd_ticks) + (sdc->wr_ticks - sdp->wr_ticks)) /</span><br><span class="line">                ((double) (sdc->nr_ios - sdp->nr_ios)) : 0.0; </span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个没啥好说的了：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await = ((所有读IO的时间)+(所有写IO的时间))/((读请求的个数) + (写请求的个数))</span><br></pre></td></tr></tbody></table></figure><p></p><p>注意一点就行了，这个所有读IO的时间和所有写IO的时间，都是包括IO在队列的时间在内的。不能一厢情愿地认为，是磁盘控制器处理该IO的时间。</p><p>注意，能不能说，await比较高，所以武断地判定这块盘的能力很菜？答案是不能。await这个值不能反映硬盘设备的性能。await的这个值不能反映硬盘设备的性能，await这个值不能反映硬盘设备的性能，重要的话讲三遍。</p><p>我们考虑两种IO的模型</p><ul><li>250个IO请求同时进入等待队列</li><li>250个IO请求同时进入等待队列</li></ul><p>第一种情况await高达500ms，第二个情况await只有4ms，但是都是同一块盘。</p><p>但是注意await是相当重要的一个参数，它表明了用户发起的IO请求的平均延迟：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait  = IO 平均处理时间 + IO在队列的平均等待时间</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><blockquote><p>因此，这个指标是比较重要的一个指标😳。</p></blockquote></blockquote><h2 id="util-和磁盘设备饱和度"><a href="#util-和磁盘设备饱和度" class="headerlink" title="%util 和磁盘设备饱和度"></a>%util 和磁盘设备饱和度</h2><h6 id="注意，-util是最容易让人产生误解的一个参数。很多初学者看到-util-等于100-就说硬盘能力到顶了，这种说法是错误的😨。"><a href="#注意，-util是最容易让人产生误解的一个参数。很多初学者看到-util-等于100-就说硬盘能力到顶了，这种说法是错误的😨。" class="headerlink" title="注意，%util是最容易让人产生误解的一个参数。很多初学者看到%util 等于100%就说硬盘能力到顶了，这种说法是错误的😨。"></a>注意，%util是最容易让人产生误解的一个参数。很多初学者看到%util 等于100%就说硬盘能力到顶了，这种说法是<strong>错误</strong>的😨。</h6><p>%util数据源自diskstats中的io_ticks，这个值并不关心等待在队里里面IO的个数，它只关心队列中有没有IO。</p><p>和超时排队结账这个类比最本质的区别在于，现代硬盘都有并行处理多个IO的能力，但是收银员没有。收银员无法做到同时处理10个顾客的结账任务而消耗的总时间与处理一个顾客结账任务相差无几。但是磁盘可以。所以，即使%util到了100%，也并不意味着设备饱和了。</p><p>最简单的例子是，某硬盘处理单个IO请求需要0.1秒，有能力同时处理10个。但是当10个请求依次提交的时候，需要1秒钟才能完成这10%的请求，，在1秒的采样周期里，%util达到了100%。但是如果10个请一次性提交的话， 硬盘可以在0.1秒内全部完成，这时候，%util只有10%。</p><p>因此，在上面的例子中，一秒中10个IO，即IOPS=10的时候，%util就达到了100%，这并不能表明，该盘的IOPS就只能到10，事实上，纵使%util到了100%，硬盘可能仍然有很大的余力处理更多的请求，即并未达到饱和的状态。</p><p>下一小节有4张图，可以看到当IOPS为1000的时候%util为100%，但是并不意味着该盘的IOPS就在1000，实际上2000，3000,5000的IOPS都可以达到。根据%util 100%时的 r/s 或w/s 来推算磁盘的IOPS是不对的。</p><p>那么有没有一个指标用来衡量硬盘设备的饱和程度呢。很遗憾，iostat没有一个指标可以衡量磁盘设备的饱和度。</p><h2 id="svctm的计算"><a href="#svctm的计算" class="headerlink" title="svctm的计算"></a>svctm的计算</h2><p>对于iostat这个功能而言，%util固然会给人带来一定的误解和苦扰，但是svctm给人带来的误解更多。一直以来，人们希望了解块设备处理单个IO的service time，这个指标直接地反应了硬盘的能力。</p><p>回到超市收银这个类比中，如果收银员是个老手，操作流，效率很高，那么大家肯定更愿意排这一队。但是如果收银员是个新手，各种操作不熟悉，动作慢，效率很低，那么同样多的任务，就会花费更长的时间。因此IO的平均service time（不包括排队时间）是非常有意义的。</p><p>但是service time和iostat无关，iostat没有任何一个参数能够提供这方面的信息。而svctm这个输出给了人们这种美好的期待，却只能让人空欢喜。</p><p>从现在起，我们记住，我们不能从svctm中得到自己期待的service time这个值，这个值其实并没有什么意义，事实上，这个值不是独立的，它是根据其他值计算出来的。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void compute_ext_disk_stats(struct stats_disk *sdc, struct stats_disk *sdp,</span><br><span class="line">                            unsigned long long itv, struct ext_disk_stats *xds) </span><br><span class="line">{</span><br><span class="line">        double tput </span><br><span class="line">                = ((double) (sdc->nr_ios - sdp->nr_ios)) * HZ / itv; </span><br><span class="line">                </span><br><span class="line">        xds->util  = S_VALUE(sdp->tot_ticks, sdc->tot_ticks, itv);</span><br><span class="line">        xds->svctm = tput ? xds->util / tput : 0.0; </span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果一个盘的能力很强悍，随机小IO（4K）fio测试中我们会看到如下现象：当IOPS为1000的时候，iosta输出的svctm为1(ms)，当IOPS为2000的时候，iostat输出的svctm为0.5(ms),当IOPS为3000的时候，iostat输出的svctm为0.33。原因其实无他，因为这种情况下%util都是100%，即当采样周期是1秒的时候，用满了1秒，tput就是fio指定的–rate-iops 即1000、2000、3000，因此算出来svctm为对应的1、0.5、0.33。<br><img src="/2019/03/11/深入理解iostat/iops_1000_svctm.png" title="iops_1000_svctm"><br><img src="/2019/03/11/深入理解iostat/iops_2000_svctm.png" title="iops_2000_svctm"><br><img src="/2019/03/11/深入理解iostat/iops_3000_svctm.png" title="iops_3000_svctm"><br><img src="/2019/03/11/深入理解iostat/iops_5000_svctm.png" title="iops_5000_svctm"></p><blockquote><p>注意上面的盘sdg是iSCSI，存储空间是由分布式存储提供，不要问我为什么单个盘随机IOPS能无压力的到5000）</p></blockquote><p>因此从这个例子看，把iostat的输出中的svctm看作是IO的处理时间是相当不靠谱的。为了防止带来的误解，可以直接忽略这个参数。</p><p>既然svctm不能反映IO处理时间，那么有没有一个参数可以测量块设备的IO平均处理时间呢？很遗憾iostat是做不到的。但是只要思想不滑坡，办法总比困难多，blktrace这个神器可能得到这个设备的IO平均处理时间。</p><p>接下来我们就可以进入另一个天地😇。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>iostat能够提供给我们的信息就这么多了，通过分析我们期待能够得到块设备处理IO的时间，这就要靠blocktrace这个工具了。blktrace可以讲IO路径分段，分别统计各段的消耗的时间。</p><p>本文大量参考vmunix的<a href="http://linuxperf.com/?p=156" target="_blank" rel="noopener">容易被误读的IOSTAT</a>，以及<a href="http://ykrocku.github.io/blog/2014/04/11/diskstats/" target="_blank" rel="noopener">深入分析diskstats</a>，其中第二篇文章给出了一个很详细的IO PATH的流程图，非常有用。第二篇文章中随着代码演进有一些变化，本文采用的比较新的Linux Kernel code做介绍，同时演算io_ticks和time_in_queue部分第二篇文章也有错误，也一并修正了。不过瑕不掩瑜，这两篇都是非常棒的文章。向前辈致敬。</p><h6 id="本文来自于Bean-Li"><a href="#本文来自于Bean-Li" class="headerlink" title="本文来自于Bean Li"></a>本文来自于<a href="http://bean-li.github.io/dive-into-iostat/" target="_blank" rel="noopener">Bean Li</a></h6><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdisk_常用操作</title>
      <link href="/2019/03/11/gdisk-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/11/gdisk-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="传统的老牌的分区工具是fdisk，但是fdisk出道太早，只支持MBR（Master-Boot-Record），并不支持GPT（GUID-Partition-Table），无法操作超过2T的磁盘，因此gdisk-parted等分区工具横空出世。"><a href="#传统的老牌的分区工具是fdisk，但是fdisk出道太早，只支持MBR（Master-Boot-Record），并不支持GPT（GUID-Partition-Table），无法操作超过2T的磁盘，因此gdisk-parted等分区工具横空出世。" class="headerlink" title="传统的老牌的分区工具是fdisk，但是fdisk出道太早，只支持MBR（Master Boot Record），并不支持GPT（GUID Partition Table），无法操作超过2T的磁盘，因此gdisk parted等分区工具横空出世。"></a>传统的老牌的分区工具是fdisk，但是fdisk出道太早，只支持MBR（Master Boot Record），并不支持GPT（GUID Partition Table），无法操作超过2T的磁盘，因此gdisk parted等分区工具横空出世。</h4><h4 id="gdisk和parted都曾经用过，但是我更喜欢gdisk，因为使用上，gdisk-上承fdisk，没有太多的学习负担。另外我们QA测出过，parted方式分区，在某些使用上会有问题。"><a href="#gdisk和parted都曾经用过，但是我更喜欢gdisk，因为使用上，gdisk-上承fdisk，没有太多的学习负担。另外我们QA测出过，parted方式分区，在某些使用上会有问题。" class="headerlink" title="gdisk和parted都曾经用过，但是我更喜欢gdisk，因为使用上，gdisk 上承fdisk，没有太多的学习负担。另外我们QA测出过，parted方式分区，在某些使用上会有问题。"></a>gdisk和parted都曾经用过，但是我更喜欢gdisk，因为使用上，gdisk 上承fdisk，没有太多的学习负担。另外我们QA测出过，parted方式分区，在某些使用上会有问题。</h4><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h4 id="首先，我有一个sdd，作为我操作的对象。"><a href="#首先，我有一个sdd，作为我操作的对象。" class="headerlink" title="首先，我有一个sdd，作为我操作的对象。"></a>首先，我有一个sdd，作为我操作的对象。</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="built_in">test</span>:~<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">fd0      2:0    1     4K  0 disk </span><br><span class="line">sda      8:0    0    40G  0 disk </span><br><span class="line">├─sda1   8:1    0  30.5M  0 part </span><br><span class="line">├─sda2   8:2    0 488.3M  0 part </span><br><span class="line">├─sda3   8:3    0  31.1G  0 part /</span><br><span class="line">├─sda4   8:4    0     8G  0 part [SWAP]</span><br><span class="line">└─sda5   8:5    0 387.8M  0 part </span><br><span class="line">sdb      8:16   0    50G  0 disk </span><br><span class="line">├─sdb1   8:17   0     4G  0 part </span><br><span class="line">└─sdb2   8:18   0    46G  0 part /data/osd.4</span><br><span class="line">sdc      8:32   0    50G  0 disk </span><br><span class="line">├─sdc1   8:33   0     4G  0 part </span><br><span class="line">└─sdc2   8:34   0    46G  0 part /data/osd.5</span><br><span class="line">sdd      8:48   0   500G  0 disk </span><br><span class="line">sr0     11:0    1   1.6G  0 rom</span><br></pre></td></tr></tbody></table></figure><h4 id="查看help信息"><a href="#查看help信息" class="headerlink" title="查看help信息"></a><strong>查看help信息</strong></h4><h5 id="进入交互模式之后，输入h可以查看帮助信息"><a href="#进入交互模式之后，输入h可以查看帮助信息" class="headerlink" title="进入交互模式之后，输入h可以查看帮助信息"></a>进入交互模式之后，输入h可以查看帮助信息</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="built_in">test</span>:~<span class="comment"># gdisk /dev/sdd</span></span><br><span class="line">GPT fdisk (gdisk) version 0.8.1</span><br><span class="line"></span><br><span class="line">Partition table scan:</span><br><span class="line">  MBR: protective</span><br><span class="line">  BSD: not present</span><br><span class="line">  APM: not present</span><br><span class="line">  GPT: present</span><br><span class="line"></span><br><span class="line">Found valid GPT with protective MBR; using GPT.</span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): h  </span><br><span class="line">bback up GPT data to a file</span><br><span class="line">cchange a partition<span class="string">'s name</span></span><br><span class="line"><span class="string">ddelete a partition</span></span><br><span class="line"><span class="string">ishow detailed information on a partition</span></span><br><span class="line"><span class="string">llist known partition types</span></span><br><span class="line"><span class="string">nadd a new partition</span></span><br><span class="line"><span class="string">ocreate a new empty GUID partition table (GPT)</span></span><br><span class="line"><span class="string">pprint the partition table</span></span><br><span class="line"><span class="string">qquit without saving changes</span></span><br><span class="line"><span class="string">rrecovery and transformation options (experts only)</span></span><br><span class="line"><span class="string">ssort partitions</span></span><br><span class="line"><span class="string">tchange a partition'</span>s <span class="built_in">type</span> code</span><br><span class="line">vverify disk</span><br><span class="line">wwrite table to disk and <span class="built_in">exit</span></span><br><span class="line">xextra functionality (experts only)</span><br><span class="line">?<span class="built_in">print</span> this menu</span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>):</span><br></pre></td></tr></tbody></table></figure><h4 id="查看分区表信息"><a href="#查看分区表信息" class="headerlink" title="查看分区表信息"></a><strong>查看分区表信息</strong></h4><h5 id="很明显，做出没有分区，所以分区表为空-后面创建分区之后，可以通过p命令查看分区信息"><a href="#很明显，做出没有分区，所以分区表为空-后面创建分区之后，可以通过p命令查看分区信息" class="headerlink" title="很明显，做出没有分区，所以分区表为空,后面创建分区之后，可以通过p命令查看分区信息"></a>很明显，做出没有分区，所以分区表为空,后面创建分区之后，可以通过p命令查看分区信息</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/sdd: 1048576000 sectors, 500.0 GiB</span><br><span class="line">Logical sector size: 512 bytes</span><br><span class="line">Disk identifier (GUID): D3328858-7A3F-4A64-BC46-A7040F306F33</span><br><span class="line">Partition table holds up to 128 entries</span><br><span class="line">First usable sector is 34, last usable sector is 104857566</span><br><span class="line">Partitions will be aligned on 2048-sector boundaries</span><br><span class="line">Total free space is 1048575330 sectors (500.0 GiB)</span><br><span class="line"></span><br><span class="line">Number  Start (sector)    End (sector)  Size       Code  Name</span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>):</span><br></pre></td></tr></tbody></table></figure><h4 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a><strong>创建分区</strong></h4><h5 id="打算将500G的空间划分成2个分区，分别是100G和400G：-创建分区是用命令n，你需要选择"><a href="#打算将500G的空间划分成2个分区，分别是100G和400G：-创建分区是用命令n，你需要选择" class="headerlink" title="打算将500G的空间划分成2个分区，分别是100G和400G： 创建分区是用命令n，你需要选择"></a>打算将500G的空间划分成2个分区，分别是100G和400G： 创建分区是用命令n，你需要选择</h5><p>1.分区number<br>2.起始扇区<br>3.结束扇区</p><h5 id="起始扇区可以敲回车选择默认值，而结束扇区用＋100G这种方式来决定分区大小为100G-分区后，可以用p命令查看最新的分区表"><a href="#起始扇区可以敲回车选择默认值，而结束扇区用＋100G这种方式来决定分区大小为100G-分区后，可以用p命令查看最新的分区表" class="headerlink" title="起始扇区可以敲回车选择默认值，而结束扇区用＋100G这种方式来决定分区大小为100G 分区后，可以用p命令查看最新的分区表"></a>起始扇区可以敲回车选择默认值，而结束扇区用＋100G这种方式来决定分区大小为100G 分区后，可以用p命令查看最新的分区表</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): n    </span><br><span class="line">Partition number (1-128, default 1): 1</span><br><span class="line">First sector (34-1048575660, default = 34) or {+-}size{KMGTP}: </span><br><span class="line">Information: Moved requested sector from 34 to 2048 <span class="keyword">in</span></span><br><span class="line">order to align on 2048-sector boundaries.</span><br><span class="line">Use <span class="string">'l'</span> on the experts<span class="string">' menu to adjust alignment</span></span><br><span class="line"><span class="string">Last sector (2048-1048575660, default = 1048575660) or {+-}size{KMGTP}: +100G</span></span><br><span class="line"><span class="string">Current type is '</span>Linux filesystem<span class="string">'</span></span><br><span class="line"><span class="string">Hex code or GUID (L to show codes, Enter = 8300): </span></span><br><span class="line"><span class="string">Changed type of partition to '</span>Linux filesystem<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (? for help): p</span></span><br><span class="line"><span class="string">Disk /dev/sdd: 1048576000 sectors, 500.0 GiB</span></span><br><span class="line"><span class="string">Logical sector size: 512 bytes</span></span><br><span class="line"><span class="string">Disk identifier (GUID): D3328858-7A3F-4A64-BC46-A7040F366F33</span></span><br><span class="line"><span class="string">Partition table holds up to 128 entries</span></span><br><span class="line"><span class="string">First usable sector is 34, last usable sector is 104857566</span></span><br><span class="line"><span class="string">Partitions will be aligned on 2048-sector boundaries</span></span><br><span class="line"><span class="string">Total free space is 83886013 sectors (40.0 GiB)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Number  Start (sector)    End (sector)  Size       Code  Name</span></span><br><span class="line"><span class="string">   1            2048        20973567  100.0 GiB    8300  Linux filesystem</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (? for help): n</span></span><br><span class="line"><span class="string">Partition number (2-128, default 2): 2</span></span><br><span class="line"><span class="string">First sector (34-104857566, default = 20973568) or {+-}size{KMGTP}: </span></span><br><span class="line"><span class="string">Last sector (20973568-104857566, default = 104857566) or {+-}size{KMGTP}: </span></span><br><span class="line"><span class="string">Current type is '</span>Linux filesystem<span class="string">'</span></span><br><span class="line"><span class="string">Hex code or GUID (L to show codes, Enter = 8300): </span></span><br><span class="line"><span class="string">Changed type of partition to '</span>Linux filesystem<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (? for help): p</span></span><br><span class="line"><span class="string">Disk /dev/sdd: 1048576000 sectors, 500.0 GiB</span></span><br><span class="line"><span class="string">Logical sector size: 512 bytes</span></span><br><span class="line"><span class="string">Disk identifier (GUID): D3328858-7A3F-4A64-BC46-A7040F366F33</span></span><br><span class="line"><span class="string">Partition table holds up to 128 entries</span></span><br><span class="line"><span class="string">First usable sector is 34, last usable sector is 1048575660</span></span><br><span class="line"><span class="string">Partitions will be aligned on 2048-sector boundaries</span></span><br><span class="line"><span class="string">Total free space is 2014 sectors (1007.0 KiB)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Number  Start (sector)    End (sector)  Size       Code  Name</span></span><br><span class="line"><span class="string">   1            2048        209735677  100.0 GiB    8300  Linux filesystem</span></span><br><span class="line"><span class="string">   2       209735678       1048575660  400.0 GiB    8300  Linux filesystem</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (? for help):</span></span><br></pre></td></tr></tbody></table></figure><h4 id="设置分区标签信息partlabel"><a href="#设置分区标签信息partlabel" class="headerlink" title="设置分区标签信息partlabel"></a><strong>设置分区标签信息partlabel</strong></h4><h5 id="有些时候，磁盘的盘符会漂移，使用sdx这种方式来分辨磁盘是不靠谱，使用lable这种方式是可靠的。那么如何创建分区标签呢？"><a href="#有些时候，磁盘的盘符会漂移，使用sdx这种方式来分辨磁盘是不靠谱，使用lable这种方式是可靠的。那么如何创建分区标签呢？" class="headerlink" title="有些时候，磁盘的盘符会漂移，使用sdx这种方式来分辨磁盘是不靠谱，使用lable这种方式是可靠的。那么如何创建分区标签呢？"></a>有些时候，磁盘的盘符会漂移，使用sdx这种方式来分辨磁盘是不靠谱，使用lable这种方式是可靠的。那么如何创建分区标签呢？</h5><h5 id="c-是用来设置partlable的"><a href="#c-是用来设置partlable的" class="headerlink" title="c 是用来设置partlable的"></a>c 是用来设置partlable的</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): c </span><br><span class="line">Partition number (1-2): 1</span><br><span class="line">Enter name: test1</span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): c</span><br><span class="line">Partition number (1-2): 2</span><br><span class="line">Enter name: test2</span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/sdd: 1048576000 sectors, 500.0 GiB</span><br><span class="line">Logical sector size: 512 bytes</span><br><span class="line">Disk identifier (GUID): D3328858-7A3F-4A64-BC46-A7040F366F33</span><br><span class="line">Partition table holds up to 128 entries</span><br><span class="line">First usable sector is 34, last usable sector is 1048575660</span><br><span class="line">Partitions will be aligned on 2048-sector boundaries</span><br><span class="line">Total free space is 2014 sectors (1007.0 KiB)</span><br><span class="line"></span><br><span class="line">Number  Start (sector)    End (sector)  Size       Code  Name</span><br><span class="line">   1            2048       209735677   100.0 GiB    8300  bean_part1</span><br><span class="line">   2      209735678       1048575660   400.0 GiB    8300  bean_part2</span><br></pre></td></tr></tbody></table></figure><h4 id="保存分区信息"><a href="#保存分区信息" class="headerlink" title="保存分区信息"></a><strong>保存分区信息</strong></h4><h5 id="我们将磁盘分成了2个区，给每一个分区贴上了partlabel，但是退出gdisk之前必须保存，否则前功尽弃。"><a href="#我们将磁盘分成了2个区，给每一个分区贴上了partlabel，但是退出gdisk之前必须保存，否则前功尽弃。" class="headerlink" title="我们将磁盘分成了2个区，给每一个分区贴上了partlabel，但是退出gdisk之前必须保存，否则前功尽弃。"></a>我们将磁盘分成了2个区，给每一个分区贴上了partlabel，但是退出gdisk之前必须保存，否则前功尽弃。</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line"></span><br><span class="line">Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING</span><br><span class="line">PARTITIONS!!</span><br><span class="line"></span><br><span class="line">Do you want to proceed? (Y/N): y</span><br><span class="line">OK; writing new GUID partition table (GPT).</span><br><span class="line">The operation has completed successfully.</span><br><span class="line">root@<span class="built_in">test</span>:~<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a><strong>效果</strong></h4><h5 id="愉快地查看分区效果吧："><a href="#愉快地查看分区效果吧：" class="headerlink" title="愉快地查看分区效果吧："></a>愉快地查看分区效果吧：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="built_in">test</span>:~<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">fd0      2:0    1     4K  0 disk </span><br><span class="line">sda      8:0    0    40G  0 disk </span><br><span class="line">├─sda1   8:1    0  30.5M  0 part </span><br><span class="line">├─sda2   8:2    0 488.3M  0 part </span><br><span class="line">├─sda3   8:3    0  31.1G  0 part /</span><br><span class="line">├─sda4   8:4    0     8G  0 part [SWAP]</span><br><span class="line">└─sda5   8:5    0 387.8M  0 part </span><br><span class="line">sdb      8:16   0    50G  0 disk </span><br><span class="line">├─sdb1   8:17   0     4G  0 part </span><br><span class="line">└─sdb2   8:18   0    46G  0 part /data/osd.4</span><br><span class="line">sdc      8:32   0    50G  0 disk </span><br><span class="line">├─sdc1   8:33   0     4G  0 part </span><br><span class="line">└─sdc2   8:34   0    46G  0 part /data/osd.5</span><br><span class="line">sdd      8:48   0   500G  0 disk </span><br><span class="line">├─sdd1   8:49   0   100G  0 part </span><br><span class="line">└─sdd2   8:50   0   400G  0 part </span><br><span class="line">sr0     11:0    1   1.6G  0 rom  </span><br><span class="line">root@<span class="built_in">test</span>:~<span class="comment"># ll /dev/disk/by-partlabel/</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 180 Apr  1 22:23 ./</span><br><span class="line">drwxr-xr-x 9 root root 180 Apr  1 21:34 ../</span><br><span class="line">lrwxrwxrwx 1 root root  10 Apr  1 22:23 test1 -> ../../sdd1</span><br><span class="line">lrwxrwxrwx 1 root root  10 Apr  1 22:23 test2 -> ../../sdd2</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储的性能</title>
      <link href="/2019/03/11/%E5%AD%98%E5%82%A8%E7%9A%84%E6%80%A7%E8%83%BD/"/>
      <url>/2019/03/11/%E5%AD%98%E5%82%A8%E7%9A%84%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>比如我想测试400路并发写10G的大文件，一共写入2000个文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq 1 2000 |xargs -P 400 -I {} dd <span class="keyword">if</span>=/dev/zero of=file_{} bs=1M count=10240 oflag=direct</span><br></pre></td></tr></tbody></table></figure><p></p><h6 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h6><h6 id="xargs-参数中-P-选项相当逆天，保持400路并发。"><a href="#xargs-参数中-P-选项相当逆天，保持400路并发。" class="headerlink" title="xargs 参数中 -P 选项相当逆天，保持400路并发。"></a>xargs 参数中 -P 选项相当逆天，保持400路并发。</h6><h6 id="但是如果需要多台测试机，比如多台client机通过NFS测试写入，怎么办？其实我们需要的是将xargs-逆天的能力扩展到多台机器。"><a href="#但是如果需要多台测试机，比如多台client机通过NFS测试写入，怎么办？其实我们需要的是将xargs-逆天的能力扩展到多台机器。" class="headerlink" title="但是如果需要多台测试机，比如多台client机通过NFS测试写入，怎么办？其实我们需要的是将xargs 逆天的能力扩展到多台机器。"></a>但是如果需要多台测试机，比如多台client机通过NFS测试写入，怎么办？其实我们需要的是将xargs 逆天的能力扩展到多台机器。</h6><h6 id="parallel作为主角，是时候登场了"><a href="#parallel作为主角，是时候登场了" class="headerlink" title="parallel作为主角，是时候登场了"></a>parallel作为主角，是时候登场了</h6><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h4 id="安装-parallel-包"><a href="#安装-parallel-包" class="headerlink" title="安装 parallel 包"></a>安装 parallel 包</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubunt/Dabin</span></span><br><span class="line">sudo apt-get install parallel</span><br><span class="line"><span class="comment"># Linux</span></span><br><span class="line">yum install parallel</span><br></pre></td></tr></tbody></table></figure><h4 id="修改parallel的配置文件"><a href="#修改parallel的配置文件" class="headerlink" title="修改parallel的配置文件"></a>修改parallel的配置文件</h4><h6 id="简单地说，就是删除–tollef"><a href="#简单地说，就是删除–tollef" class="headerlink" title="简单地说，就是删除–tollef"></a>简单地说，就是删除–tollef</h6><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/parallel/config</span><br><span class="line">--tollef</span><br></pre></td></tr></tbody></table></figure><h2 id="测试可用性"><a href="#测试可用性" class="headerlink" title="测试可用性"></a>测试可用性</h2><p>可以用简单的sleep命令来测试parallel的可用性：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seq 1 100 ｜parallel -j 2 -S 10.16.17.17 -S 10.16.17.169 sleep {}</span><br><span class="line"><span class="comment"># 参数 -j 表示每次分发几个job，比如本例子中，每次发两个任务，即每台机器上会有两个sleep任务在跑。</span></span><br></pre></td></tr></tbody></table></figure><p></p><h6 id="注意节点之间需要设置ssh无需输入密码"><a href="#注意节点之间需要设置ssh无需输入密码" class="headerlink" title="注意节点之间需要设置ssh无需输入密码"></a>注意节点之间需要设置ssh无需输入密码</h6><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL查询语句是如何执行的？</title>
      <link href="/2019/01/28/studyMySQL-01/"/>
      <url>/2019/01/28/studyMySQL-01/</url>
      
        <content type="html"><![CDATA[<h2 id="比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时："><a href="#比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：" class="headerlink" title="比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时："></a>比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> SELECT * FROM T WHERE ID=10;</span><br></pre></td></tr></tbody></table></figure><p>看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p><p>所以一起把MySQL拆解一下，看看里面都有哪些”零件”，希望借由这个拆解过程，对MySQL有更深入的理解。这样当碰到MySQL的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。</p><p>下面的是MySQL的基本架构示意图，从中可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p><img src="/2019/01/28/studyMySQL-01/SQLzhixing.png" title="MySQL SQL解析图"><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。</p><p>从图中不难看出，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条SQL语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>第一步先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></tbody></table></figure><p></p><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><pre><code>* 如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。* 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</code></pre><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><img src="/2019/01/28/studyMySQL-01/showprocesslist.png" title="MySQL proceelist图"><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><pre><code>*定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。*如果你用的是 MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</code></pre><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立完成后，就可以执行 SELECT 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql> SELECT SQL_CACHE * FROM T WHERE ID=10;</span><br><span class="line">------------------------------------------------</span><br><span class="line">注:</span><br><span class="line">    MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”SELECT/select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> elect * from t <span class="built_in">where</span> ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error <span class="keyword">in</span> your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">'elect * from t where ID=1'</span> at line 1</span><br></pre></td></tr></tbody></table></figure><p></p><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> select * from t1 join t2 using(ID) <span class="built_in">where</span> t1.c=10 and t2.d=20</span><br></pre></td></tr></tbody></table></figure><pre><code>* 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。* 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</code></pre><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> select * from T <span class="built_in">where</span> ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT <span class="built_in">command</span> denied to user <span class="string">'b'</span>@<span class="string">'localhost'</span> <span class="keyword">for</span> table <span class="string">'T'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><p>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</p><p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p><p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>介绍了MySQL的SQL逻辑架构，希望对一个SQL语句完整执行流程的各个阶段有了一个初步的印象。我只是用一个查询的例子将各个环节过了一遍。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="/2019/01/28/%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/01/28/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="timg.jpeg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><!-- 文本居中的引用 标签 方式，要求版本在0.4.5或以上 --><!-- <blockquote class="blockquote-center"><p><strong>好男人就是我, 我就是好男人！</strong><br>我就是王杰民 ^_^</p></blockquote>–&gt;<!-- 标签别名 --><blockquote class="blockquote-center"><p><strong>好男人就是我, 我就是好男人！</strong><br>我就是王杰民 ^_^ </p></blockquote><h3 id="能说说你们这个业务的逻辑以及数据库怎么设计吗？"><a href="#能说说你们这个业务的逻辑以及数据库怎么设计吗？" class="headerlink" title="能说说你们这个业务的逻辑以及数据库怎么设计吗？"></a>能说说你们这个业务的逻辑以及数据库怎么设计吗？</h3><h4 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h4><h3 id="在工作中遇到过的难点问题有哪些？能说说代表性几个吗？"><a href="#在工作中遇到过的难点问题有哪些？能说说代表性几个吗？" class="headerlink" title="在工作中遇到过的难点问题有哪些？能说说代表性几个吗？"></a>在工作中遇到过的难点问题有哪些？能说说代表性几个吗？</h3><h4 id="答：-1"><a href="#答：-1" class="headerlink" title="答："></a>答：</h4><h3 id="MySQL-异地冗灾怎么做？"><a href="#MySQL-异地冗灾怎么做？" class="headerlink" title="MySQL 异地冗灾怎么做？"></a>MySQL 异地冗灾怎么做？</h3><h4 id="答：-2"><a href="#答：-2" class="headerlink" title="答："></a>答：</h4><p>###业务数据增长量是多少G，数据库怎么监控数据增长量？</p><h4 id="答：-3"><a href="#答：-3" class="headerlink" title="答："></a>答：</h4><h3 id="分库分表逻辑简单说下？增量怎么解决？"><a href="#分库分表逻辑简单说下？增量怎么解决？" class="headerlink" title="分库分表逻辑简单说下？增量怎么解决？"></a>分库分表逻辑简单说下？增量怎么解决？</h3><h4 id="答：-4"><a href="#答：-4" class="headerlink" title="答："></a>答：</h4><h3 id="kafka会丢数据吗？为什么回丢数据？"><a href="#kafka会丢数据吗？为什么回丢数据？" class="headerlink" title="kafka会丢数据吗？为什么回丢数据？"></a>kafka会丢数据吗？为什么回丢数据？</h3><h4 id="答：-5"><a href="#答：-5" class="headerlink" title="答："></a>答：</h4><h5 id="会丢数据"><a href="#会丢数据" class="headerlink" title="会丢数据"></a>会丢数据</h5><h3 id="MySQL-备份怎么做？-备份校验怎么做？"><a href="#MySQL-备份怎么做？-备份校验怎么做？" class="headerlink" title="MySQL 备份怎么做？ 备份校验怎么做？"></a>MySQL 备份怎么做？ 备份校验怎么做？</h3><h4 id="答：-6"><a href="#答：-6" class="headerlink" title="答："></a>答：</h4><h3 id="使用中间件之后的架构，数据库的事务是什么样子的？与程序直接链接数据库使用的事务区别是什么？"><a href="#使用中间件之后的架构，数据库的事务是什么样子的？与程序直接链接数据库使用的事务区别是什么？" class="headerlink" title="使用中间件之后的架构，数据库的事务是什么样子的？与程序直接链接数据库使用的事务区别是什么？"></a>使用中间件之后的架构，数据库的事务是什么样子的？与程序直接链接数据库使用的事务区别是什么？</h3><h4 id="答：-7"><a href="#答：-7" class="headerlink" title="答："></a>答：</h4><h3 id="之前分表了16张，在使用一定时间够发现16张表已经不满足了，那怎么扩容，扩容之后数据怎么同步过来？"><a href="#之前分表了16张，在使用一定时间够发现16张表已经不满足了，那怎么扩容，扩容之后数据怎么同步过来？" class="headerlink" title="之前分表了16张，在使用一定时间够发现16张表已经不满足了，那怎么扩容，扩容之后数据怎么同步过来？"></a>之前分表了16张，在使用一定时间够发现16张表已经不满足了，那怎么扩容，扩容之后数据怎么同步过来？</h3><h4 id="答：-8"><a href="#答：-8" class="headerlink" title="答："></a>答：</h4><h3 id="程序中的名词-线程和协程各是什么意思？"><a href="#程序中的名词-线程和协程各是什么意思？" class="headerlink" title="程序中的名词 线程和协程各是什么意思？"></a>程序中的名词 线程和协程各是什么意思？</h3><h4 id="答：-9"><a href="#答：-9" class="headerlink" title="答："></a>答：</h4><h3 id="有没有看过MySQL源码？那主从同步的底层是怎么实现的？底层的网络传输模式是什么样子的？"><a href="#有没有看过MySQL源码？那主从同步的底层是怎么实现的？底层的网络传输模式是什么样子的？" class="headerlink" title="有没有看过MySQL源码？那主从同步的底层是怎么实现的？底层的网络传输模式是什么样子的？"></a>有没有看过MySQL源码？那主从同步的底层是怎么实现的？底层的网络传输模式是什么样子的？</h3><h4 id="答：-10"><a href="#答：-10" class="headerlink" title="答："></a>答：</h4><h3 id="innobackupex比冷拷贝的优势是什么？"><a href="#innobackupex比冷拷贝的优势是什么？" class="headerlink" title="innobackupex比冷拷贝的优势是什么？"></a>innobackupex比冷拷贝的优势是什么？</h3><h4 id="答：-11"><a href="#答：-11" class="headerlink" title="答："></a>答：</h4><h3 id="数据库的RC和RR事务级别区别是什么？"><a href="#数据库的RC和RR事务级别区别是什么？" class="headerlink" title="数据库的RC和RR事务级别区别是什么？"></a>数据库的RC和RR事务级别区别是什么？</h3><h4 id="答：-12"><a href="#答：-12" class="headerlink" title="答："></a>答：</h4><h3 id="MySQL-的-SQL审核怎么做？"><a href="#MySQL-的-SQL审核怎么做？" class="headerlink" title="MySQL 的 SQL审核怎么做？"></a>MySQL 的 SQL审核怎么做？</h3><h4 id="答：-13"><a href="#答：-13" class="headerlink" title="答："></a>答：</h4><h3 id="监控怎么做的？都监控哪些指标？"><a href="#监控怎么做的？都监控哪些指标？" class="headerlink" title="监控怎么做的？都监控哪些指标？"></a>监控怎么做的？都监控哪些指标？</h3><h4 id="答：-14"><a href="#答：-14" class="headerlink" title="答："></a>答：</h4><h3 id="系统怎么优化？"><a href="#系统怎么优化？" class="headerlink" title="系统怎么优化？"></a>系统怎么优化？</h3><h4 id="答：-15"><a href="#答：-15" class="headerlink" title="答："></a>答：</h4><h3 id="MySQL-GTID复制时候，发生问题，快速解决。为何不用找binlog-file-number和-binlogbposition点。就能直接change-master-to-NewMaster-？"><a href="#MySQL-GTID复制时候，发生问题，快速解决。为何不用找binlog-file-number和-binlogbposition点。就能直接change-master-to-NewMaster-？" class="headerlink" title="MySQL GTID复制时候，发生问题，快速解决。为何不用找binlog file number和 binlogbposition点。就能直接change master to NewMaster ？"></a>MySQL GTID复制时候，发生问题，快速解决。为何不用找binlog file number和 binlogbposition点。就能直接change master to NewMaster ？</h3><h4 id="答：-16"><a href="#答：-16" class="headerlink" title="答："></a>答：</h4><h3 id="工作中出现故障，你的判断处理思路是什么？"><a href="#工作中出现故障，你的判断处理思路是什么？" class="headerlink" title="工作中出现故障，你的判断处理思路是什么？"></a>工作中出现故障，你的判断处理思路是什么？</h3><h4 id="答：-17"><a href="#答：-17" class="headerlink" title="答："></a>答：</h4><h3 id="服务器机器突然死机重启，怎么排查问题？"><a href="#服务器机器突然死机重启，怎么排查问题？" class="headerlink" title="服务器机器突然死机重启，怎么排查问题？"></a>服务器机器突然死机重启，怎么排查问题？</h3><h4 id="答：-18"><a href="#答：-18" class="headerlink" title="答："></a>答：</h4><h3 id="统计一个log日志文件中，最后一个字段是手机号，取手机号的最后四位数字统计出现的次数，倒序现实打印出来。"><a href="#统计一个log日志文件中，最后一个字段是手机号，取手机号的最后四位数字统计出现的次数，倒序现实打印出来。" class="headerlink" title="统计一个log日志文件中，最后一个字段是手机号，取手机号的最后四位数字统计出现的次数，倒序现实打印出来。"></a>统计一个log日志文件中，最后一个字段是手机号，取手机号的最后四位数字统计出现的次数，倒序现实打印出来。</h3><h4 id="答：-19"><a href="#答：-19" class="headerlink" title="答："></a>答：</h4><h3 id="MySQL-半同步会丢数据吗？"><a href="#MySQL-半同步会丢数据吗？" class="headerlink" title="MySQL 半同步会丢数据吗？"></a>MySQL 半同步会丢数据吗？</h3><h4 id="答：-20"><a href="#答：-20" class="headerlink" title="答："></a>答：</h4><h3 id="MySQL-主从原理，是主推送binlog还是从获取binlog？"><a href="#MySQL-主从原理，是主推送binlog还是从获取binlog？" class="headerlink" title="MySQL 主从原理，是主推送binlog还是从获取binlog？"></a>MySQL 主从原理，是主推送binlog还是从获取binlog？</h3><h4 id="答：-21"><a href="#答：-21" class="headerlink" title="答："></a>答：</h4><h3 id="怎么做才能保证MySQL-不丢数据？"><a href="#怎么做才能保证MySQL-不丢数据？" class="headerlink" title="怎么做才能保证MySQL 不丢数据？"></a>怎么做才能保证MySQL 不丢数据？</h3><h4 id="答：-22"><a href="#答：-22" class="headerlink" title="答："></a>答：</h4><h3 id="MySQL-IBP中的LRU的原理"><a href="#MySQL-IBP中的LRU的原理" class="headerlink" title="MySQL IBP中的LRU的原理"></a>MySQL IBP中的LRU的原理</h3><h4 id="答：-23"><a href="#答：-23" class="headerlink" title="答："></a>答：</h4><h3 id="ph-ost-实现原理"><a href="#ph-ost-实现原理" class="headerlink" title="ph-ost 实现原理"></a>ph-ost 实现原理</h3><h4 id="答：-24"><a href="#答：-24" class="headerlink" title="答："></a>答：</h4><h3 id="pt-osc和gh-ost-的区别"><a href="#pt-osc和gh-ost-的区别" class="headerlink" title="pt-osc和gh-ost 的区别"></a>pt-osc和gh-ost 的区别</h3><h4 id="答：-25"><a href="#答：-25" class="headerlink" title="答："></a>答：</h4><h3 id="MHA-架构中有没有做二次开发？MHA有什么缺点？在使用MHA架构，网络抖动了发生切换了怎么办？怎么防止这个问题发生？"><a href="#MHA-架构中有没有做二次开发？MHA有什么缺点？在使用MHA架构，网络抖动了发生切换了怎么办？怎么防止这个问题发生？" class="headerlink" title="MHA 架构中有没有做二次开发？MHA有什么缺点？在使用MHA架构，网络抖动了发生切换了怎么办？怎么防止这个问题发生？"></a>MHA 架构中有没有做二次开发？MHA有什么缺点？在使用MHA架构，网络抖动了发生切换了怎么办？怎么防止这个问题发生？</h3><h4 id="答：-26"><a href="#答：-26" class="headerlink" title="答："></a>答：</h4><h3 id="MySQL-清除三个小时的binlog？"><a href="#MySQL-清除三个小时的binlog？" class="headerlink" title="MySQL 清除三个小时的binlog？"></a>MySQL 清除三个小时的binlog？</h3><h4 id="答：-27"><a href="#答：-27" class="headerlink" title="答："></a>答：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql> PURGE MASTER LOGS BEFORE DATE_SUB(NOW(), INTERVAL 3 HOUR);</span><br></pre></td></tr></tbody></table></figure><h3 id="MySQL-binlog文件里面都有什么内容？"><a href="#MySQL-binlog文件里面都有什么内容？" class="headerlink" title="MySQL binlog文件里面都有什么内容？"></a>MySQL binlog文件里面都有什么内容？</h3><h4 id="答：-28"><a href="#答：-28" class="headerlink" title="答："></a>答：</h4><h5 id="binlog由一系列的binlog-event构成。每个binlog-event包含header和data两部分。"><a href="#binlog由一系列的binlog-event构成。每个binlog-event包含header和data两部分。" class="headerlink" title="binlog由一系列的binlog event构成。每个binlog event包含header和data两部分。"></a>binlog由一系列的binlog event构成。每个binlog event包含header和data两部分。</h5><ul><li>header部分提供的是event的公共的类型信息，包括event的创建时间，服务器等等。</li><li>data部分提供的是针对该event的具体信息，如具体数据的修改<ul><li>从mysql5.0版本开始，binlog采用的是v4版本，第一个event都是format_desc event 用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式。关于之前版本的binlog格式，可以参见<a href="http://dev.mysql.com/doc/internals/en/binary-log-versions.html" target="_blank" rel="noopener">binary-log-versions</a><h5 id="接下来的event就是按照上面的格式版本写入的event"><a href="#接下来的event就是按照上面的格式版本写入的event" class="headerlink" title="接下来的event就是按照上面的格式版本写入的event"></a>接下来的event就是按照上面的格式版本写入的event</h5><h5 id="最后一个rotate-event用于说明下一个binlog文件。"><a href="#最后一个rotate-event用于说明下一个binlog文件。" class="headerlink" title="最后一个rotate event用于说明下一个binlog文件。"></a>最后一个rotate event用于说明下一个binlog文件。</h5><h5 id="binlog索引文件是一个文本文件，其中内容为当前的binlog文件列表。比如下面就是一个mysql-bin-index文件的内容。"><a href="#binlog索引文件是一个文本文件，其中内容为当前的binlog文件列表。比如下面就是一个mysql-bin-index文件的内容。" class="headerlink" title="binlog索引文件是一个文本文件，其中内容为当前的binlog文件列表。比如下面就是一个mysql-bin.index文件的内容。"></a>binlog索引文件是一个文本文件，其中内容为当前的binlog文件列表。比如下面就是一个mysql-bin.index文件的内容。</h5><h5 id="接下来分析下几种常见的event，其他的event类型可以参见官方文档。"><a href="#接下来分析下几种常见的event，其他的event类型可以参见官方文档。" class="headerlink" title="接下来分析下几种常见的event，其他的event类型可以参见官方文档。"></a>接下来分析下几种常见的event，其他的event类型可以参见官方文档。</h5></li></ul></li><li>format_desc event<ul><li>下面是我在FLUSH LOGS之后新建的一个全新的binlog文件mysql-bin.000053，从binlog第一个event也就是format_desc event开始分析<blockquote><p>前面4个字节是固定的magic number,值为0x6e6962fe。接着是一个format_desc event，先看下19个字节的header。这19个字节中前4个字节0x567fb2b8是时间戳，第5个字节0x0f是event type，接着4个字节0x00000004是server_id，再接着4个字节0x00000067是长度103，然后的4个字节0x0000006b是下一个event的起始位置107，接着的2个字节的0x0001是flag（1为LOG_EVENT_BINLOG_IN_USE_F，标识binlog还没有关闭，binlog关闭后，flag会被设置为0），这样4+1+4+4+4+2=19个字节的公共头就完了(extra_headers暂时没有用到)。然后是这个event的data部分，event的data分为Fixed data和Variable data两部分，其中Fixed data是event的固定长度和格式的数据，Variable data则是长度变化的数据，比如format_desc event的Fixed data长度是0x54=84个字节。下面看下这84=2+50+4+1+27个字节的分配：开始的2个字节0x0004为binlog的版本号4，接着的50个字节为mysql-server版本，如我的版本是5.5.46-0ubuntu0.14.04.2-log，与SELECT version();查看的结果一致。接下来4个字节是binlog创建时间，这里是0；然后的1个字节0x13是指之后所有event的公共头长度，这里都是19；接着的27个字节中每个字节为mysql已知的event（共27个）的Fixed data的长度；可以发现format_desc event自身的Variable data部分为空。</p></blockquote></li></ul></li><li>rotate event<ul><li>接着我们不做额外操作，直接FLUSH LOGS，可以看到一个rotate event，除了format_desc event的flag从0x0001变成了0x0000。然后从0x567fb3c2开始是一个rotate event。依照前面的分析，前面19个字节为event的header，其event type是0x04，长度为0x2b=43，下一个event起始位置为0x96=150，然后是flag为0x0000，接着是event data部分，首先的8个字节为Fixed data部分，记录的是下一个binlog的位置偏移4，而余下来的43-19-8=16个字节为Variable data部分，记录的是下一个binlog的文件名mysql-bin.000054。对照mysqlbinlog -vv mysql-bin.000053可以验证。</li></ul></li><li>query event<ul><li>刷新binlog，设置binlog_format=statement，创建一个表CREATE TABLEtt(ivarchar(100) DEFAULT NULL) ENGINE=InnoDB, 然后在测试表tt中插入一条数据insert into tt values(‘abc’)，会产生3个event，包括2个query event和1个xid event。其中2个query event分别是BEGIN以及INSERT 语句，而xid event则是事务提交语句（xid event是支持XA的存储引擎才有的，因为测试表tt是innodb引擎的，所以会有。如果是myisam引擎的表，也会有BEGIN和COMMIT,只不过COMMIT会是一个query event而不是xid event）。</li><li>抛开format_desc event，从0000006b开始分析第一个query event。头部跟之前的event一样，只是query event的type为0x02，长度为0x44=64，下一个event位置为0xaf=175。flag为8，接着是data部分，从format_desc event我们可以知道query event的Fixed data部分为13个字节，因此也可以算出Variable data部分为64-19-13=32字节。<ul><li>Fixed data：首先的4个字节0x00000026为执行该语句的thread id，接下来的4个字节是执行的时间0(以秒为单位)，接下来的1个字节0x04是语句执行时的默认数据库名字的长度，我这里数据库是test，所以长度为4.接着的2个字节0x0000是错误码（注：通常情况下错误码是0表示没有错误，但是在一些非事务性表如myisam表执行INSERT…SELECT语句时可能插入部分数据后遇到duplicate-key错误会产生错误码1062，或者是事务性表在INSERT…SELECT出错不会插入部分数据，但是在执行过程中CTRL+C终止语句也可能记录错误码。slave db在复制时会执行后检查错误码是否一致，如果不一致，则复制过程会中止）,接着2个字节0x001a为状态变量块的长度26。</li><li>Variable data：从0x001a之后的26个字节为状态变量块（这个暂时先不管），然后是默认数据库名test，以0x00结尾，然后是sql语句BEGIN，接下来就是第2个query event的内容了。</li></ul></li><li>第二个query event与第一个格式一样，只是执行语句变成了insert into tt values(‘abc’)。</li><li>第三个xid event为COMMIT语句。前19个字节是通用头部，type是16。data部分中Fixed data为空，而variable data为8个字节，这8个字节0x000000008a是事务编号（注意事务编号不一定是小端字节序，因为是从内存中拷贝到磁盘的，所以这个字节序跟机器相关）。<ul><li>0x0000006b-0x000000ae为query event，语句是BEGIN,前面已经分析过。</li></ul></li></ul></li><li>table_map event<ul><li>0x0000000af开始为table_map event。除去头部19个字节，Fixed data为8个字节，前面6个字节0x32=50为table id，接着2个字节0x0001为flags。</li><li>Variable data部分，首先1个字节0x04为数据库名test的长度，然后5个字节是数据库名test+结束符。接着1个字节0x04为表名长度，接着5个字节为表名trow+结束符。接着1个字节0x02为列的数目。而后是2个列的类型定义，分别是0x03和0x0f（列的类型MYSQL_TYPE_LONG为0x03，MYSQL_TYPE_VARCHAR为0x0f)。接着是列的元数据定义，首先0x02表示元数据长度为2，因为MYSQL_TYPE_LONG没有元数据，而MYSQL_TYPE_VARCHAR元数据长度为2。接着的0x000a就是MYSQL_TYPE_VARCHAR的元数据，表示我们在定义表时的varchar字段c长度为10，最后一个字节0x02为掩码，表示第一个字段i不能为NULL。关于列的类型以及元数据等更详细的信息可以参见<a href="http://dev.mysql.com/doc/internals/en/table-map-event.html" target="_blank" rel="noopener">官方资料</a></li></ul></li><li>write_rows event<ul><li>从0x000000dd开始为write_rows event，除去头部19个字节，前6个字节0x32也是table id，然后两个字节0x0001为flags。接着的1个字节0x02为表中列的数目。然后1个字节0xff各个bit标识各列是否存在值，这里表示都存在。</li><li>接着的就是插入的各行数据了。第1个字节0xfe的各个bit标识该行变化之后各列是否为NULL，为NULL记为1.这里表示第1列不为NULL，因为第一行数据插入的是(1,NULL)。接下来是各列的数据，第一列是MYSQL_TYPE_LONG,长度为4个字节，所以0x00000001就是这个值。第二列是NULL不占字节。接下来是第二行，先是0xfc标识两列都不为NULL，先读取第一列的4个字节0x00000002也就是我们插入的数字2，然后读取第二列，先是一个字节的长度0x01，然后是内容0x61也就是字符’a’。到此，write_rows event也就分析完了。rows相关的event还有update_rows event和delete_rows event等，欲了解更多可以参见官方文档。 </li></ul></li><li>intvar event<ul><li>intvar event在binlog_format=statement时使用到，用于自增键类型auto_increment，十分重要。intval event的Fixed data部分为空，而Variable data部分为9个字节，第1个字节用于标识自增事件类型 LAST_INSERT_ID_EVENT = 1 or INSERT_ID_EVENT = 2，余下的8个字节为自增ID。 创建一个测试表 create table tinc (i int auto_increment primary key, c varchar(10)) engine=innodb;，然后执行一个插入语句INSERT INTO tinc(c) values(‘abc’);就可以看到intvar event了，这里的自增事件类型为INSERT_ID_EVENT。而如果用语句INSERT INTO tinc(i, c) VALUES(LAST_INSERT_ID()+1, ‘abc’)，则可以看到自增事件类型为LAST_INSERT_ID_EVENT的intvar event。</li></ul></li></ul><p>参考资料为<a href="https://dev.mysql.com/doc/internals/en/binary-log.html" target="_blank" rel="noopener">官方资料</a></p><h3 id="数据库加锁是什么样的流程？"><a href="#数据库加锁是什么样的流程？" class="headerlink" title="数据库加锁是什么样的流程？"></a>数据库加锁是什么样的流程？</h3><h4 id="答：-29"><a href="#答：-29" class="headerlink" title="答："></a>答：</h4><h5 id="表级锁定（table-level）"><a href="#表级锁定（table-level）" class="headerlink" title="表级锁定（table-level）"></a>表级锁定（table-level）</h5><pre><code>* 表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</code></pre><h5 id="行级锁定（row-level）"><a href="#行级锁定（row-level）" class="headerlink" title="行级锁定（row-level）"></a>行级锁定（row-level）</h5><pre><code>* 行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。</code></pre><h5 id="页级锁定（page-level）"><a href="#页级锁定（page-level）" class="headerlink" title="页级锁定（page-level）"></a>页级锁定（page-level）</h5><pre><code>* 页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。使用页级锁定的主要是BerkeleyDB存储引擎。</code></pre><h6 id="总的来说，MySQL这3种锁的特性可大致归纳如下："><a href="#总的来说，MySQL这3种锁的特性可大致归纳如下：" class="headerlink" title="总的来说，MySQL这3种锁的特性可大致归纳如下："></a>总的来说，MySQL这3种锁的特性可大致归纳如下：</h6><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<h6 id="适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。"><a href="#适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。" class="headerlink" title="适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。"></a>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</h6><h5 id="InnoDB锁定模式及实现机制"><a href="#InnoDB锁定模式及实现机制" class="headerlink" title="InnoDB锁定模式及实现机制"></a>InnoDB锁定模式及实现机制</h5>InnoDB的行级锁定同样分为两种类型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，InnoDB也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。所以，可以说InnoDB的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX），我们可以通过以下表格来总结上面这四种所的共存逻辑关系：<img src="/2019/01/28/面试/lock.png" title="lock图">如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。 意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line">排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></tbody></table></figure></li></ul><h6 id="用SELECT-…-IN-SHARE-MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。-但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT…-FOR-UPDATE方式获得排他锁。"><a href="#用SELECT-…-IN-SHARE-MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。-但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT…-FOR-UPDATE方式获得排他锁。" class="headerlink" title="用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。 但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。"></a>用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。 但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</h6><p>InnoDB行锁实现方式 InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁 在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。 （1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。 （2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。 （3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。 （4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。 3.间隙锁（Next-Key锁） 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁； 对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）</p><h5 id="nnoDB使用间隙锁的目的："><a href="#nnoDB使用间隙锁的目的：" class="headerlink" title="nnoDB使用间隙锁的目的："></a>nnoDB使用间隙锁的目的：</h5><ol><li>防止幻读，以满足相关隔离级别的要求。对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；</li><li>为了满足其恢复和复制的需要。<ul><li>很显然，在使用范围条件检索并锁定记录时，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</li><li>除了间隙锁给InnoDB带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：<ul><li>当Query无法利用索引的时候，InnoDB会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；</li><li>当Query使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所只想的数据可能有部分并不属于该Query的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；</li><li>当Query在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索引只是过滤条件的一部分），一样会被锁定。<br>因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。<br>还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁。<br>通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的SQL语句，绝大部分死锁都可以避免。下面就通过实例来介绍几种避免死锁的常用方法：</li><li>在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。</li><li>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。</li><li>在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。</li><li>当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁。这时如果有第3个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。</li></ul></li></ul></li></ol><h5 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h5><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁：</p><pre><code>* 事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。* 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。  当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。* 在InnoDB下，使用表锁要注意以下两点。    * 使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、InnoDB_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁，否则，InnoDB将无法自动检测并处理这种死锁    * 在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁</code></pre><h3 id="SQL优化怎么做？SQL执行过程是什么样子的？从client发起请求到数据库执行SQL在返回数据流程是什么？"><a href="#SQL优化怎么做？SQL执行过程是什么样子的？从client发起请求到数据库执行SQL在返回数据流程是什么？" class="headerlink" title="SQL优化怎么做？SQL执行过程是什么样子的？从client发起请求到数据库执行SQL在返回数据流程是什么？"></a>SQL优化怎么做？SQL执行过程是什么样子的？从client发起请求到数据库执行SQL在返回数据流程是什么？</h3><h4 id="答：-30"><a href="#答：-30" class="headerlink" title="答："></a>答：</h4><img src="/2019/01/28/面试/SQL执行.png" title="MySQL SQL解析图"><img src="/2019/01/28/面试/SQL.png" title="MySQL SQL"><img src="/2019/01/28/面试/流程图.png" title="MySQL 流程图"><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><ul><li>客户端发起一条Query请求，监听客户端的’连接管理模块’接收请求</li><li>将请求转发到’连接进/线程模块’</li><li>调用’用户模块’来进行授权检查</li><li>通过检查后，’连接进/线程模块’从’线程连接池’中取出空闲的被缓存的连接线程和客户端请求对接，如果失败则创建一个新的连接请求<h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5></li><li>先查询缓存，检查Query语句是否完全匹配，接着再检查是否具有权限，都成功则直接取数据返回</li><li>上一步有失败则转交给’命令解析器’，经过词法分析，语法分析后生成解析树</li><li>接下来是预处理阶段，处理解析器无法解决的语义，检查权限等，生成新的解析树</li><li>再转交给对应的模块处理</li><li>如果是SELECT查询还会经由’查询优化器’做大量的优化，生成执行计划</li><li>模块收到请求后，通过’访问控制模块’检查所连接的用户是否有访问目标表和目标字段的权限</li><li>有则调用’表管理模块’，先是查看table cache中是否存在，有则直接对应的表和获取锁，否则重新打开表文件</li><li>根据表的meta数据，获取表的存储引擎类型等信息，通过接口调用对应的存储引擎处理</li><li>上述过程中产生数据变化的时候，若打开日志功能，则会记录到相应二进制日志文件中<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5></li><li>Query请求完成后，将结果集返回给’连接进/线程模块’</li><li>返回的也可以是相应的状态标识，如成功或失败等</li><li>连接进/线程模块’进行后续的清理工作，并继续等待请求或断开与客户端的连接</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>用户模块校验用户,然后去线程连接池拿线程(连接足够的话),找命令分发器,到查询缓存模块查SQL语句,如果没有,走命令解析器,然后访问控制模块,设定用户的权限,设定好后走表管理模块,获取锁和缓存,然后获取各种信息,存储的方式:存储引擎,从存储引擎获取数据,然后返回</p><h3 id="数据库事务ACID特性"><a href="#数据库事务ACID特性" class="headerlink" title="数据库事务ACID特性"></a>数据库事务ACID特性</h3><h4 id="答：-31"><a href="#答：-31" class="headerlink" title="答："></a>答：</h4><h5 id="数据库事务ACID特性-数据库事务的4个特性："><a href="#数据库事务ACID特性-数据库事务的4个特性：" class="headerlink" title="数据库事务ACID特性,数据库事务的4个特性："></a>数据库事务ACID特性,数据库事务的4个特性：</h5><ul><li>原子性(Atomic): 事务中的多个操作，不可分割，要么都成功，要么都失败； All or Nothing.</li><li>一致性(Consistency): 事务操作之后, 数据库所处的状态和业务规则是一致的; 比如a,b账户相互转账之后，总金额不变；</li><li>隔离性(Isolation): 多个事务之间就像是串行执行一样，不相互影响;</li><li>持久性(Durability): 事务提交后被持久化到永久存储.<h5 id="隔离性-其中隔离性分为了四种："><a href="#隔离性-其中隔离性分为了四种：" class="headerlink" title="隔离性,其中隔离性分为了四种："></a>隔离性,其中隔离性分为了四种：</h5></li><li>READ UNCOMMITTED：可以读取未提交的数据，未提交的数据称为脏数据，所以又称脏读。此时：幻读，不可重复读和脏读均允许；</li><li>READ COMMITTED：只能读取已经提交的数据；此时：允许幻读和不可重复读，但不允许脏读，所以RC隔离级别要求解决脏读；</li><li>REPEATABLE READ：同一个事务中多次执行同一个select,读取到的数据没有发生改变；此时：允许幻读，但不允许不可重复读和脏读，所以RR隔离级别要求解决不可重复读；</li><li>SERIALIZABLE: 幻读，不可重复读和脏读都不允许，所以serializable要求解决幻读；<h5 id="加强理解："><a href="#加强理解：" class="headerlink" title="加强理解："></a>加强理解：</h5></li><li>脏读：可以读取未提交的数据。RC 要求解决脏读；</li><li>不可重复读：同一个事务中多次执行同一个select, 读取到的数据发生了改变(被其它事务update并且提交)；</li><li>可重复读：同一个事务中多次执行同一个select, 读取到的数据没有发生改变(一般使用MVCC实现)；RR各级级别要求达到可重复读的标准；</li><li>幻读：同一个事务中多次执行同一个select, 读取到的数据行发生改变。也就是行数减少或者增加了(被其它事务delete/insert并且提交)。SERIALIZABLE要求解决幻读问题；</li></ul><p>这里一定要区分 不可重复读 和 幻读：</p><p>不可重复读的重点是修改:</p><p>同样的条件的select, 你读取过的数据, 再次读取出来发现值不一样了</p><p>幻读的重点在于新增或者删除:</p><p>同样的条件的select, 第1次和第2次读出来的记录数不一样</p><p>从结果上来看, 两者都是为多次读取的结果不一致。但如果你从实现的角度来看, 它们的区别就比较大：</p><p>对于前者, 在RC下只需要锁住满足条件的记录，就可以避免被其它事务修改，也就是 select for update, select in share mode; RR隔离下使用MVCC实现可重复读；</p><p>对于后者, 要锁住满足条件的记录及所有这些记录之间的gap，也就是需要 gap lock。</p><p>而ANSI SQL标准没有从隔离程度进行定义，而是定义了事务的隔离级别，同时定义了不同事务隔离级别解决的三大并发问题：</p><table><thead><tr><th style="text-align:left">Isolation Level</th><th style="text-align:center">Dirty Read</th><th style="text-align:center">Unrepeatable Read</th><th style="text-align:center">Phantom Read</th></tr></thead><tbody><tr><td style="text-align:left">Read UNCOMMITTED</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:left">READ COMMITTED</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:left">READ REPEATABLE</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr></tbody></table><h5 id="MySQL-中RC和RR隔离级别的区别"><a href="#MySQL-中RC和RR隔离级别的区别" class="headerlink" title="MySQL 中RC和RR隔离级别的区别"></a>MySQL 中RC和RR隔离级别的区别</h5><p>MySQL数据库中默认隔离级别为RR，但是实际情况是使用RC 和 RR隔离级别的都不少。好像淘宝、网易都是使用的 RC 隔离级别。那么在MySQL中 RC 和 RR有什么区别呢？我们该如何选择呢？为什么MySQL将RR作为默认的隔离级别呢？<br><strong>RC 与 RR 在锁方面的区别</strong></p><blockquote><p>显然 RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR；</p></blockquote><blockquote><p>RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉(虽然这里破坏了“两阶段加锁原则”)；但是RR隔离级别，即使不符合where条件的记录，也不会是否行锁和gap lock；所以从锁方面来看，RC的并发应该要好于RR；另外 insert into t select … from s where 语句在s表上的锁也是不一样的</p></blockquote><p><strong>两个并发事务A，B执行的时间序列如下(A先于B开始，B先于A结束)</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A1: start transaction;</span><br><span class="line">B1: start transaction;</span><br><span class="line">A2: select * from t;</span><br><span class="line">B2: insert into t values (4, wangwu);</span><br><span class="line">A3: select * from t;</span><br><span class="line">B3: commit;</span><br><span class="line">A4: select * from t;</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提问1：假设事务的隔离级别是可重复读RR，事务A中的三次查询，A2, A3, A4分别读到什么结果集？</span><br><span class="line">回答：RR下</span><br><span class="line">(1)A2读到的结果集肯定是{1, 2, 3}，这是事务A的第一个<span class="built_in">read</span>，假设为时间T；</span><br><span class="line">(2)A3读到的结果集也是{1, 2, 3}，因为B还没有提交；</span><br><span class="line">(3)A4读到的结果集还是{1, 2, 3}，因为事务B是在时间T之后提交的，A4得读到和A2一样的记录；</span><br><span class="line"></span><br><span class="line">提问2：假设事务的隔离级别是读提交RC，A2, A3, A4又分别读到什么结果集呢？</span><br><span class="line">回答：RC下</span><br><span class="line">(1)A2读到的结果集是{1, 2, 3}；</span><br><span class="line">(2)A3读到的结果集也是{1, 2, 3}，因为B还没有提交；</span><br><span class="line">(3)A4读到的结果集还是{1, 2, 3, 4}，因为事务B已经提交</span><br></pre></td></tr></tbody></table></figure><p><strong>仍然是上面的两个事务，只是A和B开始时间稍有不同(B先于A开始，B先于A结束)</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">B1: start transaction;</span><br><span class="line">A1: start transaction;</span><br><span class="line">A2: select * from t;</span><br><span class="line">B2: insert into t values (4, wangwu);</span><br><span class="line">A3: select * from t;</span><br><span class="line">B3: commit;</span><br><span class="line">A4: select * from t;</span><br><span class="line"></span><br><span class="line">提问3：假设事务的隔离级别是可重复读RR，事务A中的三次查询，A2, A3, A4分别读到什么结果集？</span><br><span class="line">提问4：假设事务的隔离级别是读提交RC，A2, A3, A4的结果集又是什么呢？</span><br><span class="line"></span><br><span class="line">回答：事务的开始时间不一样，不会影响“快照读”的结果，所以结果集和<span class="keyword">case</span> 1一样。</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>仍然是并发的事务A与B(A先于B开始，B先于A结束)</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A1: start transaction;</span><br><span class="line">B1: start transaction;</span><br><span class="line">B2: insert into t values (4, wangwu);</span><br><span class="line">B3: commit;</span><br><span class="line">A2: select * from t;</span><br><span class="line">提问5：假设事务的隔离级别是可重复读RR，事务A中的A2查询，结果集是什么？</span><br><span class="line">提问6：假设事务的隔离级别是读提交RC，A2的结果集又是什么呢？</span><br><span class="line">回答：在RR下，</span><br><span class="line">A2是事务A的第一个<span class="built_in">read</span>，假设为时间T，它能读取到T之前提交事务写入的数据行，故结果集为{1, 2, 3, 4}。在RC下，没有疑问，一定是{1, 2, 3, 4}。</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>事务开始的时间再换一下(B先于A开始，B先于A结束)</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">B1: start transaction;</span><br><span class="line">A1: start transaction;</span><br><span class="line">B2: insert into t values (4, wangwu);</span><br><span class="line">B3: commit;</span><br><span class="line">A2: select * from t;</span><br><span class="line"></span><br><span class="line">提问7：假设事务的隔离级别是可重复读RR，事务A中的A2查询，结果集是什么？</span><br><span class="line">提问8：假设事务的隔离级别是读提交RC，A2的结果集又是什么呢？</span><br><span class="line">回答：事务的开始时间不一样，不会影响“快照读”的结果，所以结果集和<span class="keyword">case</span> 3一样。</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>RR下，事务在第一个Read操作时，会建立Read View</li><li>RC下，事务在每次Read操作时，都会建立Read View</li></ul><h3 id="怎么针对数据库中某一张表中的一条数据上锁？"><a href="#怎么针对数据库中某一张表中的一条数据上锁？" class="headerlink" title="怎么针对数据库中某一张表中的一条数据上锁？"></a>怎么针对数据库中某一张表中的一条数据上锁？</h3><h4 id="答：-32"><a href="#答：-32" class="headerlink" title="答："></a>答：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql> SELECT * FROM T1 WHERE ID = 1 FOR UPDATE;</span><br><span class="line">mysql> SELECT * FROM T1 WHERE ID = 1 LOCK IN SHARE MODE;</span><br></pre></td></tr></tbody></table></figure><h3 id="行锁的三种模式，讲讲是什么？"><a href="#行锁的三种模式，讲讲是什么？" class="headerlink" title="行锁的三种模式，讲讲是什么？"></a>行锁的三种模式，讲讲是什么？</h3><h4 id="答：-33"><a href="#答：-33" class="headerlink" title="答："></a>答：</h4><h5 id="InnoDB有三种行锁的算法："><a href="#InnoDB有三种行锁的算法：" class="headerlink" title="InnoDB有三种行锁的算法："></a>InnoDB有三种行锁的算法：</h5><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</li><li>Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</li></ul><h3 id="innobackupex原理说一下"><a href="#innobackupex原理说一下" class="headerlink" title="innobackupex原理说一下"></a>innobackupex原理说一下</h3><h4 id="答：-34"><a href="#答：-34" class="headerlink" title="答："></a>答：</h4><img src="/2019/01/28/面试/innodbbackup.png" title="innodbbackup图"><ul><li>innobackupex 在启动后，会先 fork 一个进程，启动 xtrabackup进程，然后就等待 xtrabackup 备份完 ibd 数据文件；</li><li>xtrabackup 在备份 InnoDB 相关数据时，是有2种线程的，1种是 redo 拷贝线程，负责拷贝 redo 文件，1种是 ibd 拷贝线程，负责拷贝 ibd 文件；redo 拷贝线程只有一个，在 ibd 拷贝线程之前启动，在 ibd 线程结束后结束。xtrabackup 进程开始执行后，先启动 redo 拷贝线程，从最新的 checkpoint 点开始顺序拷贝 redo 日志；然后再启动 ibd 数据拷贝线程，在 xtrabackup 拷贝 ibd 过程中，innobackupex 进程一直处于等待状态（等待文件被创建）。</li><li>xtrabackup 拷贝完成idb后，通知 innobackupex（通过创建文件），同时自己进入等待（redo 线程仍然继续拷贝）;</li><li>innobackupex 收到 xtrabackup 通知后，执行FLUSH TABLES WITH READ LOCK (FTWRL)，取得一致性位点，然后开始备份非 InnoDB 文件（包括 frm、MYD、MYI、CSV、opt、par等）。拷贝非 InnoDB 文件过程中，因为数据库处于全局只读状态，如果在业务的主库备份的话，要特别小心，非 InnoDB 表（主要是MyISAM）比较多的话整库只读时间就会比较长，这个影响一定要评估到。</li><li>当 innobackupex 拷贝完所有非 InnoDB 表文件后，通知 xtrabackup（通过删文件） ，同时自己进入等待（等待另一个文件被创建）；</li><li>xtrabackup 收到 innobackupex 备份完非 InnoDB 通知后，就停止 redo 拷贝线程，然后通知 innobackupexredo log 拷贝完成（通过创建文件）；</li><li>innobackupex 收到 redo 备份完成通知后，就开始解锁，执行 UNLOCK TABLES；</li><li>最后 innobackupex 和 xtrabackup 进程各自完成收尾工作，如资源的释放、写备份元数据信息等，innobackupex 等待 xtrabackup 子进程结束后退出。</li></ul><p>在上面描述的文件拷贝，都是备份进程直接通过操作系统读取数据文件的，只在执行 SQL 命令时和数据库有交互，基本不影响数据库的运行，在备份非 InnoDB 时会有一段时间只读（如果没有MyISAM表的话，只读时间在几秒左右），在备份 InnoDB 数据文件时，对数据库完全没有影响，是真正的热备。InnoDB 和非 InnoDB 文件的备份都是通过拷贝文件来做的，但是实现的方式不同，前者是以page为粒度做的(xtrabackup)，后者是 cp 或者 tar 命令(innobackupex)，xtrabackup 在读取每个page时会校验 checksum 值，保证数据块是一致的，而 innobackupex 在 cp MyISAM 文件时已经做了flush（FTWRL），磁盘上的文件也是完整的，所以最终备份集里的数据文件都是写入完整的。</p><h3 id="对NoSQL有了解吗？mongoDB副本集选举流程什么？"><a href="#对NoSQL有了解吗？mongoDB副本集选举流程什么？" class="headerlink" title="对NoSQL有了解吗？mongoDB副本集选举流程什么？"></a>对NoSQL有了解吗？mongoDB副本集选举流程什么？</h3><h4 id="答：-35"><a href="#答：-35" class="headerlink" title="答："></a>答：</h4><h6 id="Mongodb复制集由一组Mongod实例（进程）组成，包含一个Primary节点和多个Secondary节点，Mongodb-Driver（客户端）的所有数据都写入Primary，Secondary从Primary同步写入的数据，以保持复制集内所有成员存储相同的数据集，提供数据的高可用。"><a href="#Mongodb复制集由一组Mongod实例（进程）组成，包含一个Primary节点和多个Secondary节点，Mongodb-Driver（客户端）的所有数据都写入Primary，Secondary从Primary同步写入的数据，以保持复制集内所有成员存储相同的数据集，提供数据的高可用。" class="headerlink" title="Mongodb复制集由一组Mongod实例（进程）组成，包含一个Primary节点和多个Secondary节点，Mongodb Driver（客户端）的所有数据都写入Primary，Secondary从Primary同步写入的数据，以保持复制集内所有成员存储相同的数据集，提供数据的高可用。"></a>Mongodb复制集由一组Mongod实例（进程）组成，包含一个Primary节点和多个Secondary节点，Mongodb Driver（客户端）的所有数据都写入Primary，Secondary从Primary同步写入的数据，以保持复制集内所有成员存储相同的数据集，提供数据的高可用。</h6><img src="/2019/01/28/面试/mongodb.png" title="mongodb图"><h6 id="Primary选举"><a href="#Primary选举" class="headerlink" title="Primary选举"></a>Primary选举</h6><blockquote><p>复制集通过replSetInitiate命令（或mongo shell的rs.initiate()）进行初始化，初始化后各个成员间开始发送心跳消息，并发起Priamry选举操作，获得『大多数』成员投票支持的节点，会成为Primary，其余节点成为Secondary。</p></blockquote><h6 id="大多数』的定义"><a href="#大多数』的定义" class="headerlink" title="大多数』的定义"></a>大多数』的定义</h6><blockquote><p>假设复制集内投票成员（后续介绍）数量为N，则大多数为 N/2 + 1，当复制集内存活成员数量不足大多数时，整个复制集将无法选举出Primary，复制集将无法提供写服务，处于只读状态。</p></blockquote><h6 id="特殊的Secondary"><a href="#特殊的Secondary" class="headerlink" title="特殊的Secondary"></a>特殊的Secondary</h6><blockquote><p>正常情况下，复制集的Seconary会参与Primary选举（自身也可能会被选为Primary），并从Primary同步最新写入的数据，以保证与Primary存储相同的数据。</p></blockquote><blockquote><p>Secondary可以提供读服务，增加Secondary节点可以提供复制集的读服务能力，同时提升复制集的可用性。另外，Mongodb支持对复制集的Secondary节点进行灵活的配置，以适应多种场景的需求。</p></blockquote><h6 id="特殊的Secondary-1"><a href="#特殊的Secondary-1" class="headerlink" title="特殊的Secondary"></a>特殊的Secondary</h6><blockquote><p>正常情况下，复制集的Seconary会参与Primary选举（自身也可能会被选为Primary），并从Primary同步最新写入的数据，以保证与Primary存储相同的数据。</p></blockquote><blockquote><p>Secondary可以提供读服务，增加Secondary节点可以提供复制集的读服务能力，同时提升复制集的可用性。另外，Mongodb支持对复制集的Secondary节点进行灵活的配置，以适应多种场景的需求</p></blockquote><h6 id="Arbiter"><a href="#Arbiter" class="headerlink" title="Arbiter"></a>Arbiter</h6><blockquote><p>Arbiter节点只参与投票，不能被选为Primary，并且不从Primary同步数据。 比如你部署了一个2个节点的复制集，1个Primary，1个Secondary，任意节点宕机，复制集将不能提供服务了（无法选出Primary），这时可以给复制集添加一个Arbiter节点，即使有节点宕机，仍能选出Primary。</p></blockquote><blockquote><p>Arbiter本身不存储数据，是非常轻量级的服务，当复制集成员为偶数时，最好加入一个Arbiter节点，以提升复制集可用性。</p></blockquote><h6 id="Priority0"><a href="#Priority0" class="headerlink" title="Priority0"></a>Priority0</h6><blockquote><p>Priority0节点的选举优先级为0，不会被选举为Primary。</p></blockquote><pre><code>比如你跨机房A、B部署了一个复制集，并且想指定Primary必须在A机房，这时可以将B机房的复制集成员Priority设置为0，这样Primary就一定会是A机房的成员。（注意：如果这样部署，最好将『大多数』节点部署在A机房，否则网络分区时可能无法选出Primary） </code></pre><h6 id="Vote0"><a href="#Vote0" class="headerlink" title="Vote0"></a>Vote0</h6><blockquote><p>Mongodb 3.0里，复制集成员最多50个，参与Primary选举投票的成员最多7个，其他成员（Vote0）的vote属性必须设置为0，即不参与投票。</p></blockquote><h6 id="Hidden"><a href="#Hidden" class="headerlink" title="Hidden"></a>Hidden</h6><blockquote><p>Hidden节点不能被选为主（Priority为0），并且对Driver不可见。 因Hidden节点不会接受Driver的请求，可使用Hidden节点做一些数据备份、离线计算的任务，不会影响复制集的服务。</p></blockquote><h6 id="Delayed"><a href="#Delayed" class="headerlink" title="Delayed"></a>Delayed</h6><blockquote><p>Delayed节点必须是Hidden节点，并且其数据落后与Primary一段时间（可配置，比如1个小时）。 因Delayed节点的数据比Primary落后一段时间，当错误或者无效的数据写入Primary时，可通过Delayed节点的数据来恢复到之前的时间点。</p></blockquote><h6 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h6><blockquote><p>Primary与Secondary之间通过oplog来同步数据，Primary上的写操作完成后，会向特殊的local.oplog.rs特殊集合写入一条oplog，Secondary不断的从Primary取新的oplog并应用。</p></blockquote><blockquote><p>因oplog的数据会不断增加，local.oplog.rs被设置成为一个capped集合，当容量达到配置上限时，会将最旧的数据删除掉。另外考虑到oplog在Secondary上可能重复应用，oplog必须具有幂等性，即重复应用也会得到相同的结果。</p></blockquote><h6 id="oplog里各个字段的含义如下"><a href="#oplog里各个字段的含义如下" class="headerlink" title="oplog里各个字段的含义如下"></a>oplog里各个字段的含义如下</h6><ul><li>ts： 操作时间，当前timestamp + 计数器，计数器每秒都被重置</li><li>h：操作的全局唯一标识</li><li>v：oplog版本信息</li><li>op：操作类型<ul><li>i：插入操作</li><li>u：更新操作</li><li>d：删除操作</li><li>c：执行命令（如createDatabase，dropDatabase）</li><li>n：空操作，特殊用途</li></ul></li><li>ns：操作针对的集合</li><li>o：操作内容，如果是更新操作</li><li>o2：操作查询条件，仅update操作包含该字段<h6 id="Secondary初次同步数据时，会先进行init-sync，从Primary（或其他数据更新的Secondary）同步全量数据，然后不断通过tailable-cursor从Primary的local-oplog-rs集合里查询最新的oplog并应用到自身。"><a href="#Secondary初次同步数据时，会先进行init-sync，从Primary（或其他数据更新的Secondary）同步全量数据，然后不断通过tailable-cursor从Primary的local-oplog-rs集合里查询最新的oplog并应用到自身。" class="headerlink" title="Secondary初次同步数据时，会先进行init sync，从Primary（或其他数据更新的Secondary）同步全量数据，然后不断通过tailable cursor从Primary的local.oplog.rs集合里查询最新的oplog并应用到自身。"></a>Secondary初次同步数据时，会先进行init sync，从Primary（或其他数据更新的Secondary）同步全量数据，然后不断通过tailable cursor从Primary的local.oplog.rs集合里查询最新的oplog并应用到自身。</h6></li></ul><ol><li>T1时间，从Primary同步所有数据库的数据（local除外），通过listDatabases + listCollections + cloneCollection敏命令组合完成，假设T2时间完成所有操作。</li><li>从Primary应用[T1-T2]时间段内的所有oplog，可能部分操作已经包含在步骤1，但由于oplog的幂等性，可重复应用。</li><li>根据Primary各集合的index设置，在Secondary上为相应集合创建index。（每个集合_id的index已在步骤1中完成）。</li></ol><h6 id="oplog集合的大小应根据DB规模及应用写入需求合理配置，配置得太大，会造成存储空间的浪费；配置得太小，可能造成Secondary的init-sync一直无法成功。比如在步骤1里由于DB数据太多、并且oplog配置太小，导致oplog不足以存储-T1-T2-时间内的所有oplog，这就Secondary无法从Primary上同步完整的数据集。"><a href="#oplog集合的大小应根据DB规模及应用写入需求合理配置，配置得太大，会造成存储空间的浪费；配置得太小，可能造成Secondary的init-sync一直无法成功。比如在步骤1里由于DB数据太多、并且oplog配置太小，导致oplog不足以存储-T1-T2-时间内的所有oplog，这就Secondary无法从Primary上同步完整的数据集。" class="headerlink" title="oplog集合的大小应根据DB规模及应用写入需求合理配置，配置得太大，会造成存储空间的浪费；配置得太小，可能造成Secondary的init sync一直无法成功。比如在步骤1里由于DB数据太多、并且oplog配置太小，导致oplog不足以存储[T1, T2]时间内的所有oplog，这就Secondary无法从Primary上同步完整的数据集。"></a>oplog集合的大小应根据DB规模及应用写入需求合理配置，配置得太大，会造成存储空间的浪费；配置得太小，可能造成Secondary的init sync一直无法成功。比如在步骤1里由于DB数据太多、并且oplog配置太小，导致oplog不足以存储[T1, T2]时间内的所有oplog，这就Secondary无法从Primary上同步完整的数据集。</h6><h6 id="细说Primary选举"><a href="#细说Primary选举" class="headerlink" title="细说Primary选举"></a>细说Primary选举</h6><h6 id="Primary选举除了在复制集初始化时发生，还有如下场景"><a href="#Primary选举除了在复制集初始化时发生，还有如下场景" class="headerlink" title="Primary选举除了在复制集初始化时发生，还有如下场景"></a>Primary选举除了在复制集初始化时发生，还有如下场景</h6><ul><li>复制集被reconfig</li><li>Secondary节点检测到Primary宕机时，会触发新Primary的选举</li><li>当有Primary节点主动stepDown（主动降级为Secondary）时，也会触发新的Primary选举<h6 id="Primary的选举受节点间心跳、优先级、最新的oplog时间等多种因素影响。"><a href="#Primary的选举受节点间心跳、优先级、最新的oplog时间等多种因素影响。" class="headerlink" title="Primary的选举受节点间心跳、优先级、最新的oplog时间等多种因素影响。"></a>Primary的选举受节点间心跳、优先级、最新的oplog时间等多种因素影响。</h6><h6 id="节点间心跳"><a href="#节点间心跳" class="headerlink" title="节点间心跳"></a>节点间心跳</h6><h6 id="复制集成员间默认每2s会发送一次心跳信息，如果10s未收到某个节点的心跳，则认为该节点已宕机；如果宕机的节点为Primary，Secondary（前提是可被选为Primary）会发起新的Primary选举。"><a href="#复制集成员间默认每2s会发送一次心跳信息，如果10s未收到某个节点的心跳，则认为该节点已宕机；如果宕机的节点为Primary，Secondary（前提是可被选为Primary）会发起新的Primary选举。" class="headerlink" title="复制集成员间默认每2s会发送一次心跳信息，如果10s未收到某个节点的心跳，则认为该节点已宕机；如果宕机的节点为Primary，Secondary（前提是可被选为Primary）会发起新的Primary选举。"></a>复制集成员间默认每2s会发送一次心跳信息，如果10s未收到某个节点的心跳，则认为该节点已宕机；如果宕机的节点为Primary，Secondary（前提是可被选为Primary）会发起新的Primary选举。</h6><h6 id="节点优先级"><a href="#节点优先级" class="headerlink" title="节点优先级"></a>节点优先级</h6></li><li>每个节点都倾向于投票给优先级最高的节点</li><li>优先级为0的节点不会主动发起Primary选举</li><li>当Primary发现有优先级更高Secondary，并且该Secondary的数据落后在10s内，则Primary会主动降级，让优先级更高的Secondary有成为Primary的机会。<h6 id="Optime"><a href="#Optime" class="headerlink" title="Optime"></a>Optime</h6><blockquote><p>拥有最新optime（最近一条oplog的时间戳）的节点才能被选为主。</p></blockquote><h6 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h6><blockquote><p>只有更大多数投票节点间保持网络连通，才有机会被选Primary；如果Primary与大多数的节点断开连接，Primary会主动降级为Secondary。当发生网络分区时，可能在短时间内出现多个Primary，故Driver在写入时，最好设置『大多数成功』的策略，这样即使出现多个Primary，也只有一个Primary能成功写入大多数。</p></blockquote></li></ul><h3 id="说说TCP协议流程"><a href="#说说TCP协议流程" class="headerlink" title="说说TCP协议流程"></a>说说TCP协议流程</h3><h4 id="答：-36"><a href="#答：-36" class="headerlink" title="答："></a>答：</h4><img src="/2019/01/28/面试/tcpbao.jpg" title="tcpbao"><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">URG</td><td style="text-align:left">紧急指针是否有效。为1，表示某一位需要被优先处理</td></tr><tr><td style="text-align:left">ACK</td><td style="text-align:left">确认号是否有效，一般置为1。</td></tr><tr><td style="text-align:left">PSH</td><td style="text-align:left">提示接收端应用程序立即从TCP缓冲区把数据读走。</td></tr><tr><td style="text-align:left">RST</td><td style="text-align:left">对方要求重新建立连接，复位。</td></tr><tr><td style="text-align:left">SYN</td><td style="text-align:left">请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td></tr><tr><td style="text-align:left">FIN</td><td style="text-align:left">希望断开连接。</td></tr></tbody></table><h5 id="TCP-握手"><a href="#TCP-握手" class="headerlink" title="TCP 握手"></a>TCP 握手</h5><img src="/2019/01/28/面试/tcpwoshou.png" title="tcpwoshou"><h6 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h6><blockquote><p>客户端发送数据包到服务器,(在此连接请求报文段中的同步位SYN=1,确认ACK=0,表示这是一个TCP连接请求数据报文,序号seq=x,表示传输数据时的起始序号是x)此时,客户端进入SYN_SENT状态,等待服务器确认</p></blockquote><h6 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h6><blockquote><p>服务器收到连接请求报文段后，若同意建立连接,则向客户端发送确认报文段。此时服务器进入SYN_RECV状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。</p></blockquote><h6 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h6><blockquote><p>客户端再次向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。</p></blockquote><h5 id="TCP释放"><a href="#TCP释放" class="headerlink" title="TCP释放"></a>TCP释放</h5><img src="/2019/01/28/面试/tcpshifang.png" title="tcpshifang"><h6 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h6><blockquote><p>首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。</p></blockquote><h6 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h6><blockquote><p>服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。</p></blockquote><h6 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h6><blockquote><p>关闭服务器到客户端的连接，发送一个FIN给客户端。</p></blockquote><h6 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h6><blockquote><p>客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p></blockquote><h5 id="TCP-挥手总结"><a href="#TCP-挥手总结" class="headerlink" title="TCP 挥手总结"></a>TCP 挥手总结</h5><p>客户端发送FIN后，进入终止等待状态，服务器收到客户端连接释放报文段后，就立即给客户端发送确认，服务器就进入CLOSE_WAIT状态，此时TCP服务器进程就通知高层应用进程，因而从客户端到服务器的连接就释放了。此时是“半关闭状态”，即客户端不可以发送给服务器，服务器可以发送给客户端。此时，如果服务器没有数据报发送给客户端，其应用程序就通知TCP释放连接，然后发送给客户端连接释放数据报，并等待确认。客户端发送确认后，进入TIME_WAIT状态，但是此时TCP连接还没有释放，然后经过等待计时器设置的2MSL后，才进入到CLOSE状态。</p><h3 id="MySQL的-Double-Writer-双写-是什么？"><a href="#MySQL的-Double-Writer-双写-是什么？" class="headerlink" title="MySQL的 Double Writer(双写)是什么？"></a>MySQL的 Double Writer(双写)是什么？</h3><h4 id="答：-37"><a href="#答：-37" class="headerlink" title="答："></a>答：</h4><p>有一个double write buffer，大小为2M。另一部分是物理磁盘上ibdata系统表空间中大小为2MB，共128个连续的Page，既2个分区。其中120个用于批量写脏，另外8个用于Single Page Flush。做区分的原因是批量刷脏是后台线程做的，不影响前台线程。而Single page flush是用户线程发起的，需要尽快的刷脏并替换出一个空闲页出来。对于批量刷脏，每次找到一个可做flush的page，对其持有S lock，然后将该page拷贝到dblwr中，当dblwr满后者一次批量刷脏结束时，将dblwr中的page全部刷到ibdata中，注意这是同步写操作；然后再唤醒后台IO线程去写数据页。当后台IO线程完成写操作后，会去更新dblwr中的计数以腾出空间，释放block上的S锁，完成写入。</p><p>对于Single Page Flush，则做的是同步写操作，在挑出一个可以刷脏的page后，先加入到dblwr中，刷到ibdata，然后写到用户表空间，完成后，会对该用户表空间做一次fsync操作。</p><p>Single Page Flush在buffer pool中free page不够时触发，通常由前台线程发起，由于每次single page flush都会导致一次fsync操作，在大并发负载下，如果大量线程去做flush，很显然会产生严重的性能下降。Percona在5.6版本中做了优化，可以选择由后台线程lru manager来做预刷，避免用户线程陷入其中。</p><p>如果发生了极端情况（断电）Crash Recovery，InnoDB再次启动后，发现了一个Page数据已经损坏，那么此时就可以从double write buffer中进行数据恢复了。触发数据缓冲池中的脏页进行刷新到data file的时候，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的double write buffer，之后通过double write buffer再分两次、每次1MB顺序写入共享表空间的物理磁盘上。然后马上调用fsync函数，同步脏页进磁盘上。由于在这个过程中，double write页的存储时连续的，因此写入磁盘为顺序写，性能很高；完成double write后，再将脏页写入实际的各个表空间文件。</p><h3 id="MySQL-半同步中5-7比5-6的优点是那些呢？"><a href="#MySQL-半同步中5-7比5-6的优点是那些呢？" class="headerlink" title="MySQL 半同步中5.7比5.6的优点是那些呢？"></a>MySQL 半同步中5.7比5.6的优点是那些呢？</h3><h4 id="答：-38"><a href="#答：-38" class="headerlink" title="答："></a>答：</h4><p>半同步复制，普通的replication，即mysql的异步复制，依靠mysql二进制日志也即binary log进行数据复制。比如两台机器，一台主机(master)，另外一台是从机(slave)。</p><ul><li>正常的复制为：事务一（t1）写入binlog buffer；dumper 线程通知slave有新的事务t1；binlog buffer 进行checkpoint；slave的io线程接收到t1并写入到自己的的relay log；slave的sql线程写入到本地数据库。 这时，master和slave都能看到这条新的事务，即使master挂了，slave可以提升为新的master。</li><li>异常的复制为：事务一（t1）写入binlog buffer；dumper 线程通知slave有新的事务t1；binlog buffer 进行checkpoint；slave因为网络不稳定，一直没有收到t1；master 挂掉，slave提升为新的master，t1丢失。</li><li>很大的问题是：主机和从机事务更新的不同步，就算是没有网络或者其他系统的异常，当业务并发上来时，slave因为要顺序执行master批量事务，导致很大的延迟。</li></ul><p>为了弥补以上几种场景的不足，mysql从5.5开始推出了半同步。即在master的dumper线程通知slave后，增加了一个ack，即是否成功收到t1的标志码。也就是dumper线程除了发送t1到slave，还承担了接收slave的ack工作。如果出现异常，没有收到ack，那么将自动降级为普通的复制，直到异常修复。</p><p>我们可以看到半同步带来的新问题：</p><ul><li>如果异常发生，会降级为普通的复制。 那么从机出现数据不一致的几率会减少，并不是完全消失。</li><li>主机dumper线程承担的工作变多了，这样显然会降低整个数据库的性能。</li><li>在MySQL 5.5和5.6使用after_commit的模式下, 即如果slave 没有收到事务，也就是还没有写入到relay log 之前，网络出现异常或者不稳定，此时刚好master挂了，系统切换到从机，两边的数据就会出现不一致。 在此情况下，slave会少一个事务的数据。</li></ul><p>MySQL 5.7 主从一致性加强，支持在事务commit前等待ACK<br>新版本的semi sync 增加了rpl_semi_sync_master_wait_point= AFTER_SYNC;参数, 来控制半同步模式下主库在返回给会话事务成功之前提交事务的方式。<br>该参数有两个值:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFTER_COMMIT: master将每个事务写入binlog ,传递到slave 刷新到磁盘(relay <span class="built_in">log</span>)，同时主库提交事务。master等待slave 反馈收到relay <span class="built_in">log</span>，只有收到ACK后master才将commit OK结果反馈给客户端。</span><br><span class="line">AFTER_SYNC(5.7独有): master 将每个事务写入binlog , 传递到slave 刷新到磁盘(relay <span class="built_in">log</span>)。master等待slave 反馈接收到relay <span class="built_in">log</span>的ack之后，再提交事务并且返回commit OK结果给客户端。 即使主库crash，所有在主库上已经提交的事务都能保证已经同步到slave的relay <span class="built_in">log</span>中。</span><br></pre></td></tr></tbody></table></figure><p></p><p>支持发送binlog和接受ACK的异步化</p><ul><li>旧版本的semi sync 受限于dump thread ，原因是dump thread 承担了两份不同且又十分频繁的任务：传送binlog 给slave ，还需要等待slave反馈信息，而且这两个任务是串行的，dump thread 必须等待 slave 返回之后才会传送下一个 events 事务。dump thread 已然成为整个半同步提高性能的瓶颈。在高并发业务场景下，这样的机制会影响数据库整体的TPS 。</li><li>without_ack_receiving_thread<ul><li>为了解决上述问题，在5.7版本的semi sync 框架中，独立出一个 ack collector thread ，专门用于接收slave 的反馈信息。这样master 上有两个线程独立工作，可以同时发送binlog 到slave ，和接收slave的反馈。</li></ul></li><li>控制主库接受SLAVE写事务成功反馈数量。<ul><li>MySQL 5.7 新增了SET GLOBAL rpl_semi_sync_master_wait_for_slave_count= N;参数，可以用来控制主库接受多少个slave写事务成功反馈，给高可用架构切换提供了灵活性。当count值为2时，master需等待两个slave的ack。</li></ul></li><li>Binlog 互斥锁改进<ul><li>旧版本半同步复制在主提交binlog的写会话和dump thread读binlog的操作都会对binlog添加互斥锁，导致binlog文件的读写是串行化的，存在并发度的问题。</li></ul><ul><li>binlog_mutex_after_tuning<ul><li>MySQL 5.7 对binlog lock进行了以下两方面优化:<ul><li>移除了dump thread对binlog的互斥锁</li><li>加入了安全边际保证binlog的读安全</li></ul></li></ul></li></ul></li><li>组提交<ul><li>MySQL 5.7 引入了新的变量slave-parallel-type，其可以配置的值有:<ul><li>DATABASE （5.7之前默认值），基于库的并行复制方式</li><li>LOGICAL_CLOCK （5.7新增值），基于组提交的并行复制方式；</li></ul></li></ul></li></ul><h3 id="MySQL的RPO-和-RTO-名词是什么意思？"><a href="#MySQL的RPO-和-RTO-名词是什么意思？" class="headerlink" title="MySQL的RPO 和 RTO 名词是什么意思？"></a>MySQL的RPO 和 RTO 名词是什么意思？</h3><h4 id="答：-39"><a href="#答：-39" class="headerlink" title="答："></a>答：</h4><h4 id="RPO-恢复点目标"><a href="#RPO-恢复点目标" class="headerlink" title="RPO: 恢复点目标"></a>RPO: 恢复点目标</h4><ul><li>恢复点目标是指企业的损失容限：在对业务造成重大损害之前可能丢失的数据量。该目标表示为从丢失事件到最近一次在前备份的时间度量。<h4 id="RTO-恢复时间目标"><a href="#RTO-恢复时间目标" class="headerlink" title="RTO: 恢复时间目标"></a>RTO: 恢复时间目标</h4></li><li>RTO指的是应用程序可以中断或关闭多少时间而不会对业务造成重大损害。有些应用程序可能会停机数天而不会产生严重的后果。而一些高优先级的应用程序只能停下来几秒钟，否则将会让企业和客户难以应对，并导致业务丢失。</li></ul><h3 id="比如一个操作，Begin-insert-into…-commit-这么操作。TPS-是几？QPS-是几"><a href="#比如一个操作，Begin-insert-into…-commit-这么操作。TPS-是几？QPS-是几" class="headerlink" title="比如一个操作，Begin;insert into….; commit; 这么操作。TPS 是几？QPS 是几?"></a>比如一个操作，Begin;insert into….; commit; 这么操作。TPS 是几？QPS 是几?</h3><h4 id="答：-40"><a href="#答：-40" class="headerlink" title="答："></a>答：</h4><p>我理解的是QPS中包含TPS，所以QPS 是3，TPS 是1.</p><h3 id="InnoDB的-MVCC-和-READ-VIEW-给我讲解下？"><a href="#InnoDB的-MVCC-和-READ-VIEW-给我讲解下？" class="headerlink" title="InnoDB的 MVCC 和 READ VIEW 给我讲解下？"></a>InnoDB的 MVCC 和 READ VIEW 给我讲解下？</h3><h4 id="答：-41"><a href="#答：-41" class="headerlink" title="答："></a>答：</h4><p>MVCC</p><h5 id="是multiversion-concurrency-control的简称，也就是多版本并发控制，是个很基本的概念。MVCC的作用是让事务在并行发生时，在一定隔离级别前提下，可以保证在某个事务中能实现一致性读，也就是该事务启动时根据某个条件读取到的数据，直到事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化（不会看到被其他并行事务修改的数据）。"><a href="#是multiversion-concurrency-control的简称，也就是多版本并发控制，是个很基本的概念。MVCC的作用是让事务在并行发生时，在一定隔离级别前提下，可以保证在某个事务中能实现一致性读，也就是该事务启动时根据某个条件读取到的数据，直到事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化（不会看到被其他并行事务修改的数据）。" class="headerlink" title="是multiversion concurrency control的简称，也就是多版本并发控制，是个很基本的概念。MVCC的作用是让事务在并行发生时，在一定隔离级别前提下，可以保证在某个事务中能实现一致性读，也就是该事务启动时根据某个条件读取到的数据，直到事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化（不会看到被其他并行事务修改的数据）。"></a>是multiversion concurrency control的简称，也就是多版本并发控制，是个很基本的概念。MVCC的作用是让事务在并行发生时，在一定隔离级别前提下，可以保证在某个事务中能实现一致性读，也就是该事务启动时根据某个条件读取到的数据，直到事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化（不会看到被其他并行事务修改的数据）。</h5><p>read view</p><h5 id="InnoDB-MVCC使用的内部快照的意思。在不同的隔离级别下，事务启动时（有些情况下，可能是SQL语句开始时）看到的数据快照版本可能也不同。在RR、RC、RU（READ-UNCOMMITTED）等几个隔离级别下会用到-read-view。"><a href="#InnoDB-MVCC使用的内部快照的意思。在不同的隔离级别下，事务启动时（有些情况下，可能是SQL语句开始时）看到的数据快照版本可能也不同。在RR、RC、RU（READ-UNCOMMITTED）等几个隔离级别下会用到-read-view。" class="headerlink" title="InnoDB MVCC使用的内部快照的意思。在不同的隔离级别下，事务启动时（有些情况下，可能是SQL语句开始时）看到的数据快照版本可能也不同。在RR、RC、RU（READ UNCOMMITTED）等几个隔离级别下会用到 read view。"></a>InnoDB MVCC使用的内部快照的意思。在不同的隔离级别下，事务启动时（有些情况下，可能是SQL语句开始时）看到的数据快照版本可能也不同。在RR、RC、RU（READ UNCOMMITTED）等几个隔离级别下会用到 read view。</h5><p>何时创建read view</p><h5 id="其实，我们从上面的解释已经明白了，在RC隔离级别下，是每个SELECT都会获取最新的read-view；而在RR隔离级别下，则是当事务中的第一个SELECT请求才创建read-view"><a href="#其实，我们从上面的解释已经明白了，在RC隔离级别下，是每个SELECT都会获取最新的read-view；而在RR隔离级别下，则是当事务中的第一个SELECT请求才创建read-view" class="headerlink" title="其实，我们从上面的解释已经明白了，在RC隔离级别下，是每个SELECT都会获取最新的read view；而在RR隔离级别下，则是当事务中的第一个SELECT请求才创建read view"></a>其实，我们从上面的解释已经明白了，在RC隔离级别下，是每个SELECT都会获取最新的read view；而在RR隔离级别下，则是当事务中的第一个SELECT请求才创建read view</h5><h3 id="MySQL-mysqldump-实现的原理是什么样子的？"><a href="#MySQL-mysqldump-实现的原理是什么样子的？" class="headerlink" title="MySQL mysqldump 实现的原理是什么样子的？"></a>MySQL mysqldump 实现的原理是什么样子的？</h3><h4 id="答：-42"><a href="#答：-42" class="headerlink" title="答："></a>答：</h4><ol><li>FLUSH /<em>!40101 LOCAL </em>/ TABLES</li><li>FLUSH TABLES WITH READ LOCK<br>   执行flush tables操作，并加一个全局读锁，很多童鞋可能会好奇，这两个命令貌似是重复的，为什么不在第一次执行flush tables操作的时候加上锁了，其实，这样做的原因在于可以尽量减少加锁的影响。加上全局读锁，只允许读，不允许更新操作。</li><li>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ<br>   设置当前会话的事务隔离等级为RR，RR可避免不可重复读和幻读。</li><li>START TRANSACTION /<em>!40100 WITH CONSISTENT SNAPSHOT </em>/<br>   获取当前数据库的快照，这个是由mysqldump中–single-transaction决定的。<br>   这个只适用于支持事务的表，在MySQL中，只有Innodb。<br>  注意：<pre><code>START TRANSACTION 和 START TRANSACTION WITH CONSISTENT SNAPSHOT 并不一样，START TRANSACTION WITH CONSISTENT SNAPSHOT 是开启事务的一致性快照。RC 下的 START TRANSACTION WITH CONSISTENT SNAPSHOT 相当于RR下的START TRANSACTION。</code></pre> 不明白事务的童鞋可能觉得这点会比较绕，其实所谓的不可重复读和幻读可简单理解为，在同一个事务内，两次SELECT的结果并不相同。<br> 之所以要使用START TRANSACTION WITH CONSISTENT SNAPSHOT，因为每个表的备份时间并不相同，这就要求在对第一张表进行备份的期间，对第二个表进行的操作，并不会反映到第二张表开始备份时执行的SELECT操作中。（注：mysqldump备份的底层实现即是select * from tab）。而这用START TRANSACTION就无法实现。</li><li>SHOW MASTER STATUS<br> 这个是由–master-data决定的，记录了开始备份时，binlog的状态信息，包括MASTER_LOG_FILE和MASTER_LOG_POS</li><li>UNLOCK TABLES<br> 等记录完成后，就立即释放了，因为现在已经在一个事务中了，其他线程再修改数据已经无所谓，在本线程中已经是可重复读，这也是这一步必须在19 rows之后的原因，如果20 rows和21 rows都在19 rows之前的话就不行了，因为这时事务还没开启，一旦释放，其他线程立即就可以更改数据，从而无法保证得到事务开启时最准确的pos点</li><li>备份的核心是SELECT /<em>!40001 SQL_NO_CACHE </em>/ * FROM <code>test1</code>语句。<br> 该语句会查询到表test1的所有数据，在备份文件中会生成相应的insert语句。<br> 其中SQL_NO_CACHE的作用是查询的结果并不会缓存到查询缓存中。</li><li>SHOW CREATE DATABASE IF NOT EXISTS <code>test</code>，show create table <code>test1</code><br> 生成创库语句和创表语句。</li><li>SHOW TRIGGERS LIKE ‘test1’<br> 可以看出，如果不加-R参数，默认是会备份触发器的。</li><li>SHOW FUNCTION STATUS WHERE Db = ‘test’<br>SHOW CREATE FUNCTION <code>mycat_seq_currval</code><br>SHOW PROCEDURE STATUS WHERE Db = ‘test’<br> 用于备份存储过程和函数。</li><li>设置SAVEPOINT，然后备份完每个表后再回滚到该SAVEPOINT。<br>因为前面通过START TRANSACTION WITH CONSISTENT SNAPSHOT开启的事务只能通过commit或者rollback来结束，而不是ROLLBACK TO SAVEPOINT sp。<br>PS：<pre><code>这样做不会阻塞在备份期间对已经备份表的ddl操作，具体可见下面的“后续补充”第三点。</code></pre></li></ol><p>总结：</p><ul><li>mysqldump的本质是通过select * from tab来获取表的数据的。</li><li>START TRANSACTION /!40100 WITH CONSISTENT SNAPSHOT /必须放到FLUSH TABLES WITH READ LOCK和UNLOCK TABLES之间，放到之前会造成START TRANSACTION /!40100 WITH CONSISTENT SNAPSHOT /和FLUSH TABLES WITH READ LOCK之间执行的DML语句丢失，放到之后，会造成从库重复插入数据。</li><li>mysqldump只适合放到业务低峰期做，如果备份的过程中数据操作很频繁，会造成Undo表空间越来越大，undo表空间默认是放到共享表空间中的，而ibdata的特性是一旦增大，就不会收缩。</li><li>mysqldump的效率还是比较低下，START TRANSACTION /!40100 WITH CONSISTENT SNAPSHOT /只能等到所有表备份完后才结束，其实效率比较高的做法是备份完一张表就提交一次，这样可尽快释放Undo表空间快照占用的空间。但这样做，就无法实现对所有表的一致性备份。</li></ul><h3 id="mysqldump-single-transaction怎么实现获取InnoDB表的一致性备份？"><a href="#mysqldump-single-transaction怎么实现获取InnoDB表的一致性备份？" class="headerlink" title="mysqldump single-transaction怎么实现获取InnoDB表的一致性备份？"></a>mysqldump single-transaction怎么实现获取InnoDB表的一致性备份？</h3><h4 id="答：-43"><a href="#答：-43" class="headerlink" title="答："></a>答：</h4><ul><li>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ</li><li>批注：–single-transaction参数的作用，设置事务的隔离级别为可重复读，即REPEATABLE READ，这样能保证在一个事务中所有相同的查询读取到同样的数据，也就大概保证了在dump期间，如果其他innodb引擎的线程修改了表的数据并提交，对该dump线程的数据并无影响，然而这个还不够，还需要看下一条</li><li>START TRANSACTION /!40100 WITH CONSISTENT SNAPSHOT /</li><li>这时开启一个事务，并且设置WITH CONSISTENT SNAPSHOT为快照级别（如果mysql版本高于某一个版本值，我还不大清楚40100代表什么版本）。想象一下，如果只是可重复读，那么在事务开始时还没dump数据时，这时其他线程修改并提交了数据，那么这时第一次查询得到的结果是其他线程提交后的结果，而WITH CONSISTENT SNAPSHOT能够保证在事务开启的时候，第一次查询的结果就是事务开始时的数据A，即使这时其他线程将其数据修改为B，查的结果依然是A</li></ul><h3 id="Paxos协议和Raft协议"><a href="#Paxos协议和Raft协议" class="headerlink" title="Paxos协议和Raft协议"></a>Paxos协议和Raft协议</h3><h4 id="答：-44"><a href="#答：-44" class="headerlink" title="答："></a>答：</h4><p>在分布式中我们非常非常看重的有一般网上经常说的三个点，CAP ！即：C (Consistency 一致性)、A (Availability 可用性)、P (Partition)；也就是我们经常所说的【CAP原理】；而在一致性中我们有非常非常注重四个点， ACID ！ 即：A (Atomicity 原子性)、C (Consistency 一致性)、 I (Isolation 隔离性)、 D (Durability 持久性)，也就是我们常说的【ACID原则】是的一致性原则中的一种</p><h5 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h5><p>Raft是一个分布式一致性协议／算法，是Replicated And Fault Tolerant的缩写。在raft中首先具备了三种角色：</p><ul><li>Leader (领导者)</li><li>Candidate（候选者）</li><li>Follower（追随者）</li></ul><p>通常再做决策之前需要选举出一个全局的Leader来简化后续的决策过程。Leader决定了log的提交，且 log只能是Leader 想follower单向提交。</p><ul><li>Leader (领导者)：负责接收客户端的Log，并分发给其他节点。</li><li>Candidate （候选者）：发起选举请求，竞争Leader。</li><li>Follower （追随者）：负责接收Leader发送过来的Log，并刷新保存。</li></ul><p>Raft 分为两个过程:</p><ul><li>选举Leader</li><li>日志同步。</li></ul><p>Raft的核心思想</p><ul><li>Leader的选举过程</li><li>Log的复制方案</li><li>数据安全（其实就是一致性）</li></ul><h5 id="Paxos（Lamport）："><a href="#Paxos（Lamport）：" class="headerlink" title="Paxos（Lamport）："></a>Paxos（Lamport）：</h5><p>分布式系统中的节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。</p><p>基于消息传递通信模型的分布式系统，不可避免的会发生以下错误：进程可能会慢、被杀死或者重启，消息可能会延迟、丢失、重复，在基础Paxos场景中，先不考虑可能出现消息篡改即拜占庭错误的情况。</p><p>Paxos算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。</p><p>主要有三类节点:</p><ul><li>提议者（Proposer）：提出提案等待大家认可该提案为决议。(系统中的提案都拥有一个自增的唯一提案号，<往往由客户端担任该角色>)</li><li>接受者（Acceptor）：负责对提案进行投票，认可提案。<往往由服务器担任该角色></li><li>学习者（Learner）：获取批准的结果 （学习acceptor所认可的结果），并帮忙传播，不参与投票过程。<客户端和服务器担任></li></ul><p>Paxos的流程分为两个阶段:</p><ul><li>准备阶段</li><li>提交阶段</li></ul><p>准备阶段：</p><ul><li>proposer向网络内超过半数的acceptor发送prepare消息 (即：提交自己的提案编号)</li><li>acceptor正常情况下回复promise消息（接受者时可保存收到过的提案的最大编号和认可的最大提案，如果收到的提案号比自己保留的最大提案号还大，则返回自己已认可的提案号；如果从未认可过提案，则返回空，并更新当前保存的最大提案号，并说明不再认可小于最大提案号的提案）</li></ul><p>提交阶段：</p><ul><li>在有足够多acceptor回复promise消息时，proposer发送accept消息（如果提案者收到大多数的回复，则发送带有刚才提案号的接受 accept 信息。<注意：如果收到的回复中不带有提案号，说明 提案锁定成功，则使用自己当前的提案内容；如果收到的回复中有提案内容，则替换当前提案值为返回的编号最大的提案值；如果没有收到足够的 回复，则会再次发送请求。<即 第一阶段的动作>）</li><li>正常情况下acceptor回复accepted消息 （接受者收到 提案者发来的 接受 accept 信息，如果发现 提案号 不小于 自己保存的当前已接收的最大提案号，则更新 认可的最大提案，并更新认可提案内容）</li></ul><h3 id="在MHA架构中，如果VIP发生切换，有没有遇到过VIP不通的现象？怎么解决这个问题呢？"><a href="#在MHA架构中，如果VIP发生切换，有没有遇到过VIP不通的现象？怎么解决这个问题呢？" class="headerlink" title="在MHA架构中，如果VIP发生切换，有没有遇到过VIP不通的现象？怎么解决这个问题呢？"></a>在MHA架构中，如果VIP发生切换，有没有遇到过VIP不通的现象？怎么解决这个问题呢？</h3><h4 id="答：-45"><a href="#答：-45" class="headerlink" title="答："></a>答：</h4><h5 id="有遇到过。"><a href="#有遇到过。" class="headerlink" title="有遇到过。"></a>有遇到过。</h5><h5 id="解决的方法有两种："><a href="#解决的方法有两种：" class="headerlink" title="解决的方法有两种："></a>解决的方法有两种：</h5><ul><li><p>执行命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arp -d vip</span></span><br><span class="line"><span class="comment"># ip neigh flush dev eth0 # 清空eth0的arp表</span></span><br><span class="line"><span class="comment"># arp -n|awk '/^[1-9]/{print "arp -d  " $1}'|sh -x</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>修改sysctl.conf</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="comment"># echo 1 > /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line"><span class="comment"># sed -i '/net.ipv4.ip_forward/ s/\(.*= \).*/\11/' /etc/sysctl.conf</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="在InnoDB引擎中，16k-PAGE-SIZE-InnoDB的非叶子节点最多能放多少个INT的Primary-Keys-能用-16K-4-来估算吗？"><a href="#在InnoDB引擎中，16k-PAGE-SIZE-InnoDB的非叶子节点最多能放多少个INT的Primary-Keys-能用-16K-4-来估算吗？" class="headerlink" title="在InnoDB引擎中，16k PAGE SIZE, InnoDB的非叶子节点最多能放多少个INT的Primary Keys,能用 16K/4 来估算吗？"></a>在InnoDB引擎中，16k PAGE SIZE, InnoDB的非叶子节点最多能放多少个INT的Primary Keys,能用 16K/4 来估算吗？</h3><h4 id="答：-46"><a href="#答：-46" class="headerlink" title="答："></a>答：</h4><h5 id="在InnoDB引擎中，每一个page预留1-6空闲空间，再减去头尾元数据信息，就是-16338-15-16-1024-4。就是大概的结果。"><a href="#在InnoDB引擎中，每一个page预留1-6空闲空间，再减去头尾元数据信息，就是-16338-15-16-1024-4。就是大概的结果。" class="headerlink" title="在InnoDB引擎中，每一个page预留1/6空闲空间，再减去头尾元数据信息，就是 16338*15/16*1024/4。就是大概的结果。"></a>在InnoDB引擎中，每一个page预留1/6空闲空间，再减去头尾元数据信息，就是 16338*15/16*1024/4。就是大概的结果。</h5><h6 id="注-16338-是去掉-头尾元数据信息后的大小。"><a href="#注-16338-是去掉-头尾元数据信息后的大小。" class="headerlink" title="注: 16338 是去掉 头尾元数据信息后的大小。"></a>注: 16338 是去掉 头尾元数据信息后的大小。</h6><img src="/2019/01/28/面试/INNODB页结构图.png" title="INNODB 页结构图"><p><a href="https://dev.mysql.com/doc/internals/en/innodb-page-overview.html" target="_blank" rel="noopener">参考官方资料</a></p><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><h4 id="答：-47"><a href="#答：-47" class="headerlink" title="答："></a>答：</h4><h5 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF):"></a>第一范式(1NF):</h5><blockquote><p>数据库表中的字段都是单一属性的,不可再分. 这个单一属性由基本类型构成, 包括整型/实数/字符型/逻辑性/日期型等.</p></blockquote><h5 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF):"></a>第二范式(2NF):</h5><blockquote><p>数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖(部分函数依赖指的是存在组合关键字段中的某些字段决定非关键字段的情况), 也即所有非关键字段都完全依赖于任意一组候选关键字.</p></blockquote><h5 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF):"></a>第三范式(3NF):</h5><blockquote><p>在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式. 所谓传递函数依赖, 指的是如果存在 ‘A -> B -> C’ 的决定关系, 则C传递函数依赖于A. 因此, 满足第三范式的数据库表应该不存在如下依赖关系: 关键字段 -> 非关键字段x -> 非关键字段y</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL 面试笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL 面试笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
